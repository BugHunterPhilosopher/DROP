<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>ExposureAdjustmentAggregator.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">DROP</a> &gt; <a href="index.source.html" class="el_package">org.drip.xva.gross</a> &gt; <span class="el_source">ExposureAdjustmentAggregator.java</span></div><h1>ExposureAdjustmentAggregator.java</h1><pre class="source lang-java linenums">
package org.drip.xva.gross;

/*
 * -*- mode: java; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*-
 */

/*!
 * Copyright (C) 2018 Lakshmi Krishnamurthy
 * Copyright (C) 2017 Lakshmi Krishnamurthy
 * 
 *  This file is part of DRIP, a free-software/open-source library for buy/side financial/trading model
 *  	libraries targeting analysts and developers
 *  	https://lakshmidrip.github.io/DRIP/
 *  
 *  DRIP is composed of four main libraries:
 *  
 *  - DRIP Fixed Income - https://lakshmidrip.github.io/DRIP-Fixed-Income/
 *  - DRIP Asset Allocation - https://lakshmidrip.github.io/DRIP-Asset-Allocation/
 *  - DRIP Numerical Optimizer - https://lakshmidrip.github.io/DRIP-Numerical-Optimizer/
 *  - DRIP Statistical Learning - https://lakshmidrip.github.io/DRIP-Statistical-Learning/
 * 
 *  - DRIP Fixed Income: Library for Instrument/Trading Conventions, Treasury Futures/Options,
 *  	Funding/Forward/Overnight Curves, Multi-Curve Construction/Valuation, Collateral Valuation and XVA
 *  	Metric Generation, Calibration and Hedge Attributions, Statistical Curve Construction, Bond RV
 *  	Metrics, Stochastic Evolution and Option Pricing, Interest Rate Dynamics and Option Pricing, LMM
 *  	Extensions/Calibrations/Greeks, Algorithmic Differentiation, and Asset Backed Models and Analytics.
 * 
 *  - DRIP Asset Allocation: Library for model libraries for MPT framework, Black Litterman Strategy
 *  	Incorporator, Holdings Constraint, and Transaction Costs.
 * 
 *  - DRIP Numerical Optimizer: Library for Numerical Optimization and Spline Functionality.
 * 
 *  - DRIP Statistical Learning: Library for Statistical Evaluation and Machine Learning.
 * 
 *  Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 *   	you may not use this file except in compliance with the License.
 *   
 *  You may obtain a copy of the License at
 *  	http://www.apache.org/licenses/LICENSE-2.0
 *  
 *  Unless required by applicable law or agreed to in writing, software
 *  	distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 *  	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  
 *  See the License for the specific language governing permissions and
 *  	limitations under the License.
 */

/**
 * ExposureAdjustmentAggregator aggregates across Multiple Exposure/Adjustment Paths belonging to the Counter
 *  Party. The References are:
 *  
 *  - Burgard, C., and M. Kjaer (2014): PDE Representations of Derivatives with Bilateral Counter-party Risk
 *  	and Funding Costs, Journal of Credit Risk, 7 (3) 1-19.
 *  
 *  - Burgard, C., and M. Kjaer (2014): In the Balance, Risk, 24 (11) 72-75.
 *  
 *  - Gregory, J. (2009): Being Two-faced over Counter-party Credit Risk, Risk 20 (2) 86-90.
 *  
 *  - Li, B., and Y. Tang (2007): Quantitative Analysis, Derivatives Modeling, and Trading Strategies in the
 *  	Presence of Counter-party Credit Risk for the Fixed Income Market, World Scientific Publishing,
 *  	Singapore.
 * 
 *  - Piterbarg, V. (2010): Funding Beyond Discounting: Collateral Agreements and Derivatives Pricing, Risk
 *  	21 (2) 97-102.
 * 
 * @author Lakshmi Krishnamurthy
 */

public class ExposureAdjustmentAggregator
{
<span class="nc" id="L73">	private org.drip.xva.gross.PathExposureAdjustment[] _pathExposureAdjustmentArray = null;</span>

	/**
	 * ExposureAdjustmentAggregator Constructor
	 * 
	 * @param pathExposureAdjustmentArray Array of the Counter Party Group Paths
	 * 
	 * @throws java.lang.Exception Thrown if the Inputs are Invalid
	 */

	public ExposureAdjustmentAggregator (
		final org.drip.xva.gross.PathExposureAdjustment[] pathExposureAdjustmentArray)
		throws java.lang.Exception
<span class="nc" id="L86">	{</span>
<span class="nc bnc" id="L87" title="All 4 branches missed.">		if (null == (_pathExposureAdjustmentArray = pathExposureAdjustmentArray) ||</span>
			0 == _pathExposureAdjustmentArray.length)
		{
<span class="nc" id="L90">			throw new java.lang.Exception (&quot;ExposureAdjustmentAggregator Constructor =&gt; Invalid Inputs&quot;);</span>
		}
<span class="nc" id="L92">	}</span>

	/**
	 * Retrieve the Array of Group Path Exposure Adjustments
	 * 
	 * @return Array of Group Path Exposure Adjustments
	 */

	public org.drip.xva.gross.PathExposureAdjustment[] pathExposureAdjustmentArray()
	{
<span class="nc" id="L102">		return _pathExposureAdjustmentArray;</span>
	}

	/**
	 * Retrieve the Array of the Vertex Anchor Dates
	 * 
	 * @return The Array of the Vertex Anchor Dates
	 */

	public org.drip.analytics.date.JulianDate[] vertexDates()
	{
<span class="nc" id="L113">		return _pathExposureAdjustmentArray[0].vertexDates();</span>
	}

	/**
	 * Retrieve the Array of Collateralized Exposures
	 * 
	 * @return The Array of Collateralized Exposures
	 */

	public double[] collateralizedExposure()
	{
<span class="nc" id="L124">		int vertexCount = vertexDates().length;</span>

<span class="nc" id="L126">		int pathCount = _pathExposureAdjustmentArray.length;</span>
<span class="nc" id="L127">		double[] collateralizedExposure = new double[vertexCount];</span>

<span class="nc bnc" id="L129" title="All 2 branches missed.">		for (int vertexIndex = 0; vertexIndex &lt; vertexCount; ++vertexIndex)</span>
		{
<span class="nc" id="L131">			collateralizedExposure[vertexIndex] = 0.;</span>
		}

<span class="nc bnc" id="L134" title="All 2 branches missed.">		for (int pathIndex = 0; pathIndex &lt; pathCount; ++pathIndex)</span>
		{
<span class="nc" id="L136">			double[] pathCollateralizedExposure =</span>
<span class="nc" id="L137">				_pathExposureAdjustmentArray[pathIndex].vertexCollateralizedExposure();</span>

<span class="nc bnc" id="L139" title="All 2 branches missed.">			for (int vertexIndex = 0; vertexIndex &lt; vertexCount; ++vertexIndex)</span>
			{
<span class="nc" id="L141">				collateralizedExposure[vertexIndex] += pathCollateralizedExposure[vertexIndex];</span>
			}
		}

<span class="nc bnc" id="L145" title="All 2 branches missed.">		for (int vertexIndex = 0; vertexIndex &lt; vertexCount; ++vertexIndex)</span>
		{
<span class="nc" id="L147">			collateralizedExposure[vertexIndex] /= pathCount;</span>
		}

<span class="nc" id="L150">		return collateralizedExposure;</span>
	}

	/**
	 * Retrieve the Array of Collateralized Exposure PV's
	 * 
	 * @return The Array of Collateralized Exposure PV's
	 */

	public double[] collateralizedExposurePV()
	{
<span class="nc" id="L161">		int vertexCount = vertexDates().length;</span>

<span class="nc" id="L163">		int pathCount = _pathExposureAdjustmentArray.length;</span>
<span class="nc" id="L164">		double[] collateralizedExposurePV = new double[vertexCount];</span>

<span class="nc bnc" id="L166" title="All 2 branches missed.">		for (int vertexIndex = 0; vertexIndex &lt; vertexCount; ++vertexIndex)</span>
		{
<span class="nc" id="L168">			collateralizedExposurePV[vertexIndex] = 0.;</span>
		}

<span class="nc bnc" id="L171" title="All 2 branches missed.">		for (int pathIndex = 0; pathIndex &lt; pathCount; ++pathIndex)</span>
		{
<span class="nc" id="L173">			double[] pathCollateralizedExposurePV =</span>
<span class="nc" id="L174">				_pathExposureAdjustmentArray[pathIndex].vertexCollateralizedExposurePV();</span>

<span class="nc bnc" id="L176" title="All 2 branches missed.">			for (int vertexIndex = 0; vertexIndex &lt; vertexCount; ++vertexIndex)</span>
			{
<span class="nc" id="L178">				collateralizedExposurePV[vertexIndex] += pathCollateralizedExposurePV[vertexIndex];</span>
			}
		}

<span class="nc bnc" id="L182" title="All 2 branches missed.">		for (int vertexIndex = 0; vertexIndex &lt; vertexCount; ++vertexIndex)</span>
		{
<span class="nc" id="L184">			collateralizedExposurePV[vertexIndex] /= pathCount;</span>
		}

<span class="nc" id="L187">		return collateralizedExposurePV;</span>
	}

	/**
	 * Retrieve the Array of Uncollateralized Exposures
	 * 
	 * @return The Array of Uncollateralized Exposures
	 */

	public double[] uncollateralizedExposure()
	{
<span class="nc" id="L198">		int vertexCount = vertexDates().length;</span>

<span class="nc" id="L200">		int pathCount = _pathExposureAdjustmentArray.length;</span>
<span class="nc" id="L201">		double[] uncollateralizedExposure = new double[vertexCount];</span>

<span class="nc bnc" id="L203" title="All 2 branches missed.">		for (int vertexIndex = 0; vertexIndex &lt; vertexCount; ++vertexIndex)</span>
		{
<span class="nc" id="L205">			uncollateralizedExposure[vertexIndex] = 0.;</span>
		}

<span class="nc bnc" id="L208" title="All 2 branches missed.">		for (int pathIndex = 0; pathIndex &lt; pathCount; ++pathIndex)</span>
		{
<span class="nc" id="L210">			double[] pathUncollateralizedExposure =</span>
<span class="nc" id="L211">				_pathExposureAdjustmentArray[pathIndex].vertexUncollateralizedExposure();</span>

<span class="nc bnc" id="L213" title="All 2 branches missed.">			for (int vertexIndex = 0; vertexIndex &lt; vertexCount; ++vertexIndex)</span>
			{
<span class="nc" id="L215">				uncollateralizedExposure[vertexIndex] += pathUncollateralizedExposure[vertexIndex];</span>
			}
		}

<span class="nc bnc" id="L219" title="All 2 branches missed.">		for (int vertexIndex = 0; vertexIndex &lt; vertexCount; ++vertexIndex)</span>
<span class="nc" id="L220">			uncollateralizedExposure[vertexIndex] /= pathCount;</span>

<span class="nc" id="L222">		return uncollateralizedExposure;</span>
	}

	/**
	 * Retrieve the Array of Uncollateralized Exposure PV's
	 * 
	 * @return The Array of Uncollateralized Exposure PV's
	 */

	public double[] uncollateralizedExposurePV()
	{
<span class="nc" id="L233">		int vertexCount = vertexDates().length;</span>

<span class="nc" id="L235">		int pathCount = _pathExposureAdjustmentArray.length;</span>
<span class="nc" id="L236">		double[] uncollateralizedExposurePV = new double[vertexCount];</span>

<span class="nc bnc" id="L238" title="All 2 branches missed.">		for (int vertexIndex = 0; vertexIndex &lt; vertexCount; ++vertexIndex)</span>
		{
<span class="nc" id="L240">			uncollateralizedExposurePV[vertexIndex] = 0.;</span>
		}

<span class="nc bnc" id="L243" title="All 2 branches missed.">		for (int pathIndex = 0; pathIndex &lt; pathCount; ++pathIndex)</span>
		{
<span class="nc" id="L245">			double[] pathUncollateralizedExposurePV =</span>
<span class="nc" id="L246">				_pathExposureAdjustmentArray[pathIndex].vertexUncollateralizedExposurePV();</span>

<span class="nc bnc" id="L248" title="All 2 branches missed.">			for (int vertexIndex = 0; vertexIndex &lt; vertexCount; ++vertexIndex)</span>
			{
<span class="nc" id="L250">				uncollateralizedExposurePV[vertexIndex] +=</span>
					pathUncollateralizedExposurePV[vertexIndex];
			}
		}

<span class="nc bnc" id="L255" title="All 2 branches missed.">		for (int vertexIndex = 0; vertexIndex &lt; vertexCount; ++vertexIndex)</span>
		{
<span class="nc" id="L257">			uncollateralizedExposurePV[vertexIndex] /= pathCount;</span>
		}

<span class="nc" id="L260">		return uncollateralizedExposurePV;</span>
	}

	/**
	 * Retrieve the Array of Collateralized Positive Exposures
	 * 
	 * @return The Array of Collateralized Positive Exposures
	 */

	public double[] collateralizedPositiveExposure()
	{
<span class="nc" id="L271">		int vertexCount = vertexDates().length;</span>

<span class="nc" id="L273">		int pathCount = _pathExposureAdjustmentArray.length;</span>
<span class="nc" id="L274">		double[] collateralizedPositiveExposure = new double[vertexCount];</span>

<span class="nc bnc" id="L276" title="All 2 branches missed.">		for (int vertexIndex = 0; vertexIndex &lt; vertexCount; ++vertexIndex)</span>
		{
<span class="nc" id="L278">			collateralizedPositiveExposure[vertexIndex] = 0.;</span>
		}

<span class="nc bnc" id="L281" title="All 2 branches missed.">		for (int pathIndex = 0; pathIndex &lt; pathCount; ++pathIndex)</span>
		{
<span class="nc" id="L283">			double[] pathCollateralizedPositiveExposure =</span>
<span class="nc" id="L284">				_pathExposureAdjustmentArray[pathIndex].vertexCollateralizedPositiveExposure();</span>

<span class="nc bnc" id="L286" title="All 2 branches missed.">			for (int vertexIndex = 0; vertexIndex &lt; vertexCount; ++vertexIndex)</span>
			{
<span class="nc" id="L288">				collateralizedPositiveExposure[vertexIndex] +=</span>
					pathCollateralizedPositiveExposure[vertexIndex];
			}
		}

<span class="nc bnc" id="L293" title="All 2 branches missed.">		for (int vertexIndex = 0; vertexIndex &lt; vertexCount; ++vertexIndex)</span>
		{
<span class="nc" id="L295">			collateralizedPositiveExposure[vertexIndex] /= pathCount;</span>
		}

<span class="nc" id="L298">		return collateralizedPositiveExposure;</span>
	}

	/**
	 * Retrieve the Array of Collateralized Positive Exposure PV
	 * 
	 * @return The Array of Collateralized Positive Exposure PV
	 */

	public double[] collateralizedPositiveExposurePV()
	{
<span class="nc" id="L309">		int vertexCount = vertexDates().length;</span>

<span class="nc" id="L311">		int pathCount = _pathExposureAdjustmentArray.length;</span>
<span class="nc" id="L312">		double[] collateralizedPositiveExposurePV = new double[vertexCount];</span>

<span class="nc bnc" id="L314" title="All 2 branches missed.">		for (int vertexIndex = 0; vertexIndex &lt; vertexCount; ++vertexIndex)</span>
		{
<span class="nc" id="L316">			collateralizedPositiveExposurePV[vertexIndex] = 0.;</span>
		}

<span class="nc bnc" id="L319" title="All 2 branches missed.">		for (int pathIndex = 0; pathIndex &lt; pathCount; ++pathIndex)</span>
		{
<span class="nc" id="L321">			double[] pathCollateralizedPositiveExposurePV =</span>
<span class="nc" id="L322">				_pathExposureAdjustmentArray[pathIndex].vertexCollateralizedPositiveExposurePV();</span>

<span class="nc bnc" id="L324" title="All 2 branches missed.">			for (int vertexIndex = 0; vertexIndex &lt; vertexCount; ++vertexIndex)</span>
			{
<span class="nc" id="L326">				collateralizedPositiveExposurePV[vertexIndex] +=</span>
					pathCollateralizedPositiveExposurePV[vertexIndex];
			}
		}

<span class="nc bnc" id="L331" title="All 2 branches missed.">		for (int vertexIndex = 0; vertexIndex &lt; vertexCount; ++vertexIndex)</span>
		{
<span class="nc" id="L333">			collateralizedPositiveExposurePV[vertexIndex] /= pathCount;</span>
		}

<span class="nc" id="L336">		return collateralizedPositiveExposurePV;</span>
	}

	/**
	 * Retrieve the Array of Uncollateralized Positive Exposures
	 * 
	 * @return The Array of Uncollateralized Positive Exposures
	 */

	public double[] uncollateralizedPositiveExposure()
	{
<span class="nc" id="L347">		int vertexCount = vertexDates().length;</span>

<span class="nc" id="L349">		int pathCount = _pathExposureAdjustmentArray.length;</span>
<span class="nc" id="L350">		double[] uncollateralizedPositiveExposure = new double[vertexCount];</span>

<span class="nc bnc" id="L352" title="All 2 branches missed.">		for (int vertexIndex = 0; vertexIndex &lt; vertexCount; ++vertexIndex)</span>
		{
<span class="nc" id="L354">			uncollateralizedPositiveExposure[vertexIndex] = 0.;</span>
		}

<span class="nc bnc" id="L357" title="All 2 branches missed.">		for (int pathIndex = 0; pathIndex &lt; pathCount; ++pathIndex)</span>
		{
<span class="nc" id="L359">			double[] pathUncollateralizedPositiveExposure =</span>
<span class="nc" id="L360">				_pathExposureAdjustmentArray[pathIndex].vertexUncollateralizedPositiveExposure();</span>

<span class="nc bnc" id="L362" title="All 2 branches missed.">			for (int vertexIndex = 0; vertexIndex &lt; vertexCount; ++vertexIndex)</span>
			{
<span class="nc" id="L364">				uncollateralizedPositiveExposure[vertexIndex] +=</span>
					pathUncollateralizedPositiveExposure[vertexIndex];
			}
		}

<span class="nc bnc" id="L369" title="All 2 branches missed.">		for (int vertexIndex = 0; vertexIndex &lt; vertexCount; ++vertexIndex)</span>
		{
<span class="nc" id="L371">			uncollateralizedPositiveExposure[vertexIndex] /= pathCount;</span>
		}

<span class="nc" id="L374">		return uncollateralizedPositiveExposure;</span>
	}

	/**
	 * Retrieve the Array of Uncollateralized Positive Exposure PV
	 * 
	 * @return The Array of Uncollateralized Positive Exposure PV
	 */

	public double[] uncollateralizedPositiveExposurePV()
	{
<span class="nc" id="L385">		int vertexCount = vertexDates().length;</span>

<span class="nc" id="L387">		int pathCount = _pathExposureAdjustmentArray.length;</span>
<span class="nc" id="L388">		double[] uncollateralizedPositiveExposurePV = new double[vertexCount];</span>

<span class="nc bnc" id="L390" title="All 2 branches missed.">		for (int vertexIndex = 0; vertexIndex &lt; vertexCount; ++vertexIndex)</span>
		{
<span class="nc" id="L392">			uncollateralizedPositiveExposurePV[vertexIndex] = 0.;</span>
		}

<span class="nc bnc" id="L395" title="All 2 branches missed.">		for (int pathIndex = 0; pathIndex &lt; pathCount; ++pathIndex)</span>
		{
<span class="nc" id="L397">			double[] pathUncollateralizedPositiveExposurePV =</span>
<span class="nc" id="L398">				_pathExposureAdjustmentArray[pathIndex].vertexUncollateralizedPositiveExposurePV();</span>

<span class="nc bnc" id="L400" title="All 2 branches missed.">			for (int vertexIndex = 0; vertexIndex &lt; vertexCount; ++vertexIndex)</span>
			{
<span class="nc" id="L402">				uncollateralizedPositiveExposurePV[vertexIndex] +=</span>
					pathUncollateralizedPositiveExposurePV[vertexIndex];
			}
		}

<span class="nc bnc" id="L407" title="All 2 branches missed.">		for (int vertexIndex = 0; vertexIndex &lt; vertexCount; ++vertexIndex)</span>
		{
<span class="nc" id="L409">			uncollateralizedPositiveExposurePV[vertexIndex] /= pathCount;</span>
		}

<span class="nc" id="L412">		return uncollateralizedPositiveExposurePV;</span>
	}

	/**
	 * Retrieve the Array of Collateralized Negative Exposures
	 * 
	 * @return The Array of Collateralized Negative Exposures
	 */

	public double[] collateralizedNegativeExposure()
	{
<span class="nc" id="L423">		int vertexCount = vertexDates().length;</span>

<span class="nc" id="L425">		int pathCount = _pathExposureAdjustmentArray.length;</span>
<span class="nc" id="L426">		double[] collateralizedNegativeExposure = new double[vertexCount];</span>

<span class="nc bnc" id="L428" title="All 2 branches missed.">		for (int vertexIndex = 0; vertexIndex &lt; vertexCount; ++vertexIndex)</span>
		{
<span class="nc" id="L430">			collateralizedNegativeExposure[vertexIndex] = 0.;</span>
		}

<span class="nc bnc" id="L433" title="All 2 branches missed.">		for (int pathIndex = 0; pathIndex &lt; pathCount; ++pathIndex)</span>
		{
<span class="nc" id="L435">			double[] pathCollateralizedNegativeExposure =</span>
<span class="nc" id="L436">				_pathExposureAdjustmentArray[pathIndex].vertexCollateralizedNegativeExposure();</span>

<span class="nc bnc" id="L438" title="All 2 branches missed.">			for (int vertexIndex = 0; vertexIndex &lt; vertexCount; ++vertexIndex)</span>
			{
<span class="nc" id="L440">				collateralizedNegativeExposure[vertexIndex] +=</span>
					pathCollateralizedNegativeExposure[vertexIndex];
			}
		}

<span class="nc bnc" id="L445" title="All 2 branches missed.">		for (int vertexIndex = 0; vertexIndex &lt; vertexCount; ++vertexIndex)</span>
		{
<span class="nc" id="L447">			collateralizedNegativeExposure[vertexIndex] /= pathCount;</span>
		}

<span class="nc" id="L450">		return collateralizedNegativeExposure;</span>
	}

	/**
	 * Retrieve the Array of Collateralized Negative Exposure PV
	 * 
	 * @return The Array of Collateralized Negative Exposure PV
	 */

	public double[] collateralizedNegativeExposurePV()
	{
<span class="nc" id="L461">		int vertexCount = vertexDates().length;</span>

<span class="nc" id="L463">		int pathCount = _pathExposureAdjustmentArray.length;</span>
<span class="nc" id="L464">		double[] collateralizedNegativeExposurePV = new double[vertexCount];</span>

<span class="nc bnc" id="L466" title="All 2 branches missed.">		for (int vertexIndex = 0; vertexIndex &lt; vertexCount; ++vertexIndex)</span>
		{
<span class="nc" id="L468">			collateralizedNegativeExposurePV[vertexIndex] = 0.;</span>
		}

<span class="nc bnc" id="L471" title="All 2 branches missed.">		for (int pathIndex = 0; pathIndex &lt; pathCount; ++pathIndex)</span>
		{
<span class="nc" id="L473">			double[] pathCollateralizedNegativeExposurePV =</span>
<span class="nc" id="L474">				_pathExposureAdjustmentArray[pathIndex].vertexCollateralizedNegativeExposurePV();</span>

<span class="nc bnc" id="L476" title="All 2 branches missed.">			for (int vertexIndex = 0; vertexIndex &lt; vertexCount; ++vertexIndex)</span>
			{
<span class="nc" id="L478">				collateralizedNegativeExposurePV[vertexIndex] +=</span>
					pathCollateralizedNegativeExposurePV[vertexIndex];
			}
		}

<span class="nc bnc" id="L483" title="All 2 branches missed.">		for (int vertexIndex = 0; vertexIndex &lt; vertexCount; ++vertexIndex)</span>
		{
<span class="nc" id="L485">			collateralizedNegativeExposurePV[vertexIndex] /= pathCount;</span>
		}

<span class="nc" id="L488">		return collateralizedNegativeExposurePV;</span>
	}

	/**
	 * Retrieve the Array of Uncollateralized Negative Exposures
	 * 
	 * @return The Array of Uncollateralized Negative Exposures
	 */

	public double[] uncollateralizedNegativeExposure()
	{
<span class="nc" id="L499">		int vertexCount = vertexDates().length;</span>

<span class="nc" id="L501">		int pathCount = _pathExposureAdjustmentArray.length;</span>
<span class="nc" id="L502">		double[] uncollateralizedNegativeExposure = new double[vertexCount];</span>

<span class="nc bnc" id="L504" title="All 2 branches missed.">		for (int vertexIndex = 0; vertexIndex &lt; vertexCount; ++vertexIndex)</span>
		{
<span class="nc" id="L506">			uncollateralizedNegativeExposure[vertexIndex] = 0.;</span>
		}

<span class="nc bnc" id="L509" title="All 2 branches missed.">		for (int pathIndex = 0; pathIndex &lt; pathCount; ++pathIndex)</span>
		{
<span class="nc" id="L511">			double[] pathUncollateralizedNegativeExposure =</span>
<span class="nc" id="L512">				_pathExposureAdjustmentArray[pathIndex].vertexUncollateralizedNegativeExposure();</span>

<span class="nc bnc" id="L514" title="All 2 branches missed.">			for (int vertexIndex = 0; vertexIndex &lt; vertexCount; ++vertexIndex)</span>
			{
<span class="nc" id="L516">				uncollateralizedNegativeExposure[vertexIndex] +=</span>
					pathUncollateralizedNegativeExposure[vertexIndex];
			}
		}

<span class="nc bnc" id="L521" title="All 2 branches missed.">		for (int vertexIndex = 0; vertexIndex &lt; vertexCount; ++vertexIndex)</span>
		{
<span class="nc" id="L523">			uncollateralizedNegativeExposure[vertexIndex] /= pathCount;</span>
		}

<span class="nc" id="L526">		return uncollateralizedNegativeExposure;</span>
	}

	/**
	 * Retrieve the Array of Uncollateralized Negative Exposure PV
	 * 
	 * @return The Array of Uncollateralized Negative Exposure PV
	 */

	public double[] uncollateralizedNegativeExposurePV()
	{
<span class="nc" id="L537">		int vertexCount = vertexDates().length;</span>

<span class="nc" id="L539">		int pathCount = _pathExposureAdjustmentArray.length;</span>
<span class="nc" id="L540">		double[] uncollateralizedNegativeExposurePV = new double[vertexCount];</span>

<span class="nc bnc" id="L542" title="All 2 branches missed.">		for (int vertexIndex = 0; vertexIndex &lt; vertexCount; ++vertexIndex)</span>
		{
<span class="nc" id="L544">			uncollateralizedNegativeExposurePV[vertexIndex] = 0.;</span>
		}

<span class="nc bnc" id="L547" title="All 2 branches missed.">		for (int pathIndex = 0; pathIndex &lt; pathCount; ++pathIndex)</span>
		{
<span class="nc" id="L549">			double[] pathUncollateralizedNegativeExposurePV =</span>
<span class="nc" id="L550">				_pathExposureAdjustmentArray[pathIndex].vertexUncollateralizedNegativeExposurePV();</span>

<span class="nc bnc" id="L552" title="All 2 branches missed.">			for (int vertexIndex = 0; vertexIndex &lt; vertexCount; ++vertexIndex)</span>
			{
<span class="nc" id="L554">				uncollateralizedNegativeExposurePV[vertexIndex] +=</span>
					pathUncollateralizedNegativeExposurePV[vertexIndex];
			}
		}

<span class="nc bnc" id="L559" title="All 2 branches missed.">		for (int vertexIndex = 0; vertexIndex &lt; vertexCount; ++vertexIndex)</span>
		{
<span class="nc" id="L561">			uncollateralizedNegativeExposurePV[vertexIndex] /= pathCount;</span>
		}

<span class="nc" id="L564">		return uncollateralizedNegativeExposurePV;</span>
	}

	/**
	 * Retrieve the Array of Funding Exposures
	 * 
	 * @return The Array of Funding Exposures
	 */

	public double[] fundingExposure()
	{
<span class="nc" id="L575">		int vertexCount = vertexDates().length;</span>

<span class="nc" id="L577">		double[] fundingExposure = new double[vertexCount];</span>
<span class="nc" id="L578">		int pathCount = _pathExposureAdjustmentArray.length;</span>

<span class="nc bnc" id="L580" title="All 2 branches missed.">		for (int vertexIndex = 0; vertexIndex &lt; vertexCount; ++vertexIndex)</span>
		{
<span class="nc" id="L582">			fundingExposure[vertexIndex] = 0.;</span>
		}

<span class="nc bnc" id="L585" title="All 2 branches missed.">		for (int pathIndex = 0; pathIndex &lt; pathCount; ++pathIndex)</span>
		{
<span class="nc" id="L587">			double[] pathFundingExposure = _pathExposureAdjustmentArray[pathIndex].vertexFundingExposure();</span>

<span class="nc bnc" id="L589" title="All 2 branches missed.">			for (int vertexIndex = 0; vertexIndex &lt; vertexCount; ++vertexIndex)</span>
			{
<span class="nc" id="L591">				fundingExposure[vertexIndex] += pathFundingExposure[vertexIndex];</span>
			}
		}

<span class="nc bnc" id="L595" title="All 2 branches missed.">		for (int vertexIndex = 0; vertexIndex &lt; vertexCount; ++vertexIndex)</span>
		{
<span class="nc" id="L597">			fundingExposure[vertexIndex] /= pathCount;</span>
		}

<span class="nc" id="L600">		return fundingExposure;</span>
	}

	/**
	 * Retrieve the Array of Funding Exposure PV
	 * 
	 * @return The Array of Funding Exposure PV
	 */

	public double[] fundingExposurePV()
	{
<span class="nc" id="L611">		int vertexCount = vertexDates().length;</span>

<span class="nc" id="L613">		int pathCount = _pathExposureAdjustmentArray.length;</span>
<span class="nc" id="L614">		double[] fundingExposurePV = new double[vertexCount];</span>

<span class="nc bnc" id="L616" title="All 2 branches missed.">		for (int vertexIndex = 0; vertexIndex &lt; vertexCount; ++vertexIndex)</span>
		{
<span class="nc" id="L618">			fundingExposurePV[vertexIndex] = 0.;</span>
		}

<span class="nc bnc" id="L621" title="All 2 branches missed.">		for (int pathIndex = 0; pathIndex &lt; pathCount; ++pathIndex)</span>
		{
<span class="nc" id="L623">			double[] pathFundingExposurePV =</span>
<span class="nc" id="L624">				_pathExposureAdjustmentArray[pathIndex].vertexFundingExposurePV();</span>

<span class="nc bnc" id="L626" title="All 2 branches missed.">			for (int vertexIndex = 0; vertexIndex &lt; vertexCount; ++vertexIndex)</span>
			{
<span class="nc" id="L628">				fundingExposurePV[vertexIndex] += pathFundingExposurePV[vertexIndex];</span>
			}
		}

<span class="nc bnc" id="L632" title="All 2 branches missed.">		for (int vertexIndex = 0; vertexIndex &lt; vertexCount; ++vertexIndex)</span>
		{
<span class="nc" id="L634">			fundingExposurePV[vertexIndex] /= pathCount;</span>
		}

<span class="nc" id="L637">		return fundingExposurePV;</span>
	}

	/**
	 * Retrieve the Expected Bilateral Collateral VA
	 * 
	 * @return The Expected Bilateral Collateral VA
	 */

	public org.drip.xva.basel.ValueAdjustment ftdcolva()
	{
<span class="nc" id="L648">		double ftdcolva = 0.;</span>
<span class="nc" id="L649">		int pathCount = _pathExposureAdjustmentArray.length;</span>

		try
		{
<span class="nc bnc" id="L653" title="All 2 branches missed.">			for (int pathIndex = 0; pathIndex &lt; pathCount; ++pathIndex)</span>
			{
<span class="nc" id="L655">				ftdcolva += _pathExposureAdjustmentArray[pathIndex].bilateralCollateralAdjustment();</span>
			}
		}
<span class="nc" id="L658">		catch (java.lang.Exception e)</span>
		{
<span class="nc" id="L660">			e.printStackTrace();</span>

<span class="nc" id="L662">			return null;</span>
<span class="nc" id="L663">		}</span>

<span class="nc" id="L665">		return org.drip.xva.basel.ValueAdjustment.COLVA (ftdcolva / pathCount);</span>
	}

	/**
	 * Retrieve the Expected Collateral VA
	 * 
	 * @return The Expected Collateral VA
	 */

	public org.drip.xva.basel.ValueAdjustment colva()
	{
<span class="nc" id="L676">		double colva = 0.;</span>
<span class="nc" id="L677">		int pathCount = _pathExposureAdjustmentArray.length;</span>

		try
		{
<span class="nc bnc" id="L681" title="All 2 branches missed.">			for (int pathIndex = 0; pathIndex &lt; pathCount; ++pathIndex)</span>
			{
<span class="nc" id="L683">				colva += _pathExposureAdjustmentArray[pathIndex].bilateralCollateralAdjustment();</span>
			}
		}
<span class="nc" id="L686">		catch (java.lang.Exception e)</span>
		{
<span class="nc" id="L688">			e.printStackTrace();</span>

<span class="nc" id="L690">			return null;</span>
<span class="nc" id="L691">		}</span>

<span class="nc" id="L693">		return org.drip.xva.basel.ValueAdjustment.COLVA (colva / pathCount);</span>
	}

	/**
	 * Retrieve the Expected Unilateral CVA
	 * 
	 * @return The Expected Unilateral CVA
	 */

	public org.drip.xva.basel.ValueAdjustment ucva()
	{
<span class="nc" id="L704">		double ucva = 0.;</span>
<span class="nc" id="L705">		int pathCount = _pathExposureAdjustmentArray.length;</span>

		try
		{
<span class="nc bnc" id="L709" title="All 2 branches missed.">			for (int pathIndex = 0; pathIndex &lt; pathCount; ++pathIndex)</span>
			{
<span class="nc" id="L711">				ucva += _pathExposureAdjustmentArray[pathIndex].unilateralCreditAdjustment();</span>
			}
		}
<span class="nc" id="L714">		catch (java.lang.Exception e)</span>
		{
<span class="nc" id="L716">			e.printStackTrace();</span>

<span class="nc" id="L718">			return null;</span>
<span class="nc" id="L719">		}</span>

<span class="nc" id="L721">		return org.drip.xva.basel.ValueAdjustment.UCVA (ucva / pathCount);</span>
	}

	/**
	 * Retrieve the Expected Bilateral/FTD CVA
	 * 
	 * @return The Expected Bilateral/FTD CVA
	 */

	public org.drip.xva.basel.ValueAdjustment ftdcva()
	{
<span class="nc" id="L732">		double ftdcva = 0.;</span>
<span class="nc" id="L733">		int pathCount = _pathExposureAdjustmentArray.length;</span>

		try
		{
<span class="nc bnc" id="L737" title="All 2 branches missed.">			for (int pathIndex = 0; pathIndex &lt; pathCount; ++pathIndex)</span>
			{
<span class="nc" id="L739">				ftdcva += _pathExposureAdjustmentArray[pathIndex].bilateralCreditAdjustment();</span>
			}
		}
<span class="nc" id="L742">		catch (java.lang.Exception e)</span>
		{
<span class="nc" id="L744">			e.printStackTrace();</span>

<span class="nc" id="L746">			return null;</span>
<span class="nc" id="L747">		}</span>

<span class="nc" id="L749">		return org.drip.xva.basel.ValueAdjustment.FTDCVA (ftdcva / pathCount);</span>
	}

	/**
	 * Retrieve the Expected CVA
	 * 
	 * @return The Expected CVA
	 */

	public org.drip.xva.basel.ValueAdjustment cva()
	{
<span class="nc" id="L760">		return ftdcva();</span>
	}

	/**
	 * Retrieve the Expected CVA Contra-Liability
	 * 
	 * @return The Expected CVA Contra-Liability
	 */

	public org.drip.xva.basel.ValueAdjustment cvacl()
	{
<span class="nc" id="L771">		double cvacl = 0.;</span>
<span class="nc" id="L772">		int pathCount = _pathExposureAdjustmentArray.length;</span>

		try
		{
<span class="nc bnc" id="L776" title="All 2 branches missed.">			for (int pathIndex = 0; pathIndex &lt; pathCount; ++pathIndex)</span>
			{
<span class="nc" id="L778">				cvacl += _pathExposureAdjustmentArray[pathIndex].contraLiabilityCreditAdjustment();</span>
			}
		}
<span class="nc" id="L781">		catch (java.lang.Exception e)</span>
		{
<span class="nc" id="L783">			e.printStackTrace();</span>

<span class="nc" id="L785">			return null;</span>
<span class="nc" id="L786">		}</span>

<span class="nc" id="L788">		return org.drip.xva.basel.ValueAdjustment.CVACL (cvacl / pathCount);</span>
	}

	/**
	 * Retrieve the Expected Unilateral DVA
	 * 
	 * @return The Expected Unilateral DVA
	 */

	public org.drip.xva.basel.ValueAdjustment udva()
	{
<span class="nc" id="L799">		double udva = 0.;</span>
<span class="nc" id="L800">		int pathCount = _pathExposureAdjustmentArray.length;</span>

		try {
<span class="nc bnc" id="L803" title="All 2 branches missed.">			for (int pathIndex = 0; pathIndex &lt; pathCount; ++pathIndex)</span>
			{
<span class="nc" id="L805">				udva += _pathExposureAdjustmentArray[pathIndex].unilateralDebtAdjustment();</span>
			}
		}
<span class="nc" id="L808">		catch (java.lang.Exception e)</span>
		{
<span class="nc" id="L810">			e.printStackTrace();</span>

<span class="nc" id="L812">			return null;</span>
<span class="nc" id="L813">		}</span>

<span class="nc" id="L815">		return org.drip.xva.basel.ValueAdjustment.DVA (udva / pathCount);</span>
	}

	/**
	 * Retrieve the Expected Bilateral DVA
	 * 
	 * @return The Expected Bilateral DVA
	 */

	public org.drip.xva.basel.ValueAdjustment ftddva()
	{
<span class="nc" id="L826">		double ftddva = 0.;</span>
<span class="nc" id="L827">		int pathCount = _pathExposureAdjustmentArray.length;</span>

		try {
<span class="nc bnc" id="L830" title="All 2 branches missed.">			for (int pathIndex = 0; pathIndex &lt; pathCount; ++pathIndex)</span>
			{
<span class="nc" id="L832">				ftddva += _pathExposureAdjustmentArray[pathIndex].bilateralDebtAdjustment();</span>
			}
		}
<span class="nc" id="L835">		catch (java.lang.Exception e)</span>
		{
<span class="nc" id="L837">			e.printStackTrace();</span>

<span class="nc" id="L839">			return null;</span>
<span class="nc" id="L840">		}</span>

<span class="nc" id="L842">		return org.drip.xva.basel.ValueAdjustment.DVA (ftddva / pathCount);</span>
	}

	/**
	 * Retrieve the Expected DVA
	 * 
	 * @return The Expected DVA
	 */

	public org.drip.xva.basel.ValueAdjustment dva()
	{
<span class="nc" id="L853">		double dva = 0.;</span>
<span class="nc" id="L854">		int pathCount = _pathExposureAdjustmentArray.length;</span>

		try {
<span class="nc bnc" id="L857" title="All 2 branches missed.">			for (int pathIndex = 0; pathIndex &lt; pathCount; ++pathIndex)</span>
			{
<span class="nc" id="L859">				dva += _pathExposureAdjustmentArray[pathIndex].debtAdjustment();</span>
			}
		}
<span class="nc" id="L862">		catch (java.lang.Exception e)</span>
		{
<span class="nc" id="L864">			e.printStackTrace();</span>

<span class="nc" id="L866">			return null;</span>
<span class="nc" id="L867">		}</span>

<span class="nc" id="L869">		return org.drip.xva.basel.ValueAdjustment.DVA (dva / pathCount);</span>
	}

	/**
	 * Retrieve the Expected FVA
	 * 
	 * @return The Expected FVA
	 */

	public org.drip.xva.basel.ValueAdjustment fva()
	{
<span class="nc" id="L880">		double fva = 0.;</span>
<span class="nc" id="L881">		int pathCount = _pathExposureAdjustmentArray.length;</span>

		try
		{
<span class="nc bnc" id="L885" title="All 2 branches missed.">			for (int pathIndex = 0; pathIndex &lt; pathCount; ++pathIndex)</span>
			{
<span class="nc" id="L887">				fva += _pathExposureAdjustmentArray[pathIndex].fundingValueAdjustment();</span>
			}
		}
<span class="nc" id="L890">		catch (java.lang.Exception e)</span>
		{
<span class="nc" id="L892">			e.printStackTrace();</span>

<span class="nc" id="L894">			return null;</span>
<span class="nc" id="L895">		}</span>

<span class="nc" id="L897">		return org.drip.xva.basel.ValueAdjustment.FVA (fva / pathCount);</span>
	}

	/**
	 * Retrieve the Expected FDA
	 * 
	 * @return The Expected FDA
	 */

	public org.drip.xva.basel.ValueAdjustment fda()
	{
<span class="nc" id="L908">		double fda = 0.;</span>
<span class="nc" id="L909">		int pathCount = _pathExposureAdjustmentArray.length;</span>

		try
		{
<span class="nc bnc" id="L913" title="All 2 branches missed.">			for (int pathIndex = 0; pathIndex &lt; pathCount; ++pathIndex)</span>
			{
<span class="nc" id="L915">				fda += _pathExposureAdjustmentArray[pathIndex].fundingDebtAdjustment();</span>
			}
		}
<span class="nc" id="L918">		catch (java.lang.Exception e)</span>
		{
<span class="nc" id="L920">			e.printStackTrace();</span>

<span class="nc" id="L922">			return null;</span>
<span class="nc" id="L923">		}</span>

<span class="nc" id="L925">		return org.drip.xva.basel.ValueAdjustment.FDA (fda / pathCount);</span>
	}

	/**
	 * Retrieve the Expected DVA2
	 * 
	 * @return The Expected DVA2
	 */

	public org.drip.xva.basel.ValueAdjustment dva2()
	{
<span class="nc" id="L936">		return fda();</span>
	}

	/**
	 * Retrieve the Expected FCA
	 * 
	 * @return The Expected FCA
	 */

	public org.drip.xva.basel.ValueAdjustment fca()
	{
<span class="nc" id="L947">		double fca = 0.;</span>
<span class="nc" id="L948">		int pathCount = _pathExposureAdjustmentArray.length;</span>

<span class="nc bnc" id="L950" title="All 2 branches missed.">		for (int pathIndex = 0; pathIndex &lt; pathCount; ++pathIndex)</span>
		{
<span class="nc" id="L952">			fca += _pathExposureAdjustmentArray[pathIndex].fundingCostAdjustment();</span>
		}

<span class="nc" id="L955">		return org.drip.xva.basel.ValueAdjustment.HYBRID (fca / pathCount);</span>
	}

	/**
	 * Retrieve the Expected FBA
	 * 
	 * @return The Expected FBA
	 */

	public org.drip.xva.basel.ValueAdjustment fba()
	{
<span class="nc" id="L966">		double fba = 0.;</span>
<span class="nc" id="L967">		int pathCount = _pathExposureAdjustmentArray.length;</span>

<span class="nc bnc" id="L969" title="All 2 branches missed.">		for (int pathIndex = 0; pathIndex &lt; pathCount; ++pathIndex)</span>
		{
<span class="nc" id="L971">			fba += _pathExposureAdjustmentArray[pathIndex].fundingBenefitAdjustment();</span>
		}

<span class="nc" id="L974">		return org.drip.xva.basel.ValueAdjustment.HYBRID (fba / pathCount);</span>
	}

	/**
	 * Retrieve the Expected SFVA
	 * 
	 * @return The Expected SFVA
	 */

	public org.drip.xva.basel.ValueAdjustment sfva()
	{
<span class="nc" id="L985">		double sfva = 0.;</span>
<span class="nc" id="L986">		int pathCount = _pathExposureAdjustmentArray.length;</span>

<span class="nc bnc" id="L988" title="All 2 branches missed.">		for (int pathIndex = 0; pathIndex &lt; pathCount; ++pathIndex)</span>
		{
<span class="nc" id="L990">			sfva += _pathExposureAdjustmentArray[pathIndex].symmetricFundingValueAdjustment();</span>
		}

<span class="nc" id="L993">		return org.drip.xva.basel.ValueAdjustment.HYBRID (sfva / pathCount);</span>
	}

	/**
	 * Retrieve the Total VA
	 * 
	 * @return The Total VA
	 */

	public double total()
	{
<span class="nc" id="L1004">		return cva().amount() + dva().amount() + fva().amount() + colva().amount();</span>
	}

	/**
	 * Generate the &quot;Digest&quot; containing the &quot;Thin&quot; Path Statistics
	 * 
	 * @return The &quot;Digest&quot; containing the &quot;Thin&quot; Path Statistics
	 */

	public org.drip.xva.gross.ExposureAdjustmentDigest digest()
	{
<span class="nc" id="L1015">		int vertexCount = vertexDates().length;</span>

<span class="nc" id="L1017">		int pathCount = _pathExposureAdjustmentArray.length;</span>
<span class="nc" id="L1018">		double[] pathCVA = new double[pathCount];</span>
<span class="nc" id="L1019">		double[] pathDVA = new double[pathCount];</span>
<span class="nc" id="L1020">		double[] pathFBA = new double[pathCount];</span>
<span class="nc" id="L1021">		double[] pathFCA = new double[pathCount];</span>
<span class="nc" id="L1022">		double[] pathFDA = new double[pathCount];</span>
<span class="nc" id="L1023">		double[] pathFVA = new double[pathCount];</span>
<span class="nc" id="L1024">		double[] pathUCVA = new double[pathCount];</span>
<span class="nc" id="L1025">		double[] pathSFVA = new double[pathCount];</span>
<span class="nc" id="L1026">		double[] pathCVACL = new double[pathCount];</span>
<span class="nc" id="L1027">		double[] pathFTDCVA = new double[pathCount];</span>
<span class="nc" id="L1028">		double[] pathCOLVA = new double[pathCount];</span>
<span class="nc" id="L1029">		double[] pathTotalVA = new double[pathCount];</span>
<span class="nc" id="L1030">		double[] pathFTDCOLVA = new double[pathCount];</span>
<span class="nc" id="L1031">		double[][] fundingExposure = new double[vertexCount][pathCount];</span>
<span class="nc" id="L1032">		double[][] fundingExposurePV = new double[vertexCount][pathCount];</span>
<span class="nc" id="L1033">		double[][] collateralizedExposure = new double[vertexCount][pathCount];</span>
<span class="nc" id="L1034">		double[][] uncollateralizedExposure = new double[vertexCount][pathCount];</span>
<span class="nc" id="L1035">		double[][] collateralizedExposurePV = new double[vertexCount][pathCount];</span>
<span class="nc" id="L1036">		double[][] uncollateralizedExposurePV = new double[vertexCount][pathCount];</span>
<span class="nc" id="L1037">		double[][] collateralizedPositiveExposure = new double[vertexCount][pathCount];</span>
<span class="nc" id="L1038">		double[][] collateralizedNegativeExposure = new double[vertexCount][pathCount];</span>
<span class="nc" id="L1039">		double[][] uncollateralizedPositiveExposure = new double[vertexCount][pathCount];</span>
<span class="nc" id="L1040">		double[][] uncollateralizedNegativeExposure = new double[vertexCount][pathCount];</span>
<span class="nc" id="L1041">		double[][] collateralizedPositiveExposurePV = new double[vertexCount][pathCount];</span>
<span class="nc" id="L1042">		double[][] collateralizedNegativeExposurePV = new double[vertexCount][pathCount];</span>
<span class="nc" id="L1043">		double[][] uncollateralizedPositiveExposurePV = new double[vertexCount][pathCount];</span>
<span class="nc" id="L1044">		double[][] uncollateralizedNegativeExposurePV = new double[vertexCount][pathCount];</span>

<span class="nc bnc" id="L1046" title="All 2 branches missed.">		for (int vertexIndex = 0; vertexIndex &lt; vertexCount; ++vertexIndex)</span>
		{
<span class="nc bnc" id="L1048" title="All 2 branches missed.">			for (int pathIndex = 0; pathIndex &lt; pathCount; ++pathIndex)</span>
			{
<span class="nc" id="L1050">				collateralizedExposure[vertexIndex][pathIndex] = 0.;</span>
<span class="nc" id="L1051">				uncollateralizedExposure[vertexIndex][pathIndex] = 0.;</span>
<span class="nc" id="L1052">				collateralizedExposurePV[vertexIndex][pathIndex] = 0.;</span>
<span class="nc" id="L1053">				uncollateralizedExposurePV[vertexIndex][pathIndex] = 0.;</span>
<span class="nc" id="L1054">				collateralizedPositiveExposure[vertexIndex][pathIndex] = 0.;</span>
<span class="nc" id="L1055">				collateralizedNegativeExposure[vertexIndex][pathIndex] = 0.;</span>
<span class="nc" id="L1056">				uncollateralizedPositiveExposure[vertexIndex][pathIndex] = 0.;</span>
<span class="nc" id="L1057">				uncollateralizedNegativeExposure[vertexIndex][pathIndex] = 0.;</span>
<span class="nc" id="L1058">				collateralizedPositiveExposurePV[vertexIndex][pathIndex] = 0.;</span>
<span class="nc" id="L1059">				collateralizedNegativeExposurePV[vertexIndex][pathIndex] = 0.;</span>
<span class="nc" id="L1060">				uncollateralizedPositiveExposurePV[vertexIndex][pathIndex] = 0.;</span>
<span class="nc" id="L1061">				uncollateralizedNegativeExposurePV[vertexIndex][pathIndex] = 0.;</span>
			}
		}

<span class="nc bnc" id="L1065" title="All 2 branches missed.">		for (int pathIndex = 0; pathIndex &lt; pathCount; ++pathIndex)</span>
		{
<span class="nc" id="L1067">			double[] pathCollateralizedExposure =</span>
<span class="nc" id="L1068">				_pathExposureAdjustmentArray[pathIndex].vertexCollateralizedExposure();</span>

<span class="nc" id="L1070">			double[] pathCollateralizedExposurePV =</span>
<span class="nc" id="L1071">				_pathExposureAdjustmentArray[pathIndex].vertexCollateralizedExposurePV();</span>

<span class="nc" id="L1073">			double[] pathCollateralizedPositiveExposure =</span>
<span class="nc" id="L1074">				_pathExposureAdjustmentArray[pathIndex].vertexCollateralizedPositiveExposure();</span>

<span class="nc" id="L1076">			double[] pathCollateralizedPositiveExposurePV =</span>
<span class="nc" id="L1077">				_pathExposureAdjustmentArray[pathIndex].vertexCollateralizedPositiveExposurePV();</span>

<span class="nc" id="L1079">			double[] pathCollateralizedNegativeExposure =</span>
<span class="nc" id="L1080">				_pathExposureAdjustmentArray[pathIndex].vertexCollateralizedNegativeExposure();</span>

<span class="nc" id="L1082">			double[] pathCollateralizedNegativeExposurePV =</span>
<span class="nc" id="L1083">				_pathExposureAdjustmentArray[pathIndex].vertexCollateralizedNegativeExposurePV();</span>

<span class="nc" id="L1085">			double[] pathUncollateralizedExposure =</span>
<span class="nc" id="L1086">				_pathExposureAdjustmentArray[pathIndex].vertexUncollateralizedExposure();</span>

<span class="nc" id="L1088">			double[] pathUncollateralizedExposurePV =</span>
<span class="nc" id="L1089">				_pathExposureAdjustmentArray[pathIndex].vertexUncollateralizedExposurePV();</span>

<span class="nc" id="L1091">			double[] pathUncollateralizedPositiveExposure =</span>
<span class="nc" id="L1092">				_pathExposureAdjustmentArray[pathIndex].vertexUncollateralizedPositiveExposure();</span>

<span class="nc" id="L1094">			double[] pathUncollateralizedPositiveExposurePV =</span>
<span class="nc" id="L1095">				_pathExposureAdjustmentArray[pathIndex].vertexUncollateralizedPositiveExposurePV();</span>

<span class="nc" id="L1097">			double[] pathUncollateralizedNegativeExposure =</span>
<span class="nc" id="L1098">				_pathExposureAdjustmentArray[pathIndex].vertexUncollateralizedNegativeExposure();</span>

<span class="nc" id="L1100">			double[] pathUncollateralizedNegativeExposurePV =</span>
<span class="nc" id="L1101">				_pathExposureAdjustmentArray[pathIndex].vertexUncollateralizedNegativeExposurePV();</span>

<span class="nc" id="L1103">			double[] pathFundingExposure = _pathExposureAdjustmentArray[pathIndex].vertexFundingExposure();</span>

<span class="nc" id="L1105">			double[] pathFundingExposurePV =</span>
<span class="nc" id="L1106">				_pathExposureAdjustmentArray[pathIndex].vertexFundingExposurePV();</span>

			try
			{
<span class="nc" id="L1110">				pathCVA[pathIndex] = _pathExposureAdjustmentArray[pathIndex].creditAdjustment();</span>

<span class="nc" id="L1112">				pathDVA[pathIndex] = _pathExposureAdjustmentArray[pathIndex].debtAdjustment();</span>

<span class="nc" id="L1114">				pathFCA[pathIndex] = _pathExposureAdjustmentArray[pathIndex].fundingCostAdjustment();</span>

<span class="nc" id="L1116">				pathFDA[pathIndex] = _pathExposureAdjustmentArray[pathIndex].fundingDebtAdjustment();</span>

<span class="nc" id="L1118">				pathFVA[pathIndex] = _pathExposureAdjustmentArray[pathIndex].fundingValueAdjustment();</span>

<span class="nc" id="L1120">				pathFBA[pathIndex] = _pathExposureAdjustmentArray[pathIndex].fundingBenefitAdjustment();</span>

<span class="nc" id="L1122">				pathUCVA[pathIndex] = _pathExposureAdjustmentArray[pathIndex].unilateralCreditAdjustment();</span>

<span class="nc" id="L1124">				pathSFVA[pathIndex] =</span>
<span class="nc" id="L1125">					_pathExposureAdjustmentArray[pathIndex].symmetricFundingValueAdjustment();</span>

<span class="nc" id="L1127">				pathCVACL[pathIndex] =</span>
<span class="nc" id="L1128">					_pathExposureAdjustmentArray[pathIndex].contraLiabilityCreditAdjustment();</span>

<span class="nc" id="L1130">				pathFTDCVA[pathIndex] = _pathExposureAdjustmentArray[pathIndex].bilateralCreditAdjustment();</span>

<span class="nc" id="L1132">				pathCOLVA[pathIndex] =</span>
<span class="nc" id="L1133">					_pathExposureAdjustmentArray[pathIndex].bilateralCollateralAdjustment();</span>

<span class="nc" id="L1135">				pathFTDCOLVA[pathIndex] =</span>
<span class="nc" id="L1136">					_pathExposureAdjustmentArray[pathIndex].bilateralCollateralAdjustment();</span>

<span class="nc" id="L1138">				pathTotalVA[pathIndex] = _pathExposureAdjustmentArray[pathIndex].totalAdjustment();</span>
			}
<span class="nc" id="L1140">			catch (java.lang.Exception e)</span>
			{
<span class="nc" id="L1142">				e.printStackTrace();</span>

<span class="nc" id="L1144">				return null;</span>
<span class="nc" id="L1145">			}</span>

<span class="nc bnc" id="L1147" title="All 2 branches missed.">			for (int vertexIndex = 0; vertexIndex &lt; vertexCount; ++vertexIndex)</span>
			{
<span class="nc" id="L1149">				collateralizedExposure[vertexIndex][pathIndex] =</span>
					pathCollateralizedExposure[vertexIndex];
<span class="nc" id="L1151">				collateralizedExposurePV[vertexIndex][pathIndex] =</span>
					pathCollateralizedExposurePV[vertexIndex];
<span class="nc" id="L1153">				collateralizedPositiveExposure[vertexIndex][pathIndex] =</span>
					pathCollateralizedPositiveExposure[vertexIndex];
<span class="nc" id="L1155">				collateralizedPositiveExposurePV[vertexIndex][pathIndex] =</span>
					pathCollateralizedPositiveExposurePV[vertexIndex];
<span class="nc" id="L1157">				collateralizedNegativeExposure[vertexIndex][pathIndex] =</span>
					pathCollateralizedNegativeExposure[vertexIndex];
<span class="nc" id="L1159">				collateralizedNegativeExposurePV[vertexIndex][pathIndex] =</span>
					pathCollateralizedNegativeExposurePV[vertexIndex];
<span class="nc" id="L1161">				uncollateralizedExposure[vertexIndex][pathIndex] =</span>
					pathUncollateralizedExposure[vertexIndex];
<span class="nc" id="L1163">				uncollateralizedExposurePV[vertexIndex][pathIndex] =</span>
					pathUncollateralizedExposurePV[vertexIndex];
<span class="nc" id="L1165">				uncollateralizedPositiveExposure[vertexIndex][pathIndex] =</span>
					pathUncollateralizedPositiveExposure[vertexIndex];
<span class="nc" id="L1167">				uncollateralizedPositiveExposurePV[vertexIndex][pathIndex] =</span>
					pathUncollateralizedPositiveExposurePV[vertexIndex];
<span class="nc" id="L1169">				uncollateralizedNegativeExposure[vertexIndex][pathIndex] =</span>
					pathUncollateralizedNegativeExposure[vertexIndex];
<span class="nc" id="L1171">				uncollateralizedNegativeExposurePV[vertexIndex][pathIndex] =</span>
					pathUncollateralizedNegativeExposurePV[vertexIndex];
<span class="nc" id="L1173">				fundingExposure[vertexIndex][pathIndex] = pathFundingExposure[vertexIndex];</span>
<span class="nc" id="L1174">				fundingExposurePV[vertexIndex][pathIndex] = pathFundingExposurePV[vertexIndex];</span>
			}
		}

		try
		{
<span class="nc" id="L1180">			return new org.drip.xva.gross.ExposureAdjustmentDigest (</span>
				pathCOLVA,
				pathFTDCOLVA,
				pathUCVA,
				pathFTDCVA,
				pathCVA,
				pathCVACL,
				pathDVA,
				pathFVA,
				pathFDA,
				pathFCA,
				pathFBA,
				pathSFVA,
				pathTotalVA,
				collateralizedExposure,
				collateralizedExposurePV,
				collateralizedPositiveExposure,
				collateralizedPositiveExposurePV,
				collateralizedNegativeExposure,
				collateralizedNegativeExposurePV,
				uncollateralizedExposure,
				uncollateralizedExposurePV,
				uncollateralizedPositiveExposure,
				uncollateralizedPositiveExposurePV,
				uncollateralizedNegativeExposure,
				uncollateralizedNegativeExposurePV,
				fundingExposure,
				fundingExposurePV
			);
		}
<span class="nc" id="L1210">		catch (java.lang.Exception e)</span>
		{
<span class="nc" id="L1212">			e.printStackTrace();</span>
		}

<span class="nc" id="L1215">		return null;</span>
	}

	/**
	 * Generate the Basel Exposure Digest
	 * 
	 * @param standardizedExposureGeneratorScheme The Standardized Basel Exposure Generation Scheme
	 * 
	 * @return The Basel Exposure Digest
	 */

	public org.drip.xva.gross.BaselExposureDigest baselExposureDigest (
		final org.drip.xva.settings.StandardizedExposureGeneratorScheme standardizedExposureGeneratorScheme)
	{
<span class="nc bnc" id="L1229" title="All 2 branches missed.">		if (null == standardizedExposureGeneratorScheme)</span>
		{
<span class="nc" id="L1231">			return null;</span>
		}

<span class="nc" id="L1234">		org.drip.analytics.date.JulianDate[] vertexJulianDateArray = vertexDates();</span>

<span class="nc" id="L1236">		int vertexCount = vertexJulianDateArray.length;</span>
<span class="nc" id="L1237">		int[] vertexDateArray = new int[vertexCount];</span>
<span class="nc" id="L1238">		int pathCount = _pathExposureAdjustmentArray.length;</span>
<span class="nc" id="L1239">		double[] collateralizedPositiveExposure = new double[vertexCount];</span>
<span class="nc" id="L1240">		double[] effectiveCollateralizedPositiveExposure = new double[vertexCount];</span>
<span class="nc" id="L1241">		org.drip.spline.params.SegmentCustomBuilderControl[] collateralizedExposureSegmentBuilderControlArray</span>
			= new org.drip.spline.params.SegmentCustomBuilderControl[vertexCount - 1];
		org.drip.spline.params.SegmentCustomBuilderControl[]
<span class="nc" id="L1244">			collateralizedPositiveExposureSegmentBuilderControlArray = new</span>
				org.drip.spline.params.SegmentCustomBuilderControl[vertexCount - 1];

<span class="nc" id="L1247">		org.drip.spline.params.SegmentCustomBuilderControl collateralizedExposureSegmentBuilderControl =</span>
<span class="nc" id="L1248">			standardizedExposureGeneratorScheme.collateralizedExposureSegmentBuilderControl();</span>

		org.drip.spline.params.SegmentCustomBuilderControl
<span class="nc" id="L1251">			collateralizedPositiveExposureSegmentBuilderControl =</span>
<span class="nc" id="L1252">				standardizedExposureGeneratorScheme.collateralizedPositiveExposureSegmentBuilderControl();</span>

<span class="nc bnc" id="L1254" title="All 2 branches missed.">		for (int i = 0; i &lt; vertexCount - 1; ++i)</span>
		{
<span class="nc" id="L1256">			collateralizedExposureSegmentBuilderControlArray[i] =</span>
				collateralizedExposureSegmentBuilderControl;
<span class="nc" id="L1258">			collateralizedPositiveExposureSegmentBuilderControlArray[i] =</span>
				collateralizedPositiveExposureSegmentBuilderControl;
		}

<span class="nc bnc" id="L1262" title="All 2 branches missed.">		for (int vertexIndex = 0; vertexIndex &lt; vertexCount; ++vertexIndex)</span>
		{
<span class="nc" id="L1264">			collateralizedPositiveExposure[vertexIndex] = 0.;</span>

<span class="nc" id="L1266">			vertexDateArray[vertexIndex] = vertexJulianDateArray[vertexIndex].julian();</span>
		}

<span class="nc bnc" id="L1269" title="All 2 branches missed.">		for (int pathIndex = 0; pathIndex &lt; pathCount; ++pathIndex)</span>
		{
<span class="nc" id="L1271">			double[] pathCollateralizedPositiveExposure =</span>
<span class="nc" id="L1272">				_pathExposureAdjustmentArray[pathIndex].vertexCollateralizedPositiveExposure();</span>

<span class="nc bnc" id="L1274" title="All 2 branches missed.">			for (int vertexIndex = 0; vertexIndex &lt; vertexCount; ++vertexIndex)</span>
			{
<span class="nc" id="L1276">				collateralizedPositiveExposure[vertexIndex] +=</span>
					pathCollateralizedPositiveExposure[vertexIndex];
			}
		}

<span class="nc bnc" id="L1281" title="All 2 branches missed.">		for (int vertexIndex = 0; vertexIndex &lt; vertexCount; ++vertexIndex)</span>
		{
<span class="nc" id="L1283">			collateralizedPositiveExposure[vertexIndex] /= pathCount;</span>

<span class="nc bnc" id="L1285" title="All 2 branches missed.">			if (0 == vertexIndex)</span>
			{
<span class="nc" id="L1287">				effectiveCollateralizedPositiveExposure[0] = collateralizedPositiveExposure[0];</span>
			}
			else
			{
<span class="nc bnc" id="L1291" title="All 2 branches missed.">				effectiveCollateralizedPositiveExposure[vertexIndex] =</span>
					collateralizedPositiveExposure[vertexIndex] &gt;
					effectiveCollateralizedPositiveExposure[vertexIndex - 1] ?
					collateralizedPositiveExposure[vertexIndex] :
					effectiveCollateralizedPositiveExposure[vertexIndex - 1];
			}
		}

		try
		{
<span class="nc" id="L1301">			org.drip.spline.stretch.MultiSegmentSequence multiSegmentSequenceCollateralizedPositiveExposure =</span>
<span class="nc" id="L1302">				org.drip.spline.stretch.MultiSegmentSequenceBuilder.CreateCalibratedStretchEstimator (</span>
					&quot;CollateralizedPositiveExposure&quot;,
					vertexDateArray,
					collateralizedPositiveExposure,
					collateralizedExposureSegmentBuilderControlArray,
					null,
<span class="nc" id="L1308">					org.drip.spline.stretch.BoundarySettings.NaturalStandard(),</span>
					org.drip.spline.stretch.MultiSegmentSequence.CALIBRATE
				);

			org.drip.spline.stretch.MultiSegmentSequence
<span class="nc" id="L1313">				multiSegmentSequenceEffectiveCollateralizedPositiveExposure =</span>
<span class="nc" id="L1314">					org.drip.spline.stretch.MultiSegmentSequenceBuilder.CreateCalibratedStretchEstimator (</span>
						&quot;EffectiveCollateralizedPositiveExposure&quot;,
						vertexDateArray,
						effectiveCollateralizedPositiveExposure,
						collateralizedPositiveExposureSegmentBuilderControlArray,
						null,
<span class="nc" id="L1320">						org.drip.spline.stretch.BoundarySettings.NaturalStandard(),</span>
						org.drip.spline.stretch.MultiSegmentSequence.CALIBRATE
					);

<span class="nc bnc" id="L1324" title="All 4 branches missed.">			if (null == multiSegmentSequenceCollateralizedPositiveExposure ||</span>
				null == multiSegmentSequenceEffectiveCollateralizedPositiveExposure)
			{
<span class="nc" id="L1327">				return null;</span>
			}

<span class="nc" id="L1330">			int exposureGeneratorTimeIntegrand = standardizedExposureGeneratorScheme.timeIntegrand();</span>

<span class="nc" id="L1332">			int integrandFinishDate = vertexDateArray[0] + exposureGeneratorTimeIntegrand;</span>

<span class="nc" id="L1334">			double effectiveExpectedPositiveExposure =</span>
<span class="nc" id="L1335">				multiSegmentSequenceEffectiveCollateralizedPositiveExposure.toAU().integrate (</span>
					vertexDateArray[0],
					integrandFinishDate
				) / exposureGeneratorTimeIntegrand;

<span class="nc" id="L1340">			return new BaselExposureDigest (</span>
				collateralizedPositiveExposure[0],
<span class="nc" id="L1342">				multiSegmentSequenceCollateralizedPositiveExposure.toAU().integrate (</span>
					vertexDateArray[0],
					integrandFinishDate
				) / exposureGeneratorTimeIntegrand,
				effectiveCollateralizedPositiveExposure[vertexCount - 1],
				effectiveExpectedPositiveExposure,
<span class="nc" id="L1348">				effectiveExpectedPositiveExposure * standardizedExposureGeneratorScheme.eadMultiplier()</span>
			);
		}
<span class="nc" id="L1351">		catch (java.lang.Exception e)</span>
		{
<span class="nc" id="L1353">			e.printStackTrace();</span>
		}

<span class="nc" id="L1356">		return null;</span>
	}
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.7.9.201702052155</span></div></body></html>