<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>Matrix.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">DROP</a> &gt; <a href="index.source.html" class="el_package">org.drip.numerical.linearalgebra</a> &gt; <span class="el_source">Matrix.java</span></div><h1>Matrix.java</h1><pre class="source lang-java linenums">
package org.drip.numerical.linearalgebra;

/*
 * -*- mode: java; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*-
 */

/*!
 * Copyright (C) 2020 Lakshmi Krishnamurthy
 * Copyright (C) 2019 Lakshmi Krishnamurthy
 * Copyright (C) 2018 Lakshmi Krishnamurthy
 * Copyright (C) 2017 Lakshmi Krishnamurthy
 * Copyright (C) 2016 Lakshmi Krishnamurthy
 * Copyright (C) 2015 Lakshmi Krishnamurthy
 * Copyright (C) 2014 Lakshmi Krishnamurthy
 * Copyright (C) 2013 Lakshmi Krishnamurthy
 * 
 *  This file is part of DROP, an open-source library targeting analytics/risk, transaction cost analytics,
 *  	asset liability management analytics, capital, exposure, and margin analytics, valuation adjustment
 *  	analytics, and portfolio construction analytics within and across fixed income, credit, commodity,
 *  	equity, FX, and structured products. It also includes auxiliary libraries for algorithm support,
 *  	numerical analysis, numerical optimization, spline builder, model validation, statistical learning,
 *  	and computational support.
 *  
 *  	https://lakshmidrip.github.io/DROP/
 *  
 *  DROP is composed of three modules:
 *  
 *  - DROP Product Core - https://lakshmidrip.github.io/DROP-Product-Core/
 *  - DROP Portfolio Core - https://lakshmidrip.github.io/DROP-Portfolio-Core/
 *  - DROP Computational Core - https://lakshmidrip.github.io/DROP-Computational-Core/
 * 
 * 	DROP Product Core implements libraries for the following:
 * 	- Fixed Income Analytics
 * 	- Loan Analytics
 * 	- Transaction Cost Analytics
 * 
 * 	DROP Portfolio Core implements libraries for the following:
 * 	- Asset Allocation Analytics
 *  - Asset Liability Management Analytics
 * 	- Capital Estimation Analytics
 * 	- Exposure Analytics
 * 	- Margin Analytics
 * 	- XVA Analytics
 * 
 * 	DROP Computational Core implements libraries for the following:
 * 	- Algorithm Support
 * 	- Computation Support
 * 	- Function Analysis
 *  - Model Validation
 * 	- Numerical Analysis
 * 	- Numerical Optimizer
 * 	- Spline Builder
 *  - Statistical Learning
 * 
 * 	Documentation for DROP is Spread Over:
 * 
 * 	- Main                     =&gt; https://lakshmidrip.github.io/DROP/
 * 	- Wiki                     =&gt; https://github.com/lakshmiDRIP/DROP/wiki
 * 	- GitHub                   =&gt; https://github.com/lakshmiDRIP/DROP
 * 	- Repo Layout Taxonomy     =&gt; https://github.com/lakshmiDRIP/DROP/blob/master/Taxonomy.md
 * 	- Javadoc                  =&gt; https://lakshmidrip.github.io/DROP/Javadoc/index.html
 * 	- Technical Specifications =&gt; https://github.com/lakshmiDRIP/DROP/tree/master/Docs/Internal
 * 	- Release Versions         =&gt; https://lakshmidrip.github.io/DROP/version.html
 * 	- Community Credits        =&gt; https://lakshmidrip.github.io/DROP/credits.html
 * 	- Issues Catalog           =&gt; https://github.com/lakshmiDRIP/DROP/issues
 * 	- JUnit                    =&gt; https://lakshmidrip.github.io/DROP/junit/index.html
 * 	- Jacoco                   =&gt; https://lakshmidrip.github.io/DROP/jacoco/index.html
 * 
 *  Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 *   	you may not use this file except in compliance with the License.
 *   
 *  You may obtain a copy of the License at
 *  	http://www.apache.org/licenses/LICENSE-2.0
 *  
 *  Unless required by applicable law or agreed to in writing, software
 *  	distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 *  	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  
 *  See the License for the specific language governing permissions and
 *  	limitations under the License.
 */

/**
 * &lt;i&gt;Matrix&lt;/i&gt; implements Matrix manipulation routines. It exports the following functionality:
 *  &lt;ul&gt;
 *  	&lt;li&gt;
 * 			Matrix Inversion using Closed form solutions (for low-dimension matrices), or using Gaussian
 * 				elimination
 *  	&lt;/li&gt;
 *  	&lt;li&gt;
 * 			Matrix Product
 *  	&lt;/li&gt;
 *  	&lt;li&gt;
 * 			Matrix Diagonalization and Diagonal Pivoting
 *  	&lt;/li&gt;
 *  	&lt;li&gt;
 * 			Matrix Regularization through Row Addition/Row Swap
 *  	&lt;/li&gt;
 *  &lt;/ul&gt;
 * 
 * &lt;br&gt;&lt;br&gt;
 *  &lt;ul&gt;
 *		&lt;li&gt;&lt;b&gt;Module &lt;/b&gt; = &lt;a href = &quot;https://github.com/lakshmiDRIP/DROP/tree/master/ComputationalCore.md&quot;&gt;Computational Core Module&lt;/a&gt;&lt;/li&gt;
 *		&lt;li&gt;&lt;b&gt;Library&lt;/b&gt; = &lt;a href = &quot;https://github.com/lakshmiDRIP/DROP/tree/master/NumericalAnalysisLibrary.md&quot;&gt;Numerical Analysis Library&lt;/a&gt;&lt;/li&gt;
 *		&lt;li&gt;&lt;b&gt;Project&lt;/b&gt; = &lt;a href = &quot;https://github.com/lakshmiDRIP/DROP/tree/master/src/main/java/org/drip/numerical/README.md&quot;&gt;Numerical Quadrature, Differentiation, Eigenization, Linear Algebra, and Utilities&lt;/a&gt;&lt;/li&gt;
 *		&lt;li&gt;&lt;b&gt;Package&lt;/b&gt; = &lt;a href = &quot;https://github.com/lakshmiDRIP/DROP/tree/master/src/main/java/org/drip/numerical/linearalgebra/README.md&quot;&gt;Linear Algebra Matrix Transform Library&lt;/a&gt;&lt;/li&gt;
 *  &lt;/ul&gt;
 * &lt;br&gt;&lt;br&gt;
 *
 * @author Lakshmi Krishnamurthy
 */

<span class="nc" id="L114">public class Matrix {</span>

	/**
	 * Lower Triangular Matrix
	 */

<span class="fc" id="L120">	public static int LOWER_TRIANGULAR = 1;</span>

	/**
	 * Upper Triangular Matrix
	 */

<span class="fc" id="L126">	public static int UPPER_TRIANGULAR = 2;</span>

	/**
	 * Lower+Upper Triangular Matrix
	 */

<span class="fc" id="L132">	public static int LOWER_AND_UPPER_TRIANGULAR = 3;</span>

	/**
	 * Non Triangular Matrix
	 */

<span class="fc" id="L138">	public static int NON_TRIANGULAR = 0;</span>

	/**
	 * Diagonalize the specified row in the source matrix, and apply comparable operations to the target
	 * 
	 * @param iQ Row in the Source Matrix
	 * @param aadblZ2XJack Source Matrix
	 * @param aadblZ2YJack Target Matrix
	 * 
	 * @return TRUE - Diagonalization was successful
	 */

	public static final boolean DiagonalizeRow (
		final int iQ,
		final double[][] aadblZ2XJack,
		final double[][] aadblZ2YJack)
	{
<span class="nc bnc" id="L155" title="All 2 branches missed.">		if (0. != aadblZ2XJack[iQ][iQ]) return true;</span>

<span class="nc" id="L157">		int iSize = aadblZ2XJack.length;</span>
<span class="nc" id="L158">		int iP = iSize - 1;</span>

<span class="nc bnc" id="L160" title="All 4 branches missed.">		while (0. == aadblZ2XJack[iP][iQ] &amp;&amp; iP &gt;= 0) --iP;</span>

<span class="nc bnc" id="L162" title="All 2 branches missed.">		if (0 &gt; iP) return false;</span>

<span class="nc bnc" id="L164" title="All 2 branches missed.">		for (int j = 0; j &lt; iSize; ++j)</span>
<span class="nc" id="L165">			aadblZ2XJack[iQ][j] += aadblZ2XJack[iP][j];</span>

<span class="nc" id="L167">		aadblZ2YJack[iQ][iP] += 1.;</span>
<span class="nc" id="L168">		return true;</span>
	}

	/**
	 * Compute the Product of an Input Matrix and a Column
	 * 
	 * @param aadblA Matrix A
	 * @param adblB Array B
	 * 
	 * @return The Product
	 */

	public static final double[] Product (
		final double[][] aadblA,
		final double[] adblB)
	{
<span class="pc bpc" id="L184" title="2 of 4 branches missed.">		if (null == aadblA || null == adblB) return null;</span>

<span class="fc" id="L186">		int iNumACol = aadblA[0].length;</span>
<span class="fc" id="L187">		int iNumProductCol = adblB.length;</span>
<span class="fc" id="L188">		int iNumProductRow = aadblA.length;</span>
<span class="fc" id="L189">		double[] adblProduct = new double[iNumProductRow];</span>

<span class="pc bpc" id="L191" title="4 of 8 branches missed.">		if (0 == iNumACol || iNumACol != adblB.length || 0 == iNumProductRow || 0 == iNumProductCol)</span>
<span class="nc" id="L192">			return null;</span>

<span class="fc bfc" id="L194" title="All 2 branches covered.">		for (int iRow = 0; iRow &lt; iNumProductRow; ++iRow) {</span>
<span class="fc" id="L195">			adblProduct[iRow] = 0.;</span>

<span class="fc bfc" id="L197" title="All 2 branches covered.">			for (int i = 0; i &lt; iNumACol; ++i) {</span>
<span class="pc bpc" id="L198" title="1 of 2 branches missed.">				if (!org.drip.numerical.common.NumberUtil.IsValid (aadblA[iRow][i]) ||</span>
<span class="pc bpc" id="L199" title="1 of 2 branches missed.">					!org.drip.numerical.common.NumberUtil.IsValid (adblB[i]))</span>
<span class="nc" id="L200">					return null;</span>

<span class="fc" id="L202">				adblProduct[iRow] += aadblA[iRow][i] * adblB[i];</span>
			}
		}

<span class="fc" id="L206">		return adblProduct;</span>
	}

	/**
	 * Compute the Product of an input column and a matrix
	 * 
	 * @param adblA Column A
	 * @param aadblB Matrix B
	 * 
	 * @return The Product
	 */

	public static final double[][] Product (
		final double[] adblA,
		final double[][] aadblB)
	{
<span class="nc bnc" id="L222" title="All 4 branches missed.">		if (null == adblA || null == aadblB) return null;</span>

<span class="nc" id="L224">		int iNumACol = adblA.length;</span>
<span class="nc" id="L225">		int iNumProductCol = aadblB.length;</span>
<span class="nc" id="L226">		double[][] aadblProduct = new double[iNumACol][iNumProductCol];</span>

<span class="nc bnc" id="L228" title="All 6 branches missed.">		if (0 == iNumACol || iNumACol != aadblB.length || 0 == iNumProductCol) return null;</span>

<span class="nc bnc" id="L230" title="All 2 branches missed.">		for (int iRow = 0; iRow &lt; iNumACol; ++iRow) {</span>
<span class="nc bnc" id="L231" title="All 2 branches missed.">			for (int iCol = 0; iCol &lt; iNumProductCol; ++iCol) {</span>
<span class="nc" id="L232">				aadblProduct[iRow][iCol] = 0.;</span>

<span class="nc bnc" id="L234" title="All 2 branches missed.">				for (int i = 0; i &lt; iNumACol; ++i) {</span>
<span class="nc bnc" id="L235" title="All 2 branches missed.">					if (!org.drip.numerical.common.NumberUtil.IsValid (adblA[iRow]) ||</span>
<span class="nc bnc" id="L236" title="All 2 branches missed.">						!org.drip.numerical.common.NumberUtil.IsValid (aadblB[i][iCol]))</span>
<span class="nc" id="L237">						return null;</span>

<span class="nc" id="L239">					aadblProduct[iRow][iCol] += adblA[iRow] * aadblB[i][iCol];</span>
				}
			}
		}

<span class="nc" id="L244">		return aadblProduct;</span>
	}

	/**
	 * Compute the Product of the input matrices
	 * 
	 * @param aadblA Matrix A
	 * @param aadblB Matrix B
	 * 
	 * @return The Product
	 */

	public static final double[][] Product (
		final double[][] aadblA,
		final double[][] aadblB)
	{
<span class="pc bpc" id="L260" title="2 of 4 branches missed.">		if (null == aadblA || null == aadblB) return null;</span>

<span class="fc" id="L262">		int iNumACol = aadblA[0].length;</span>
<span class="fc" id="L263">		int iNumProductRow = aadblA.length;</span>
<span class="fc" id="L264">		int iNumProductCol = aadblB[0].length;</span>
<span class="fc" id="L265">		double[][] aadblProduct = new double[iNumProductRow][iNumProductCol];</span>

<span class="pc bpc" id="L267" title="4 of 8 branches missed.">		if (0 == iNumACol || iNumACol != aadblB.length || 0 == iNumProductRow || 0 == iNumProductCol)</span>
<span class="nc" id="L268">			return null;</span>

<span class="fc bfc" id="L270" title="All 2 branches covered.">		for (int iRow = 0; iRow &lt; iNumProductRow; ++iRow) {</span>
<span class="fc bfc" id="L271" title="All 2 branches covered.">			for (int iCol = 0; iCol &lt; iNumProductCol; ++iCol) {</span>
<span class="fc" id="L272">				aadblProduct[iRow][iCol] = 0.;</span>

<span class="fc bfc" id="L274" title="All 2 branches covered.">				for (int i = 0; i &lt; iNumACol; ++i) {</span>
<span class="pc bpc" id="L275" title="1 of 2 branches missed.">					if (!org.drip.numerical.common.NumberUtil.IsValid (aadblA[iRow][i]) ||</span>
<span class="pc bpc" id="L276" title="1 of 2 branches missed.">						!org.drip.numerical.common.NumberUtil.IsValid (aadblB[i][iCol]))</span>
<span class="nc" id="L277">						return null;</span>

<span class="fc" id="L279">					aadblProduct[iRow][iCol] += aadblA[iRow][i] * aadblB[i][iCol];</span>
				}
			}
		}

<span class="fc" id="L284">		return aadblProduct;</span>
	}

	/**
	 * Make a Square Diagonal Matrix from a Row
	 * 
	 * @param adblA The Row Array
	 * 
	 * @return The corresponding Square Diagonal Matrix
	 */

	public static final double[][] MakeSquareDiagonal (
		final double[] adblA)
	{
<span class="nc bnc" id="L298" title="All 2 branches missed.">		if (null == adblA) return null;</span>

<span class="nc" id="L300">		int iNumElement = adblA.length;</span>
<span class="nc bnc" id="L301" title="All 2 branches missed.">		double[][] aadblDiagonal = 0 == iNumElement ? null : new double[iNumElement][iNumElement];</span>

<span class="nc bnc" id="L303" title="All 2 branches missed.">		if (0 == iNumElement) return null;</span>

<span class="nc bnc" id="L305" title="All 2 branches missed.">		for (int i = 0; i &lt; iNumElement; ++i) {</span>
<span class="nc bnc" id="L306" title="All 2 branches missed.">			for (int j = 0; j &lt; iNumElement; ++j)</span>
<span class="nc bnc" id="L307" title="All 2 branches missed.">				aadblDiagonal[i][j] = i == j ? adblA[i] : 0.;</span>
		}

<span class="nc" id="L310">		return aadblDiagonal;</span>
	}

	/**
	 * Invert a 2D Matrix using Cramer's Rule
	 * 
	 * @param aadblA Input 2D Matrix
	 * 
	 * @return The Inverted Matrix
	 */

	public static final double[][] Invert2DMatrixUsingCramerRule (
		final double[][] aadblA)
	{
<span class="nc bnc" id="L324" title="All 6 branches missed.">		if (null == aadblA || 2 != aadblA.length || 2 != aadblA[0].length) return null;</span>

<span class="nc bnc" id="L326" title="All 2 branches missed.">		for (int i = 0; i &lt; 2; ++i) {</span>
<span class="nc bnc" id="L327" title="All 2 branches missed.">			for (int j = 0; j &lt; 2; ++j) {</span>
<span class="nc bnc" id="L328" title="All 2 branches missed.">				if (!org.drip.numerical.common.NumberUtil.IsValid (aadblA[i][j])) return null;</span>
			}
		}

<span class="nc" id="L332">		double dblScale = aadblA[0][0] * aadblA[1][1] - aadblA[0][1] * aadblA[1][0];</span>

<span class="nc bnc" id="L334" title="All 2 branches missed.">		if (0. == dblScale) return null;</span>

<span class="nc" id="L336">		return new double[][] {{aadblA[1][1] / dblScale, -1. * aadblA[0][1] / dblScale}, {-1. * aadblA[1][0]</span>
			/ dblScale, aadblA[0][0] / dblScale}};
	}

	/**
	 * Regularize the specified diagonal entry of the input matrix using Row Swapping
	 * 
	 * @param mct The Input Matrix Complement Transform
	 * 
	 * @return The Regularization was successful
	 */

	public static final boolean RegularizeUsingRowSwap (
		final org.drip.numerical.linearalgebra.MatrixComplementTransform mct)
	{
<span class="pc bpc" id="L351" title="1 of 2 branches missed.">		if (null == mct) return false;</span>

<span class="fc" id="L353">		int iSize = mct.size();</span>

<span class="fc" id="L355">		double[][] aadblSource = mct.getSource();</span>

<span class="fc" id="L357">		double[][] aadblComplement = mct.getComplement();</span>

<span class="fc bfc" id="L359" title="All 2 branches covered.">		for (int iDiagonal = 0; iDiagonal &lt; iSize; ++iDiagonal) {</span>
<span class="fc bfc" id="L360" title="All 2 branches covered.">			if (0. == aadblSource[iDiagonal][iDiagonal]) {</span>
<span class="fc" id="L361">				int iSwapRow = iSize - 1;</span>

<span class="fc bfc" id="L363" title="All 6 branches covered.">				while (iSwapRow &gt;= 0 &amp;&amp; (0. == aadblSource[iSwapRow][iDiagonal] || 0. ==</span>
					aadblSource[iDiagonal][iSwapRow]))
<span class="fc" id="L365">					--iSwapRow;</span>

<span class="fc bfc" id="L367" title="All 2 branches covered.">				if (0 &gt; iSwapRow) {</span>
<span class="fc" id="L368">					iSwapRow = 0;</span>

<span class="fc bfc" id="L370" title="All 4 branches covered.">					while (iSwapRow &lt; iSize &amp;&amp; 0. == aadblSource[iSwapRow][iDiagonal])</span>
<span class="fc" id="L371">						++iSwapRow;</span>

<span class="fc bfc" id="L373" title="All 2 branches covered.">					if (iSwapRow &gt;= iSize) return false;</span>
				}

<span class="fc bfc" id="L376" title="All 2 branches covered.">				for (int iCol = 0; iCol &lt; iSize; ++iCol) {</span>
<span class="fc" id="L377">					double dblComplementDiagonalEntry = aadblComplement[iDiagonal][iCol];</span>
<span class="fc" id="L378">					aadblComplement[iDiagonal][iCol] = aadblComplement[iSwapRow][iCol];</span>
<span class="fc" id="L379">					aadblComplement[iSwapRow][iCol] = dblComplementDiagonalEntry;</span>
<span class="fc" id="L380">					double dblSourceDiagonalEntry = aadblSource[iDiagonal][iCol];</span>
<span class="fc" id="L381">					aadblSource[iDiagonal][iCol] = aadblSource[iSwapRow][iCol];</span>
<span class="fc" id="L382">					aadblSource[iSwapRow][iCol] = dblSourceDiagonalEntry;</span>
				}
			}
		}

		/* for (int iDiagonal = 0; iDiagonal &lt; iSize; ++iDiagonal) {
			if (0. == aadblSource[iDiagonal][iDiagonal]) {
				org.drip.quant.common.NumberUtil.Print2DArray (&quot;ZERO DIAG!&quot;, aadblSource, false);

				return false;
			}
		} */

<span class="fc" id="L395">		return true;</span>
	}

	/**
	 * Regularize the specified diagonal entry of the input matrix using Row Addition
	 * 
	 * @param mct The Input Matrix Complement Transform
	 * 
	 * @return The Regularization was successful
	 */

	public static final boolean RegularizeUsingRowAddition (
		final org.drip.numerical.linearalgebra.MatrixComplementTransform mct)
	{
<span class="nc bnc" id="L409" title="All 2 branches missed.">		if (null == mct) return false;</span>

<span class="nc" id="L411">		int iSize = mct.size();</span>

<span class="nc" id="L413">		double[][] aadblSource = mct.getSource();</span>

<span class="nc" id="L415">		double[][] aadblComplement = mct.getComplement();</span>

<span class="nc bnc" id="L417" title="All 2 branches missed.">		for (int iDiagonal = 0; iDiagonal &lt; iSize; ++iDiagonal) {</span>
<span class="nc bnc" id="L418" title="All 2 branches missed.">			if (0. == aadblSource[iDiagonal][iDiagonal]) {</span>
<span class="nc" id="L419">				int iPivotRow = iSize - 1;</span>

<span class="nc bnc" id="L421" title="All 4 branches missed.">				while (0. == aadblSource[iPivotRow][iDiagonal] &amp;&amp; iPivotRow &gt;= 0) --iPivotRow;</span>

<span class="nc bnc" id="L423" title="All 2 branches missed.">				if (0 &gt; iPivotRow) return false;</span>

<span class="nc bnc" id="L425" title="All 2 branches missed.">				for (int iCol = 0; iCol &lt; iSize; ++iCol) {</span>
<span class="nc" id="L426">					aadblSource[iDiagonal][iCol] += aadblSource[iPivotRow][iCol];</span>
<span class="nc" id="L427">					aadblComplement[iDiagonal][iCol] += aadblComplement[iPivotRow][iCol];</span>
				}
			}
		}

<span class="nc" id="L432">		return true;</span>
	}

	/**
	 * Pivot the Diagonal of the Input Matrix
	 * 
	 * @param aadblA The Input Matrix
	 * 
	 * @return The Matrix Complement Transform Instance
	 */

	public static final org.drip.numerical.linearalgebra.MatrixComplementTransform PivotDiagonal (
		final double[][] aadblA)
	{
<span class="pc bpc" id="L446" title="1 of 2 branches missed.">		if (null == aadblA) return null;</span>

<span class="fc" id="L448">		int iSize = aadblA.length;</span>
<span class="fc" id="L449">		double[][] aadblSource = new double[iSize][iSize];</span>
<span class="fc" id="L450">		double[][] aadblComplement = new double[iSize][iSize];</span>
<span class="fc" id="L451">		org.drip.numerical.linearalgebra.MatrixComplementTransform mctOut = null;</span>

<span class="pc bpc" id="L453" title="3 of 6 branches missed.">		if (0 == iSize || null == aadblA[0] || iSize != aadblA[0].length) return null;</span>

<span class="fc bfc" id="L455" title="All 2 branches covered.">		for (int i = 0; i &lt; iSize; ++i) {</span>
<span class="fc bfc" id="L456" title="All 2 branches covered.">			for (int j = 0; j &lt; iSize; ++j) {</span>
<span class="fc" id="L457">				aadblSource[i][j] = aadblA[i][j];</span>
<span class="fc bfc" id="L458" title="All 2 branches covered.">				aadblComplement[i][j] = i == j ? 1. : 0.;</span>
			}
		}

		try {
<span class="fc" id="L463">			mctOut = new org.drip.numerical.linearalgebra.MatrixComplementTransform (aadblSource,</span>
				aadblComplement);
<span class="nc" id="L465">		} catch (java.lang.Exception e) {</span>
<span class="nc" id="L466">			e.printStackTrace();</span>

<span class="nc" id="L468">			return null;</span>
<span class="fc" id="L469">		}</span>

<span class="fc bfc" id="L471" title="All 2 branches covered.">		return RegularizeUsingRowSwap (mctOut) ? mctOut : null;</span>
	}

	/**
	 * Invert the Source Matrix using Gaussian Elimination
	 * 
	 * @param aadblSource Source Matrix
	 * 
	 * @return The Inverted Matrix
	 */

	public static final double[][] InvertUsingGaussianElimination (
		final double[][] aadblSource)
	{
<span class="fc" id="L485">		org.drip.numerical.linearalgebra.MatrixComplementTransform mctRegularized =</span>
<span class="fc" id="L486">			org.drip.numerical.linearalgebra.Matrix.PivotDiagonal (aadblSource);</span>

<span class="fc bfc" id="L488" title="All 2 branches covered.">		if (null == mctRegularized) return null;</span>

<span class="fc" id="L490">		double[][] aadblRegularizedSource = mctRegularized.getSource();</span>

<span class="fc" id="L492">		double[][] aadblRegularizedInverse = mctRegularized.getComplement();</span>

<span class="fc" id="L494">		int iSize = aadblRegularizedSource.length;</span>

<span class="fc bfc" id="L496" title="All 2 branches covered.">		for (int iDiagonal = 0; iDiagonal &lt; iSize; ++iDiagonal) {</span>
<span class="fc bfc" id="L497" title="All 2 branches covered.">			if (0. == aadblRegularizedSource[iDiagonal][iDiagonal]) return null;</span>

<span class="fc bfc" id="L499" title="All 2 branches covered.">			for (int iRow = 0; iRow &lt; iSize; ++iRow) {</span>
<span class="fc bfc" id="L500" title="All 4 branches covered.">				if (iRow == iDiagonal || 0. == aadblRegularizedSource[iRow][iDiagonal]) continue;</span>

<span class="fc" id="L502">				double dblColEntryEliminatorRatio = aadblRegularizedSource[iDiagonal][iDiagonal] /</span>
					aadblRegularizedSource[iRow][iDiagonal];

<span class="fc bfc" id="L505" title="All 2 branches covered.">				for (int iCol = 0; iCol &lt; iSize; ++iCol) {</span>
<span class="fc" id="L506">					aadblRegularizedSource[iRow][iCol] = aadblRegularizedSource[iRow][iCol] *</span>
						dblColEntryEliminatorRatio - aadblRegularizedSource[iDiagonal][iCol];
<span class="fc" id="L508">					aadblRegularizedInverse[iRow][iCol] = aadblRegularizedInverse[iRow][iCol] *</span>
						dblColEntryEliminatorRatio - aadblRegularizedInverse[iDiagonal][iCol];
				}
			}
		}

<span class="fc bfc" id="L514" title="All 2 branches covered.">		for (int iDiagonal = 0; iDiagonal &lt; iSize; ++iDiagonal) {</span>
<span class="fc" id="L515">			double dblDiagScaleDown = aadblRegularizedSource[iDiagonal][iDiagonal];</span>

<span class="pc bpc" id="L517" title="1 of 2 branches missed.">			if (0. == dblDiagScaleDown) return null;</span>

<span class="fc bfc" id="L519" title="All 2 branches covered.">			for (int iCol = 0; iCol &lt; iSize; ++iCol) {</span>
<span class="fc" id="L520">				aadblRegularizedSource[iDiagonal][iCol] /= dblDiagScaleDown;</span>
<span class="fc" id="L521">				aadblRegularizedInverse[iDiagonal][iCol] /= dblDiagScaleDown;</span>
			}
		}

<span class="fc" id="L525">		return aadblRegularizedInverse;</span>
	}

	/**
	 * Invert the input matrix using the specified Method
	 * 
	 * @param aadblA Input Matrix
	 * @param strMethod The Inversion Method
	 * 
	 * @return The Inverted Matrix
	 */

	public static final double[][] Invert (
		final double[][] aadblA,
		final java.lang.String strMethod)
	{
<span class="nc bnc" id="L541" title="All 2 branches missed.">		if (null == aadblA) return null;</span>

<span class="nc" id="L543">		int iSize = aadblA.length;</span>
<span class="nc" id="L544">		double[][] aadblAInv = null;</span>
<span class="nc" id="L545">		double[][] aadblASource = new double[iSize][iSize];</span>
<span class="nc" id="L546">		double[][] aadblZ2YJack = new double[iSize][iSize];</span>

<span class="nc bnc" id="L548" title="All 4 branches missed.">		if (0 == iSize || iSize != aadblA[0].length) return null;</span>

<span class="nc bnc" id="L550" title="All 2 branches missed.">		for (int i = 0; i &lt; iSize; ++i) {</span>
<span class="nc bnc" id="L551" title="All 2 branches missed.">			for (int j = 0; j &lt; iSize; ++j) {</span>
<span class="nc bnc" id="L552" title="All 2 branches missed.">				if (!org.drip.numerical.common.NumberUtil.IsValid (aadblASource[i][j] = aadblA[i][j]))</span>
<span class="nc" id="L553">					return null;</span>

<span class="nc bnc" id="L555" title="All 2 branches missed.">				aadblZ2YJack[i][j] = i == j ? 1. : 0.;</span>
			}
		}

<span class="nc bnc" id="L559" title="All 2 branches missed.">		for (int i = 0; i &lt; iSize; ++i) {</span>
<span class="nc bnc" id="L560" title="All 4 branches missed.">			if (0. == aadblASource[i][i] &amp;&amp; !DiagonalizeRow (i, aadblASource, aadblZ2YJack)) return null;</span>
		}

<span class="nc bnc" id="L563" title="All 6 branches missed.">		if (null == strMethod || strMethod.isEmpty() || strMethod.equalsIgnoreCase (&quot;GaussianElimination&quot;))</span>
<span class="nc" id="L564">			aadblAInv = InvertUsingGaussianElimination (aadblASource);</span>

<span class="nc bnc" id="L566" title="All 6 branches missed.">		if (null == aadblAInv || iSize != aadblAInv.length || iSize != aadblAInv[0].length) return null;</span>

<span class="nc" id="L568">		return Product (aadblAInv, aadblZ2YJack);</span>
	}

	/**
	 * Compute the Rank of the Matrix
	 * 
	 * @param aadblSource Source Matrix
	 * 
	 * @return The Rank of the Matrix
	 * 
	 * @throws java.lang.Exception Thrown if the Rank Cannot be computed
	 */

	public static final int Rank (
		final double[][] aadblSource)
		throws java.lang.Exception
	{
<span class="pc bpc" id="L585" title="1 of 2 branches missed.">		if (null == aadblSource) return 0;</span>

<span class="fc" id="L587">		int iNumRow = aadblSource.length;</span>

<span class="pc bpc" id="L589" title="1 of 2 branches missed.">		if (iNumRow == 0) return 0;</span>

<span class="fc" id="L591">		int iNumCol = aadblSource[0].length;</span>

<span class="fc bfc" id="L593" title="All 2 branches covered.">		for (int iScanRow = 0; iScanRow &lt; iNumRow; ++iScanRow) {</span>
<span class="pc bpc" id="L594" title="1 of 2 branches missed.">			if (!org.drip.numerical.common.NumberUtil.IsValid (aadblSource[iScanRow]))</span>
<span class="nc" id="L595">				throw new java.lang.Exception (&quot;Matrix::Rank =&gt; Invalid Inputs&quot;);</span>
		}

<span class="pc bpc" id="L598" title="1 of 2 branches missed.">		double[][] aadblRegularizedSource = iNumRow &lt; iNumCol ?</span>
<span class="pc" id="L599">			org.drip.numerical.linearalgebra.Matrix.Transpose (aadblSource) : aadblSource;</span>

<span class="fc" id="L601">		int iNumDependentRow = 0;</span>
<span class="fc" id="L602">		int iProcessedRow = aadblRegularizedSource.length;</span>
<span class="fc" id="L603">		int iProcessedCol = aadblRegularizedSource[0].length;</span>

<span class="pc bpc" id="L605" title="3 of 4 branches missed.">		if (1 == iNumRow || 1 == iNumCol) return iProcessedRow;</span>

<span class="nc bnc" id="L607" title="All 2 branches missed.">		for (int iScanRow = 0; iScanRow &lt; iProcessedCol; ++iScanRow) {</span>
<span class="nc bnc" id="L608" title="All 2 branches missed.">			for (int iRow = 0; iRow &lt; iProcessedCol; ++iRow) {</span>
<span class="nc bnc" id="L609" title="All 4 branches missed.">				if (iRow == iScanRow || 0. == aadblRegularizedSource[iRow][iScanRow]) continue;</span>

<span class="nc" id="L611">				double dblColEntryEliminatorRatio = aadblRegularizedSource[iScanRow][iScanRow] /</span>
					aadblRegularizedSource[iRow][iScanRow];

<span class="nc bnc" id="L614" title="All 2 branches missed.">				for (int iCol = 0; iCol &lt; iProcessedCol; ++iCol)</span>
<span class="nc" id="L615">					aadblRegularizedSource[iRow][iCol] = aadblRegularizedSource[iRow][iCol] *</span>
						dblColEntryEliminatorRatio - aadblRegularizedSource[iScanRow][iCol];
			}
		}

<span class="nc bnc" id="L620" title="All 2 branches missed.">		for (int iScanRow = 0; iScanRow &lt; iProcessedCol; ++iScanRow) {</span>
<span class="nc bnc" id="L621" title="All 2 branches missed.">			if (0. == org.drip.numerical.linearalgebra.Matrix.Modulus (aadblRegularizedSource[iScanRow]))</span>
<span class="nc" id="L622">				++iNumDependentRow;</span>
		}

<span class="nc" id="L625">		return iProcessedRow - iNumDependentRow;</span>
	}

	/**
	 * Transpose the specified Square Matrix
	 * 
	 * @param aadblA The Input Square Matrix
	 * 
	 * @return The Transpose of the Square Matrix
	 */

	public static final double[][] Transpose (
		final double[][] aadblA)
	{
<span class="pc bpc" id="L639" title="1 of 2 branches missed.">		if (null == aadblA) return null;</span>

<span class="fc" id="L641">		int iRowSize = aadblA.length;</span>

<span class="pc bpc" id="L643" title="2 of 4 branches missed.">		if (0 == iRowSize || null == aadblA[0]) return null;</span>

<span class="fc" id="L645">		int iColSize = aadblA[0].length;</span>
<span class="fc" id="L646">		double[][] aadblATranspose = new double[iColSize][iRowSize];</span>

<span class="pc bpc" id="L648" title="1 of 2 branches missed.">		if (0 == iColSize) return null;</span>

<span class="fc bfc" id="L650" title="All 2 branches covered.">		for (int i = 0; i &lt; iColSize; ++i) {</span>
<span class="fc bfc" id="L651" title="All 2 branches covered.">			for (int j = 0; j &lt; iRowSize; ++j)</span>
<span class="fc" id="L652">				aadblATranspose[i][j] = aadblA[j][i];</span>
		}

<span class="fc" id="L655">		return aadblATranspose;</span>
	}

	/**
	 * Compute the Cholesky-Banachiewicz Factorization of the specified Matrix.
	 * 
	 * @param aadblA The Input Matrix
	 * 
	 * @return The Factorized Matrix
	 */

	public static final double[][] CholeskyBanachiewiczFactorization (
		final double[][] aadblA)
	{
<span class="pc bpc" id="L669" title="1 of 2 branches missed.">		if (null == aadblA) return null;</span>

<span class="fc" id="L671">		int iSize = aadblA.length;</span>
<span class="fc" id="L672">		double[][] aadblL = new double[iSize][iSize];</span>

<span class="pc bpc" id="L674" title="3 of 6 branches missed.">		if (0 == iSize || null == aadblA[0] || iSize != aadblA[0].length) return null;</span>

<span class="fc bfc" id="L676" title="All 2 branches covered.">		for (int i = 0; i &lt; iSize; ++i) {</span>
<span class="fc bfc" id="L677" title="All 2 branches covered.">			for (int j = 0; j &lt; iSize; ++j) {</span>
<span class="fc" id="L678">				aadblL[i][j] = 0.;</span>

<span class="fc bfc" id="L680" title="All 2 branches covered.">				if (i == j) {</span>
<span class="fc bfc" id="L681" title="All 2 branches covered.">					for (int k = 0; k &lt; j; ++k)</span>
<span class="fc" id="L682">						aadblL[j][j] -= aadblL[j][k] * aadblL[j][k];</span>

<span class="fc" id="L684">					aadblL[j][j] = java.lang.Math.sqrt (aadblL[j][j] + aadblA[j][j]);</span>
<span class="fc bfc" id="L685" title="All 2 branches covered.">				} else if (i &gt; j) {</span>
<span class="fc bfc" id="L686" title="All 2 branches covered.">					for (int k = 0; k &lt; j; ++k)</span>
<span class="fc" id="L687">						aadblL[i][j] -= aadblL[i][k] * aadblL[j][k];</span>

<span class="fc" id="L689">					aadblL[i][j] = (aadblA[i][j] + aadblL[i][j]) / aadblL[j][j];</span>
				}
			}
		}

<span class="fc" id="L694">		return aadblL;</span>
	}

	/**
	 * Dot Product of Vectors A and E
	 * 
	 * @param adblA Vector A
	 * @param adblE Vector E
	 * 
	 * @return The Dot Product
	 * 
	 * @throws java.lang.Exception Thrown if the Dot-Product cannot be computed
	 */

	public static final double DotProduct (
		final double[] adblA,
		final double[] adblE)
		throws java.lang.Exception
	{
<span class="pc bpc" id="L713" title="2 of 4 branches missed.">		if (null == adblA || null == adblE)</span>
<span class="nc" id="L714">			throw new java.lang.Exception (&quot;Matrix::DotProduct =&gt; Invalid Inputs!&quot;);</span>

<span class="fc" id="L716">		int iSize = adblA.length;</span>
<span class="fc" id="L717">		double dblDotProduct = 0.;</span>

<span class="pc bpc" id="L719" title="2 of 4 branches missed.">		if (0 == iSize || iSize != adblE.length)</span>
<span class="nc" id="L720">			throw new java.lang.Exception (&quot;Matrix::DotProduct =&gt; Invalid Inputs!&quot;);</span>

<span class="fc bfc" id="L722" title="All 2 branches covered.">		for (int i = 0; i &lt; iSize; ++i)</span>
<span class="fc" id="L723">			dblDotProduct += adblE[i] * adblA[i];</span>

<span class="fc" id="L725">		return dblDotProduct;</span>
	}

	/**
	 * Compute the Cross Product between the Specified Vectors
	 * 
	 * @param vector1 Vector #1
	 * @param vector2 Vector #2
	 * 
	 * @return The Cross Product
	 */

	public static final double[][] CrossProduct (
		final double[] vector1,
		final double[] vector2)
	{
<span class="nc bnc" id="L741" title="All 4 branches missed.">		if (null == vector1 || null == vector2)</span>
		{
<span class="nc" id="L743">			return null;</span>
		}

<span class="nc" id="L746">		int size1 = vector1.length;</span>
<span class="nc" id="L747">		int size2 = vector2.length;</span>
<span class="nc bnc" id="L748" title="All 4 branches missed.">		double[][] crossProduct = 0 == size1 || 0 == size2 ? null : new double[size1][size2];</span>

<span class="nc bnc" id="L750" title="All 2 branches missed.">		if (null == crossProduct)</span>
		{
<span class="nc" id="L752">			return null;</span>
		}

<span class="nc bnc" id="L755" title="All 2 branches missed.">		for (int index1 = 0; index1 &lt; size1; ++index1)</span>
		{
<span class="nc bnc" id="L757" title="All 2 branches missed.">			for (int index2 = 0; index2 &lt; size2; ++index2)</span>
			{
<span class="nc" id="L759">				crossProduct[index1][index2] = vector1[index1] * vector2[index2];</span>
			}
		}

<span class="nc" id="L763">		return crossProduct;</span>
	}

	/**
	 * Project the Vector A along the Vector E
	 * 
	 * @param adblA Vector A
	 * @param adblE Vector E
	 * 
	 * @return The Vector of Projection of A along E
	 */

	public static final double[] Project (
		final double[] adblA,
		final double[] adblE)
	{
<span class="nc bnc" id="L779" title="All 4 branches missed.">		if (null == adblA || null == adblE) return null;</span>

<span class="nc" id="L781">		int iSize = adblA.length;</span>
<span class="nc" id="L782">		double dblProjection = java.lang.Double.NaN;</span>
<span class="nc" id="L783">		double[] adblProjectAOnE = new double[iSize];</span>

<span class="nc bnc" id="L785" title="All 4 branches missed.">		if (0 == iSize || iSize != adblE.length) return null;</span>

		try {
<span class="nc" id="L788">			dblProjection = DotProduct (adblA, adblE) / DotProduct (adblE, adblE);</span>
<span class="nc" id="L789">		} catch (java.lang.Exception e) {</span>
<span class="nc" id="L790">			e.printStackTrace();</span>

<span class="nc" id="L792">			return null;</span>
<span class="nc" id="L793">		}</span>

<span class="nc bnc" id="L795" title="All 2 branches missed.">		for (int i = 0; i &lt; iSize; ++i)</span>
<span class="nc" id="L796">			adblProjectAOnE[i] = adblE[i] * dblProjection;</span>

<span class="nc" id="L798">		return adblProjectAOnE;</span>
	}

	/**
	 * Compute the Sum of the Input Vector
	 * 
	 * @param adbl The Input Vector
	 * 
	 * @return TRUE - The Sum of the Input Vector
	 * 
	 * @throws java.lang.Exception Thrown if the Inputs are Invalid
	 */

	public static final double Sum (
		final double[] adbl)
		throws java.lang.Exception
	{
<span class="pc bpc" id="L815" title="2 of 4 branches missed.">		if (null == adbl || !org.drip.numerical.common.NumberUtil.IsValid (adbl))</span>
<span class="nc" id="L816">			throw new java.lang.Exception (&quot;Matrix::Sum =&gt; Invalid Inputs&quot;);</span>

<span class="fc" id="L818">		double dblSum = 0.;</span>
<span class="fc" id="L819">		int iSize = adbl.length;</span>

<span class="pc bpc" id="L821" title="1 of 2 branches missed.">		if (0 == iSize) throw new java.lang.Exception (&quot;Matrix::Sum =&gt; Invalid Inputs&quot;);</span>

<span class="fc bfc" id="L823" title="All 2 branches covered.">		for (int i = 0; i &lt; iSize; ++i)</span>
<span class="fc" id="L824">			dblSum += adbl[i];</span>

<span class="fc" id="L826">		return dblSum;</span>
	}

	/**
	 * Compute the Modulus of the Input Vector
	 * 
	 * @param adbl The Input Vector
	 * 
	 * @return TRUE - The Modulus of the Input Vector
	 * 
	 * @throws java.lang.Exception Thrown if the Inputs are Invalid
	 */

	public static final double Modulus (
		final double[] adbl)
		throws java.lang.Exception
	{
<span class="nc bnc" id="L843" title="All 4 branches missed.">		if (null == adbl || !org.drip.numerical.common.NumberUtil.IsValid (adbl))</span>
<span class="nc" id="L844">			throw new java.lang.Exception (&quot;Matrix::Modulus =&gt; Invalid Inputs&quot;);</span>

<span class="nc" id="L846">		double dblModulus = 0.;</span>
<span class="nc" id="L847">		int iSize = adbl.length;</span>

<span class="nc bnc" id="L849" title="All 2 branches missed.">		if (0 == iSize) throw new java.lang.Exception (&quot;Matrix::Modulus =&gt; Invalid Inputs&quot;);</span>

<span class="nc bnc" id="L851" title="All 2 branches missed.">		for (int i = 0; i &lt; iSize; ++i)</span>
<span class="nc" id="L852">			dblModulus += adbl[i] * adbl[i];</span>

<span class="nc" id="L854">		return java.lang.Math.sqrt (dblModulus);</span>
	}

	/**
	 * Indicate if the Array Entries are Positive or Zero
	 * 
	 * @param adbl The Array
	 * 
	 * @return TRUE - The Array Entries are Positive or Zero
	 * 
	 * @throws java.lang.Exception Thrown if the Inputs are Invalid
	 */

	public static final boolean PositiveOrZero (
		final double[] adbl)
		throws java.lang.Exception
	{
<span class="nc bnc" id="L871" title="All 4 branches missed.">		if (null == adbl || !org.drip.numerical.common.NumberUtil.IsValid (adbl))</span>
<span class="nc" id="L872">			throw new java.lang.Exception (&quot;Matrix::PositiveOrZero =&gt; Invalid Inputs&quot;);</span>

<span class="nc" id="L874">		int iSize = adbl.length;</span>

<span class="nc bnc" id="L876" title="All 2 branches missed.">		if (0 == iSize) throw new java.lang.Exception (&quot;Matrix::PositiveOrZero =&gt; Invalid Inputs&quot;);</span>

<span class="nc bnc" id="L878" title="All 2 branches missed.">		for (int i = 0; i &lt; iSize; ++i) {</span>
<span class="nc bnc" id="L879" title="All 2 branches missed.">			if (0. &gt; adbl[i]) return false;</span>
		}

<span class="nc" id="L882">		return true;</span>
	}

	/**
	 * Indicate if the Array Entries are Negative or Zero
	 * 
	 * @param adbl The Array
	 * 
	 * @return The Array Entries are Negative or Zero
	 * 
	 * @throws java.lang.Exception Thrown if the Inputs are Invalid
	 */

	public static final boolean NegativeOrZero (
		final double[] adbl)
		throws java.lang.Exception
	{
<span class="nc bnc" id="L899" title="All 4 branches missed.">		if (null == adbl || !org.drip.numerical.common.NumberUtil.IsValid (adbl))</span>
<span class="nc" id="L900">			throw new java.lang.Exception (&quot;Matrix::NegativeOrZero =&gt; Invalid Inputs&quot;);</span>

<span class="nc" id="L902">		int iSize = adbl.length;</span>

<span class="nc bnc" id="L904" title="All 2 branches missed.">		if (0 == iSize)  throw new java.lang.Exception (&quot;Matrix::NegativeOrZero =&gt; Invalid Inputs&quot;);</span>

<span class="nc bnc" id="L906" title="All 2 branches missed.">		for (int i = 0; i &lt; iSize; ++i) {</span>
<span class="nc bnc" id="L907" title="All 2 branches missed.">			if (0. &lt; adbl[i]) return false;</span>
		}

<span class="nc" id="L910">		return true;</span>
	}

	/**
	 * Indicate if the Array Entries are Positive Linearly Independent
	 * 
	 * @param adbl The Array
	 * 
	 * @return TRUE - The Array Entries are Positive Linearly Independent
	 * 
	 * @throws java.lang.Exception Thrown if the Inputs are Invalid
	 */

	public static final boolean PositiveLinearlyIndependent (
		final double[] adbl)
		throws java.lang.Exception
	{
<span class="nc bnc" id="L927" title="All 4 branches missed.">		return !PositiveOrZero (adbl) &amp;&amp; !NegativeOrZero (adbl);</span>
	}

	/**
	 * Normalize the Input Vector
	 * 
	 * @param adbl The Input Vector
	 * 
	 * @return The Normalized Vector
	 */

	public static final double[] Normalize (
		final double[] adbl)
	{
<span class="pc bpc" id="L941" title="1 of 2 branches missed.">		if (null == adbl) return null;</span>

<span class="fc" id="L943">		double dblNorm = 0.;</span>
<span class="fc" id="L944">		int iSize = adbl.length;</span>
<span class="fc" id="L945">		double[] adblNormalized = new double[iSize];</span>

<span class="pc bpc" id="L947" title="1 of 2 branches missed.">		if (0 == iSize) return null;</span>

<span class="fc bfc" id="L949" title="All 2 branches covered.">		for (int i = 0; i &lt; iSize; ++i)</span>
<span class="fc" id="L950">			dblNorm += adbl[i] * adbl[i];</span>

<span class="fc" id="L952">		dblNorm = java.lang.Math.sqrt (dblNorm);</span>

<span class="fc bfc" id="L954" title="All 2 branches covered.">		for (int i = 0; i &lt; iSize; ++i)</span>
<span class="fc" id="L955">			adblNormalized[i] = adbl[i] / dblNorm;</span>

<span class="fc" id="L957">		return adblNormalized;</span>
	}

	/**
	 * Orthogonalize the Specified Matrix Using the Graham-Schmidt Method
	 * 
	 * @param aadblV The Input Matrix
	 * 
	 * @return The Orthogonalized Matrix
	 */

	public static final double[][] GrahamSchmidtOrthogonalization (
		final double[][] aadblV)
	{
<span class="pc bpc" id="L971" title="1 of 2 branches missed.">		if (null == aadblV) return null;</span>

<span class="fc" id="L973">		int iSize = aadblV.length;</span>
<span class="fc" id="L974">		double[][] aadblU = new double[iSize][iSize];</span>

<span class="pc bpc" id="L976" title="3 of 6 branches missed.">		if (0 == iSize || null == aadblV[0] || iSize != aadblV[0].length) return null;</span>

<span class="fc bfc" id="L978" title="All 2 branches covered.">		for (int i = 0; i &lt; iSize; ++i) {</span>
<span class="fc bfc" id="L979" title="All 2 branches covered.">			for (int j = 0; j &lt; iSize; ++j)</span>
<span class="fc" id="L980">				aadblU[i][j] = aadblV[i][j];</span>

<span class="fc bfc" id="L982" title="All 2 branches covered.">			for (int j = 0; j &lt; i; ++j) {</span>
<span class="fc" id="L983">				double dblProjectionAmplitude = java.lang.Double.NaN;</span>

				try {
<span class="fc" id="L986">					dblProjectionAmplitude = DotProduct (aadblV[i], aadblU[j]) / DotProduct (aadblU[j],</span>
						aadblU[j]);
<span class="nc" id="L988">				} catch (java.lang.Exception e) {</span>
<span class="nc" id="L989">					e.printStackTrace();</span>

<span class="nc" id="L991">					return null;</span>
<span class="fc" id="L992">				}</span>

<span class="fc bfc" id="L994" title="All 2 branches covered.">				for (int k = 0; k &lt; iSize; ++k)</span>
<span class="fc" id="L995">					aadblU[i][k] -= dblProjectionAmplitude * aadblU[j][k];</span>
			}
		}

<span class="fc" id="L999">		return aadblU;</span>
	}

	/**
	 * Orthonormalize the Specified Matrix Using the Graham-Schmidt Method
	 * 
	 * @param aadblV The Input Matrix
	 * 
	 * @return The Orthonormalized Matrix
	 */

	public static final double[][] GrahamSchmidtOrthonormalization (
		final double[][] aadblV)
	{
<span class="fc" id="L1013">		double[][] aadblVOrthogonal = GrahamSchmidtOrthogonalization (aadblV);</span>

<span class="pc bpc" id="L1015" title="1 of 2 branches missed.">		if (null == aadblVOrthogonal) return null;</span>

<span class="fc" id="L1017">		int iSize = aadblVOrthogonal.length;</span>

<span class="fc" id="L1019">		double[][] aadblVOrthonormal = new double[iSize][];</span>

<span class="fc bfc" id="L1021" title="All 2 branches covered.">		for (int i = 0; i &lt; iSize; ++i)</span>
<span class="fc" id="L1022">			aadblVOrthonormal[i] = Normalize (aadblVOrthogonal[i]);</span>

<span class="fc" id="L1024">		return aadblVOrthonormal;</span>
	}

	/**
	 * Perform a QR Decomposition on the Input Matrix
	 * 
	 * @param aadblA The Input Matrix
	 * 
	 * @return The Output of QR Decomposition
	 */

	public static final org.drip.numerical.linearalgebra.QR QRDecomposition (
		final double[][] aadblA)
	{
<span class="fc" id="L1038">		double[][] aadblQ = GrahamSchmidtOrthonormalization (aadblA);</span>

<span class="pc bpc" id="L1040" title="1 of 2 branches missed.">		if (null == aadblQ) return null;</span>

<span class="fc" id="L1042">		int iSize = aadblQ.length;</span>
<span class="fc" id="L1043">		double[][] aadblR = new double[iSize][iSize];</span>

		try {
<span class="fc bfc" id="L1046" title="All 2 branches covered.">			for (int i = 0; i &lt; iSize; ++i) {</span>
<span class="fc bfc" id="L1047" title="All 2 branches covered.">				for (int j = 0; j &lt; iSize; ++j)</span>
<span class="fc bfc" id="L1048" title="All 2 branches covered.">					aadblR[i][j] = i &gt; j ? DotProduct (aadblQ[i], aadblA[j]) : 0.;</span>
			}

<span class="fc" id="L1051">			return new org.drip.numerical.linearalgebra.QR (aadblQ, aadblR);</span>
<span class="nc" id="L1052">		} catch (java.lang.Exception e) {</span>
<span class="nc" id="L1053">			e.printStackTrace();</span>
		}

<span class="nc" id="L1056">		return null;</span>
	}

	/**
	 * Retrieve the Triangular Type of the Matrix
	 * 
	 * @param aadblA The Input Matrix
	 * @param dblFloor The Floor Level that means &quot;Zero&quot;
	 * 
	 * @return The Triangular Type
	 */

	public static final int TriangularType (
		final double[][] aadblA,
		final double dblFloor)
	{
<span class="pc bpc" id="L1072" title="3 of 6 branches missed.">		if (null == aadblA || !org.drip.numerical.common.NumberUtil.IsValid (dblFloor) || dblFloor &lt; 0.)</span>
<span class="nc" id="L1073">			return NON_TRIANGULAR;</span>

<span class="fc" id="L1075">		int iSize = aadblA.length;</span>
<span class="fc" id="L1076">		boolean bLowerTriangular = true;</span>
<span class="fc" id="L1077">		boolean bUpperTriangular = true;</span>

<span class="pc bpc" id="L1079" title="3 of 6 branches missed.">		if (1 &gt;= iSize || null == aadblA[0] || iSize != aadblA[0].length) return NON_TRIANGULAR;</span>

<span class="fc bfc" id="L1081" title="All 2 branches covered.">		for (int i = 0; i &lt; iSize; ++i) {</span>
<span class="fc bfc" id="L1082" title="All 2 branches covered.">			for (int j = 0; j &lt; iSize; ++j) {</span>
<span class="fc bfc" id="L1083" title="All 2 branches covered.">				if (i &gt; j) {</span>
<span class="fc bfc" id="L1084" title="All 2 branches covered.">					if (java.lang.Math.abs (aadblA[i][j]) &gt; dblFloor) bLowerTriangular = false;</span>
<span class="fc bfc" id="L1085" title="All 2 branches covered.">				} else if (i &lt; j) {</span>
<span class="fc bfc" id="L1086" title="All 2 branches covered.">					if (java.lang.Math.abs (aadblA[i][j]) &gt; dblFloor) bUpperTriangular = false;</span>
				}
			}
		}

<span class="pc bpc" id="L1091" title="1 of 4 branches missed.">		if (bLowerTriangular &amp;&amp; bUpperTriangular) return LOWER_AND_UPPER_TRIANGULAR;</span>

<span class="pc bpc" id="L1093" title="3 of 4 branches missed.">		if (bLowerTriangular &amp;&amp; !bUpperTriangular) return LOWER_TRIANGULAR;</span>

<span class="pc bpc" id="L1095" title="1 of 4 branches missed.">		if (!bLowerTriangular &amp;&amp; bUpperTriangular) return UPPER_TRIANGULAR;</span>

<span class="fc" id="L1097">		return NON_TRIANGULAR;</span>
	}

	/**
	 * Compute the Rayleigh Quotient given the Matrix and one of its Eigenvector
	 * 
	 * @param matrix The Given Matrix
	 * @param eigenvector The corresponding Eigenvector
	 * 
	 * @return The Computed Rayleigh Quotient
	 * 
	 * @throws java.lang.Exception Thrown if the Inputs are Invalid
	 */

	public static final double RayleighQuotient (
		final double[][] matrix,
		final double[] eigenvector)
		throws java.lang.Exception
	{
<span class="fc" id="L1116">		return org.drip.numerical.linearalgebra.Matrix.DotProduct (</span>
			eigenvector,
<span class="fc" id="L1118">			org.drip.numerical.linearalgebra.Matrix.Product (</span>
				matrix,
				eigenvector
			)
		);
	}

	/**
	 * Scale the Entries of the Input Vector by the Factor
	 * 
	 * @param vector The Input Vector
	 * @param scaleFactor The Scale Factor
	 * 
	 * @return The Scaled Matrix
	 */

	public static final double[] Scale1D (
		final double[] vector,
		final double scaleFactor)
	{
<span class="nc bnc" id="L1138" title="All 4 branches missed.">		if (null == vector || !org.drip.numerical.common.NumberUtil.IsValid (scaleFactor))</span>
		{
<span class="nc" id="L1140">			return null;</span>
		}

<span class="nc" id="L1143">		int rowCount = vector.length;</span>
<span class="nc bnc" id="L1144" title="All 2 branches missed.">		double[] scaledVector = 0 == rowCount ? null : new double[rowCount];</span>

<span class="nc bnc" id="L1146" title="All 2 branches missed.">		for (int rowIndex = 0; rowIndex &lt; rowCount ; ++rowIndex)</span>
		{
<span class="nc" id="L1148">			scaledVector[rowIndex] = vector[rowIndex] * scaleFactor;</span>
		}

<span class="nc" id="L1151">		return scaledVector;</span>
	}

	/**
	 * Scale the Entries of the Input Matrix by the Factor
	 * 
	 * @param matrix The Input Matrix
	 * @param scaleFactor The Scale Factor
	 * 
	 * @return The Scaled Matrix
	 */

	public static final double[][] Scale2D (
		final double[][] matrix,
		final double scaleFactor)
	{
<span class="nc bnc" id="L1167" title="All 4 branches missed.">		if (null == matrix || !org.drip.numerical.common.NumberUtil.IsValid (scaleFactor))</span>
		{
<span class="nc" id="L1169">			return null;</span>
		}

<span class="nc" id="L1172">		int rowCount = matrix.length;</span>
<span class="nc bnc" id="L1173" title="All 4 branches missed.">		int columnCount = 0 == rowCount || null == matrix[0] ? 0 : matrix[0].length;</span>
<span class="nc bnc" id="L1174" title="All 2 branches missed.">		double[][] scaledMatrix = 0 == columnCount ? null : new double[rowCount][columnCount];</span>

<span class="nc bnc" id="L1176" title="All 2 branches missed.">		for (int rowIndex = 0; rowIndex &lt; rowCount ; ++rowIndex)</span>
		{
<span class="nc bnc" id="L1178" title="All 2 branches missed.">			for (int columnIndex = 0; columnIndex &lt; columnCount ; ++columnIndex)</span>
			{
<span class="nc" id="L1180">				scaledMatrix[rowIndex][columnIndex] = matrix[rowIndex][columnIndex] * scaleFactor;</span>
			}
		}

<span class="nc" id="L1184">		return scaledMatrix;</span>
	}

    /**
     * Indicate if the Specified Matrix is Diagonal
     *
     * @param matrix The Matrix
     *
     * @return TRUE - The Specified Matrix is Diagonal
     */

    public static final boolean IsDiagonal (
    	final double[][] matrix)
    {
<span class="nc bnc" id="L1198" title="All 2 branches missed.">       if (null == matrix)</span>
       {
<span class="nc" id="L1200">    	   return false;</span>
       }

<span class="nc" id="L1203">       int rowCount = matrix.length;</span>
<span class="nc bnc" id="L1204" title="All 4 branches missed.">       int columnCount = 0 == rowCount || null == matrix[0] ? 0 : matrix[0].length;</span>

<span class="nc" id="L1206">       for (int rowIndex = 0;</span>
<span class="nc bnc" id="L1207" title="All 2 branches missed.">    		rowIndex &lt; rowCount;</span>
<span class="nc" id="L1208">            ++rowIndex)</span>
       {
<span class="nc" id="L1210">    	   for (int columnIndex = 0;</span>
<span class="nc bnc" id="L1211" title="All 2 branches missed.">                columnIndex &lt; columnCount;</span>
<span class="nc" id="L1212">                ++columnIndex)</span>
           {
<span class="nc bnc" id="L1214" title="All 4 branches missed.">    		   if (rowIndex != columnIndex &amp;&amp; 0. != matrix[rowIndex][columnIndex])</span>
    		   {
<span class="nc" id="L1216">                   return false;</span>
    		   }
           }
       }

<span class="nc" id="L1221">       return true;</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.7.9.201702052155</span></div></body></html>