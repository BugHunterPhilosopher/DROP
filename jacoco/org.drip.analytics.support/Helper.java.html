<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>Helper.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">DROP</a> &gt; <a href="index.source.html" class="el_package">org.drip.analytics.support</a> &gt; <span class="el_source">Helper.java</span></div><h1>Helper.java</h1><pre class="source lang-java linenums">
package org.drip.analytics.support;

/*
 * -*- mode: java; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*-
 */

/*!
 * Copyright (C) 2019 Lakshmi Krishnamurthy
 * Copyright (C) 2018 Lakshmi Krishnamurthy
 * Copyright (C) 2017 Lakshmi Krishnamurthy
 * Copyright (C) 2016 Lakshmi Krishnamurthy
 * Copyright (C) 2015 Lakshmi Krishnamurthy
 * Copyright (C) 2014 Lakshmi Krishnamurthy
 * Copyright (C) 2013 Lakshmi Krishnamurthy
 * Copyright (C) 2012 Lakshmi Krishnamurthy
 * Copyright (C) 2011 Lakshmi Krishnamurthy
 * 
 *  This file is part of DROP, an open-source library targeting risk, transaction costs, exposure, margin
 *  	calculations, valuation adjustment, and portfolio construction within and across fixed income,
 *  	credit, commodity, equity, FX, and structured products.
 *  
 *  	https://lakshmidrip.github.io/DROP/
 *  
 *  DROP is composed of three modules:
 *  
 *  - DROP Analytics Core - https://lakshmidrip.github.io/DROP-Analytics-Core/
 *  - DROP Portfolio Core - https://lakshmidrip.github.io/DROP-Portfolio-Core/
 *  - DROP Numerical Core - https://lakshmidrip.github.io/DROP-Numerical-Core/
 * 
 * 	DROP Analytics Core implements libraries for the following:
 * 	- Fixed Income Analytics
 * 	- Asset Backed Analytics
 * 	- XVA Analytics
 * 	- Exposure and Margin Analytics
 * 
 * 	DROP Portfolio Core implements libraries for the following:
 * 	- Asset Allocation Analytics
 * 	- Transaction Cost Analytics
 * 
 * 	DROP Numerical Core implements libraries for the following:
 * 	- Statistical Learning Library
 * 	- Numerical Optimizer Library
 * 	- Machine Learning Library
 * 	- Spline Builder Library
 * 
 * 	Documentation for DROP is Spread Over:
 * 
 * 	- Main                     =&gt; https://lakshmidrip.github.io/DROP/
 * 	- Wiki                     =&gt; https://github.com/lakshmiDRIP/DROP/wiki
 * 	- GitHub                   =&gt; https://github.com/lakshmiDRIP/DROP
 * 	- Repo Layout Taxonomy     =&gt; https://github.com/lakshmiDRIP/DROP/blob/master/Taxonomy.md
 * 	- Javadoc                  =&gt; https://lakshmidrip.github.io/DROP/Javadoc/index.html
 * 	- Technical Specifications =&gt; https://github.com/lakshmiDRIP/DROP/tree/master/Docs/Internal
 * 	- Release Versions         =&gt; https://lakshmidrip.github.io/DROP/version.html
 * 	- Community Credits        =&gt; https://lakshmidrip.github.io/DROP/credits.html
 * 	- Issues Catalog           =&gt; https://github.com/lakshmiDRIP/DROP/issues
 * 	- JUnit                    =&gt; https://lakshmidrip.github.io/DROP/junit/index.html
 * 	- Jacoco                   =&gt; https://lakshmidrip.github.io/DROP/jacoco/index.html
 * 
 *  Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 *   	you may not use this file except in compliance with the License.
 *   
 *  You may obtain a copy of the License at
 *  	http://www.apache.org/licenses/LICENSE-2.0
 *  
 *  Unless required by applicable law or agreed to in writing, software
 *  	distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 *  	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  
 *  See the License for the specific language governing permissions and
 *  	limitations under the License.
 */

/**
 * &lt;i&gt;Helper&lt;/i&gt; contains the collection of the analytics related utility functions used by the modules.
 * Following are some of the functionality that it exposes:
 *
 *	&lt;br&gt;&lt;br&gt;
 *  &lt;ul&gt;
 * 		&lt;li&gt;
 * 			Yield to Discount Factor, and vice versa
 * 		&lt;/li&gt;
 * 		&lt;li&gt;
 * 			Map Bloomberg Day Count Codes to Credit Analytics Day Count Codes
 * 		&lt;/li&gt;
 * 		&lt;li&gt;
 * 			Generate rule-based curve node manifest measure bumps
 * 		&lt;/li&gt;
 * 		&lt;li&gt;
 * 			Generate loss periods using a variety of different schemes
 * 		&lt;/li&gt;
 * 		&lt;li&gt;
 * 			Aggregate/disaggregate/merge coupon period lists
 * 		&lt;/li&gt;
 * 		&lt;li&gt;
 * 			Create fixings objects, rate index from currency/coupon/frequency
 * 		&lt;/li&gt;
 * 		&lt;li&gt;
 * 			String Tenor/Month Code/Work-out
 * 		&lt;/li&gt;
 * 		&lt;li&gt;
 * 			Standard Treasury Bench-mark off of Maturity
 * 		&lt;/li&gt;
 *  &lt;/ul&gt;
 *
 *	&lt;br&gt;&lt;br&gt;
 *  &lt;ul&gt;
 *		&lt;li&gt;&lt;b&gt;Module &lt;/b&gt; = &lt;a href = &quot;https://github.com/lakshmiDRIP/DROP/tree/master/AnalyticsCore.md&quot;&gt;Analytics Core Module&lt;/a&gt;&lt;/li&gt;
 *		&lt;li&gt;&lt;b&gt;Library&lt;/b&gt; = &lt;a href = &quot;https://github.com/lakshmiDRIP/DROP/tree/master/FixedIncomeAnalyticsLibrary.md&quot;&gt;Fixed Income Analytics&lt;/a&gt;&lt;/li&gt;
 *		&lt;li&gt;&lt;b&gt;Project&lt;/b&gt; = &lt;a href = &quot;https://github.com/lakshmiDRIP/DROP/tree/master/src/main/java/org/drip/analytics/README.md&quot;&gt;Analytics&lt;/a&gt;&lt;/li&gt;
 *		&lt;li&gt;&lt;b&gt;Package&lt;/b&gt; = &lt;a href = &quot;https://github.com/lakshmiDRIP/DROP/tree/master/src/main/java/org/drip/analytics/support/README.md&quot;&gt;Support&lt;/a&gt;&lt;/li&gt;
 *  &lt;/ul&gt;
 * 
 * @author Lakshmi Krishnamurthy
 */

<span class="nc" id="L118">public class Helper {</span>

	/**
	 * Tenor Comparator - Left Tenor Greater than Right
	 */

<span class="fc" id="L124">	public static int LEFT_TENOR_GREATER = 1;</span>

	/**
	 * Tenor Comparator - Left Tenor Lesser than Right
	 */

<span class="fc" id="L130">	public static int LEFT_TENOR_LESSER = 2;</span>

	/**
	 * Tenor Comparator - Left Tenor Matches Right
	 */

<span class="fc" id="L136">	public static int LEFT_TENOR_EQUALS = 4;</span>

<span class="fc" id="L138">	private static final org.drip.analytics.support.CaseInsensitiveTreeMap&lt;java.lang.String&gt; s_mapIRSwitch =</span>
		new org.drip.analytics.support.CaseInsensitiveTreeMap&lt;java.lang.String&gt;();

<span class="fc" id="L141">	private static final java.util.Map&lt;java.lang.Integer, java.lang.String&gt; s_mapDCBBGCode = new</span>
		java.util.HashMap&lt;java.lang.Integer, java.lang.String&gt;();

	/**
	 * Initialize IR switcher and Bloomberg day count maps
	 */

	public static final void Init()
	{
<span class="nc" id="L150">		s_mapDCBBGCode.put (1, &quot;ACT/ACT&quot;);</span>

<span class="nc" id="L152">		s_mapDCBBGCode.put (2, &quot;ACT/360&quot;);</span>

<span class="nc" id="L154">		s_mapDCBBGCode.put (3, &quot;ACT/365&quot;);</span>

<span class="nc" id="L156">		s_mapDCBBGCode.put (4, &quot;30/ACT&quot;);</span>

<span class="nc" id="L158">		s_mapDCBBGCode.put (5, &quot;30/360&quot;);</span>

<span class="nc" id="L160">		s_mapDCBBGCode.put (6, &quot;30/365&quot;);</span>

<span class="nc" id="L162">		s_mapDCBBGCode.put (7, &quot;NL/ACT&quot;);</span>

<span class="nc" id="L164">		s_mapDCBBGCode.put (8, &quot;NL/360&quot;);</span>

<span class="nc" id="L166">		s_mapDCBBGCode.put (9, &quot;NL/365&quot;);</span>

<span class="nc" id="L168">		s_mapDCBBGCode.put (10, &quot;ACT/ACT NON-EOM&quot;);</span>

<span class="nc" id="L170">		s_mapDCBBGCode.put (11, &quot;ACT/360 NON-EOM&quot;);</span>

<span class="nc" id="L172">		s_mapDCBBGCode.put (12, &quot;ACT/365 NON-EOM&quot;);</span>

<span class="nc" id="L174">		s_mapDCBBGCode.put (13, &quot;30/ACT NON-EOM&quot;);</span>

<span class="nc" id="L176">		s_mapDCBBGCode.put (14, &quot;30/360 NON-EOM&quot;);</span>

<span class="nc" id="L178">		s_mapDCBBGCode.put (15, &quot;30/365 NON-EOM&quot;);</span>

<span class="nc" id="L180">		s_mapDCBBGCode.put (16, &quot;NL/ACT NON-EOM&quot;);</span>

<span class="nc" id="L182">		s_mapDCBBGCode.put (17, &quot;NL/360 NON-EOM&quot;);</span>

<span class="nc" id="L184">		s_mapDCBBGCode.put (18, &quot;NL/365 NON-EOM&quot;);</span>

<span class="nc" id="L186">		s_mapDCBBGCode.put (19, &quot;ISMA 30/ACT&quot;);</span>

<span class="nc" id="L188">		s_mapDCBBGCode.put (20, &quot;ISMA 30/360&quot;);</span>

<span class="nc" id="L190">		s_mapDCBBGCode.put (21, &quot;ISMA 30/365&quot;);</span>

<span class="nc" id="L192">		s_mapDCBBGCode.put (22, &quot;ISMA 30/ACT NON-EOM&quot;);</span>

<span class="nc" id="L194">		s_mapDCBBGCode.put (23, &quot;ISMA 30/360 NON-EOM&quot;);</span>

<span class="nc" id="L196">		s_mapDCBBGCode.put (24, &quot;ISMA 30/365 NON-EOM&quot;);</span>

<span class="nc" id="L198">		s_mapDCBBGCode.put (27, &quot;ACT/364&quot;);</span>

<span class="nc" id="L200">		s_mapDCBBGCode.put (29, &quot;US MUNI: 30/360&quot;);</span>

<span class="nc" id="L202">		s_mapDCBBGCode.put (30, &quot;ACT/364 NON-EOM&quot;);</span>

<span class="nc" id="L204">		s_mapDCBBGCode.put (32, &quot;MUNI30/360 NON-EOM&quot;);</span>

<span class="nc" id="L206">		s_mapDCBBGCode.put (33, &quot;BUS DAYS/252&quot;);</span>

<span class="nc" id="L208">		s_mapDCBBGCode.put (35, &quot;GERMAN:30/360&quot;);</span>

<span class="nc" id="L210">		s_mapDCBBGCode.put (36, &quot;BUS DAY/252 NON-EOM&quot;);</span>

<span class="nc" id="L212">		s_mapDCBBGCode.put (38, &quot;GER:30/360 NON-EOM&quot;);</span>

<span class="nc" id="L214">		s_mapDCBBGCode.put (40, &quot;US:WIT ACT/ACT&quot;);</span>

<span class="nc" id="L216">		s_mapDCBBGCode.put (41, &quot;US:WIB ACT/360&quot;);</span>

<span class="nc" id="L218">		s_mapDCBBGCode.put (44, &quot;ISDA SWAPS:30/360&quot;);</span>

<span class="nc" id="L220">		s_mapDCBBGCode.put (45, &quot;ISDA SWAPS:30/365&quot;);</span>

<span class="nc" id="L222">		s_mapDCBBGCode.put (46, &quot;ISDA SWAPS:30/ACT&quot;);</span>

<span class="nc" id="L224">		s_mapDCBBGCode.put (47, &quot;ISDA30/360 NON-EOM&quot;);</span>

<span class="nc" id="L226">		s_mapDCBBGCode.put (48, &quot;ISDA30/365 NON-EOM&quot;);</span>

<span class="nc" id="L228">		s_mapDCBBGCode.put (49, &quot;ISDA30/ACT NON-EOM&quot;);</span>

<span class="nc" id="L230">		s_mapDCBBGCode.put (50, &quot;ISDA 30E/360&quot;);</span>

<span class="nc" id="L232">		s_mapDCBBGCode.put (51, &quot;ISDA 30E/365&quot;);</span>

<span class="nc" id="L234">		s_mapDCBBGCode.put (52, &quot;ISDA 30E/ACT&quot;);</span>

<span class="nc" id="L236">		s_mapDCBBGCode.put (53, &quot;ISDA 30E/360 N-EOM&quot;);</span>

<span class="nc" id="L238">		s_mapDCBBGCode.put (54, &quot;ISDA 30E/365 N-EOM&quot;);</span>

<span class="nc" id="L240">		s_mapDCBBGCode.put (55, &quot;ISDA 30E/ACT N-EOM&quot;);</span>

<span class="nc" id="L242">		s_mapDCBBGCode.put (101, &quot;ACT/ACT&quot;);</span>

<span class="nc" id="L244">		s_mapDCBBGCode.put (102, &quot;ACT/360&quot;);</span>

<span class="nc" id="L246">		s_mapDCBBGCode.put (103, &quot;ACT/365&quot;);</span>

<span class="nc" id="L248">		s_mapDCBBGCode.put (104, &quot;30/360&quot;);</span>

<span class="nc" id="L250">		s_mapDCBBGCode.put (105, &quot;ACT/ACT NON-EOM&quot;);</span>

<span class="nc" id="L252">		s_mapDCBBGCode.put (106, &quot;ACT/360 NON-EOM&quot;);</span>

<span class="nc" id="L254">		s_mapDCBBGCode.put (107, &quot;ACT/365 NON-EOM&quot;);</span>

<span class="nc" id="L256">		s_mapDCBBGCode.put (108, &quot;ACT/360&quot;);</span>

<span class="nc" id="L258">		s_mapDCBBGCode.put (131, &quot;ISMA 30/360&quot;);</span>

<span class="nc" id="L260">		s_mapDCBBGCode.put (201, &quot;ISDA ACT/ACT&quot;);</span>

<span class="nc" id="L262">		s_mapDCBBGCode.put (202, &quot;AFB ACT/ACT&quot;);</span>

<span class="nc" id="L264">		s_mapDCBBGCode.put (203, &quot;ISDA ACT/ACT NOM&quot;);</span>

<span class="nc" id="L266">		s_mapDCBBGCode.put (204, &quot;AFB ACT/ACT NOM&quot;);</span>

<span class="nc" id="L268">		s_mapDCBBGCode.put (206, &quot;ISMA ACT/ACT&quot;);</span>

<span class="nc" id="L270">		s_mapDCBBGCode.put (207, &quot;ISMA ACT/ACT NON-EOM&quot;);</span>

<span class="nc" id="L272">		s_mapIRSwitch.put (&quot;ITL&quot;, &quot;EUR&quot;);</span>

<span class="nc" id="L274">		s_mapIRSwitch.put (&quot;FRF&quot;, &quot;EUR&quot;);</span>

<span class="nc" id="L276">		s_mapIRSwitch.put (&quot;CZK&quot;, &quot;EUR&quot;);</span>

<span class="nc" id="L278">		s_mapIRSwitch.put (&quot;BEF&quot;, &quot;EUR&quot;);</span>

<span class="nc" id="L280">		s_mapIRSwitch.put (&quot;ATS&quot;, &quot;EUR&quot;);</span>

<span class="nc" id="L282">		s_mapIRSwitch.put (&quot;SKK&quot;, &quot;EUR&quot;);</span>
<span class="nc" id="L283">	}</span>

	/**
	 * Calculate the discount factor from the specified frequency, yield, and accrual year fraction
	 * 
	 * @param iFreqIn Input frequency - if zero, set to semi-annual.
	 * @param dblYield Yield
	 * @param dblTime Time in DC years
	 * 
	 * @return the discount factor
	 * 
	 * @throws java.lang.Exception if input are invalid.
	 */

	public static final double Yield2DF (
		final int iFreqIn,
		final double dblYield,
		final double dblTime)
		throws java.lang.Exception
	{
<span class="pc bpc" id="L303" title="1 of 2 branches missed.">		if (!org.drip.numerical.common.NumberUtil.IsValid (dblYield) || !org.drip.numerical.common.NumberUtil.IsValid</span>
<span class="pc bpc" id="L304" title="1 of 2 branches missed.">			(dblTime))</span>
<span class="nc" id="L305">			throw new java.lang.Exception (&quot;Helper::YieldDF =&gt; Bad yield/time&quot;);</span>

<span class="pc bpc" id="L307" title="1 of 2 branches missed.">		int iFreq = (0 == iFreqIn) ? 2 : iFreqIn;</span>

<span class="fc" id="L309">		return java.lang.Math.pow (1. + (dblYield / iFreq), -1. * dblTime * iFreq);</span>
	}

	/**
	 * Calculate the yield from the specified discount factor to the given time.
	 * 
	 * @param iFreqIn Yield calculation frequency - defaults to semi-annual if zero.
	 * @param dblDF Discount Factor
	 * @param dblTime Time to which the yield/DF are specified
	 * 
	 * @return Implied yield
	 * 
	 * @throws java.lang.Exception Thrown if yield cannot be computed
	 */

	public static final double DF2Yield (
		final int iFreqIn,
		final double dblDF,
		final double dblTime)
		throws java.lang.Exception
	{
<span class="pc bpc" id="L330" title="1 of 2 branches missed.">		if (!org.drip.numerical.common.NumberUtil.IsValid (dblDF) || !org.drip.numerical.common.NumberUtil.IsValid</span>
<span class="pc bpc" id="L331" title="1 of 2 branches missed.">			(dblTime))</span>
<span class="nc" id="L332">			throw new java.lang.Exception (&quot;CurveProductHelper.DFYield: Bad yield/time&quot;);</span>

<span class="pc bpc" id="L334" title="1 of 2 branches missed.">		int iFreq = (0 == iFreqIn) ? 2 : iFreqIn;</span>

<span class="fc" id="L336">		return iFreq * (java.lang.Math.pow (dblDF, -1. / (iFreq * dblTime)) - 1.);</span>
	}

	/**
	 * Compute the uncompounded OIS Rate from the LIBOR Swap Rate and the LIBOR Swap Rate - Fed Fund Basis.
	 *  The calculation is from the following Bloomberg Publication:
	 * 
	 * 	- Lipman, H. and F. Mercurio (2012): OIS Discounting and Dual-Curve Stripping Methodology at
	 * 		Bloomberg
	 * 
	 * @param dblLIBORSwapRate LIBOR Swap Rate
	 * @param dblFedFundLIBORSwapBasis Fed Fund - LIBOR Swap Rate Basis
	 * 
	 * @return The Uncompounded OIS Rate
	 * 
	 * @throws java.lang.Exception Thrown if the Inputs are invalid
	 */

	public static final double OISFromLIBORSwapFedFundBasis (
		final double dblLIBORSwapRate,
		final double dblFedFundLIBORSwapBasis)
		throws java.lang.Exception
	{
<span class="pc bpc" id="L359" title="1 of 2 branches missed.">		if (!org.drip.numerical.common.NumberUtil.IsValid (dblLIBORSwapRate) ||</span>
<span class="pc bpc" id="L360" title="1 of 2 branches missed.">			!org.drip.numerical.common.NumberUtil.IsValid (dblFedFundLIBORSwapBasis))</span>
<span class="nc" id="L361">			throw new java.lang.Exception (&quot;Helper::OISFromLIBORSwapFedFundBasis =&gt; Invalid Inputs!&quot;);</span>

<span class="fc" id="L363">		double dblOISAnnuity = 1. + 0.25 * (4. * (java.lang.Math.sqrt (1. + (dblLIBORSwapRate * 180. / 365.))</span>
			- 1.) - dblFedFundLIBORSwapBasis);

<span class="fc" id="L366">		return dblOISAnnuity * dblOISAnnuity * dblOISAnnuity * dblOISAnnuity - 1.;</span>
	}

	/**
	 * Compute the Daily Compounded OIS Rate from the LIBOR Swap Rate and the LIBOR Swap Rate - Fed Fund
	 *  Basis. The calculation is from the following Bloomberg Publication:
	 * 
	 * 	- Lipman, H. and F. Mercurio (2012): OIS Discounting and Dual-Curve Stripping Methodology at
	 * 		Bloomberg
	 * 
	 * @param dblLIBORSwapRate LIBOR Swap Rate
	 * @param dblFedFundLIBORSwapBasis Fed Fund - LIBOR Swap Rate Basis
	 * 
	 * @return The Daily Compounded OIS Rate
	 * 
	 * @throws java.lang.Exception Thrown if the Inputs are invalid
	 */

	public static final double OISFromLIBORSwapFedFundBasis2 (
		final double dblLIBORSwapRate,
		final double dblFedFundLIBORSwapBasis)
		throws java.lang.Exception
	{
<span class="fc" id="L389">		return 4. * (java.lang.Math.pow (1. + (OISFromLIBORSwapFedFundBasis (dblLIBORSwapRate,</span>
			dblFedFundLIBORSwapBasis) / 360.), 90.) - 1.);
	}

	/**
	 * Compute the DI-Style Price given the Rate
	 * 
	 * @param dblDIRate The DI Rate
	 * @param iStartDate The Start Date
	 * @param iEndDate The End Date
	 * @param strCalendar The Calendar
	 * 
	 * @return The DI-Style Price
	 * 
	 * @throws java.lang.Exception Thrown if the DI-Style Price cannot be calculated
	 */

	public static final double DIStylePriceFromRate (
		final double dblDIRate,
		final int iStartDate,
		final int iEndDate,
		final java.lang.String strCalendar)
		throws java.lang.Exception
	{
<span class="nc bnc" id="L413" title="All 4 branches missed.">		if (!org.drip.numerical.common.NumberUtil.IsValid (dblDIRate) || iStartDate &gt;= iEndDate)</span>
<span class="nc" id="L414">			throw new java.lang.Exception (&quot;Helper::DIStylePriceFromRate =&gt; Invalid Inputs&quot;);</span>

<span class="nc" id="L416">		return java.lang.Math.pow (1. + dblDIRate, -1. * org.drip.analytics.daycount.Convention.BusinessDays</span>
<span class="nc" id="L417">			(iStartDate, iEndDate, strCalendar) / 252.);</span>
	}

	/**
	 * Compute the DI-Style Rate given the Price
	 * 
	 * @param dblDIPrice The DI Price
	 * @param iStartDate The Start Date
	 * @param iEndDate The End Date
	 * @param strCalendar The Calendar
	 * 
	 * @return The DI-Style Rate
	 * 
	 * @throws java.lang.Exception Thrown if the DI-Style Price cannot be calculated
	 */

	public static final double DIStyleRateFromPrice (
		final double dblDIPrice,
		final int iStartDate,
		final int iEndDate,
		final java.lang.String strCalendar)
		throws java.lang.Exception
	{
<span class="nc bnc" id="L440" title="All 4 branches missed.">		if (!org.drip.numerical.common.NumberUtil.IsValid (dblDIPrice) || iStartDate &gt;= iEndDate)</span>
<span class="nc" id="L441">			throw new java.lang.Exception (&quot;Helper::DIStyleRateFromPrice =&gt; Invalid Inputs&quot;);</span>

<span class="nc" id="L443">		return java.lang.Math.pow (dblDIPrice, -252. / org.drip.analytics.daycount.Convention.BusinessDays</span>
<span class="nc" id="L444">			(iStartDate, iEndDate, strCalendar)) - 1.;</span>
	}

	/**
	 * Convert the Nominal Yield to the Post Tax Equivalent Yield
	 * 
	 * @param dblNominalYield The Nominal Yield
	 * @param dblTaxRate The Tax Rate
	 * 
	 * @return The Post Tax Equivalent Yield
	 * 
	 * @throws java.lang.Exception Thrown if the Inputs are Invalid
	 */

	public static final double NominalYieldToPostTaxEquivalent (
		final double dblNominalYield,
		final double dblTaxRate)
		throws java.lang.Exception
	{
<span class="nc bnc" id="L463" title="All 2 branches missed.">		if (!org.drip.numerical.common.NumberUtil.IsValid (dblNominalYield) ||</span>
<span class="nc bnc" id="L464" title="All 2 branches missed.">			!org.drip.numerical.common.NumberUtil.IsValid (dblTaxRate))</span>
<span class="nc" id="L465">			throw new java.lang.Exception (&quot;Helper::NominalYieldToPostTaxEquivalent =&gt; Invalid Inputs&quot;);</span>

<span class="nc" id="L467">		return dblNominalYield * (1. - dblTaxRate);</span>
	}

	/**
	 * Convert the Post Tax Equivalent Yield to the Nominal Yield
	 * 
	 * @param dblPostTaxEquivalentYield The Post Tax Equivalent Yield
	 * @param dblTaxRate The Tax Rate
	 * 
	 * @return The Nominal Yield
	 * 
	 * @throws java.lang.Exception Thrown if the Inputs are Invalid
	 */

	public static final double PostTaxEquivalentYieldToNominal (
		final double dblPostTaxEquivalentYield,
		final double dblTaxRate)
		throws java.lang.Exception
	{
<span class="nc bnc" id="L486" title="All 2 branches missed.">		if (!org.drip.numerical.common.NumberUtil.IsValid (dblPostTaxEquivalentYield) ||</span>
<span class="nc bnc" id="L487" title="All 2 branches missed.">			!org.drip.numerical.common.NumberUtil.IsValid (dblTaxRate))</span>
<span class="nc" id="L488">			throw new java.lang.Exception (&quot;Helper::PostTaxEquivalentYieldToNominal =&gt; Invalid Inputs&quot;);</span>

<span class="nc" id="L490">		return dblPostTaxEquivalentYield / (1. - dblTaxRate);</span>
	}

	/**
	 * Return the standard on-the-run benchmark treasury string from the valuation and the maturity dates
	 * 
	 * @param iValueDate the Valuation date
	 * @param iMaturityDate the Maturity date
	 * 
	 * @return the standard on-the-run benchmark treasury string
	 */

	public static final java.lang.String BaseTsyBmk (
		final int iValueDate,
		final int iMaturityDate)
	{
<span class="fc" id="L506">		double dblMatYears = 1. * (iMaturityDate - iValueDate) / 365.25;</span>

<span class="fc bfc" id="L508" title="All 4 branches covered.">		if (1.0 &lt; dblMatYears &amp;&amp; dblMatYears &lt;= 2.5) return &quot;02YON&quot;;</span>

<span class="fc bfc" id="L510" title="All 4 branches covered.">		if (2.5 &lt; dblMatYears &amp;&amp; dblMatYears &lt;= 4.0) return &quot;03YON&quot;;</span>

<span class="fc bfc" id="L512" title="All 4 branches covered.">		if (4.0 &lt; dblMatYears &amp;&amp; dblMatYears &lt;= 6.0) return &quot;05YON&quot;;</span>

<span class="fc bfc" id="L514" title="All 4 branches covered.">		if (6.0 &lt; dblMatYears &amp;&amp; dblMatYears &lt;= 8.5) return &quot;07YON&quot;;</span>

<span class="fc bfc" id="L516" title="All 4 branches covered.">		if (8.5 &lt; dblMatYears &amp;&amp; dblMatYears &lt;= 15.) return &quot;10YON&quot;;</span>

<span class="fc bfc" id="L518" title="All 2 branches covered.">		if (dblMatYears &gt; 15.) return &quot;30YON&quot;;</span>

<span class="fc" id="L520">		return null;</span>
	}

	/**
	 * Turn the work out type to string
	 * 
	 * @param iWOType One of the WO_TYPE_* fields in the WorkoutInfo class
	 * 
	 * @return String representation of the work out type field
	 */

	public static final java.lang.String WorkoutTypeToString (
		final int iWOType)
	{
<span class="nc bnc" id="L534" title="All 2 branches missed.">		if (org.drip.param.valuation.WorkoutInfo.WO_TYPE_PUT == iWOType) return &quot;Put&quot;;</span>

<span class="nc bnc" id="L536" title="All 2 branches missed.">		if (org.drip.param.valuation.WorkoutInfo.WO_TYPE_CALL == iWOType) return &quot;Call&quot;;</span>

<span class="nc bnc" id="L538" title="All 2 branches missed.">		if (org.drip.param.valuation.WorkoutInfo.WO_TYPE_MATURITY == iWOType) return &quot;Maturity&quot;;</span>

<span class="nc" id="L540">		return &quot;Unknown work out type&quot;;</span>
	}

	/**
	 * Convert the Bloomberg day count code to DRIP day count code.
	 *  
	 * @param strBBGDCCode String representing the Bloomberg day count code.
	 * 
	 * @return String representing the DRIP day count code.
	 */

	public static final java.lang.String ParseFromBBGDCCode (
		final java.lang.String strBBGDCCode)
	{
<span class="nc bnc" id="L554" title="All 2 branches missed.">		if (null == strBBGDCCode) return &quot;Unknown BBG DC&quot;;</span>

		try {
<span class="nc" id="L557">			return s_mapDCBBGCode.get ((int) java.lang.Double.parseDouble (strBBGDCCode.trim()));</span>
<span class="nc" id="L558">		} catch (java.lang.Exception e) {</span>
		}

<span class="nc" id="L561">		return &quot;Unknown BBG DC&quot;;</span>
	}

	/**
	 * Retrieve the tenor from the frequency
	 * 
	 * @param iFreq Integer frequency
	 * 
	 * @return String representing the tenor
	 */

	public static final java.lang.String GetTenorFromFreq (
		final int iFreq)
	{
<span class="nc bnc" id="L575" title="All 2 branches missed.">		if (1 == iFreq) return &quot;1Y&quot;;</span>

<span class="nc bnc" id="L577" title="All 2 branches missed.">		if (2 == iFreq) return &quot;6M&quot;;</span>

<span class="nc bnc" id="L579" title="All 2 branches missed.">		if (3 == iFreq) return &quot;4M&quot;;</span>

<span class="nc bnc" id="L581" title="All 2 branches missed.">		if (4 == iFreq) return &quot;3M&quot;;</span>

<span class="nc bnc" id="L583" title="All 2 branches missed.">		if (6 == iFreq) return &quot;2M&quot;;</span>

<span class="nc bnc" id="L585" title="All 2 branches missed.">		if (12 == iFreq) return &quot;1M&quot;;</span>

<span class="nc" id="L587">		return null;</span>
	}

	/**
	 * Retrieve the Number of Years from the Tenor
	 * 
	 * @param strTenor The Specified Tenor
	 * 
	 * @return The Number of Years
	 * 
	 * @throws java.lang.Exception Thrown if the Inputs are Invalid
	 */

	public static final int TenorToYears (
		final java.lang.String strTenor)
		throws java.lang.Exception
	{
<span class="nc bnc" id="L604" title="All 4 branches missed.">		if (null == strTenor || strTenor.isEmpty())</span>
<span class="nc" id="L605">			throw new java.lang.Exception (&quot;Helper::TenorToYears =&gt; Invalid Inputs&quot;);</span>

<span class="nc" id="L607">		char chTenor = strTenor.charAt (strTenor.length() - 1);</span>

<span class="nc" id="L609">		int iTimeUnit = (int) java.lang.Double.parseDouble (strTenor.substring (0, strTenor.length() -</span>
			1));

<span class="nc bnc" id="L612" title="All 4 branches missed.">		if ('y' == chTenor || 'Y' == chTenor) return iTimeUnit * 12;</span>

<span class="nc" id="L614">		throw new java.lang.Exception (&quot;AnalyticsHelper::TenorToYears =&gt; Invalid tenor format &quot; + strTenor);</span>
	}

	/**
	 * Retrieve the Number of Months from the Tenor
	 * 
	 * @param strTenor The Specified Tenor
	 * 
	 * @return The Number of Months
	 * 
	 * @throws java.lang.Exception Thrown if the Inputs are Invalid
	 */

	public static final int TenorToMonths (
		final java.lang.String strTenor)
		throws java.lang.Exception
	{
<span class="pc bpc" id="L631" title="2 of 4 branches missed.">		if (null == strTenor || strTenor.isEmpty())</span>
<span class="nc" id="L632">			throw new java.lang.Exception (&quot;Helper::TenorToMonths =&gt; Invalid Inputs&quot;);</span>

<span class="fc" id="L634">		char chTenor = strTenor.charAt (strTenor.length() - 1);</span>

<span class="fc" id="L636">		int iTimeUnit = (int) java.lang.Double.parseDouble (strTenor.substring (0, strTenor.length() -</span>
			1));

<span class="pc bpc" id="L639" title="1 of 4 branches missed.">		if ('d' == chTenor || 'D' == chTenor) return iTimeUnit * (iTimeUnit / 30);</span>

<span class="pc bpc" id="L641" title="1 of 4 branches missed.">		if ('w' == chTenor || 'W' == chTenor) return iTimeUnit * (iTimeUnit / 7);</span>

<span class="pc bpc" id="L643" title="2 of 4 branches missed.">		if ('l' == chTenor || 'L' == chTenor) return iTimeUnit;</span>

<span class="pc bpc" id="L645" title="1 of 4 branches missed.">		if ('m' == chTenor || 'M' == chTenor) return iTimeUnit;</span>

<span class="pc bpc" id="L647" title="2 of 4 branches missed.">		if ('y' == chTenor || 'Y' == chTenor) return iTimeUnit * 12;</span>

<span class="nc" id="L649">		throw new java.lang.Exception (&quot;Helper::TenorToMonths =&gt; Invalid Tenor Format &quot; + strTenor);</span>
	}

	/**
	 * Retrieve the Number of Days from the Tenor
	 * 
	 * @param strTenor The Specified Tenor
	 * 
	 * @return The Number of Days
	 * 
	 * @throws java.lang.Exception Thrown if the Inputs are Invalid
	 */

	public static final int TenorToDays (
		final java.lang.String strTenor)
		throws java.lang.Exception
	{
<span class="pc bpc" id="L666" title="2 of 4 branches missed.">		if (null == strTenor || strTenor.isEmpty())</span>
<span class="nc" id="L667">			throw new java.lang.Exception (&quot;Helper::TenorToDays =&gt; Invalid Inputs&quot;);</span>

<span class="fc" id="L669">		char chTenor = strTenor.charAt (strTenor.length() - 1);</span>

<span class="fc" id="L671">		int iTimeUnit = (int) java.lang.Double.parseDouble (strTenor.substring (0, strTenor.length() -</span>
			1));

<span class="pc bpc" id="L674" title="1 of 4 branches missed.">		if ('d' == chTenor || 'D' == chTenor) return iTimeUnit;</span>

<span class="pc bpc" id="L676" title="1 of 4 branches missed.">		if ('w' == chTenor || 'W' == chTenor) return iTimeUnit * 7;</span>

<span class="pc bpc" id="L678" title="2 of 4 branches missed.">		if ('l' == chTenor || 'L' == chTenor) return iTimeUnit * 28;</span>

<span class="pc bpc" id="L680" title="1 of 4 branches missed.">		if ('m' == chTenor || 'M' == chTenor) return iTimeUnit * 30;</span>

<span class="pc bpc" id="L682" title="2 of 4 branches missed.">		if ('y' == chTenor || 'Y' == chTenor) return (int) (365.25 * iTimeUnit);</span>

<span class="nc" id="L684">		throw new java.lang.Exception (&quot;Helper::TenorToDays =&gt; Unknown tenor format &quot; + strTenor);</span>
	}

	/**
	 * Retrieve the Year Fraction from the Tenor
	 * 
	 * @param strTenor The Specified Tenor
	 * 
	 * @return The Year Fraction
	 * 
	 * @throws java.lang.Exception Thrown if the Inputs are Invalid
	 */

	public static final double TenorToYearFraction (
		final java.lang.String strTenor)
		throws java.lang.Exception
	{
<span class="pc bpc" id="L701" title="2 of 4 branches missed.">		if (null == strTenor || strTenor.isEmpty())</span>
<span class="nc" id="L702">			throw new java.lang.Exception (&quot;Helper::TenorToYearFraction =&gt; Invalid Inputs&quot;);</span>

<span class="fc" id="L704">		char chTenor = strTenor.charAt (strTenor.length() - 1);</span>

<span class="fc" id="L706">		int iTimeUnit = (int) java.lang.Double.parseDouble (strTenor.substring (0, strTenor.length() -</span>
			1));

<span class="pc bpc" id="L709" title="2 of 4 branches missed.">		if ('d' == chTenor || 'D' == chTenor) return ((double) iTimeUnit) / 365.25;</span>

<span class="pc bpc" id="L711" title="1 of 4 branches missed.">		if ('w' == chTenor || 'W' == chTenor) return ((double) (7. * iTimeUnit)) / 365.25;</span>

<span class="pc bpc" id="L713" title="2 of 4 branches missed.">		if ('w' == chTenor || 'W' == chTenor) return ((double) (iTimeUnit)) / 52.;</span>

<span class="pc bpc" id="L715" title="2 of 4 branches missed.">		if ('l' == chTenor || 'L' == chTenor) return ((double) (28. * iTimeUnit)) / 365.25;</span>

<span class="pc bpc" id="L717" title="2 of 4 branches missed.">		if ('l' == chTenor || 'L' == chTenor) return ((double) (iTimeUnit)) / 13.;</span>

<span class="pc bpc" id="L719" title="1 of 4 branches missed.">		if ('m' == chTenor || 'M' == chTenor) return ((double) (iTimeUnit)) / 12.;</span>

<span class="pc bpc" id="L721" title="2 of 4 branches missed.">		if ('y' == chTenor || 'Y' == chTenor) return iTimeUnit;</span>

<span class="nc" id="L723">		throw new java.lang.Exception (&quot;Helper::TenorToYearFraction =&gt; Unknown tenor format &quot; + strTenor);</span>
	}

	/**
	 * Retrieve the Year Fraction from the Tenor Array 
	 * 
	 * @param astrTenor The Specified Tenor Array
	 * @param bForward TRUE - Generated the Incremental Forward Year Fraction
	 * 
	 * @throws java.lang.Exception Thrown if the Inputs are Invalid
	 * 
	 * @return The Year Fraction Array
	 */

	public static final double[] TenorToYearFraction (
		final java.lang.String[] astrTenor,
		final boolean bForward)
		throws java.lang.Exception
	{
<span class="nc bnc" id="L742" title="All 2 branches missed.">		if (null == astrTenor)</span>
<span class="nc" id="L743">			throw new java.lang.Exception (&quot;Helper::TenorToYearFraction =&gt; Invalid Inputs&quot;);</span>

<span class="nc" id="L745">		int iNumTenor = astrTenor.length;</span>
<span class="nc bnc" id="L746" title="All 2 branches missed.">		double[] adblYearFraction = 0 == iNumTenor ? null : new double[iNumTenor];</span>

<span class="nc bnc" id="L748" title="All 2 branches missed.">		for (int i = 0; i &lt; iNumTenor; ++i) {</span>
			try {
<span class="nc" id="L750">				adblYearFraction[i] = TenorToYearFraction (astrTenor[i]);</span>
<span class="nc" id="L751">			} catch (java.lang.Exception e) {</span>
<span class="nc" id="L752">				e.printStackTrace();</span>

<span class="nc" id="L754">				return null;</span>
<span class="nc" id="L755">			}</span>
		}

<span class="nc bnc" id="L758" title="All 2 branches missed.">		if (!bForward) return adblYearFraction;</span>

<span class="nc bnc" id="L760" title="All 2 branches missed.">		for (int i = iNumTenor - 1; i &gt; 1; --i)</span>
<span class="nc" id="L761">			adblYearFraction[i] = adblYearFraction[i] - adblYearFraction[i - 1];</span>

<span class="nc" id="L763">		return adblYearFraction;</span>
	}

	/**
	 * Retrieve the Annual Frequency from the Tenor
	 * 
	 * @param strTenor The Specified Tenor
	 * 
	 * @return The Annual Frequency
	 * 
	 * @throws java.lang.Exception Thrown if the Inputs are Invalid
	 */

	public static final int TenorToFreq (
		final java.lang.String strTenor)
		throws java.lang.Exception
	{
<span class="pc bpc" id="L780" title="2 of 4 branches missed.">		if (null == strTenor || strTenor.isEmpty())</span>
<span class="nc" id="L781">			throw new java.lang.Exception (&quot;Helper::TenorToFreq =&gt; Invalid Inputs&quot;);</span>

<span class="fc bfc" id="L783" title="All 2 branches covered.">		if (&quot;ON&quot;.equalsIgnoreCase (strTenor)) return 365;</span>

<span class="fc" id="L785">		char chTenor = strTenor.charAt (strTenor.length() - 1);</span>

<span class="fc" id="L787">		int iTimeUnit = (int) java.lang.Double.parseDouble (strTenor.substring (0, strTenor.length() -</span>
			1));

<span class="pc bpc" id="L790" title="2 of 4 branches missed.">		if ('d' == chTenor || 'D' == chTenor) return (int) (365. / iTimeUnit);</span>

<span class="pc bpc" id="L792" title="1 of 4 branches missed.">		if ('w' == chTenor || 'W' == chTenor) return (int) (52. / iTimeUnit);</span>

<span class="pc bpc" id="L794" title="2 of 4 branches missed.">		if ('l' == chTenor || 'L' == chTenor) return (int) (13. / iTimeUnit);</span>

<span class="pc bpc" id="L796" title="1 of 4 branches missed.">		if ('m' == chTenor || 'M' == chTenor) return (int) (12. / iTimeUnit);</span>

<span class="pc bpc" id="L798" title="2 of 4 branches missed.">		if ('y' == chTenor || 'Y' == chTenor) return iTimeUnit;</span>

<span class="nc" id="L800">		throw new java.lang.Exception (&quot;Helper::TenorToFreq =&gt; Unknown tenor format &quot; + strTenor);</span>
	}

	/**
	 * Retrieve the Date Array From the Tenor Array
	 * 
	 * @param dtSpot The Spot Date Array
	 * @param astrTenor The Specified Tenor Array
	 * 
	 * @return The Date Array From the Tenor Array
	 */

	public static final int[] TenorToDate (
		final org.drip.analytics.date.JulianDate dtSpot,
		final java.lang.String[] astrTenor)
	{
<span class="pc bpc" id="L816" title="2 of 4 branches missed.">		if (null == dtSpot || null == astrTenor) return null;</span>

<span class="fc" id="L818">		int iNumTenor = astrTenor.length;</span>
<span class="fc" id="L819">		int[] aiTenorDate = new int[iNumTenor];</span>

<span class="fc bfc" id="L821" title="All 2 branches covered.">		for (int i = 0; i &lt; iNumTenor; ++i) {</span>
<span class="fc" id="L822">			org.drip.analytics.date.JulianDate dtTenor = dtSpot.addTenor (astrTenor[i]);</span>

<span class="pc bpc" id="L824" title="1 of 2 branches missed.">			if (null == dtTenor) return null;</span>

<span class="fc" id="L826">			aiTenorDate[i] = dtTenor.julian();</span>
		}

<span class="fc" id="L829">		return aiTenorDate;</span>
	}

	/**
	 * Compare the Left and the Right Tenors
	 * 
	 * @param strTenorLeft Left Tenor
	 * @param strTenorRight Right Tenor
	 * 
	 * @return Results of the Comparison
	 * 
	 * @throws java.lang.Exception Thrown if the Comparison cannot be done
	 */

	public static final int TenorCompare (
		final java.lang.String strTenorLeft,
		final java.lang.String strTenorRight)
		throws java.lang.Exception
	{
<span class="fc" id="L848">		int iLeftTenorDays = TenorToDays (strTenorLeft);</span>

<span class="fc" id="L850">		int iRightTenorDays = TenorToDays (strTenorRight);</span>

<span class="fc bfc" id="L852" title="All 2 branches covered.">		if (iLeftTenorDays == iRightTenorDays) return LEFT_TENOR_EQUALS;</span>

<span class="fc bfc" id="L854" title="All 2 branches covered.">		return iLeftTenorDays &gt; iRightTenorDays ? LEFT_TENOR_GREATER : LEFT_TENOR_LESSER;</span>
	}

	/**
	 * Retrieve the month code from input frequency
	 * 
	 * @param iFreq Integer frequency
	 * 
	 * @return String representing the month code
	 */

	public static final java.lang.String GetMonthCodeFromFreq (
		final int iFreq)
	{
<span class="nc bnc" id="L868" title="All 2 branches missed.">		if (1 == iFreq) return &quot;0012M&quot;;</span>

<span class="nc bnc" id="L870" title="All 2 branches missed.">		if (2 == iFreq) return &quot;0006M&quot;;</span>

<span class="nc bnc" id="L872" title="All 2 branches missed.">		if (3 == iFreq) return &quot;0004M&quot;;</span>

<span class="nc bnc" id="L874" title="All 2 branches missed.">		if (4 == iFreq) return &quot;0003M&quot;;</span>

<span class="nc bnc" id="L876" title="All 2 branches missed.">		if (6 == iFreq) return &quot;0002M&quot;;</span>

<span class="nc bnc" id="L878" title="All 2 branches missed.">		if (12 == iFreq) return &quot;0001M&quot;;</span>

<span class="nc" id="L880">		return null;</span>
	}

	/**
	 * Calculate the rate index from the coupon currency and the frequency
	 * 
	 * @param strCouponCurrency String representing the coupon currency
	 * @param iCouponFreq Integer representing the coupon frequency
	 * 
	 * @return String representing the rate index
	 */

	public static final java.lang.String CalcRateIndex (
		final java.lang.String strCouponCurrency,
		final int iCouponFreq)
	{
<span class="nc bnc" id="L896" title="All 4 branches missed.">		if (null == strCouponCurrency || strCouponCurrency.isEmpty()) return null;</span>

<span class="nc" id="L898">		java.lang.String strFreqMonthCode = GetMonthCodeFromFreq (iCouponFreq);</span>

<span class="nc bnc" id="L900" title="All 2 branches missed.">		if (null == strFreqMonthCode) return null;</span>

<span class="nc" id="L902">		return strCouponCurrency.substring (0, 2) + strFreqMonthCode;</span>
	}

	/**
	 * Get the DRIP day count from the Bloomberg code
	 * 
	 * @param strBBGDC String representing the Bloomberg day count convention
	 * 
	 * @return String representing DRIP day count
	 */

	public static final java.lang.String GetDayCountFromBBGCode (
		final java.lang.String strBBGDC)
	{
<span class="nc bnc" id="L916" title="All 4 branches missed.">		if (null == strBBGDC || strBBGDC.isEmpty()) return &quot;30/360&quot;;</span>

<span class="nc" id="L918">		return &quot;30/360&quot;;</span>
	}

	/**
	 * Calculate the rate index from currency and coupon frequency
	 * 
	 * @param strCcy String representing coupon currency
	 * @param iCouponFreq Integer representing coupon frequency
	 * 
	 * @return String representing the rate index
	 */

	public static final java.lang.String RateIndexFromCcyAndCouponFreq (
		final java.lang.String strCcy,
		final int iCouponFreq)
	{
<span class="nc bnc" id="L934" title="All 6 branches missed.">		if (null == strCcy || strCcy.isEmpty() || 0 &gt;= iCouponFreq) return &quot;&quot;;</span>

<span class="nc" id="L936">		java.lang.String strCcyPrefix = strCcy.substring (0, 2);</span>

<span class="nc bnc" id="L938" title="All 2 branches missed.">		if (1 == iCouponFreq)  return strCcyPrefix + &quot;0012M&quot;;</span>

<span class="nc bnc" id="L940" title="All 2 branches missed.">		if (2 == iCouponFreq)  return strCcyPrefix + &quot;0006M&quot;;</span>

<span class="nc bnc" id="L942" title="All 2 branches missed.">		if (3 == iCouponFreq)  return strCcyPrefix + &quot;0004M&quot;;</span>

<span class="nc bnc" id="L944" title="All 2 branches missed.">		if (4 == iCouponFreq)  return strCcyPrefix + &quot;0003M&quot;;</span>

<span class="nc bnc" id="L946" title="All 2 branches missed.">		if (6 == iCouponFreq)  return strCcyPrefix + &quot;0002M&quot;;</span>

<span class="nc bnc" id="L948" title="All 2 branches missed.">		if (12 == iCouponFreq)  return strCcyPrefix + &quot;0001M&quot;;</span>

<span class="nc" id="L950">		return &quot;&quot;;</span>
	}

	/**
	 * Switch the given IR curve if necessary
	 * 
	 * @param strCurveIn String representing the input curve
	 * 
	 * @return String representing the switched curve
	 */

	public static final java.lang.String SwitchIRCurve (
		final java.lang.String strCurveIn)
	{
<span class="nc bnc" id="L964" title="All 2 branches missed.">		if (null == strCurveIn) return null;</span>

<span class="nc bnc" id="L966" title="All 2 branches missed.">		if (!s_mapIRSwitch.containsKey (strCurveIn)) return strCurveIn;</span>

<span class="nc" id="L968">		return s_mapIRSwitch.get (strCurveIn);</span>
	}

	/**
	 * Create the Latent State Fixings object from the bond, the fixings date, and the fixing.
	 * 
	 * @param bond The input bond
	 * @param dtFixing The Fixings Date
	 * @param dblFixing Double representing the fixing
	 * 
	 * @return The Latent State Fixings Instance
	 */
	
	public static final org.drip.param.market.LatentStateFixingsContainer CreateFixingsObject (
		final org.drip.product.definition.Bond bond,
		final org.drip.analytics.date.JulianDate dtFixing,
		final double dblFixing)
	{
<span class="fc bfc" id="L986" title="All 2 branches covered.">		if (!bond.isFloater()) return null;</span>

<span class="fc" id="L988">		org.drip.param.market.LatentStateFixingsContainer lsfc = new</span>
			org.drip.param.market.LatentStateFixingsContainer();

<span class="pc bpc" id="L991" title="1 of 2 branches missed.">		return lsfc.add (dtFixing, bond.forwardLabel().get (&quot;BASE&quot;), dblFixing) ? lsfc : null;</span>
	}

	/**
	 * Bump the input array quotes
	 * 
	 * @param adblQuotesIn Array of the input double quotes
	 * @param dblBump Bump amount
	 * @param bIsProportional True - Bump is proportional
	 * 
	 * @return Bumped array output
	 */

	public static final double[] BumpQuotes (
		final double[] adblQuotesIn,
		final double dblBump,
		final boolean bIsProportional)
	{
<span class="nc bnc" id="L1009" title="All 4 branches missed.">		if (null == adblQuotesIn || 0 == adblQuotesIn.length || !org.drip.numerical.common.NumberUtil.IsValid</span>
<span class="nc bnc" id="L1010" title="All 2 branches missed.">			(dblBump))</span>
<span class="nc" id="L1011">			return null;</span>

<span class="nc" id="L1013">		double[] adblQuotesOut = new double[adblQuotesIn.length];</span>

<span class="nc bnc" id="L1015" title="All 2 branches missed.">		for (int i = 0; i &lt; adblQuotesIn.length; ++i) {</span>
<span class="nc bnc" id="L1016" title="All 2 branches missed.">			if (!org.drip.numerical.common.NumberUtil.IsValid (adblQuotesIn[i])) return null;</span>

<span class="nc bnc" id="L1018" title="All 2 branches missed.">			if (!bIsProportional)</span>
<span class="nc" id="L1019">				adblQuotesOut[i] = adblQuotesIn[i] + dblBump;</span>
			else
<span class="nc" id="L1021">				adblQuotesOut[i] = adblQuotesIn[i] * (1. + dblBump);</span>
		}

<span class="nc" id="L1024">		return adblQuotesOut;</span>
	}

	/**
	 * Tweak the Manifest Measures (gor the given set of nodes) in accordance with the specified tweak
	 *  parameters
	 * 
	 * @param adblQuotesIn Array of quotes to be bumped
	 * @param ntp NodeTweakParams input
	 * 
	 * @return Bumped array output
	 */

	public static final double[] TweakManifestMeasure (
		final double[] adblQuotesIn,
		final org.drip.param.definition.ManifestMeasureTweak ntp)
	{
<span class="pc bpc" id="L1041" title="2 of 6 branches missed.">		if (null == adblQuotesIn || 0 == adblQuotesIn.length || null == ntp) return adblQuotesIn;</span>

<span class="fc" id="L1043">		double[] adblQuotesOut = new double[adblQuotesIn.length];</span>

<span class="fc bfc" id="L1045" title="All 2 branches covered.">		if (org.drip.param.definition.ManifestMeasureTweak.FLAT == ntp.node()) {</span>
<span class="fc bfc" id="L1046" title="All 2 branches covered.">			for (int i = 0; i &lt; adblQuotesIn.length; ++i) {</span>
<span class="pc bpc" id="L1047" title="1 of 2 branches missed.">				if (!org.drip.numerical.common.NumberUtil.IsValid (adblQuotesIn[i])) return null;</span>

<span class="pc bpc" id="L1049" title="1 of 2 branches missed.">				if (!ntp.isProportional())</span>
<span class="fc" id="L1050">					adblQuotesOut[i] = adblQuotesIn[i] + ntp.amount();</span>
				else
<span class="nc" id="L1052">					adblQuotesOut[i] = adblQuotesIn[i] * (1. + ntp.amount());</span>
			}
		} else {
<span class="pc bpc" id="L1055" title="2 of 4 branches missed.">			if (ntp.node() &lt; 0 || ntp.node() &gt;= adblQuotesIn.length) return null;</span>

<span class="fc bfc" id="L1057" title="All 2 branches covered.">			for (int i = 0; i &lt; adblQuotesIn.length; ++i) {</span>
<span class="pc bpc" id="L1058" title="1 of 2 branches missed.">				if (!org.drip.numerical.common.NumberUtil.IsValid (adblQuotesIn[i])) return null;</span>

<span class="fc bfc" id="L1060" title="All 2 branches covered.">				if (i == ntp.node()) {</span>
<span class="fc bfc" id="L1061" title="All 2 branches covered.">					if (!ntp.isProportional())</span>
<span class="fc" id="L1062">						adblQuotesOut[i] = adblQuotesIn[i] + ntp.amount();</span>
					else
<span class="fc" id="L1064">						adblQuotesOut[i] = adblQuotesIn[i] * (1. + ntp.amount());</span>
				} else
<span class="fc" id="L1066">					adblQuotesOut[i] = adblQuotesIn[i];</span>
			}
		}

<span class="fc" id="L1070">		return adblQuotesOut;</span>
	}

	/**
	 * Merge two lists of periods
	 * 
	 * @param lsPeriod1 Period 1
	 * @param lsPeriod2 Period 2
	 * 
	 * @return The Merged Period List
	 */

	public static final java.util.List&lt;org.drip.analytics.cashflow.CompositePeriod&gt; MergePeriodLists (
		final java.util.List&lt;org.drip.analytics.cashflow.CompositePeriod&gt; lsPeriod1,
		final java.util.List&lt;org.drip.analytics.cashflow.CompositePeriod&gt; lsPeriod2)
	{
<span class="nc bnc" id="L1086" title="All 8 branches missed.">		if ((null == lsPeriod1 || 0 == lsPeriod1.size()) &amp;&amp; (null == lsPeriod2 || 0 == lsPeriod2.size()))</span>
<span class="nc" id="L1087">			return null;</span>

<span class="nc" id="L1089">		java.util.List&lt;org.drip.analytics.cashflow.CompositePeriod&gt; lsPeriodMerged = new</span>
			java.util.ArrayList&lt;org.drip.analytics.cashflow.CompositePeriod&gt;();

<span class="nc bnc" id="L1092" title="All 4 branches missed.">		if (null == lsPeriod1 || 0 == lsPeriod1.size()) {</span>
<span class="nc bnc" id="L1093" title="All 2 branches missed.">			for (org.drip.analytics.cashflow.CompositePeriod p : lsPeriod2) {</span>
<span class="nc bnc" id="L1094" title="All 2 branches missed.">				if (null != p) lsPeriodMerged.add (p);</span>
<span class="nc" id="L1095">			}</span>

<span class="nc" id="L1097">			return lsPeriodMerged;</span>
		}

<span class="nc bnc" id="L1100" title="All 4 branches missed.">		if (null == lsPeriod2 || 0 == lsPeriod2.size()) {</span>
<span class="nc bnc" id="L1101" title="All 2 branches missed.">			for (org.drip.analytics.cashflow.CompositePeriod p : lsPeriod1) {</span>
<span class="nc bnc" id="L1102" title="All 2 branches missed.">				if (null != p) lsPeriodMerged.add (p);</span>
<span class="nc" id="L1103">			}</span>

<span class="nc" id="L1105">			return lsPeriodMerged;</span>
		}

<span class="nc" id="L1108">		int iPeriod1Index = 0;</span>
<span class="nc" id="L1109">		int iPeriod2Index = 0;</span>

<span class="nc bnc" id="L1111" title="All 4 branches missed.">		while (iPeriod1Index &lt; lsPeriod1.size() &amp;&amp; iPeriod2Index &lt; lsPeriod2.size()) {</span>
<span class="nc" id="L1112">			org.drip.analytics.cashflow.CompositePeriod p1 = lsPeriod1.get (iPeriod1Index);</span>

<span class="nc" id="L1114">			org.drip.analytics.cashflow.CompositePeriod p2 = lsPeriod2.get (iPeriod2Index);</span>

<span class="nc bnc" id="L1116" title="All 2 branches missed.">			if (p1.payDate() &lt; p2.payDate()) {</span>
<span class="nc" id="L1117">				lsPeriodMerged.add (p1);</span>

<span class="nc" id="L1119">				++iPeriod1Index;</span>
			} else {
<span class="nc" id="L1121">				lsPeriodMerged.add (p2);</span>

<span class="nc" id="L1123">				++iPeriod2Index;</span>
			}
<span class="nc" id="L1125">		}</span>

<span class="nc bnc" id="L1127" title="All 2 branches missed.">		if (iPeriod1Index &lt; lsPeriod1.size() - 1) {</span>
<span class="nc bnc" id="L1128" title="All 2 branches missed.">			for (int i = iPeriod1Index; i &lt; lsPeriod1.size(); ++i)</span>
<span class="nc" id="L1129">				lsPeriodMerged.add (lsPeriod1.get (i));</span>
<span class="nc bnc" id="L1130" title="All 2 branches missed.">		} else if (iPeriod2Index &lt; lsPeriod2.size() - 1) {</span>
<span class="nc bnc" id="L1131" title="All 2 branches missed.">			for (int i = iPeriod2Index; i &lt; lsPeriod2.size(); ++i)</span>
<span class="nc" id="L1132">				lsPeriodMerged.add (lsPeriod2.get (i));</span>
		}

<span class="nc" id="L1135">		return lsPeriodMerged;</span>
	}

	/**
	 * Aggregate the period lists for an array of components
	 * 
	 * @param aComp Array of Components
	 * 
	 * @return The Aggregated Period Set
	 */

	public static final java.util.Set&lt;org.drip.analytics.cashflow.CompositePeriod&gt; AggregateComponentPeriods
		(final org.drip.product.definition.Component[] aComp)
	{
<span class="nc bnc" id="L1149" title="All 2 branches missed.">		if (null == aComp) return null;</span>

<span class="nc" id="L1151">		int iStartIndex = 0;</span>
<span class="nc" id="L1152">		int iNumComp = aComp.length;</span>

<span class="nc bnc" id="L1154" title="All 2 branches missed.">		if (0 == iNumComp) return null;</span>

<span class="nc bnc" id="L1156" title="All 2 branches missed.">		for (int i = 0; i &lt; iNumComp; ++i) {</span>
<span class="nc bnc" id="L1157" title="All 2 branches missed.">			if (null != aComp[i]) {</span>
<span class="nc" id="L1158">				iStartIndex = i;</span>
<span class="nc" id="L1159">				break;</span>
			}
		}

<span class="nc" id="L1163">		java.util.Set&lt;org.drip.analytics.cashflow.CompositePeriod&gt; setAggregatedPeriod = new</span>
			java.util.TreeSet&lt;org.drip.analytics.cashflow.CompositePeriod&gt;();

<span class="nc bnc" id="L1166" title="All 2 branches missed.">		for (int i = iStartIndex; i &lt; iNumComp; ++i) {</span>
<span class="nc bnc" id="L1167" title="All 2 branches missed.">			if (null == aComp[i]) continue;</span>

<span class="nc" id="L1169">			java.util.List&lt;org.drip.analytics.cashflow.CompositePeriod&gt; lsCompPeriod =</span>
<span class="nc" id="L1170">				aComp[i].couponPeriods();</span>

<span class="nc bnc" id="L1172" title="All 4 branches missed.">			if (null == lsCompPeriod || 0 == lsCompPeriod.size()) continue;</span>

<span class="nc bnc" id="L1174" title="All 2 branches missed.">			for (org.drip.analytics.cashflow.CompositePeriod p : lsCompPeriod) {</span>
<span class="nc bnc" id="L1175" title="All 2 branches missed.">				if (null != p) setAggregatedPeriod.add (p);</span>
<span class="nc" id="L1176">			}</span>
		}

<span class="nc" id="L1179">		return setAggregatedPeriod;</span>
	}

	/**
	 * Append the Prefixed Map Entries of the specified Input Map onto the Output Map
	 * 
	 * @param mapOutput The Output Map
	 * @param strPrefix The Entry Prefix
	 * @param mapInput The Input Map
	 * 
	 * @return TRUE - At least one entry appended
	 */

	public static final boolean AccumulateMeasures (
		final org.drip.analytics.support.CaseInsensitiveTreeMap&lt;java.lang.Double&gt; mapOutput,
		final java.lang.String strPrefix,
		final org.drip.analytics.support.CaseInsensitiveTreeMap&lt;java.lang.Double&gt; mapInput)
	{
<span class="pc bpc" id="L1197" title="4 of 8 branches missed.">		if (null == mapOutput || null == strPrefix || strPrefix.isEmpty() || null == mapInput) return false;</span>

<span class="fc" id="L1199">		java.util.Set&lt;java.util.Map.Entry&lt;java.lang.String, java.lang.Double&gt;&gt; mapInputESSingle =</span>
<span class="fc" id="L1200">			mapInput.entrySet();</span>

<span class="pc bpc" id="L1202" title="1 of 2 branches missed.">		if (null == mapInputESSingle) return false;</span>

<span class="fc bfc" id="L1204" title="All 2 branches covered.">		for (java.util.Map.Entry&lt;java.lang.String, java.lang.Double&gt; me : mapInputESSingle) {</span>
<span class="pc bpc" id="L1205" title="1 of 2 branches missed.">			if (null == me) continue;</span>

<span class="fc" id="L1207">			java.lang.String strKey = me.getKey();</span>

<span class="pc bpc" id="L1209" title="2 of 4 branches missed.">			if (null == strKey || strKey.isEmpty()) continue;</span>

<span class="fc" id="L1211">			mapOutput.put (strPrefix + &quot;@&quot; + strKey, me.getValue());</span>
<span class="fc" id="L1212">		}</span>

<span class="fc" id="L1214">		return true;</span>
	}

	/**
	 * Do the Left and the Right Labels Match?
	 * 
	 * @param lslLeft Left Cash Flow Period Label
	 * @param lslRight Right Cash Flow Period Label
	 * 
	 * @return TRUE - The Labels Match
	 */

	public static final boolean LabelMatch (
		final org.drip.state.identifier.LatentStateLabel lslLeft,
		final org.drip.state.identifier.LatentStateLabel lslRight)
	{
<span class="nc bnc" id="L1230" title="All 4 branches missed.">		if (null == lslLeft &amp;&amp; null == lslRight) return true;</span>

<span class="nc bnc" id="L1232" title="All 8 branches missed.">		if ((null == lslLeft &amp;&amp; null != lslRight) || (null != lslLeft &amp;&amp; null == lslRight)) return false;</span>

<span class="nc" id="L1234">		return lslLeft.match (lslRight);</span>
	}

	/**
	 * Compute the Bond Futures Price AUD Bill Style from the Reference Index Level
	 * 
	 * @param dtValue The Valuation Date
	 * @param bond The Bond Instance
	 * @param dblReferenceIndex The Reference Index
	 * 
	 * @return The Bond Futures Price AUD Bill Style
	 * 
	 * @throws java.lang.Exception Thrown if the Bond Futures Price AUD Bill Style cannot be computed
	 */

	public static final double BondFuturesPriceAUDBillStyle (
		final org.drip.analytics.date.JulianDate dtValue,
		final org.drip.product.definition.Bond bond,
		final double dblReferenceIndex)
		throws java.lang.Exception
	{
<span class="nc bnc" id="L1255" title="All 6 branches missed.">		if (null == dtValue || null == bond || !org.drip.numerical.common.NumberUtil.IsValid (dblReferenceIndex))</span>
<span class="nc" id="L1256">			throw new java.lang.Exception</span>
				(&quot;AnalyticsHelper::BondFuturesPriceAUDBillStyle =&gt; Invalid Inputs&quot;);

<span class="nc" id="L1259">		return 1. / (1. + (1. - dblReferenceIndex) * org.drip.analytics.daycount.Convention.YearFraction</span>
<span class="nc" id="L1260">			(dtValue.julian(), bond.maturityDate().julian(), bond.accrualDC(), false, null,</span>
<span class="nc" id="L1261">				bond.currency()));</span>
	}

	/**
	 * Construct a Normalized, Equally Weighted Array from the Specified Number of Elements
	 * 
	 * @param iNumElement Number of Elements
	 * 
	 * @return The Normalized, Equally Weighted Array
	 */

	public static final double[] NormalizedEqualWeightedArray (
		final int iNumElement)
	{
<span class="pc bpc" id="L1275" title="1 of 2 branches missed.">		if (0 &gt;= iNumElement) return null;</span>

<span class="fc" id="L1277">		double dblWeight = 1. / iNumElement;</span>
<span class="fc" id="L1278">		double[] adblEqualWeighted = new double[iNumElement];</span>

<span class="fc bfc" id="L1280" title="All 2 branches covered.">		for (int i = 0; i &lt; iNumElement; ++i)</span>
<span class="fc" id="L1281">			adblEqualWeighted[i] = dblWeight;</span>

<span class="fc" id="L1283">		return adblEqualWeighted;</span>
	}

	/**
	 * Aggregate the Base and the Roll Tenors onto a Composite Tenor
	 * 
	 * @param strBaseTenor The Base Tenor
	 * @param strRollTenor The Roll Tenor
	 * 
	 * @return The Agrregated Composite Tenor
	 */

	public static final java.lang.String AggregateTenor (
		final java.lang.String strBaseTenor,
		final java.lang.String strRollTenor)
	{
<span class="pc bpc" id="L1299" title="1 of 4 branches missed.">		if (null == strBaseTenor || strBaseTenor.isEmpty()) return strRollTenor;</span>

<span class="fc" id="L1301">		char chBaseTenor = strBaseTenor.charAt (strBaseTenor.length() - 1);</span>

<span class="fc" id="L1303">		char chRollTenor = strRollTenor.charAt (strRollTenor.length() - 1);</span>

<span class="pc bpc" id="L1305" title="1 of 2 branches missed.">		if (chRollTenor != chBaseTenor) return null;</span>

<span class="fc" id="L1307">		int iBaseTimeUnit = (int) java.lang.Double.parseDouble (strBaseTenor.substring (0, strBaseTenor.length() -</span>
			1));

<span class="fc" id="L1310">		int iRollTimeUnit = (int) java.lang.Double.parseDouble (strRollTenor.substring (0, strRollTenor.length() -</span>
			1));

<span class="fc" id="L1313">		return &quot;&quot; + (iBaseTimeUnit + iRollTimeUnit) + chBaseTenor;</span>
	}

	/**
	 * Convert the Array of Tenors into Dates off of a Spot
	 * 
	 * @param dtSpot Spot Date
	 * @param astrTenor Array of Tenors
	 * 
	 * @return Array of Dates
	 */

	public static final org.drip.analytics.date.JulianDate[] FromTenor (
		final org.drip.analytics.date.JulianDate dtSpot,
		final java.lang.String[] astrTenor)
	{
<span class="pc bpc" id="L1329" title="2 of 4 branches missed.">		if (null == dtSpot || null == astrTenor) return null;</span>

<span class="fc" id="L1331">		int iNumTenor = astrTenor.length;</span>
<span class="pc bpc" id="L1332" title="1 of 2 branches missed.">		org.drip.analytics.date.JulianDate[] adt = 0 == iNumTenor ? null : new</span>
			org.drip.analytics.date.JulianDate[iNumTenor];

<span class="pc bpc" id="L1335" title="1 of 2 branches missed.">		if (0 == iNumTenor) return null;</span>

<span class="fc bfc" id="L1337" title="All 2 branches covered.">		for (int i = 0; i &lt; iNumTenor; ++i) {</span>
<span class="pc bpc" id="L1338" title="1 of 2 branches missed.">			if (null == (adt[i] = dtSpot.addTenor (astrTenor[i]))) return null;</span>
		}

<span class="fc" id="L1341">		return adt;</span>
	}

	/**
	 * Generate an Array of Repeated Spot Dates
	 * 
	 * @param dtSpot Spot Date
	 * @param iCount Repeat Count
	 * 
	 * @return Array of the Repeated Spot Dates
	 */

	public static final org.drip.analytics.date.JulianDate[] SpotDateArray (
		final org.drip.analytics.date.JulianDate dtSpot,
		final int iCount)
	{
<span class="pc bpc" id="L1357" title="2 of 4 branches missed.">		if (null == dtSpot || 0 &gt;= iCount) return null;</span>

<span class="fc" id="L1359">		org.drip.analytics.date.JulianDate[] adtSpot = new org.drip.analytics.date.JulianDate[iCount];</span>

<span class="fc bfc" id="L1361" title="All 2 branches covered.">		for (int i = 0; i &lt; iCount; ++i)</span>
<span class="fc" id="L1362">			adtSpot[i] = dtSpot;</span>

<span class="fc" id="L1364">		return adtSpot;</span>
	}

	/**
	 * Generate an Array of Bumped Nodes
	 * 
	 * @param adblNode Array of Unbumped Nodes
	 * @param dblBump Bump Amount
	 * 
	 * @return Array of Bumped Nodes
	 */

	public static final double[] ParallelNodeBump (
		final double[] adblNode,
		final double dblBump)
	{
<span class="pc bpc" id="L1380" title="1 of 2 branches missed.">		if (null == adblNode) return null;</span>

<span class="fc" id="L1382">		int iNumNode = adblNode.length;</span>
<span class="pc bpc" id="L1383" title="1 of 2 branches missed.">		double[] adblBumpedNode = 0 == iNumNode ? null : new double[iNumNode];</span>

<span class="fc bfc" id="L1385" title="All 2 branches covered.">		for (int i = 0; i &lt; iNumNode; ++i) {</span>
<span class="pc bpc" id="L1386" title="1 of 2 branches missed.">			if (!org.drip.numerical.common.NumberUtil.IsValid (adblBumpedNode[i] = adblNode[i] + dblBump))</span>
<span class="nc" id="L1387">				return null;</span>
		}

<span class="fc" id="L1390">		return adblBumpedNode;</span>
	}

	/**
	 * Converts the Nano-Second Interval into aH:bM:cS:dMS Format
	 * 
	 * @param lElapsedNanos The Elapsed Nano Time
	 *
	 * @return The Nano-Second Interval in the aH:bM:cS:dMS Format
	 */

	public static final java.lang.String IntervalHMSMS (
		final long lElapsedNanos)
	{
<span class="pc bpc" id="L1404" title="1 of 2 branches missed.">		if (0 &gt;= lElapsedNanos) return &quot;&quot;;</span>

<span class="fc" id="L1406">		java.lang.String strHMS = &quot;&quot;;</span>
<span class="fc" id="L1407">		long lElapsedSeconds = (long) ((0.5 + lElapsedNanos) * 1.e-09);</span>
<span class="fc" id="L1408">		long lElapsedMillis = (lElapsedNanos - lElapsedSeconds * 1000000000) / 1000000;</span>

<span class="pc bpc" id="L1410" title="1 of 2 branches missed.">		if (lElapsedSeconds &gt;= 3600)</span>
		{
<span class="nc" id="L1412">			strHMS = strHMS + (lElapsedSeconds / 3600) + &quot; h &quot;;</span>
<span class="nc" id="L1413">			lElapsedSeconds = lElapsedSeconds % 3600;</span>
		}

<span class="fc bfc" id="L1416" title="All 2 branches covered.">		if (lElapsedSeconds &gt;= 60)</span>
		{
<span class="fc" id="L1418">			strHMS = strHMS + (lElapsedSeconds / 60) + &quot; m &quot;;</span>
<span class="fc" id="L1419">			lElapsedSeconds = lElapsedSeconds % 60;</span>
		}

<span class="fc bfc" id="L1422" title="All 2 branches covered.">		if (lElapsedSeconds &gt; 0)</span>
		{
<span class="fc" id="L1424">			strHMS = strHMS + lElapsedSeconds + &quot; s &quot;;</span>
		}

<span class="fc" id="L1427">		return strHMS + lElapsedMillis + &quot; ms&quot;;</span>
	}
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.7.9.201702052155</span></div></body></html>