<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>CompositePeriodBuilder.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">DROP</a> &gt; <a href="index.source.html" class="el_package">org.drip.analytics.support</a> &gt; <span class="el_source">CompositePeriodBuilder.java</span></div><h1>CompositePeriodBuilder.java</h1><pre class="source lang-java linenums">
package org.drip.analytics.support;

/*
 * -*- mode: java; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*-
 */

/*!
 * Copyright (C) 2019 Lakshmi Krishnamurthy
 * Copyright (C) 2018 Lakshmi Krishnamurthy
 * Copyright (C) 2017 Lakshmi Krishnamurthy
 * Copyright (C) 2016 Lakshmi Krishnamurthy
 * Copyright (C) 2015 Lakshmi Krishnamurthy
 * Copyright (C) 2014 Lakshmi Krishnamurthy
 * 
 *  This file is part of DROP, an open-source library targeting risk, transaction costs, exposure, margin
 *  	calculations, and portfolio construction within and across fixed income, credit, commodity, equity,
 *  	FX, and structured products.
 *  
 *  	https://lakshmidrip.github.io/DROP/
 *  
 *  DROP is composed of three main modules:
 *  
 *  - DROP Analytics Core - https://lakshmidrip.github.io/DROP-Analytics-Core/
 *  - DROP Portfolio Core - https://lakshmidrip.github.io/DROP-Portfolio-Core/
 *  - DROP Numerical Core - https://lakshmidrip.github.io/DROP-Numerical-Core/
 * 
 * 	DROP Analytics Core implements libraries for the following:
 * 	- Fixed Income Analytics
 * 	- Asset Backed Analytics
 * 	- XVA Analytics
 * 	- Exposure and Margin Analytics
 * 
 * 	DROP Portfolio Core implements libraries for the following:
 * 	- Asset Allocation Analytics
 * 	- Transaction Cost Analytics
 * 
 * 	DROP Numerical Core implements libraries for the following:
 * 	- Statistical Learning Library
 * 	- Numerical Optimizer Library
 * 	- Machine Learning Library
 * 	- Spline Builder Library
 * 
 * 	Documentation for DROP is Spread Over:
 * 
 * 	- Main                     =&gt; https://lakshmidrip.github.io/DROP/
 * 	- Wiki                     =&gt; https://github.com/lakshmiDRIP/DROP/wiki
 * 	- GitHub                   =&gt; https://github.com/lakshmiDRIP/DROP
 * 	- Javadoc                  =&gt; https://lakshmidrip.github.io/DROP/Javadoc/index.html
 * 	- Technical Specifications =&gt; https://github.com/lakshmiDRIP/DROP/tree/master/Docs/Internal
 * 	- Release Versions         =&gt; https://lakshmidrip.github.io/DROP/version.html
 * 	- Community Credits        =&gt; https://lakshmidrip.github.io/DROP/credits.html
 * 	- Issues Catalog           =&gt; https://github.com/lakshmiDRIP/DROP/issues
 * 	- JUnit                    =&gt; https://lakshmidrip.github.io/DROP/junit/index.html
 * 	- Jacoco                   =&gt; https://lakshmidrip.github.io/DROP/jacoco/index.html
 * 
 *  Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 *   	you may not use this file except in compliance with the License.
 *   
 *  You may obtain a copy of the License at
 *  	http://www.apache.org/licenses/LICENSE-2.0
 *  
 *  Unless required by applicable law or agreed to in writing, software
 *  	distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 *  	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  
 *  See the License for the specific language governing permissions and
 *  	limitations under the License.
 */

/**
 * &lt;i&gt;CompositePeriodBuilder&lt;/i&gt; exposes the composite period construction functionality.
 *
 *	&lt;br&gt;&lt;br&gt;
 *  &lt;ul&gt;
 *		&lt;li&gt;&lt;b&gt;Module &lt;/b&gt; = &lt;a href = &quot;https://github.com/lakshmiDRIP/DROP/tree/master/AnalyticsCore.md&quot;&gt;Analytics Core Module&lt;/a&gt;&lt;/li&gt;
 *		&lt;li&gt;&lt;b&gt;Library&lt;/b&gt; = &lt;a href = &quot;https://github.com/lakshmiDRIP/DROP/tree/master/FixedIncomeAnalyticsLibrary.md&quot;&gt;Fixed Income Analytics&lt;/a&gt;&lt;/li&gt;
 *		&lt;li&gt;&lt;b&gt;Project&lt;/b&gt; = &lt;a href = &quot;https://github.com/lakshmiDRIP/DROP/tree/master/src/main/java/org/drip/analytics&quot;&gt;Analytics&lt;/a&gt;&lt;/li&gt;
 *		&lt;li&gt;&lt;b&gt;Package&lt;/b&gt; = &lt;a href = &quot;https://github.com/lakshmiDRIP/DROP/tree/master/src/main/java/org/drip/analytics/support&quot;&gt;Support&lt;/a&gt;&lt;/li&gt;
 *  &lt;/ul&gt;
 * 
 * @author Lakshmi Krishnamurthy
 */

<span class="nc" id="L85">public class CompositePeriodBuilder {</span>

	/**
	 * Edge Date Generation Sequence - Forward
	 */

	public static final int EDGE_DATE_SEQUENCE_FORWARD = 0;

	/**
	 * Edge Date Generation Sequence - Reverse
	 */

	public static final int EDGE_DATE_SEQUENCE_REVERSE = 1;

	/**
	 * Edge Date Generation Sequence - Regular
	 */

	public static final int EDGE_DATE_SEQUENCE_REGULAR = 2;

	/**
	 * Edge Date Generation Sequence - Overnight
	 */

	public static final int EDGE_DATE_SEQUENCE_OVERNIGHT = 4;

	/**
	 * Edge Date Generation Sequence - Single Edge Date Pair Between Dates
	 */

	public static final int EDGE_DATE_SEQUENCE_SINGLE = 8;

	/**
	 * Period Set Generation Customization - Short Stub (i.e., No adjustment on either end)
	 */

	public static final int SHORT_STUB = 0;

	/**
	 * Period Set Generation Customization - Merge the front periods to produce a long front
	 */

	public static final int FULL_FRONT_PERIOD = 1;

	/**
	 * Period Set Generation Customization - Long Stub (if present) belongs to the front/back end depending
	 * 	upon backwards/forwards generation scheme
	 */

	public static final int LONG_STUB = 2;

	/**
	 * Reference Period Fixing is IN-ARREARS (i.e., displaced one period to the right) of the Coupon Period
	 */

	public static final int REFERENCE_PERIOD_IN_ARREARS = 0;

	/**
	 * Reference Period Fixing is IN-ADVANCE (i.e., the same as that) of the Coupon Period
	 */

	public static final int REFERENCE_PERIOD_IN_ADVANCE = 1;

	/**
	 * Accrual Compounding Rule - Arithmetic
	 */

	public static final int ACCRUAL_COMPOUNDING_RULE_ARITHMETIC = 1;

	/**
	 * Accrual Compounding Rule - Geometric
	 */

	public static final int ACCRUAL_COMPOUNDING_RULE_GEOMETRIC = 2;

	private static final int DAPAdjust (
		final int iDate,
		final org.drip.analytics.daycount.DateAdjustParams dap)
	{
<span class="fc bfc" id="L164" title="All 2 branches covered.">		if (null == dap) return iDate;</span>

		try {
<span class="fc" id="L167">			return dap.roll (iDate);</span>
<span class="nc" id="L168">		} catch (java.lang.Exception e) {</span>
<span class="nc" id="L169">			e.printStackTrace();</span>
		}

<span class="nc" id="L172">		return iDate;</span>
	}

	/**
	 * Verify if the Specified Accrual Compounding Rule is a Valid One
	 * 
	 * @param iAccrualCompoundingRule The Accrual Compounding Rule
	 * 
	 * @return TRUE - The Accrual Compounding Rule is valid
	 */

	public static final boolean ValidateCompoundingRule (
		final int iAccrualCompoundingRule)
	{
<span class="pc bpc" id="L186" title="1 of 4 branches missed.">		return ACCRUAL_COMPOUNDING_RULE_ARITHMETIC == iAccrualCompoundingRule ||</span>
			ACCRUAL_COMPOUNDING_RULE_GEOMETRIC == iAccrualCompoundingRule;
	}

	/**
	 * Generate a list of period edge dates forward from the start.
	 * 
	 * @param dtEffective Effective date
	 * @param dtMaturity Maturity date
	 * @param strTenor Period Tenor
	 * @param dap Inner Date Adjustment Parameters
	 * @param iPSEC Period Set Edge Customizer Setting
	 * 
	 * @return List of Period Edge Dates
	 */

	public static final java.util.List&lt;java.lang.Integer&gt; ForwardEdgeDates (
		final org.drip.analytics.date.JulianDate dtEffective,
		final org.drip.analytics.date.JulianDate dtMaturity,
		final java.lang.String strTenor,
		final org.drip.analytics.daycount.DateAdjustParams dap,
		final int iPSEC)
	{
<span class="nc bnc" id="L209" title="All 8 branches missed.">		if (null == dtEffective || null == dtMaturity || null == strTenor || strTenor.isEmpty()) return null;</span>

<span class="nc" id="L211">		java.lang.String strPeriodRollTenor = &quot;&quot;;</span>
<span class="nc" id="L212">		org.drip.analytics.date.JulianDate dtEdge = dtEffective;</span>

<span class="nc" id="L214">		int iMaturityDate = dtMaturity.julian();</span>

<span class="nc" id="L216">		int iEdgeDate = dtEdge.julian();</span>

<span class="nc bnc" id="L218" title="All 2 branches missed.">		if (iEdgeDate &gt;= iMaturityDate) return null;</span>

<span class="nc" id="L220">		java.util.List&lt;java.lang.Integer&gt; lsEdgeDate = new java.util.ArrayList&lt;java.lang.Integer&gt;();</span>

<span class="nc bnc" id="L222" title="All 2 branches missed.">		while (iEdgeDate &lt; iMaturityDate) {</span>
<span class="nc" id="L223">			lsEdgeDate.add (iEdgeDate);</span>

<span class="nc" id="L225">			strPeriodRollTenor = org.drip.analytics.support.Helper.AggregateTenor</span>
<span class="nc" id="L226">				(strPeriodRollTenor, strTenor);</span>

<span class="nc bnc" id="L228" title="All 2 branches missed.">			if (null == (dtEdge = dtMaturity.addTenor (strPeriodRollTenor))) return null;</span>

<span class="nc" id="L230">			iEdgeDate = dtEdge.julian();</span>
		}

<span class="nc bnc" id="L233" title="All 2 branches missed.">		if (iEdgeDate &gt; iMaturityDate) {</span>
<span class="nc bnc" id="L234" title="All 2 branches missed.">			if (SHORT_STUB == iPSEC)</span>
<span class="nc" id="L235">				lsEdgeDate.add (iMaturityDate);</span>
<span class="nc bnc" id="L236" title="All 2 branches missed.">			else if (LONG_STUB == iPSEC) {</span>
<span class="nc bnc" id="L237" title="All 2 branches missed.">				if (1 != lsEdgeDate.size()) lsEdgeDate.remove (lsEdgeDate.size() - 1);</span>

<span class="nc" id="L239">				lsEdgeDate.add (iMaturityDate);</span>
			}
<span class="nc bnc" id="L241" title="All 2 branches missed.">		} else if (iEdgeDate == iMaturityDate)</span>
<span class="nc" id="L242">			lsEdgeDate.add (iMaturityDate);</span>

<span class="nc" id="L244">		java.util.List&lt;java.lang.Integer&gt; lsAdjustedEdgeDate = new java.util.ArrayList&lt;java.lang.Integer&gt;();</span>

<span class="nc" id="L246">		lsAdjustedEdgeDate.add (lsEdgeDate.get (0));</span>

<span class="nc" id="L248">		int iNumDate = lsEdgeDate.size();</span>

<span class="nc bnc" id="L250" title="All 2 branches missed.">		for (int i = 1; i &lt; iNumDate - 1; ++i)</span>
<span class="nc" id="L251">			lsAdjustedEdgeDate.add (DAPAdjust (lsEdgeDate.get (i), dap));</span>

<span class="nc" id="L253">		lsAdjustedEdgeDate.add (lsEdgeDate.get (iNumDate - 1));</span>

<span class="nc bnc" id="L255" title="All 2 branches missed.">		if (1 == lsAdjustedEdgeDate.size()) lsAdjustedEdgeDate.add (1, iMaturityDate);</span>

<span class="nc" id="L257">		return lsAdjustedEdgeDate;</span>
	}

	/**
	 * Generate a list of period edge dates backward from the end.
	 * 
	 * @param dtEffective Effective date
	 * @param dtMaturity Maturity date
	 * @param strTenor Period Tenor
	 * @param dap Inner Date Adjustment Parameters
	 * @param iPSEC Period Set Edge Customizer Setting
	 * 
	 * @return List of Period Edge Dates
	 */

	public static final java.util.List&lt;java.lang.Integer&gt; BackwardEdgeDates (
		final org.drip.analytics.date.JulianDate dtEffective,
		final org.drip.analytics.date.JulianDate dtMaturity,
		final java.lang.String strTenor,
		final org.drip.analytics.daycount.DateAdjustParams dap,
		final int iPSEC)
	{
<span class="pc bpc" id="L279" title="4 of 8 branches missed.">		if (null == dtEffective || null == dtMaturity || null == strTenor || strTenor.isEmpty()) return null;</span>

<span class="fc" id="L281">		int iEffectiveDate = dtEffective.julian();</span>

<span class="fc" id="L283">		java.lang.String strPeriodRollTenor = &quot;&quot;;</span>
<span class="fc" id="L284">		org.drip.analytics.date.JulianDate dtEdge = dtMaturity;</span>

<span class="fc" id="L286">		int iEdgeDate = dtEdge.julian();</span>

<span class="pc bpc" id="L288" title="1 of 2 branches missed.">		if (iEffectiveDate &gt;= iEdgeDate) return null;</span>

<span class="fc" id="L290">		java.util.List&lt;java.lang.Integer&gt; lsEdgeDate = new java.util.ArrayList&lt;java.lang.Integer&gt;();</span>

<span class="fc bfc" id="L292" title="All 2 branches covered.">		while (iEdgeDate &gt; iEffectiveDate) {</span>
<span class="fc" id="L293">			lsEdgeDate.add (0, iEdgeDate);</span>

<span class="fc" id="L295">			strPeriodRollTenor = org.drip.analytics.support.Helper.AggregateTenor (strPeriodRollTenor,</span>
				strTenor);

<span class="pc bpc" id="L298" title="1 of 2 branches missed.">			if (null == (dtEdge = dtMaturity.subtractTenor (strPeriodRollTenor))) return null;</span>

<span class="fc" id="L300">			iEdgeDate = dtEdge.julian();</span>
		}

<span class="fc bfc" id="L303" title="All 2 branches covered.">		if (iEdgeDate &lt; iEffectiveDate) {</span>
<span class="fc bfc" id="L304" title="All 2 branches covered.">			if (SHORT_STUB == iPSEC)</span>
<span class="fc" id="L305">				lsEdgeDate.add (0, iEffectiveDate);</span>
<span class="pc bpc" id="L306" title="1 of 2 branches missed.">			else if (FULL_FRONT_PERIOD == iPSEC)</span>
<span class="nc" id="L307">				lsEdgeDate.add (0, iEdgeDate);</span>
<span class="pc bpc" id="L308" title="1 of 2 branches missed.">			else if (LONG_STUB == iPSEC) {</span>
<span class="fc bfc" id="L309" title="All 2 branches covered.">				if (1 != lsEdgeDate.size()) lsEdgeDate.remove (0);</span>

<span class="fc" id="L311">				lsEdgeDate.add (0, iEffectiveDate);</span>
			}
<span class="pc bpc" id="L313" title="1 of 2 branches missed.">		} else if (dtEdge.julian() == iEffectiveDate)</span>
<span class="fc" id="L314">			lsEdgeDate.add (0, iEffectiveDate);</span>

<span class="fc" id="L316">		java.util.List&lt;java.lang.Integer&gt; lsAdjustedEdgeDate = new java.util.ArrayList&lt;java.lang.Integer&gt;();</span>

<span class="fc" id="L318">		lsAdjustedEdgeDate.add (lsEdgeDate.get (0));</span>

<span class="fc" id="L320">		int iNumDate = lsEdgeDate.size();</span>

<span class="fc bfc" id="L322" title="All 2 branches covered.">		for (int i = 1; i &lt; iNumDate - 1; ++i)</span>
<span class="fc" id="L323">			lsAdjustedEdgeDate.add (DAPAdjust (lsEdgeDate.get (i), dap));</span>

<span class="fc" id="L325">		lsAdjustedEdgeDate.add (lsEdgeDate.get (iNumDate - 1));</span>

<span class="fc" id="L327">		return lsAdjustedEdgeDate;</span>
	}

	/**
	 * Generate a list of regular period edge dates forward from the start.
	 * 
	 * @param dtEffective Effective date
	 * @param strPeriodTenor Period Tenor
	 * @param strMaturityTenor Period Tenor
	 * @param dap Inner Date Adjustment Parameters
	 * 
	 * @return List of Period Edge Dates
	 */

	public static final java.util.List&lt;java.lang.Integer&gt; RegularEdgeDates (
		final org.drip.analytics.date.JulianDate dtEffective,
		final java.lang.String strPeriodTenor,
		final java.lang.String strMaturityTenor,
		final org.drip.analytics.daycount.DateAdjustParams dap)
	{
<span class="pc bpc" id="L347" title="4 of 8 branches missed.">		if (null == dtEffective || null == strPeriodTenor || strPeriodTenor.isEmpty() || null ==</span>
<span class="pc bpc" id="L348" title="1 of 2 branches missed.">			strMaturityTenor || strMaturityTenor.isEmpty())</span>
<span class="nc" id="L349">			return null;</span>

<span class="fc" id="L351">		int iPeriodTenorMonth = -1;</span>
<span class="fc" id="L352">		int iMaturityTenorMonth = -1;</span>
<span class="fc" id="L353">		int iPeriodMaturityTenorComparison = -1;</span>

<span class="fc" id="L355">		int iMaturityDate = dtEffective.addTenor (strMaturityTenor).julian();</span>

<span class="fc" id="L357">		java.util.List&lt;java.lang.Integer&gt; lsEdgeDate = new java.util.ArrayList&lt;java.lang.Integer&gt;();</span>

		try {
<span class="fc" id="L360">			iPeriodMaturityTenorComparison = org.drip.analytics.support.Helper.TenorCompare (strPeriodTenor,</span>
				strMaturityTenor);
<span class="nc" id="L362">		} catch (java.lang.Exception e) {</span>
<span class="nc" id="L363">			e.printStackTrace();</span>

<span class="nc" id="L365">			return null;</span>
<span class="fc" id="L366">		}</span>

<span class="fc bfc" id="L368" title="All 4 branches covered.">		if (org.drip.analytics.support.Helper.LEFT_TENOR_EQUALS == iPeriodMaturityTenorComparison ||</span>
			org.drip.analytics.support.Helper.LEFT_TENOR_GREATER == iPeriodMaturityTenorComparison) {
<span class="fc" id="L370">			lsEdgeDate.add (dtEffective.julian());</span>

<span class="fc" id="L372">			lsEdgeDate.add (iMaturityDate);</span>

<span class="fc" id="L374">			return lsEdgeDate;</span>
		}

		try {
<span class="fc" id="L378">			iPeriodTenorMonth = org.drip.analytics.support.Helper.TenorToMonths (strPeriodTenor);</span>

<span class="fc" id="L380">			iMaturityTenorMonth = org.drip.analytics.support.Helper.TenorToMonths (strMaturityTenor);</span>
<span class="nc" id="L381">		} catch (java.lang.Exception e) {</span>
<span class="nc" id="L382">			e.printStackTrace();</span>

<span class="nc" id="L384">			return null;</span>
<span class="fc" id="L385">		}</span>

<span class="fc" id="L387">		org.drip.analytics.date.JulianDate dtEdge = dtEffective;</span>
<span class="fc" id="L388">		int iNumPeriod = iMaturityTenorMonth / iPeriodTenorMonth;</span>

<span class="fc" id="L390">		lsEdgeDate.add (dtEdge.julian());</span>

<span class="fc bfc" id="L392" title="All 2 branches covered.">		for (int i = 0; i &lt; iNumPeriod; ++i) {</span>
<span class="fc" id="L393">			dtEdge = dtEdge.addTenor (strPeriodTenor);</span>

<span class="fc" id="L395">			int iEdgeDate = dtEdge.julian();</span>

<span class="fc bfc" id="L397" title="All 2 branches covered.">			if (iEdgeDate &lt; iMaturityDate) lsEdgeDate.add (DAPAdjust (iEdgeDate, dap));</span>
		}

<span class="fc" id="L400">		lsEdgeDate.add (iMaturityDate);</span>

<span class="fc" id="L402">		return lsEdgeDate;</span>
	}

	/**
	 * Generate a list of regular period edge dates forward from the start.
	 * 
	 * @param iStartDate Start Date
	 * @param iEndDate End Date
	 * @param strPeriodTenor Period Tenor
	 * @param dap Inner Date Adjustment Parameters
	 * 
	 * @return List of Period Edge Dates
	 */

	public static final java.util.List&lt;java.lang.Integer&gt; RegularEdgeDates (
		final int iStartDate,
		final int iEndDate,
		final java.lang.String strPeriodTenor,
		final org.drip.analytics.daycount.DateAdjustParams dap)
	{
<span class="pc bpc" id="L422" title="3 of 6 branches missed.">		if (iStartDate &gt;= iEndDate || null == strPeriodTenor || strPeriodTenor.isEmpty()) return null;</span>

<span class="fc" id="L424">		java.util.List&lt;java.lang.Integer&gt; lsEdgeDate = new java.util.ArrayList&lt;java.lang.Integer&gt;();</span>

<span class="fc" id="L426">		int iEdgeDate = iStartDate;</span>

<span class="fc" id="L428">		org.drip.analytics.date.JulianDate dtEdge = new org.drip.analytics.date.JulianDate (iStartDate);</span>

<span class="fc bfc" id="L430" title="All 2 branches covered.">		while (iEdgeDate &lt; iEndDate) {</span>
<span class="fc" id="L431">			int iAdjustedEdgeDate = DAPAdjust (iEdgeDate, dap);</span>

<span class="pc bpc" id="L433" title="1 of 2 branches missed.">			if (!lsEdgeDate.contains (iAdjustedEdgeDate)) lsEdgeDate.add (iAdjustedEdgeDate);</span>

<span class="pc bpc" id="L435" title="1 of 2 branches missed.">			if (null == (dtEdge = dtEdge.addTenor (strPeriodTenor))) return null;</span>

<span class="fc" id="L437">			iEdgeDate = dtEdge.julian();</span>
<span class="fc" id="L438">		}</span>

<span class="fc bfc" id="L440" title="All 2 branches covered.">		if (!lsEdgeDate.contains (iEndDate)) lsEdgeDate.add (iEndDate);</span>

<span class="fc" id="L442">		return lsEdgeDate;</span>
	}

	/**
	 * Generate a list of the IMM period edge dates forward from the spot date.
	 * 
	 * @param dtSpot Spot Date
	 * @param iRollMonths Number of Months to Roll to the Next IMM Date
	 * @param strPeriodTenor Period Tenor
	 * @param strMaturityTenor Period Tenor
	 * @param dap Inner Date Adjustment Parameters
	 * 
	 * @return List of IMM Period Edge Dates
	 */

	public static final java.util.List&lt;java.lang.Integer&gt; IMMEdgeDates (
		final org.drip.analytics.date.JulianDate dtSpot,
		final int iRollMonths,
		final java.lang.String strPeriodTenor,
		final java.lang.String strMaturityTenor,
		final org.drip.analytics.daycount.DateAdjustParams dap)
	{
<span class="pc bpc" id="L464" title="1 of 2 branches missed.">		if (null == dtSpot) return null;</span>

		try {
<span class="fc" id="L467">			return RegularEdgeDates (dtSpot.nextRatesFuturesIMM (iRollMonths), strPeriodTenor,</span>
				strMaturityTenor, dap);
<span class="nc" id="L469">		} catch (java.lang.Exception e) {</span>
<span class="nc" id="L470">			e.printStackTrace();</span>
		}

<span class="nc" id="L473">		return null;</span>
	}

	/**
	 * Generate the List of Overnight Edge Dates between the specified dates, using the specified Calendar
	 * 
	 * @param dtStart Start Date
	 * @param dtEnd End Date
	 * @param strCalendar Calendar
	 * 
	 * @return List of Overnight Edge Dates
	 */

	public static final java.util.List&lt;java.lang.Integer&gt; OvernightEdgeDates (
		final org.drip.analytics.date.JulianDate dtStart,
		final org.drip.analytics.date.JulianDate dtEnd,
		final java.lang.String strCalendar)
	{
<span class="pc bpc" id="L491" title="2 of 4 branches missed.">		if (null == dtStart || null == dtEnd) return null;</span>

<span class="fc" id="L493">		org.drip.analytics.date.JulianDate dtEdge = dtStart;</span>

<span class="fc" id="L495">		int iEndDate = dtEnd.julian();</span>

<span class="fc" id="L497">		int iEdgeDate = dtEdge.julian();</span>

<span class="pc bpc" id="L499" title="1 of 2 branches missed.">		if (iEndDate &lt;= iEdgeDate) return null;</span>

<span class="fc" id="L501">		java.util.List&lt;java.lang.Integer&gt; lsOvernightEdgeDate = new java.util.ArrayList&lt;java.lang.Integer&gt;();</span>

<span class="fc bfc" id="L503" title="All 2 branches covered.">		while (iEdgeDate &lt; iEndDate) {</span>
<span class="fc" id="L504">			lsOvernightEdgeDate.add (iEdgeDate);</span>

<span class="pc bpc" id="L506" title="1 of 2 branches missed.">			if (null == (dtEdge = dtEdge.addBusDays (1, strCalendar))) return null;</span>

<span class="fc" id="L508">			iEdgeDate = dtEdge.julian();</span>
		}

<span class="fc" id="L511">		lsOvernightEdgeDate.add (iEndDate);</span>

<span class="fc" id="L513">		return lsOvernightEdgeDate;</span>
	}

	/**
	 * Generate a single Spanning Edge Pair between the specified dates, using the specified Calendar
	 * 
	 * @param dtStart Start Date
	 * @param dtEnd End Date
	 * 
	 * @return List Containing the Pair
	 */

	public static final java.util.List&lt;java.lang.Integer&gt; EdgePair (
		final org.drip.analytics.date.JulianDate dtStart,
		final org.drip.analytics.date.JulianDate dtEnd)
	{
<span class="pc bpc" id="L529" title="2 of 4 branches missed.">		if (null == dtStart || null == dtEnd) return null;</span>

<span class="fc" id="L531">		int iEndDate = dtEnd.julian();</span>

<span class="fc" id="L533">		int iStartDate = dtStart.julian();</span>

<span class="pc bpc" id="L535" title="1 of 2 branches missed.">		if (iEndDate &lt;= iStartDate) return null;</span>

<span class="fc" id="L537">		java.util.List&lt;java.lang.Integer&gt; lsOvernightEdgeDate = new java.util.ArrayList&lt;java.lang.Integer&gt;();</span>

<span class="fc" id="L539">		lsOvernightEdgeDate.add (iStartDate);</span>

<span class="fc" id="L541">		lsOvernightEdgeDate.add (iEndDate);</span>

<span class="fc" id="L543">		return lsOvernightEdgeDate;</span>
	}

	/**
	 * Construct a Reference Period using the Start/End Dates, the Floater Label, and the Reference Period
	 *  Arrears Type
	 * 
	 * @param dtStart Start Date
	 * @param dtEnd End Date
	 * @param floaterLabel Floater Label
	 * @param iReferencePeriodArrearsType Reference Period Arrears Type
	 * 
	 * @return The Reference Period
	 */

	public static final org.drip.analytics.cashflow.ReferenceIndexPeriod ReferencePeriod (
		final org.drip.analytics.date.JulianDate dtStart,
		final org.drip.analytics.date.JulianDate dtEnd,
		final org.drip.state.identifier.FloaterLabel floaterLabel,
		final int iReferencePeriodArrearsType)
	{
<span class="pc bpc" id="L564" title="3 of 6 branches missed.">		if (null == dtStart || null == dtEnd || null == floaterLabel) return null;</span>

<span class="fc" id="L566">		java.lang.String strForwardTenor = &quot;&quot;;</span>

<span class="fc bfc" id="L568" title="All 2 branches covered.">		if (floaterLabel instanceof org.drip.state.identifier.ForwardLabel)</span>
<span class="fc" id="L569">			strForwardTenor = floaterLabel.tenor();</span>
<span class="pc bpc" id="L570" title="1 of 2 branches missed.">		else if (floaterLabel instanceof org.drip.state.identifier.OTCFixFloatLabel)</span>
<span class="fc" id="L571">			strForwardTenor = ((org.drip.state.identifier.OTCFixFloatLabel) floaterLabel).fixFloatTenor();</span>

		try {
<span class="fc bfc" id="L574" title="All 2 branches covered.">			return org.drip.analytics.cashflow.ReferenceIndexPeriod.Standard (</span>
				REFERENCE_PERIOD_IN_ARREARS == iReferencePeriodArrearsType ? dtStart.addTenor
<span class="fc bfc" id="L576" title="All 2 branches covered.">					(strForwardTenor).julian() : dtStart.julian(),</span>
				REFERENCE_PERIOD_IN_ARREARS == iReferencePeriodArrearsType ? dtEnd.addTenor
<span class="fc" id="L578">					(strForwardTenor).julian() : dtEnd.julian(),</span>
				floaterLabel
			);
<span class="nc" id="L581">		} catch (java.lang.Exception e) {</span>
<span class="nc" id="L582">			e.printStackTrace();</span>
		}

<span class="nc" id="L585">		return null;</span>
	}

	/**
	 * Generate a list of period edge dates forward from the start.
	 * 
	 * @param iEffective Effective Date
	 * @param iMaturity Maturity Date
	 * @param strTenor Period Tenor
	 * @param dap Inner Date Adjustment Parameters
	 * @param iPSEC Period Set Edge Customizer Setting
	 * 
	 * @return List of Period Edge Dates
	 */

	public static final java.util.List&lt;java.lang.Integer&gt; ForwardEdgeDates (
		final int iEffective,
		final int iMaturity,
		final java.lang.String strTenor,
		final org.drip.analytics.daycount.DateAdjustParams dap,
		final int iPSEC)
	{
<span class="nc" id="L607">		return ForwardEdgeDates (new org.drip.analytics.date.JulianDate (iEffective), new</span>
			org.drip.analytics.date.JulianDate (iMaturity), strTenor, dap, iPSEC);
	}

	/**
	 * Generate a list of period edge dates backward from the end.
	 * 
	 * @param iEffective Effective Date
	 * @param iMaturity Maturity Date
	 * @param strTenor Period Tenor
	 * @param dap Inner Date Adjustment Parameters
	 * @param iPSEC Period Set Edge Customizer Setting
	 * 
	 * @return List of Period Edge Dates
	 */

	public static final java.util.List&lt;java.lang.Integer&gt; BackwardEdgeDates (
		final int iEffective,
		final int iMaturity,
		final java.lang.String strTenor,
		final org.drip.analytics.daycount.DateAdjustParams dap,
		final int iPSEC)
	{
<span class="nc" id="L630">		return BackwardEdgeDates (new org.drip.analytics.date.JulianDate (iEffective), new</span>
			org.drip.analytics.date.JulianDate (iMaturity), strTenor, dap, iPSEC);
	}

	/**
	 * Generate a list of regular period edge dates forward from the start.
	 * 
	 * @param iEffective Effective Date
	 * @param strPeriodTenor Period Tenor
	 * @param strMaturityTenor Period Tenor
	 * @param dap Inner Date Adjustment Parameters
	 * 
	 * @return List of Period Edge Dates
	 */

	public static final java.util.List&lt;java.lang.Integer&gt; RegularEdgeDates (
		final int iEffective,
		final java.lang.String strPeriodTenor,
		final java.lang.String strMaturityTenor,
		final org.drip.analytics.daycount.DateAdjustParams dap)
	{
<span class="fc" id="L651">		return RegularEdgeDates (new org.drip.analytics.date.JulianDate (iEffective), strPeriodTenor,</span>
			strMaturityTenor, dap);
	}

	/**
	 * Generate the List of Overnight Edge Dates between the specified dates, using the specified Calendar
	 * 
	 * @param iStartDate Start Date
	 * @param iEndDate End Date
	 * @param strCalendar Calendar
	 * 
	 * @return List of Overnight Edge Dates
	 */

	public static final java.util.List&lt;java.lang.Integer&gt; OvernightEdgeDates (
		final int iStartDate,
		final int iEndDate,
		final java.lang.String strCalendar)
	{
<span class="fc" id="L670">		return OvernightEdgeDates (new org.drip.analytics.date.JulianDate (iStartDate), new</span>
			org.drip.analytics.date.JulianDate (iEndDate), strCalendar);
	}

	/**
	 * Construct a Reference Index Period using the Start/End Dates, the Floater Label, and the Reference
	 *  Period Arrears Type
	 * 
	 * @param iStartDate Start Date
	 * @param iEndDate End Date
	 * @param floaterLabel Floater Label
	 * @param iReferencePeriodArrearsType Reference Period Arrears Type
	 * 
	 * @return The Reference Period
	 */

	public static final org.drip.analytics.cashflow.ReferenceIndexPeriod ReferencePeriod (
		final int iStartDate,
		final int iEndDate,
		final org.drip.state.identifier.FloaterLabel floaterLabel,
		final int iReferencePeriodArrearsType)
	{
<span class="fc" id="L692">		return ReferencePeriod (</span>
			new org.drip.analytics.date.JulianDate (iStartDate),
			new org.drip.analytics.date.JulianDate (iEndDate),
			floaterLabel,
			iReferencePeriodArrearsType
		);
	}

	/**
	 * Retrieve the List of Edge Dates across all Units
	 * 
	 * @param iUnitPeriodStartDate Unit Period Start Date
	 * @param iUnitPeriodEndDate Unit Period End Date
	 * @param strCalendar Unit Date Generation Calendar
	 * @param cubs Composable Unit Builder Setting
	 * 
	 * @return List of Edge Dates across all Units
	 */

	public static final java.util.List&lt;java.lang.Integer&gt; UnitDateEdges (
		final int iUnitPeriodStartDate,
		final int iUnitPeriodEndDate,
		final java.lang.String strCalendar,
		final org.drip.param.period.ComposableUnitBuilderSetting cubs)
	{
<span class="pc bpc" id="L717" title="1 of 2 branches missed.">		if (null == cubs) return null;</span>

<span class="fc" id="L719">		int iEdgeDateSequenceScheme = cubs.edgeDateSequenceScheme();</span>

<span class="fc bfc" id="L721" title="All 2 branches covered.">		if (EDGE_DATE_SEQUENCE_SINGLE == iEdgeDateSequenceScheme) {</span>
<span class="pc bpc" id="L722" title="1 of 2 branches missed.">			if (iUnitPeriodStartDate &gt;= iUnitPeriodEndDate) return null;</span>

<span class="fc" id="L724">			java.util.List&lt;java.lang.Integer&gt; lsEdgeDates = new java.util.ArrayList&lt;java.lang.Integer&gt;();</span>

<span class="fc" id="L726">			lsEdgeDates.add (iUnitPeriodStartDate);</span>

<span class="fc" id="L728">			lsEdgeDates.add (iUnitPeriodEndDate);</span>

<span class="fc" id="L730">			return lsEdgeDates;</span>
		}

<span class="fc bfc" id="L733" title="All 2 branches covered.">		if (EDGE_DATE_SEQUENCE_REGULAR == iEdgeDateSequenceScheme)</span>
<span class="fc" id="L734">			return RegularEdgeDates (iUnitPeriodStartDate, iUnitPeriodEndDate, cubs.tenor(), cubs.dapEdge());</span>

<span class="pc bpc" id="L736" title="1 of 2 branches missed.">		if (EDGE_DATE_SEQUENCE_OVERNIGHT == iEdgeDateSequenceScheme)</span>
<span class="fc" id="L737">			return OvernightEdgeDates (iUnitPeriodStartDate, iUnitPeriodEndDate, strCalendar);</span>

<span class="nc" id="L739">		return null;</span>
	}

	/**
	 * Construct the List of Composable Fixed Units from the inputs
	 * 
	 * @param iUnitPeriodStartDate Unit Period Start Date
	 * @param iUnitPeriodEndDate Unit Period End Date
	 * @param ucas Unit Coupon/Accrual Setting
	 * @param cfus Composable Fixed Unit Setting
	 * 
	 * @return The List of Composable Floating Units
	 */

	public static final java.util.List&lt;org.drip.analytics.cashflow.ComposableUnitPeriod&gt; FixedUnits (
		final int iUnitPeriodStartDate,
		final int iUnitPeriodEndDate,
		final org.drip.param.period.UnitCouponAccrualSetting ucas,
		final org.drip.param.period.ComposableFixedUnitSetting cfus)
	{
<span class="pc bpc" id="L759" title="1 of 2 branches missed.">		if (null == cfus) return null;</span>

<span class="fc" id="L761">		java.util.List&lt;java.lang.Integer&gt; lsUnitEdgeDate = UnitDateEdges (iUnitPeriodStartDate,</span>
<span class="fc" id="L762">			iUnitPeriodEndDate, ucas.calendar(), cfus);</span>

<span class="pc bpc" id="L764" title="1 of 2 branches missed.">		if (null == lsUnitEdgeDate) return null;</span>

<span class="fc" id="L766">		int iNumDate = lsUnitEdgeDate.size();</span>

<span class="pc bpc" id="L768" title="1 of 2 branches missed.">		if (2 &gt; iNumDate) return null;</span>

<span class="fc" id="L770">		java.util.List&lt;org.drip.analytics.cashflow.ComposableUnitPeriod&gt; lsCUP = new</span>
			java.util.ArrayList&lt;org.drip.analytics.cashflow.ComposableUnitPeriod&gt;();

<span class="fc bfc" id="L773" title="All 2 branches covered.">		for (int i = 1; i &lt; iNumDate; ++i) {</span>
			try {
<span class="fc" id="L775">				lsCUP.add (new org.drip.analytics.cashflow.ComposableUnitFixedPeriod (lsUnitEdgeDate.get</span>
<span class="fc" id="L776">					(i - 1), lsUnitEdgeDate.get (i), ucas, cfus));</span>
<span class="nc" id="L777">			} catch (java.lang.Exception e) {</span>
<span class="nc" id="L778">				e.printStackTrace();</span>

<span class="nc" id="L780">				return null;</span>
<span class="fc" id="L781">			}</span>
		}

<span class="fc" id="L784">		return lsCUP;</span>
	}

	/**
	 * Construct the List of Composable Floating Units from the inputs
	 * 
	 * @param iUnitPeriodStartDate Unit Period Start Date
	 * @param iUnitPeriodEndDate Unit Period End Date
	 * @param cfus Composable Floating Unit Setting
	 * 
	 * @return The List of Composable Floating Units
	 */

	public static final java.util.List&lt;org.drip.analytics.cashflow.ComposableUnitPeriod&gt; FloatingUnits (
		final int iUnitPeriodStartDate,
		final int iUnitPeriodEndDate,
		final org.drip.param.period.ComposableFloatingUnitSetting cfus)
	{
<span class="pc bpc" id="L802" title="1 of 2 branches missed.">		if (null == cfus) return null;</span>

<span class="fc" id="L804">		org.drip.state.identifier.FloaterLabel floaterLabel = cfus.floaterLabel();</span>

<span class="fc" id="L806">		java.lang.String strCalendar = floaterLabel.floaterIndex().calendar();</span>

<span class="fc" id="L808">		java.util.List&lt;java.lang.Integer&gt; lsUnitEdgeDate = UnitDateEdges (iUnitPeriodStartDate,</span>
			iUnitPeriodEndDate, strCalendar, cfus);

<span class="pc bpc" id="L811" title="1 of 2 branches missed.">		if (null == lsUnitEdgeDate) return null;</span>

<span class="fc" id="L813">		int iNumDate = lsUnitEdgeDate.size();</span>

<span class="pc bpc" id="L815" title="1 of 2 branches missed.">		if (2 &gt; iNumDate) return null;</span>

<span class="fc" id="L817">		java.util.List&lt;org.drip.analytics.cashflow.ComposableUnitPeriod&gt; lsCUP = new</span>
			java.util.ArrayList&lt;org.drip.analytics.cashflow.ComposableUnitPeriod&gt;();

<span class="fc" id="L820">		double dblSpread = cfus.spread();</span>

<span class="fc" id="L822">		java.lang.String strUnitTenor = cfus.tenor();</span>

<span class="fc" id="L824">		java.lang.String strForwardTenor = floaterLabel.tenor();</span>

<span class="fc" id="L826">		int iReferencePeriodArrearsType = cfus.referencePeriodArrearsType();</span>

<span class="fc" id="L828">		boolean bComposableForwardPeriodsMatch = cfus.tenor().equalsIgnoreCase (strForwardTenor);</span>

<span class="fc bfc" id="L830" title="All 2 branches covered.">		for (int i = 1; i &lt; iNumDate; ++i) {</span>
<span class="fc" id="L831">			int iUnitStartDate = lsUnitEdgeDate.get (i - 1);</span>

<span class="fc" id="L833">			int iUnitEndDate = lsUnitEdgeDate.get (i);</span>

<span class="fc" id="L835">			int iReferencePeriodEndDate = iUnitEndDate;</span>

<span class="fc bfc" id="L837" title="All 2 branches covered.">			int iReferencePeriodStartDate = bComposableForwardPeriodsMatch ? iUnitStartDate : new</span>
<span class="fc" id="L838">				org.drip.analytics.date.JulianDate (iUnitEndDate).subtractTenorAndAdjust (strForwardTenor,</span>
<span class="fc" id="L839">					strCalendar).julian();</span>

			try {
<span class="fc" id="L842">				lsCUP.add (</span>
					new org.drip.analytics.cashflow.ComposableUnitFloatingPeriod (
						iUnitStartDate,
						iUnitEndDate,
						strUnitTenor,
<span class="fc" id="L847">						ReferencePeriod (</span>
							iReferencePeriodStartDate,
							iReferencePeriodEndDate,
							floaterLabel,
							iReferencePeriodArrearsType
						),
						dblSpread
					)
				);
<span class="nc" id="L856">			} catch (java.lang.Exception e) {</span>
<span class="nc" id="L857">				e.printStackTrace();</span>

<span class="nc" id="L859">				return null;</span>
<span class="fc" id="L860">			}</span>
		}

<span class="fc" id="L863">		return lsCUP;</span>
	}

	/**
	 * Construct the List of Composite Fixed Periods from the corresponding Composable Fixed Period Units
	 * 
	 * @param lsCompositeEdgeDate The Composite Period Edge Dates
	 * @param cps Composite Period Setting Instance
	 * @param ucas Unit Coupon/Accrual Setting
	 * @param cfus Composable Fixed Unit Setting
	 * 
	 * @return List of Composite Fixed Periods
	 */

	public static final java.util.List&lt;org.drip.analytics.cashflow.CompositePeriod&gt; FixedCompositeUnit (
		final java.util.List&lt;java.lang.Integer&gt; lsCompositeEdgeDate,
		final org.drip.param.period.CompositePeriodSetting cps,
		final org.drip.param.period.UnitCouponAccrualSetting ucas,
		final org.drip.param.period.ComposableFixedUnitSetting cfus)
	{
<span class="pc bpc" id="L883" title="1 of 2 branches missed.">		if (null == lsCompositeEdgeDate) return null;</span>

<span class="fc" id="L885">		int iNumEdge = lsCompositeEdgeDate.size();</span>

<span class="pc bpc" id="L887" title="1 of 2 branches missed.">		if (2 &gt; iNumEdge) return null;</span>

<span class="fc" id="L889">		java.util.List&lt;org.drip.analytics.cashflow.CompositePeriod&gt; lsCFP = new</span>
			java.util.ArrayList&lt;org.drip.analytics.cashflow.CompositePeriod&gt;();

<span class="fc bfc" id="L892" title="All 2 branches covered.">		for (int i = 1; i &lt; iNumEdge; ++i) {</span>
			try {
<span class="fc" id="L894">				lsCFP.add (new org.drip.analytics.cashflow.CompositeFixedPeriod (cps, FixedUnits</span>
<span class="fc" id="L895">					(lsCompositeEdgeDate.get (i - 1), lsCompositeEdgeDate.get (i), ucas, cfus)));</span>
<span class="nc" id="L896">			} catch (java.lang.Exception e) {</span>
<span class="nc" id="L897">				e.printStackTrace();</span>

<span class="nc" id="L899">				return null;</span>
<span class="fc" id="L900">			}</span>
		}

<span class="fc" id="L903">		return lsCFP;</span>
	}

	/**
	 * Construct the List of Composite Floating Period from the corresponding Composable Floating Period
	 *  Units
	 * 
	 * @param lsCompositeEdgeDate The Composite Period Edge Dates
	 * @param cps Composite Period Setting Instance
	 * @param cfus Composable Floating Unit Setting
	 * 
	 * @return List of Composite Floating Periods
	 */

	public static final java.util.List&lt;org.drip.analytics.cashflow.CompositePeriod&gt; FloatingCompositeUnit (
		final java.util.List&lt;java.lang.Integer&gt; lsCompositeEdgeDate,
		final org.drip.param.period.CompositePeriodSetting cps,
		final org.drip.param.period.ComposableFloatingUnitSetting cfus)
	{
<span class="pc bpc" id="L922" title="1 of 2 branches missed.">		if (null == lsCompositeEdgeDate) return null;</span>

<span class="fc" id="L924">		int iNumEdge = lsCompositeEdgeDate.size();</span>

<span class="pc bpc" id="L926" title="1 of 2 branches missed.">		if (2 &gt; iNumEdge) return null;</span>

<span class="fc" id="L928">		java.util.List&lt;org.drip.analytics.cashflow.CompositePeriod&gt; lsCFP = new</span>
			java.util.ArrayList&lt;org.drip.analytics.cashflow.CompositePeriod&gt;();

<span class="fc bfc" id="L931" title="All 2 branches covered.">		for (int i = 1; i &lt; iNumEdge; ++i) {</span>
			try {
<span class="fc" id="L933">				lsCFP.add (new org.drip.analytics.cashflow.CompositeFloatingPeriod (cps, FloatingUnits</span>
<span class="fc" id="L934">					(lsCompositeEdgeDate.get (i - 1), lsCompositeEdgeDate.get (i), cfus)));</span>
<span class="nc" id="L935">			} catch (java.lang.Exception e) {</span>
<span class="nc" id="L936">				e.printStackTrace();</span>

<span class="nc" id="L938">				return null;</span>
<span class="fc" id="L939">			}</span>
		}

<span class="fc" id="L942">		return lsCFP;</span>
	}
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.7.9.201702052155</span></div></body></html>