<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>CompositePeriodBuilder.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">DROP</a> &gt; <a href="index.source.html" class="el_package">org.drip.analytics.support</a> &gt; <span class="el_source">CompositePeriodBuilder.java</span></div><h1>CompositePeriodBuilder.java</h1><pre class="source lang-java linenums">
package org.drip.analytics.support;

/*
 * -*- mode: java; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*-
 */

/*!
 * Copyright (C) 2019 Lakshmi Krishnamurthy
 * Copyright (C) 2018 Lakshmi Krishnamurthy
 * Copyright (C) 2017 Lakshmi Krishnamurthy
 * Copyright (C) 2016 Lakshmi Krishnamurthy
 * Copyright (C) 2015 Lakshmi Krishnamurthy
 * Copyright (C) 2014 Lakshmi Krishnamurthy
 * 
 *  This file is part of DROP, an open-source library targeting risk, transaction costs, exposure, margin
 *  	calculations, and portfolio construction within and across fixed income, credit, commodity, equity,
 *  	FX, and structured products.
 *  
 *  	https://lakshmidrip.github.io/DROP/
 *  
 *  DROP is composed of three main modules:
 *  
 *  - DROP Analytics Core - https://lakshmidrip.github.io/DROP-Analytics-Core/
 *  - DROP Portfolio Core - https://lakshmidrip.github.io/DROP-Portfolio-Core/
 *  - DROP Numerical Core - https://lakshmidrip.github.io/DROP-Numerical-Core/
 * 
 * 	DROP Analytics Core implements libraries for the following:
 * 	- Fixed Income Analytics
 * 	- Asset Backed Analytics
 * 	- XVA Analytics
 * 	- Exposure and Margin Analytics
 * 
 * 	DROP Portfolio Core implements libraries for the following:
 * 	- Asset Allocation Analytics
 * 	- Transaction Cost Analytics
 * 
 * 	DROP Numerical Core implements libraries for the following:
 * 	- Statistical Learning Library
 * 	- Numerical Optimizer Library
 * 	- Machine Learning Library
 * 	- Spline Builder Library
 * 
 * 	Documentation for DROP is Spread Over:
 * 
 * 	- Main                     =&gt; https://lakshmidrip.github.io/DROP/
 * 	- Wiki                     =&gt; https://github.com/lakshmiDRIP/DROP/wiki
 * 	- GitHub                   =&gt; https://github.com/lakshmiDRIP/DROP
 * 	- Javadoc                  =&gt; https://lakshmidrip.github.io/DROP/Javadoc/index.html
 * 	- Technical Specifications =&gt; https://github.com/lakshmiDRIP/DROP/tree/master/Docs/Internal
 * 	- Release Versions         =&gt; https://lakshmidrip.github.io/DROP/version.html
 * 	- Community Credits        =&gt; https://lakshmidrip.github.io/DROP/credits.html
 * 	- Issues Catalog           =&gt; https://github.com/lakshmiDRIP/DROP/issues
 * 	- JUnit                    =&gt; https://lakshmidrip.github.io/DROP/junit/index.html
 * 	- Jacoco                   =&gt; https://lakshmidrip.github.io/DROP/jacoco/index.html
 * 
 *  Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 *   	you may not use this file except in compliance with the License.
 *   
 *  You may obtain a copy of the License at
 *  	http://www.apache.org/licenses/LICENSE-2.0
 *  
 *  Unless required by applicable law or agreed to in writing, software
 *  	distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 *  	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  
 *  See the License for the specific language governing permissions and
 *  	limitations under the License.
 */

/**
 * &lt;i&gt;CompositePeriodBuilder&lt;/i&gt; exposes the composite period construction functionality.
 *  &lt;br&gt;
 *  &lt;ul&gt;
 *		&lt;li&gt;&lt;b&gt;Module&lt;/b&gt;        = &lt;a href = &quot;https://github.com/lakshmiDRIP/DROP/tree/master/src/main/java/org/drip/analytics&quot;&gt;Analytics&lt;/a&gt;&lt;/li&gt;
 *		&lt;li&gt;&lt;b&gt;Package&lt;/b&gt;       = &lt;a href = &quot;https://github.com/lakshmiDRIP/DROP/tree/master/src/main/java/org/drip/analytics/support&quot;&gt;Support&lt;/a&gt;&lt;/li&gt;
 *		&lt;li&gt;&lt;b&gt;Specification&lt;/b&gt; = &lt;a href = &quot;https://github.com/lakshmiDRIP/DROP/tree/master/Docs/Internal/FixedIncome&quot;&gt;Fixed Income&lt;/a&gt;&lt;/li&gt;
 *  &lt;/ul&gt;
 * 
 * @author Lakshmi Krishnamurthy
 */

<span class="nc" id="L83">public class CompositePeriodBuilder {</span>

	/**
	 * Edge Date Generation Sequence - Forward
	 */

	public static final int EDGE_DATE_SEQUENCE_FORWARD = 0;

	/**
	 * Edge Date Generation Sequence - Reverse
	 */

	public static final int EDGE_DATE_SEQUENCE_REVERSE = 1;

	/**
	 * Edge Date Generation Sequence - Regular
	 */

	public static final int EDGE_DATE_SEQUENCE_REGULAR = 2;

	/**
	 * Edge Date Generation Sequence - Overnight
	 */

	public static final int EDGE_DATE_SEQUENCE_OVERNIGHT = 4;

	/**
	 * Edge Date Generation Sequence - Single Edge Date Pair Between Dates
	 */

	public static final int EDGE_DATE_SEQUENCE_SINGLE = 8;

	/**
	 * Period Set Generation Customization - Short Stub (i.e., No adjustment on either end)
	 */

	public static final int SHORT_STUB = 0;

	/**
	 * Period Set Generation Customization - Merge the front periods to produce a long front
	 */

	public static final int FULL_FRONT_PERIOD = 1;

	/**
	 * Period Set Generation Customization - Long Stub (if present) belongs to the front/back end depending
	 * 	upon backwards/forwards generation scheme
	 */

	public static final int LONG_STUB = 2;

	/**
	 * Reference Period Fixing is IN-ARREARS (i.e., displaced one period to the right) of the Coupon Period
	 */

	public static final int REFERENCE_PERIOD_IN_ARREARS = 0;

	/**
	 * Reference Period Fixing is IN-ADVANCE (i.e., the same as that) of the Coupon Period
	 */

	public static final int REFERENCE_PERIOD_IN_ADVANCE = 1;

	/**
	 * Accrual Compounding Rule - Arithmetic
	 */

	public static final int ACCRUAL_COMPOUNDING_RULE_ARITHMETIC = 1;

	/**
	 * Accrual Compounding Rule - Geometric
	 */

	public static final int ACCRUAL_COMPOUNDING_RULE_GEOMETRIC = 2;

	private static final int DAPAdjust (
		final int iDate,
		final org.drip.analytics.daycount.DateAdjustParams dap)
	{
<span class="fc bfc" id="L162" title="All 2 branches covered.">		if (null == dap) return iDate;</span>

		try {
<span class="fc" id="L165">			return dap.roll (iDate);</span>
<span class="nc" id="L166">		} catch (java.lang.Exception e) {</span>
<span class="nc" id="L167">			e.printStackTrace();</span>
		}

<span class="nc" id="L170">		return iDate;</span>
	}

	/**
	 * Verify if the Specified Accrual Compounding Rule is a Valid One
	 * 
	 * @param iAccrualCompoundingRule The Accrual Compounding Rule
	 * 
	 * @return TRUE - The Accrual Compounding Rule is valid
	 */

	public static final boolean ValidateCompoundingRule (
		final int iAccrualCompoundingRule)
	{
<span class="pc bpc" id="L184" title="1 of 4 branches missed.">		return ACCRUAL_COMPOUNDING_RULE_ARITHMETIC == iAccrualCompoundingRule ||</span>
			ACCRUAL_COMPOUNDING_RULE_GEOMETRIC == iAccrualCompoundingRule;
	}

	/**
	 * Generate a list of period edge dates forward from the start.
	 * 
	 * @param dtEffective Effective date
	 * @param dtMaturity Maturity date
	 * @param strTenor Period Tenor
	 * @param dap Inner Date Adjustment Parameters
	 * @param iPSEC Period Set Edge Customizer Setting
	 * 
	 * @return List of Period Edge Dates
	 */

	public static final java.util.List&lt;java.lang.Integer&gt; ForwardEdgeDates (
		final org.drip.analytics.date.JulianDate dtEffective,
		final org.drip.analytics.date.JulianDate dtMaturity,
		final java.lang.String strTenor,
		final org.drip.analytics.daycount.DateAdjustParams dap,
		final int iPSEC)
	{
<span class="nc bnc" id="L207" title="All 8 branches missed.">		if (null == dtEffective || null == dtMaturity || null == strTenor || strTenor.isEmpty()) return null;</span>

<span class="nc" id="L209">		java.lang.String strPeriodRollTenor = &quot;&quot;;</span>
<span class="nc" id="L210">		org.drip.analytics.date.JulianDate dtEdge = dtEffective;</span>

<span class="nc" id="L212">		int iMaturityDate = dtMaturity.julian();</span>

<span class="nc" id="L214">		int iEdgeDate = dtEdge.julian();</span>

<span class="nc bnc" id="L216" title="All 2 branches missed.">		if (iEdgeDate &gt;= iMaturityDate) return null;</span>

<span class="nc" id="L218">		java.util.List&lt;java.lang.Integer&gt; lsEdgeDate = new java.util.ArrayList&lt;java.lang.Integer&gt;();</span>

<span class="nc bnc" id="L220" title="All 2 branches missed.">		while (iEdgeDate &lt; iMaturityDate) {</span>
<span class="nc" id="L221">			lsEdgeDate.add (iEdgeDate);</span>

<span class="nc" id="L223">			strPeriodRollTenor = org.drip.analytics.support.Helper.AggregateTenor</span>
<span class="nc" id="L224">				(strPeriodRollTenor, strTenor);</span>

<span class="nc bnc" id="L226" title="All 2 branches missed.">			if (null == (dtEdge = dtMaturity.addTenor (strPeriodRollTenor))) return null;</span>

<span class="nc" id="L228">			iEdgeDate = dtEdge.julian();</span>
		}

<span class="nc bnc" id="L231" title="All 2 branches missed.">		if (iEdgeDate &gt; iMaturityDate) {</span>
<span class="nc bnc" id="L232" title="All 2 branches missed.">			if (SHORT_STUB == iPSEC)</span>
<span class="nc" id="L233">				lsEdgeDate.add (iMaturityDate);</span>
<span class="nc bnc" id="L234" title="All 2 branches missed.">			else if (LONG_STUB == iPSEC) {</span>
<span class="nc bnc" id="L235" title="All 2 branches missed.">				if (1 != lsEdgeDate.size()) lsEdgeDate.remove (lsEdgeDate.size() - 1);</span>

<span class="nc" id="L237">				lsEdgeDate.add (iMaturityDate);</span>
			}
<span class="nc bnc" id="L239" title="All 2 branches missed.">		} else if (iEdgeDate == iMaturityDate)</span>
<span class="nc" id="L240">			lsEdgeDate.add (iMaturityDate);</span>

<span class="nc" id="L242">		java.util.List&lt;java.lang.Integer&gt; lsAdjustedEdgeDate = new java.util.ArrayList&lt;java.lang.Integer&gt;();</span>

<span class="nc" id="L244">		lsAdjustedEdgeDate.add (lsEdgeDate.get (0));</span>

<span class="nc" id="L246">		int iNumDate = lsEdgeDate.size();</span>

<span class="nc bnc" id="L248" title="All 2 branches missed.">		for (int i = 1; i &lt; iNumDate - 1; ++i)</span>
<span class="nc" id="L249">			lsAdjustedEdgeDate.add (DAPAdjust (lsEdgeDate.get (i), dap));</span>

<span class="nc" id="L251">		lsAdjustedEdgeDate.add (lsEdgeDate.get (iNumDate - 1));</span>

<span class="nc bnc" id="L253" title="All 2 branches missed.">		if (1 == lsAdjustedEdgeDate.size()) lsAdjustedEdgeDate.add (1, iMaturityDate);</span>

<span class="nc" id="L255">		return lsAdjustedEdgeDate;</span>
	}

	/**
	 * Generate a list of period edge dates backward from the end.
	 * 
	 * @param dtEffective Effective date
	 * @param dtMaturity Maturity date
	 * @param strTenor Period Tenor
	 * @param dap Inner Date Adjustment Parameters
	 * @param iPSEC Period Set Edge Customizer Setting
	 * 
	 * @return List of Period Edge Dates
	 */

	public static final java.util.List&lt;java.lang.Integer&gt; BackwardEdgeDates (
		final org.drip.analytics.date.JulianDate dtEffective,
		final org.drip.analytics.date.JulianDate dtMaturity,
		final java.lang.String strTenor,
		final org.drip.analytics.daycount.DateAdjustParams dap,
		final int iPSEC)
	{
<span class="pc bpc" id="L277" title="4 of 8 branches missed.">		if (null == dtEffective || null == dtMaturity || null == strTenor || strTenor.isEmpty()) return null;</span>

<span class="fc" id="L279">		int iEffectiveDate = dtEffective.julian();</span>

<span class="fc" id="L281">		java.lang.String strPeriodRollTenor = &quot;&quot;;</span>
<span class="fc" id="L282">		org.drip.analytics.date.JulianDate dtEdge = dtMaturity;</span>

<span class="fc" id="L284">		int iEdgeDate = dtEdge.julian();</span>

<span class="pc bpc" id="L286" title="1 of 2 branches missed.">		if (iEffectiveDate &gt;= iEdgeDate) return null;</span>

<span class="fc" id="L288">		java.util.List&lt;java.lang.Integer&gt; lsEdgeDate = new java.util.ArrayList&lt;java.lang.Integer&gt;();</span>

<span class="fc bfc" id="L290" title="All 2 branches covered.">		while (iEdgeDate &gt; iEffectiveDate) {</span>
<span class="fc" id="L291">			lsEdgeDate.add (0, iEdgeDate);</span>

<span class="fc" id="L293">			strPeriodRollTenor = org.drip.analytics.support.Helper.AggregateTenor (strPeriodRollTenor,</span>
				strTenor);

<span class="pc bpc" id="L296" title="1 of 2 branches missed.">			if (null == (dtEdge = dtMaturity.subtractTenor (strPeriodRollTenor))) return null;</span>

<span class="fc" id="L298">			iEdgeDate = dtEdge.julian();</span>
		}

<span class="fc bfc" id="L301" title="All 2 branches covered.">		if (iEdgeDate &lt; iEffectiveDate) {</span>
<span class="fc bfc" id="L302" title="All 2 branches covered.">			if (SHORT_STUB == iPSEC)</span>
<span class="fc" id="L303">				lsEdgeDate.add (0, iEffectiveDate);</span>
<span class="pc bpc" id="L304" title="1 of 2 branches missed.">			else if (FULL_FRONT_PERIOD == iPSEC)</span>
<span class="nc" id="L305">				lsEdgeDate.add (0, iEdgeDate);</span>
<span class="pc bpc" id="L306" title="1 of 2 branches missed.">			else if (LONG_STUB == iPSEC) {</span>
<span class="fc bfc" id="L307" title="All 2 branches covered.">				if (1 != lsEdgeDate.size()) lsEdgeDate.remove (0);</span>

<span class="fc" id="L309">				lsEdgeDate.add (0, iEffectiveDate);</span>
			}
<span class="pc bpc" id="L311" title="1 of 2 branches missed.">		} else if (dtEdge.julian() == iEffectiveDate)</span>
<span class="fc" id="L312">			lsEdgeDate.add (0, iEffectiveDate);</span>

<span class="fc" id="L314">		java.util.List&lt;java.lang.Integer&gt; lsAdjustedEdgeDate = new java.util.ArrayList&lt;java.lang.Integer&gt;();</span>

<span class="fc" id="L316">		lsAdjustedEdgeDate.add (lsEdgeDate.get (0));</span>

<span class="fc" id="L318">		int iNumDate = lsEdgeDate.size();</span>

<span class="fc bfc" id="L320" title="All 2 branches covered.">		for (int i = 1; i &lt; iNumDate - 1; ++i)</span>
<span class="fc" id="L321">			lsAdjustedEdgeDate.add (DAPAdjust (lsEdgeDate.get (i), dap));</span>

<span class="fc" id="L323">		lsAdjustedEdgeDate.add (lsEdgeDate.get (iNumDate - 1));</span>

<span class="fc" id="L325">		return lsAdjustedEdgeDate;</span>
	}

	/**
	 * Generate a list of regular period edge dates forward from the start.
	 * 
	 * @param dtEffective Effective date
	 * @param strPeriodTenor Period Tenor
	 * @param strMaturityTenor Period Tenor
	 * @param dap Inner Date Adjustment Parameters
	 * 
	 * @return List of Period Edge Dates
	 */

	public static final java.util.List&lt;java.lang.Integer&gt; RegularEdgeDates (
		final org.drip.analytics.date.JulianDate dtEffective,
		final java.lang.String strPeriodTenor,
		final java.lang.String strMaturityTenor,
		final org.drip.analytics.daycount.DateAdjustParams dap)
	{
<span class="pc bpc" id="L345" title="4 of 8 branches missed.">		if (null == dtEffective || null == strPeriodTenor || strPeriodTenor.isEmpty() || null ==</span>
<span class="pc bpc" id="L346" title="1 of 2 branches missed.">			strMaturityTenor || strMaturityTenor.isEmpty())</span>
<span class="nc" id="L347">			return null;</span>

<span class="fc" id="L349">		int iPeriodTenorMonth = -1;</span>
<span class="fc" id="L350">		int iMaturityTenorMonth = -1;</span>
<span class="fc" id="L351">		int iPeriodMaturityTenorComparison = -1;</span>

<span class="fc" id="L353">		int iMaturityDate = dtEffective.addTenor (strMaturityTenor).julian();</span>

<span class="fc" id="L355">		java.util.List&lt;java.lang.Integer&gt; lsEdgeDate = new java.util.ArrayList&lt;java.lang.Integer&gt;();</span>

		try {
<span class="fc" id="L358">			iPeriodMaturityTenorComparison = org.drip.analytics.support.Helper.TenorCompare (strPeriodTenor,</span>
				strMaturityTenor);
<span class="nc" id="L360">		} catch (java.lang.Exception e) {</span>
<span class="nc" id="L361">			e.printStackTrace();</span>

<span class="nc" id="L363">			return null;</span>
<span class="fc" id="L364">		}</span>

<span class="fc bfc" id="L366" title="All 4 branches covered.">		if (org.drip.analytics.support.Helper.LEFT_TENOR_EQUALS == iPeriodMaturityTenorComparison ||</span>
			org.drip.analytics.support.Helper.LEFT_TENOR_GREATER == iPeriodMaturityTenorComparison) {
<span class="fc" id="L368">			lsEdgeDate.add (dtEffective.julian());</span>

<span class="fc" id="L370">			lsEdgeDate.add (iMaturityDate);</span>

<span class="fc" id="L372">			return lsEdgeDate;</span>
		}

		try {
<span class="fc" id="L376">			iPeriodTenorMonth = org.drip.analytics.support.Helper.TenorToMonths (strPeriodTenor);</span>

<span class="fc" id="L378">			iMaturityTenorMonth = org.drip.analytics.support.Helper.TenorToMonths (strMaturityTenor);</span>
<span class="nc" id="L379">		} catch (java.lang.Exception e) {</span>
<span class="nc" id="L380">			e.printStackTrace();</span>

<span class="nc" id="L382">			return null;</span>
<span class="fc" id="L383">		}</span>

<span class="fc" id="L385">		org.drip.analytics.date.JulianDate dtEdge = dtEffective;</span>
<span class="fc" id="L386">		int iNumPeriod = iMaturityTenorMonth / iPeriodTenorMonth;</span>

<span class="fc" id="L388">		lsEdgeDate.add (dtEdge.julian());</span>

<span class="fc bfc" id="L390" title="All 2 branches covered.">		for (int i = 0; i &lt; iNumPeriod; ++i) {</span>
<span class="fc" id="L391">			dtEdge = dtEdge.addTenor (strPeriodTenor);</span>

<span class="fc" id="L393">			int iEdgeDate = dtEdge.julian();</span>

<span class="fc bfc" id="L395" title="All 2 branches covered.">			if (iEdgeDate &lt; iMaturityDate) lsEdgeDate.add (DAPAdjust (iEdgeDate, dap));</span>
		}

<span class="fc" id="L398">		lsEdgeDate.add (iMaturityDate);</span>

<span class="fc" id="L400">		return lsEdgeDate;</span>
	}

	/**
	 * Generate a list of regular period edge dates forward from the start.
	 * 
	 * @param iStartDate Start Date
	 * @param iEndDate End Date
	 * @param strPeriodTenor Period Tenor
	 * @param dap Inner Date Adjustment Parameters
	 * 
	 * @return List of Period Edge Dates
	 */

	public static final java.util.List&lt;java.lang.Integer&gt; RegularEdgeDates (
		final int iStartDate,
		final int iEndDate,
		final java.lang.String strPeriodTenor,
		final org.drip.analytics.daycount.DateAdjustParams dap)
	{
<span class="pc bpc" id="L420" title="3 of 6 branches missed.">		if (iStartDate &gt;= iEndDate || null == strPeriodTenor || strPeriodTenor.isEmpty()) return null;</span>

<span class="fc" id="L422">		java.util.List&lt;java.lang.Integer&gt; lsEdgeDate = new java.util.ArrayList&lt;java.lang.Integer&gt;();</span>

<span class="fc" id="L424">		int iEdgeDate = iStartDate;</span>

<span class="fc" id="L426">		org.drip.analytics.date.JulianDate dtEdge = new org.drip.analytics.date.JulianDate (iStartDate);</span>

<span class="fc bfc" id="L428" title="All 2 branches covered.">		while (iEdgeDate &lt; iEndDate) {</span>
<span class="fc" id="L429">			int iAdjustedEdgeDate = DAPAdjust (iEdgeDate, dap);</span>

<span class="pc bpc" id="L431" title="1 of 2 branches missed.">			if (!lsEdgeDate.contains (iAdjustedEdgeDate)) lsEdgeDate.add (iAdjustedEdgeDate);</span>

<span class="pc bpc" id="L433" title="1 of 2 branches missed.">			if (null == (dtEdge = dtEdge.addTenor (strPeriodTenor))) return null;</span>

<span class="fc" id="L435">			iEdgeDate = dtEdge.julian();</span>
<span class="fc" id="L436">		}</span>

<span class="fc bfc" id="L438" title="All 2 branches covered.">		if (!lsEdgeDate.contains (iEndDate)) lsEdgeDate.add (iEndDate);</span>

<span class="fc" id="L440">		return lsEdgeDate;</span>
	}

	/**
	 * Generate a list of the IMM period edge dates forward from the spot date.
	 * 
	 * @param dtSpot Spot Date
	 * @param iRollMonths Number of Months to Roll to the Next IMM Date
	 * @param strPeriodTenor Period Tenor
	 * @param strMaturityTenor Period Tenor
	 * @param dap Inner Date Adjustment Parameters
	 * 
	 * @return List of IMM Period Edge Dates
	 */

	public static final java.util.List&lt;java.lang.Integer&gt; IMMEdgeDates (
		final org.drip.analytics.date.JulianDate dtSpot,
		final int iRollMonths,
		final java.lang.String strPeriodTenor,
		final java.lang.String strMaturityTenor,
		final org.drip.analytics.daycount.DateAdjustParams dap)
	{
<span class="pc bpc" id="L462" title="1 of 2 branches missed.">		if (null == dtSpot) return null;</span>

		try {
<span class="fc" id="L465">			return RegularEdgeDates (dtSpot.nextRatesFuturesIMM (iRollMonths), strPeriodTenor,</span>
				strMaturityTenor, dap);
<span class="nc" id="L467">		} catch (java.lang.Exception e) {</span>
<span class="nc" id="L468">			e.printStackTrace();</span>
		}

<span class="nc" id="L471">		return null;</span>
	}

	/**
	 * Generate the List of Overnight Edge Dates between the specified dates, using the specified Calendar
	 * 
	 * @param dtStart Start Date
	 * @param dtEnd End Date
	 * @param strCalendar Calendar
	 * 
	 * @return List of Overnight Edge Dates
	 */

	public static final java.util.List&lt;java.lang.Integer&gt; OvernightEdgeDates (
		final org.drip.analytics.date.JulianDate dtStart,
		final org.drip.analytics.date.JulianDate dtEnd,
		final java.lang.String strCalendar)
	{
<span class="pc bpc" id="L489" title="2 of 4 branches missed.">		if (null == dtStart || null == dtEnd) return null;</span>

<span class="fc" id="L491">		org.drip.analytics.date.JulianDate dtEdge = dtStart;</span>

<span class="fc" id="L493">		int iEndDate = dtEnd.julian();</span>

<span class="fc" id="L495">		int iEdgeDate = dtEdge.julian();</span>

<span class="pc bpc" id="L497" title="1 of 2 branches missed.">		if (iEndDate &lt;= iEdgeDate) return null;</span>

<span class="fc" id="L499">		java.util.List&lt;java.lang.Integer&gt; lsOvernightEdgeDate = new java.util.ArrayList&lt;java.lang.Integer&gt;();</span>

<span class="fc bfc" id="L501" title="All 2 branches covered.">		while (iEdgeDate &lt; iEndDate) {</span>
<span class="fc" id="L502">			lsOvernightEdgeDate.add (iEdgeDate);</span>

<span class="pc bpc" id="L504" title="1 of 2 branches missed.">			if (null == (dtEdge = dtEdge.addBusDays (1, strCalendar))) return null;</span>

<span class="fc" id="L506">			iEdgeDate = dtEdge.julian();</span>
		}

<span class="fc" id="L509">		lsOvernightEdgeDate.add (iEndDate);</span>

<span class="fc" id="L511">		return lsOvernightEdgeDate;</span>
	}

	/**
	 * Generate a single Spanning Edge Pair between the specified dates, using the specified Calendar
	 * 
	 * @param dtStart Start Date
	 * @param dtEnd End Date
	 * 
	 * @return List Containing the Pair
	 */

	public static final java.util.List&lt;java.lang.Integer&gt; EdgePair (
		final org.drip.analytics.date.JulianDate dtStart,
		final org.drip.analytics.date.JulianDate dtEnd)
	{
<span class="pc bpc" id="L527" title="2 of 4 branches missed.">		if (null == dtStart || null == dtEnd) return null;</span>

<span class="fc" id="L529">		int iEndDate = dtEnd.julian();</span>

<span class="fc" id="L531">		int iStartDate = dtStart.julian();</span>

<span class="pc bpc" id="L533" title="1 of 2 branches missed.">		if (iEndDate &lt;= iStartDate) return null;</span>

<span class="fc" id="L535">		java.util.List&lt;java.lang.Integer&gt; lsOvernightEdgeDate = new java.util.ArrayList&lt;java.lang.Integer&gt;();</span>

<span class="fc" id="L537">		lsOvernightEdgeDate.add (iStartDate);</span>

<span class="fc" id="L539">		lsOvernightEdgeDate.add (iEndDate);</span>

<span class="fc" id="L541">		return lsOvernightEdgeDate;</span>
	}

	/**
	 * Construct a Reference Period using the Start/End Dates, the Floater Label, and the Reference Period
	 *  Arrears Type
	 * 
	 * @param dtStart Start Date
	 * @param dtEnd End Date
	 * @param floaterLabel Floater Label
	 * @param iReferencePeriodArrearsType Reference Period Arrears Type
	 * 
	 * @return The Reference Period
	 */

	public static final org.drip.analytics.cashflow.ReferenceIndexPeriod ReferencePeriod (
		final org.drip.analytics.date.JulianDate dtStart,
		final org.drip.analytics.date.JulianDate dtEnd,
		final org.drip.state.identifier.FloaterLabel floaterLabel,
		final int iReferencePeriodArrearsType)
	{
<span class="pc bpc" id="L562" title="3 of 6 branches missed.">		if (null == dtStart || null == dtEnd || null == floaterLabel) return null;</span>

<span class="fc" id="L564">		java.lang.String strForwardTenor = &quot;&quot;;</span>

<span class="fc bfc" id="L566" title="All 2 branches covered.">		if (floaterLabel instanceof org.drip.state.identifier.ForwardLabel)</span>
<span class="fc" id="L567">			strForwardTenor = floaterLabel.tenor();</span>
<span class="pc bpc" id="L568" title="1 of 2 branches missed.">		else if (floaterLabel instanceof org.drip.state.identifier.OTCFixFloatLabel)</span>
<span class="fc" id="L569">			strForwardTenor = ((org.drip.state.identifier.OTCFixFloatLabel) floaterLabel).fixFloatTenor();</span>

		try {
<span class="fc bfc" id="L572" title="All 2 branches covered.">			return org.drip.analytics.cashflow.ReferenceIndexPeriod.Standard (</span>
				REFERENCE_PERIOD_IN_ARREARS == iReferencePeriodArrearsType ? dtStart.addTenor
<span class="fc bfc" id="L574" title="All 2 branches covered.">					(strForwardTenor).julian() : dtStart.julian(),</span>
				REFERENCE_PERIOD_IN_ARREARS == iReferencePeriodArrearsType ? dtEnd.addTenor
<span class="fc" id="L576">					(strForwardTenor).julian() : dtEnd.julian(),</span>
				floaterLabel
			);
<span class="nc" id="L579">		} catch (java.lang.Exception e) {</span>
<span class="nc" id="L580">			e.printStackTrace();</span>
		}

<span class="nc" id="L583">		return null;</span>
	}

	/**
	 * Generate a list of period edge dates forward from the start.
	 * 
	 * @param iEffective Effective Date
	 * @param iMaturity Maturity Date
	 * @param strTenor Period Tenor
	 * @param dap Inner Date Adjustment Parameters
	 * @param iPSEC Period Set Edge Customizer Setting
	 * 
	 * @return List of Period Edge Dates
	 */

	public static final java.util.List&lt;java.lang.Integer&gt; ForwardEdgeDates (
		final int iEffective,
		final int iMaturity,
		final java.lang.String strTenor,
		final org.drip.analytics.daycount.DateAdjustParams dap,
		final int iPSEC)
	{
<span class="nc" id="L605">		return ForwardEdgeDates (new org.drip.analytics.date.JulianDate (iEffective), new</span>
			org.drip.analytics.date.JulianDate (iMaturity), strTenor, dap, iPSEC);
	}

	/**
	 * Generate a list of period edge dates backward from the end.
	 * 
	 * @param iEffective Effective Date
	 * @param iMaturity Maturity Date
	 * @param strTenor Period Tenor
	 * @param dap Inner Date Adjustment Parameters
	 * @param iPSEC Period Set Edge Customizer Setting
	 * 
	 * @return List of Period Edge Dates
	 */

	public static final java.util.List&lt;java.lang.Integer&gt; BackwardEdgeDates (
		final int iEffective,
		final int iMaturity,
		final java.lang.String strTenor,
		final org.drip.analytics.daycount.DateAdjustParams dap,
		final int iPSEC)
	{
<span class="nc" id="L628">		return BackwardEdgeDates (new org.drip.analytics.date.JulianDate (iEffective), new</span>
			org.drip.analytics.date.JulianDate (iMaturity), strTenor, dap, iPSEC);
	}

	/**
	 * Generate a list of regular period edge dates forward from the start.
	 * 
	 * @param iEffective Effective Date
	 * @param strPeriodTenor Period Tenor
	 * @param strMaturityTenor Period Tenor
	 * @param dap Inner Date Adjustment Parameters
	 * 
	 * @return List of Period Edge Dates
	 */

	public static final java.util.List&lt;java.lang.Integer&gt; RegularEdgeDates (
		final int iEffective,
		final java.lang.String strPeriodTenor,
		final java.lang.String strMaturityTenor,
		final org.drip.analytics.daycount.DateAdjustParams dap)
	{
<span class="fc" id="L649">		return RegularEdgeDates (new org.drip.analytics.date.JulianDate (iEffective), strPeriodTenor,</span>
			strMaturityTenor, dap);
	}

	/**
	 * Generate the List of Overnight Edge Dates between the specified dates, using the specified Calendar
	 * 
	 * @param iStartDate Start Date
	 * @param iEndDate End Date
	 * @param strCalendar Calendar
	 * 
	 * @return List of Overnight Edge Dates
	 */

	public static final java.util.List&lt;java.lang.Integer&gt; OvernightEdgeDates (
		final int iStartDate,
		final int iEndDate,
		final java.lang.String strCalendar)
	{
<span class="fc" id="L668">		return OvernightEdgeDates (new org.drip.analytics.date.JulianDate (iStartDate), new</span>
			org.drip.analytics.date.JulianDate (iEndDate), strCalendar);
	}

	/**
	 * Construct a Reference Index Period using the Start/End Dates, the Floater Label, and the Reference
	 *  Period Arrears Type
	 * 
	 * @param iStartDate Start Date
	 * @param iEndDate End Date
	 * @param floaterLabel Floater Label
	 * @param iReferencePeriodArrearsType Reference Period Arrears Type
	 * 
	 * @return The Reference Period
	 */

	public static final org.drip.analytics.cashflow.ReferenceIndexPeriod ReferencePeriod (
		final int iStartDate,
		final int iEndDate,
		final org.drip.state.identifier.FloaterLabel floaterLabel,
		final int iReferencePeriodArrearsType)
	{
<span class="fc" id="L690">		return ReferencePeriod (</span>
			new org.drip.analytics.date.JulianDate (iStartDate),
			new org.drip.analytics.date.JulianDate (iEndDate),
			floaterLabel,
			iReferencePeriodArrearsType
		);
	}

	/**
	 * Retrieve the List of Edge Dates across all Units
	 * 
	 * @param iUnitPeriodStartDate Unit Period Start Date
	 * @param iUnitPeriodEndDate Unit Period End Date
	 * @param strCalendar Unit Date Generation Calendar
	 * @param cubs Composable Unit Builder Setting
	 * 
	 * @return List of Edge Dates across all Units
	 */

	public static final java.util.List&lt;java.lang.Integer&gt; UnitDateEdges (
		final int iUnitPeriodStartDate,
		final int iUnitPeriodEndDate,
		final java.lang.String strCalendar,
		final org.drip.param.period.ComposableUnitBuilderSetting cubs)
	{
<span class="pc bpc" id="L715" title="1 of 2 branches missed.">		if (null == cubs) return null;</span>

<span class="fc" id="L717">		int iEdgeDateSequenceScheme = cubs.edgeDateSequenceScheme();</span>

<span class="fc bfc" id="L719" title="All 2 branches covered.">		if (EDGE_DATE_SEQUENCE_SINGLE == iEdgeDateSequenceScheme) {</span>
<span class="pc bpc" id="L720" title="1 of 2 branches missed.">			if (iUnitPeriodStartDate &gt;= iUnitPeriodEndDate) return null;</span>

<span class="fc" id="L722">			java.util.List&lt;java.lang.Integer&gt; lsEdgeDates = new java.util.ArrayList&lt;java.lang.Integer&gt;();</span>

<span class="fc" id="L724">			lsEdgeDates.add (iUnitPeriodStartDate);</span>

<span class="fc" id="L726">			lsEdgeDates.add (iUnitPeriodEndDate);</span>

<span class="fc" id="L728">			return lsEdgeDates;</span>
		}

<span class="fc bfc" id="L731" title="All 2 branches covered.">		if (EDGE_DATE_SEQUENCE_REGULAR == iEdgeDateSequenceScheme)</span>
<span class="fc" id="L732">			return RegularEdgeDates (iUnitPeriodStartDate, iUnitPeriodEndDate, cubs.tenor(), cubs.dapEdge());</span>

<span class="pc bpc" id="L734" title="1 of 2 branches missed.">		if (EDGE_DATE_SEQUENCE_OVERNIGHT == iEdgeDateSequenceScheme)</span>
<span class="fc" id="L735">			return OvernightEdgeDates (iUnitPeriodStartDate, iUnitPeriodEndDate, strCalendar);</span>

<span class="nc" id="L737">		return null;</span>
	}

	/**
	 * Construct the List of Composable Fixed Units from the inputs
	 * 
	 * @param iUnitPeriodStartDate Unit Period Start Date
	 * @param iUnitPeriodEndDate Unit Period End Date
	 * @param ucas Unit Coupon/Accrual Setting
	 * @param cfus Composable Fixed Unit Setting
	 * 
	 * @return The List of Composable Floating Units
	 */

	public static final java.util.List&lt;org.drip.analytics.cashflow.ComposableUnitPeriod&gt; FixedUnits (
		final int iUnitPeriodStartDate,
		final int iUnitPeriodEndDate,
		final org.drip.param.period.UnitCouponAccrualSetting ucas,
		final org.drip.param.period.ComposableFixedUnitSetting cfus)
	{
<span class="pc bpc" id="L757" title="1 of 2 branches missed.">		if (null == cfus) return null;</span>

<span class="fc" id="L759">		java.util.List&lt;java.lang.Integer&gt; lsUnitEdgeDate = UnitDateEdges (iUnitPeriodStartDate,</span>
<span class="fc" id="L760">			iUnitPeriodEndDate, ucas.calendar(), cfus);</span>

<span class="pc bpc" id="L762" title="1 of 2 branches missed.">		if (null == lsUnitEdgeDate) return null;</span>

<span class="fc" id="L764">		int iNumDate = lsUnitEdgeDate.size();</span>

<span class="pc bpc" id="L766" title="1 of 2 branches missed.">		if (2 &gt; iNumDate) return null;</span>

<span class="fc" id="L768">		java.util.List&lt;org.drip.analytics.cashflow.ComposableUnitPeriod&gt; lsCUP = new</span>
			java.util.ArrayList&lt;org.drip.analytics.cashflow.ComposableUnitPeriod&gt;();

<span class="fc bfc" id="L771" title="All 2 branches covered.">		for (int i = 1; i &lt; iNumDate; ++i) {</span>
			try {
<span class="fc" id="L773">				lsCUP.add (new org.drip.analytics.cashflow.ComposableUnitFixedPeriod (lsUnitEdgeDate.get</span>
<span class="fc" id="L774">					(i - 1), lsUnitEdgeDate.get (i), ucas, cfus));</span>
<span class="nc" id="L775">			} catch (java.lang.Exception e) {</span>
<span class="nc" id="L776">				e.printStackTrace();</span>

<span class="nc" id="L778">				return null;</span>
<span class="fc" id="L779">			}</span>
		}

<span class="fc" id="L782">		return lsCUP;</span>
	}

	/**
	 * Construct the List of Composable Floating Units from the inputs
	 * 
	 * @param iUnitPeriodStartDate Unit Period Start Date
	 * @param iUnitPeriodEndDate Unit Period End Date
	 * @param cfus Composable Floating Unit Setting
	 * 
	 * @return The List of Composable Floating Units
	 */

	public static final java.util.List&lt;org.drip.analytics.cashflow.ComposableUnitPeriod&gt; FloatingUnits (
		final int iUnitPeriodStartDate,
		final int iUnitPeriodEndDate,
		final org.drip.param.period.ComposableFloatingUnitSetting cfus)
	{
<span class="pc bpc" id="L800" title="1 of 2 branches missed.">		if (null == cfus) return null;</span>

<span class="fc" id="L802">		org.drip.state.identifier.FloaterLabel floaterLabel = cfus.floaterLabel();</span>

<span class="fc" id="L804">		java.lang.String strCalendar = floaterLabel.floaterIndex().calendar();</span>

<span class="fc" id="L806">		java.util.List&lt;java.lang.Integer&gt; lsUnitEdgeDate = UnitDateEdges (iUnitPeriodStartDate,</span>
			iUnitPeriodEndDate, strCalendar, cfus);

<span class="pc bpc" id="L809" title="1 of 2 branches missed.">		if (null == lsUnitEdgeDate) return null;</span>

<span class="fc" id="L811">		int iNumDate = lsUnitEdgeDate.size();</span>

<span class="pc bpc" id="L813" title="1 of 2 branches missed.">		if (2 &gt; iNumDate) return null;</span>

<span class="fc" id="L815">		java.util.List&lt;org.drip.analytics.cashflow.ComposableUnitPeriod&gt; lsCUP = new</span>
			java.util.ArrayList&lt;org.drip.analytics.cashflow.ComposableUnitPeriod&gt;();

<span class="fc" id="L818">		double dblSpread = cfus.spread();</span>

<span class="fc" id="L820">		java.lang.String strUnitTenor = cfus.tenor();</span>

<span class="fc" id="L822">		java.lang.String strForwardTenor = floaterLabel.tenor();</span>

<span class="fc" id="L824">		int iReferencePeriodArrearsType = cfus.referencePeriodArrearsType();</span>

<span class="fc" id="L826">		boolean bComposableForwardPeriodsMatch = cfus.tenor().equalsIgnoreCase (strForwardTenor);</span>

<span class="fc bfc" id="L828" title="All 2 branches covered.">		for (int i = 1; i &lt; iNumDate; ++i) {</span>
<span class="fc" id="L829">			int iUnitStartDate = lsUnitEdgeDate.get (i - 1);</span>

<span class="fc" id="L831">			int iUnitEndDate = lsUnitEdgeDate.get (i);</span>

<span class="fc" id="L833">			int iReferencePeriodEndDate = iUnitEndDate;</span>

<span class="fc bfc" id="L835" title="All 2 branches covered.">			int iReferencePeriodStartDate = bComposableForwardPeriodsMatch ? iUnitStartDate : new</span>
<span class="fc" id="L836">				org.drip.analytics.date.JulianDate (iUnitEndDate).subtractTenorAndAdjust (strForwardTenor,</span>
<span class="fc" id="L837">					strCalendar).julian();</span>

			try {
<span class="fc" id="L840">				lsCUP.add (</span>
					new org.drip.analytics.cashflow.ComposableUnitFloatingPeriod (
						iUnitStartDate,
						iUnitEndDate,
						strUnitTenor,
<span class="fc" id="L845">						ReferencePeriod (</span>
							iReferencePeriodStartDate,
							iReferencePeriodEndDate,
							floaterLabel,
							iReferencePeriodArrearsType
						),
						dblSpread
					)
				);
<span class="nc" id="L854">			} catch (java.lang.Exception e) {</span>
<span class="nc" id="L855">				e.printStackTrace();</span>

<span class="nc" id="L857">				return null;</span>
<span class="fc" id="L858">			}</span>
		}

<span class="fc" id="L861">		return lsCUP;</span>
	}

	/**
	 * Construct the List of Composite Fixed Periods from the corresponding Composable Fixed Period Units
	 * 
	 * @param lsCompositeEdgeDate The Composite Period Edge Dates
	 * @param cps Composite Period Setting Instance
	 * @param ucas Unit Coupon/Accrual Setting
	 * @param cfus Composable Fixed Unit Setting
	 * 
	 * @return List of Composite Fixed Periods
	 */

	public static final java.util.List&lt;org.drip.analytics.cashflow.CompositePeriod&gt; FixedCompositeUnit (
		final java.util.List&lt;java.lang.Integer&gt; lsCompositeEdgeDate,
		final org.drip.param.period.CompositePeriodSetting cps,
		final org.drip.param.period.UnitCouponAccrualSetting ucas,
		final org.drip.param.period.ComposableFixedUnitSetting cfus)
	{
<span class="pc bpc" id="L881" title="1 of 2 branches missed.">		if (null == lsCompositeEdgeDate) return null;</span>

<span class="fc" id="L883">		int iNumEdge = lsCompositeEdgeDate.size();</span>

<span class="pc bpc" id="L885" title="1 of 2 branches missed.">		if (2 &gt; iNumEdge) return null;</span>

<span class="fc" id="L887">		java.util.List&lt;org.drip.analytics.cashflow.CompositePeriod&gt; lsCFP = new</span>
			java.util.ArrayList&lt;org.drip.analytics.cashflow.CompositePeriod&gt;();

<span class="fc bfc" id="L890" title="All 2 branches covered.">		for (int i = 1; i &lt; iNumEdge; ++i) {</span>
			try {
<span class="fc" id="L892">				lsCFP.add (new org.drip.analytics.cashflow.CompositeFixedPeriod (cps, FixedUnits</span>
<span class="fc" id="L893">					(lsCompositeEdgeDate.get (i - 1), lsCompositeEdgeDate.get (i), ucas, cfus)));</span>
<span class="nc" id="L894">			} catch (java.lang.Exception e) {</span>
<span class="nc" id="L895">				e.printStackTrace();</span>

<span class="nc" id="L897">				return null;</span>
<span class="fc" id="L898">			}</span>
		}

<span class="fc" id="L901">		return lsCFP;</span>
	}

	/**
	 * Construct the List of Composite Floating Period from the corresponding Composable Floating Period
	 *  Units
	 * 
	 * @param lsCompositeEdgeDate The Composite Period Edge Dates
	 * @param cps Composite Period Setting Instance
	 * @param cfus Composable Floating Unit Setting
	 * 
	 * @return List of Composite Floating Periods
	 */

	public static final java.util.List&lt;org.drip.analytics.cashflow.CompositePeriod&gt; FloatingCompositeUnit (
		final java.util.List&lt;java.lang.Integer&gt; lsCompositeEdgeDate,
		final org.drip.param.period.CompositePeriodSetting cps,
		final org.drip.param.period.ComposableFloatingUnitSetting cfus)
	{
<span class="pc bpc" id="L920" title="1 of 2 branches missed.">		if (null == lsCompositeEdgeDate) return null;</span>

<span class="fc" id="L922">		int iNumEdge = lsCompositeEdgeDate.size();</span>

<span class="pc bpc" id="L924" title="1 of 2 branches missed.">		if (2 &gt; iNumEdge) return null;</span>

<span class="fc" id="L926">		java.util.List&lt;org.drip.analytics.cashflow.CompositePeriod&gt; lsCFP = new</span>
			java.util.ArrayList&lt;org.drip.analytics.cashflow.CompositePeriod&gt;();

<span class="fc bfc" id="L929" title="All 2 branches covered.">		for (int i = 1; i &lt; iNumEdge; ++i) {</span>
			try {
<span class="fc" id="L931">				lsCFP.add (new org.drip.analytics.cashflow.CompositeFloatingPeriod (cps, FloatingUnits</span>
<span class="fc" id="L932">					(lsCompositeEdgeDate.get (i - 1), lsCompositeEdgeDate.get (i), cfus)));</span>
<span class="nc" id="L933">			} catch (java.lang.Exception e) {</span>
<span class="nc" id="L934">				e.printStackTrace();</span>

<span class="nc" id="L936">				return null;</span>
<span class="fc" id="L937">			}</span>
		}

<span class="fc" id="L940">		return lsCFP;</span>
	}
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.7.9.201702052155</span></div></body></html>