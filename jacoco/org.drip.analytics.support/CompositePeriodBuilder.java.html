<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>CompositePeriodBuilder.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">DROP</a> &gt; <a href="index.source.html" class="el_package">org.drip.analytics.support</a> &gt; <span class="el_source">CompositePeriodBuilder.java</span></div><h1>CompositePeriodBuilder.java</h1><pre class="source lang-java linenums">
package org.drip.analytics.support;

/*
 * -*- mode: java; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*-
 */

/*!
 * Copyright (C) 2019 Lakshmi Krishnamurthy
 * Copyright (C) 2018 Lakshmi Krishnamurthy
 * Copyright (C) 2017 Lakshmi Krishnamurthy
 * Copyright (C) 2016 Lakshmi Krishnamurthy
 * Copyright (C) 2015 Lakshmi Krishnamurthy
 * Copyright (C) 2014 Lakshmi Krishnamurthy
 * 
 *  This file is part of DROP, an open-source library targeting risk, transaction costs, exposure, margin
 *  	calculations, valuation adjustment, and portfolio construction within and across fixed income,
 *  	credit, commodity, equity, FX, and structured products.
 *  
 *  	https://lakshmidrip.github.io/DROP/
 *  
 *  DROP is composed of three modules:
 *  
 *  - DROP Analytics Core - https://lakshmidrip.github.io/DROP-Analytics-Core/
 *  - DROP Portfolio Core - https://lakshmidrip.github.io/DROP-Portfolio-Core/
 *  - DROP Numerical Core - https://lakshmidrip.github.io/DROP-Numerical-Core/
 * 
 * 	DROP Analytics Core implements libraries for the following:
 * 	- Fixed Income Analytics
 * 	- Asset Backed Analytics
 * 	- XVA Analytics
 * 	- Exposure and Margin Analytics
 * 
 * 	DROP Portfolio Core implements libraries for the following:
 * 	- Asset Allocation Analytics
 * 	- Transaction Cost Analytics
 * 
 * 	DROP Numerical Core implements libraries for the following:
 * 	- Statistical Learning Library
 * 	- Numerical Optimizer Library
 * 	- Machine Learning Library
 * 	- Spline Builder Library
 * 
 * 	Documentation for DROP is Spread Over:
 * 
 * 	- Main                     =&gt; https://lakshmidrip.github.io/DROP/
 * 	- Wiki                     =&gt; https://github.com/lakshmiDRIP/DROP/wiki
 * 	- GitHub                   =&gt; https://github.com/lakshmiDRIP/DROP
 * 	- Repo Layout Taxonomy     =&gt; https://github.com/lakshmiDRIP/DROP/blob/master/Taxonomy.md
 * 	- Javadoc                  =&gt; https://lakshmidrip.github.io/DROP/Javadoc/index.html
 * 	- Technical Specifications =&gt; https://github.com/lakshmiDRIP/DROP/tree/master/Docs/Internal
 * 	- Release Versions         =&gt; https://lakshmidrip.github.io/DROP/version.html
 * 	- Community Credits        =&gt; https://lakshmidrip.github.io/DROP/credits.html
 * 	- Issues Catalog           =&gt; https://github.com/lakshmiDRIP/DROP/issues
 * 	- JUnit                    =&gt; https://lakshmidrip.github.io/DROP/junit/index.html
 * 	- Jacoco                   =&gt; https://lakshmidrip.github.io/DROP/jacoco/index.html
 * 
 *  Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 *   	you may not use this file except in compliance with the License.
 *   
 *  You may obtain a copy of the License at
 *  	http://www.apache.org/licenses/LICENSE-2.0
 *  
 *  Unless required by applicable law or agreed to in writing, software
 *  	distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 *  	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  
 *  See the License for the specific language governing permissions and
 *  	limitations under the License.
 */

/**
 * &lt;i&gt;CompositePeriodBuilder&lt;/i&gt; exposes the composite period construction functionality.
 *
 *	&lt;br&gt;&lt;br&gt;
 *  &lt;ul&gt;
 *		&lt;li&gt;&lt;b&gt;Module &lt;/b&gt; = &lt;a href = &quot;https://github.com/lakshmiDRIP/DROP/tree/master/AnalyticsCore.md&quot;&gt;Analytics Core Module&lt;/a&gt;&lt;/li&gt;
 *		&lt;li&gt;&lt;b&gt;Library&lt;/b&gt; = &lt;a href = &quot;https://github.com/lakshmiDRIP/DROP/tree/master/FixedIncomeAnalyticsLibrary.md&quot;&gt;Fixed Income Analytics&lt;/a&gt;&lt;/li&gt;
 *		&lt;li&gt;&lt;b&gt;Project&lt;/b&gt; = &lt;a href = &quot;https://github.com/lakshmiDRIP/DROP/tree/master/src/main/java/org/drip/analytics/README.md&quot;&gt;Analytics&lt;/a&gt;&lt;/li&gt;
 *		&lt;li&gt;&lt;b&gt;Package&lt;/b&gt; = &lt;a href = &quot;https://github.com/lakshmiDRIP/DROP/tree/master/src/main/java/org/drip/analytics/support/README.md&quot;&gt;Support&lt;/a&gt;&lt;/li&gt;
 *  &lt;/ul&gt;
 * 
 * @author Lakshmi Krishnamurthy
 */

<span class="nc" id="L86">public class CompositePeriodBuilder {</span>

	/**
	 * Edge Date Generation Sequence - Forward
	 */

	public static final int EDGE_DATE_SEQUENCE_FORWARD = 0;

	/**
	 * Edge Date Generation Sequence - Reverse
	 */

	public static final int EDGE_DATE_SEQUENCE_REVERSE = 1;

	/**
	 * Edge Date Generation Sequence - Regular
	 */

	public static final int EDGE_DATE_SEQUENCE_REGULAR = 2;

	/**
	 * Edge Date Generation Sequence - Overnight
	 */

	public static final int EDGE_DATE_SEQUENCE_OVERNIGHT = 4;

	/**
	 * Edge Date Generation Sequence - Single Edge Date Pair Between Dates
	 */

	public static final int EDGE_DATE_SEQUENCE_SINGLE = 8;

	/**
	 * Period Set Generation Customization - Short Stub (i.e., No adjustment on either end)
	 */

	public static final int SHORT_STUB = 0;

	/**
	 * Period Set Generation Customization - Merge the front periods to produce a long front
	 */

	public static final int FULL_FRONT_PERIOD = 1;

	/**
	 * Period Set Generation Customization - Long Stub (if present) belongs to the front/back end depending
	 * 	upon backwards/forwards generation scheme
	 */

	public static final int LONG_STUB = 2;

	/**
	 * Reference Period Fixing is IN-ARREARS (i.e., displaced one period to the right) of the Coupon Period
	 */

	public static final int REFERENCE_PERIOD_IN_ARREARS = 0;

	/**
	 * Reference Period Fixing is IN-ADVANCE (i.e., the same as that) of the Coupon Period
	 */

	public static final int REFERENCE_PERIOD_IN_ADVANCE = 1;

	/**
	 * Accrual Compounding Rule - Arithmetic
	 */

	public static final int ACCRUAL_COMPOUNDING_RULE_ARITHMETIC = 1;

	/**
	 * Accrual Compounding Rule - Geometric
	 */

	public static final int ACCRUAL_COMPOUNDING_RULE_GEOMETRIC = 2;

	private static final int DAPAdjust (
		final int iDate,
		final org.drip.analytics.daycount.DateAdjustParams dap)
	{
<span class="fc bfc" id="L165" title="All 2 branches covered.">		if (null == dap) return iDate;</span>

		try {
<span class="fc" id="L168">			return dap.roll (iDate);</span>
<span class="nc" id="L169">		} catch (java.lang.Exception e) {</span>
<span class="nc" id="L170">			e.printStackTrace();</span>
		}

<span class="nc" id="L173">		return iDate;</span>
	}

	/**
	 * Verify if the Specified Accrual Compounding Rule is a Valid One
	 * 
	 * @param iAccrualCompoundingRule The Accrual Compounding Rule
	 * 
	 * @return TRUE - The Accrual Compounding Rule is valid
	 */

	public static final boolean ValidateCompoundingRule (
		final int iAccrualCompoundingRule)
	{
<span class="pc bpc" id="L187" title="1 of 4 branches missed.">		return ACCRUAL_COMPOUNDING_RULE_ARITHMETIC == iAccrualCompoundingRule ||</span>
			ACCRUAL_COMPOUNDING_RULE_GEOMETRIC == iAccrualCompoundingRule;
	}

	/**
	 * Generate a list of period edge dates forward from the start.
	 * 
	 * @param dtEffective Effective date
	 * @param dtMaturity Maturity date
	 * @param strTenor Period Tenor
	 * @param dap Inner Date Adjustment Parameters
	 * @param iPSEC Period Set Edge Customizer Setting
	 * 
	 * @return List of Period Edge Dates
	 */

	public static final java.util.List&lt;java.lang.Integer&gt; ForwardEdgeDates (
		final org.drip.analytics.date.JulianDate dtEffective,
		final org.drip.analytics.date.JulianDate dtMaturity,
		final java.lang.String strTenor,
		final org.drip.analytics.daycount.DateAdjustParams dap,
		final int iPSEC)
	{
<span class="nc bnc" id="L210" title="All 8 branches missed.">		if (null == dtEffective || null == dtMaturity || null == strTenor || strTenor.isEmpty()) return null;</span>

<span class="nc" id="L212">		java.lang.String strPeriodRollTenor = &quot;&quot;;</span>
<span class="nc" id="L213">		org.drip.analytics.date.JulianDate dtEdge = dtEffective;</span>

<span class="nc" id="L215">		int iMaturityDate = dtMaturity.julian();</span>

<span class="nc" id="L217">		int iEdgeDate = dtEdge.julian();</span>

<span class="nc bnc" id="L219" title="All 2 branches missed.">		if (iEdgeDate &gt;= iMaturityDate) return null;</span>

<span class="nc" id="L221">		java.util.List&lt;java.lang.Integer&gt; lsEdgeDate = new java.util.ArrayList&lt;java.lang.Integer&gt;();</span>

<span class="nc bnc" id="L223" title="All 2 branches missed.">		while (iEdgeDate &lt; iMaturityDate) {</span>
<span class="nc" id="L224">			lsEdgeDate.add (iEdgeDate);</span>

<span class="nc" id="L226">			strPeriodRollTenor = org.drip.analytics.support.Helper.AggregateTenor</span>
<span class="nc" id="L227">				(strPeriodRollTenor, strTenor);</span>

<span class="nc bnc" id="L229" title="All 2 branches missed.">			if (null == (dtEdge = dtMaturity.addTenor (strPeriodRollTenor))) return null;</span>

<span class="nc" id="L231">			iEdgeDate = dtEdge.julian();</span>
		}

<span class="nc bnc" id="L234" title="All 2 branches missed.">		if (iEdgeDate &gt; iMaturityDate) {</span>
<span class="nc bnc" id="L235" title="All 2 branches missed.">			if (SHORT_STUB == iPSEC)</span>
<span class="nc" id="L236">				lsEdgeDate.add (iMaturityDate);</span>
<span class="nc bnc" id="L237" title="All 2 branches missed.">			else if (LONG_STUB == iPSEC) {</span>
<span class="nc bnc" id="L238" title="All 2 branches missed.">				if (1 != lsEdgeDate.size()) lsEdgeDate.remove (lsEdgeDate.size() - 1);</span>

<span class="nc" id="L240">				lsEdgeDate.add (iMaturityDate);</span>
			}
<span class="nc bnc" id="L242" title="All 2 branches missed.">		} else if (iEdgeDate == iMaturityDate)</span>
<span class="nc" id="L243">			lsEdgeDate.add (iMaturityDate);</span>

<span class="nc" id="L245">		java.util.List&lt;java.lang.Integer&gt; lsAdjustedEdgeDate = new java.util.ArrayList&lt;java.lang.Integer&gt;();</span>

<span class="nc" id="L247">		lsAdjustedEdgeDate.add (lsEdgeDate.get (0));</span>

<span class="nc" id="L249">		int iNumDate = lsEdgeDate.size();</span>

<span class="nc bnc" id="L251" title="All 2 branches missed.">		for (int i = 1; i &lt; iNumDate - 1; ++i)</span>
<span class="nc" id="L252">			lsAdjustedEdgeDate.add (DAPAdjust (lsEdgeDate.get (i), dap));</span>

<span class="nc" id="L254">		lsAdjustedEdgeDate.add (lsEdgeDate.get (iNumDate - 1));</span>

<span class="nc bnc" id="L256" title="All 2 branches missed.">		if (1 == lsAdjustedEdgeDate.size()) lsAdjustedEdgeDate.add (1, iMaturityDate);</span>

<span class="nc" id="L258">		return lsAdjustedEdgeDate;</span>
	}

	/**
	 * Generate a list of period edge dates backward from the end.
	 * 
	 * @param dtEffective Effective date
	 * @param dtMaturity Maturity date
	 * @param strTenor Period Tenor
	 * @param dap Inner Date Adjustment Parameters
	 * @param iPSEC Period Set Edge Customizer Setting
	 * 
	 * @return List of Period Edge Dates
	 */

	public static final java.util.List&lt;java.lang.Integer&gt; BackwardEdgeDates (
		final org.drip.analytics.date.JulianDate dtEffective,
		final org.drip.analytics.date.JulianDate dtMaturity,
		final java.lang.String strTenor,
		final org.drip.analytics.daycount.DateAdjustParams dap,
		final int iPSEC)
	{
<span class="pc bpc" id="L280" title="4 of 8 branches missed.">		if (null == dtEffective || null == dtMaturity || null == strTenor || strTenor.isEmpty()) return null;</span>

<span class="fc" id="L282">		int iEffectiveDate = dtEffective.julian();</span>

<span class="fc" id="L284">		java.lang.String strPeriodRollTenor = &quot;&quot;;</span>
<span class="fc" id="L285">		org.drip.analytics.date.JulianDate dtEdge = dtMaturity;</span>

<span class="fc" id="L287">		int iEdgeDate = dtEdge.julian();</span>

<span class="pc bpc" id="L289" title="1 of 2 branches missed.">		if (iEffectiveDate &gt;= iEdgeDate) return null;</span>

<span class="fc" id="L291">		java.util.List&lt;java.lang.Integer&gt; lsEdgeDate = new java.util.ArrayList&lt;java.lang.Integer&gt;();</span>

<span class="fc bfc" id="L293" title="All 2 branches covered.">		while (iEdgeDate &gt; iEffectiveDate) {</span>
<span class="fc" id="L294">			lsEdgeDate.add (0, iEdgeDate);</span>

<span class="fc" id="L296">			strPeriodRollTenor = org.drip.analytics.support.Helper.AggregateTenor (strPeriodRollTenor,</span>
				strTenor);

<span class="pc bpc" id="L299" title="1 of 2 branches missed.">			if (null == (dtEdge = dtMaturity.subtractTenor (strPeriodRollTenor))) return null;</span>

<span class="fc" id="L301">			iEdgeDate = dtEdge.julian();</span>
		}

<span class="fc bfc" id="L304" title="All 2 branches covered.">		if (iEdgeDate &lt; iEffectiveDate) {</span>
<span class="fc bfc" id="L305" title="All 2 branches covered.">			if (SHORT_STUB == iPSEC)</span>
<span class="fc" id="L306">				lsEdgeDate.add (0, iEffectiveDate);</span>
<span class="pc bpc" id="L307" title="1 of 2 branches missed.">			else if (FULL_FRONT_PERIOD == iPSEC)</span>
<span class="nc" id="L308">				lsEdgeDate.add (0, iEdgeDate);</span>
<span class="pc bpc" id="L309" title="1 of 2 branches missed.">			else if (LONG_STUB == iPSEC) {</span>
<span class="fc bfc" id="L310" title="All 2 branches covered.">				if (1 != lsEdgeDate.size()) lsEdgeDate.remove (0);</span>

<span class="fc" id="L312">				lsEdgeDate.add (0, iEffectiveDate);</span>
			}
<span class="pc bpc" id="L314" title="1 of 2 branches missed.">		} else if (dtEdge.julian() == iEffectiveDate)</span>
<span class="fc" id="L315">			lsEdgeDate.add (0, iEffectiveDate);</span>

<span class="fc" id="L317">		java.util.List&lt;java.lang.Integer&gt; lsAdjustedEdgeDate = new java.util.ArrayList&lt;java.lang.Integer&gt;();</span>

<span class="fc" id="L319">		lsAdjustedEdgeDate.add (lsEdgeDate.get (0));</span>

<span class="fc" id="L321">		int iNumDate = lsEdgeDate.size();</span>

<span class="fc bfc" id="L323" title="All 2 branches covered.">		for (int i = 1; i &lt; iNumDate - 1; ++i)</span>
<span class="fc" id="L324">			lsAdjustedEdgeDate.add (DAPAdjust (lsEdgeDate.get (i), dap));</span>

<span class="fc" id="L326">		lsAdjustedEdgeDate.add (lsEdgeDate.get (iNumDate - 1));</span>

<span class="fc" id="L328">		return lsAdjustedEdgeDate;</span>
	}

	/**
	 * Generate a list of regular period edge dates forward from the start.
	 * 
	 * @param dtEffective Effective date
	 * @param strPeriodTenor Period Tenor
	 * @param strMaturityTenor Period Tenor
	 * @param dap Inner Date Adjustment Parameters
	 * 
	 * @return List of Period Edge Dates
	 */

	public static final java.util.List&lt;java.lang.Integer&gt; RegularEdgeDates (
		final org.drip.analytics.date.JulianDate dtEffective,
		final java.lang.String strPeriodTenor,
		final java.lang.String strMaturityTenor,
		final org.drip.analytics.daycount.DateAdjustParams dap)
	{
<span class="pc bpc" id="L348" title="4 of 8 branches missed.">		if (null == dtEffective || null == strPeriodTenor || strPeriodTenor.isEmpty() || null ==</span>
<span class="pc bpc" id="L349" title="1 of 2 branches missed.">			strMaturityTenor || strMaturityTenor.isEmpty())</span>
<span class="nc" id="L350">			return null;</span>

<span class="fc" id="L352">		int iPeriodTenorMonth = -1;</span>
<span class="fc" id="L353">		int iMaturityTenorMonth = -1;</span>
<span class="fc" id="L354">		int iPeriodMaturityTenorComparison = -1;</span>

<span class="fc" id="L356">		int iMaturityDate = dtEffective.addTenor (strMaturityTenor).julian();</span>

<span class="fc" id="L358">		java.util.List&lt;java.lang.Integer&gt; lsEdgeDate = new java.util.ArrayList&lt;java.lang.Integer&gt;();</span>

		try {
<span class="fc" id="L361">			iPeriodMaturityTenorComparison = org.drip.analytics.support.Helper.TenorCompare (strPeriodTenor,</span>
				strMaturityTenor);
<span class="nc" id="L363">		} catch (java.lang.Exception e) {</span>
<span class="nc" id="L364">			e.printStackTrace();</span>

<span class="nc" id="L366">			return null;</span>
<span class="fc" id="L367">		}</span>

<span class="fc bfc" id="L369" title="All 4 branches covered.">		if (org.drip.analytics.support.Helper.LEFT_TENOR_EQUALS == iPeriodMaturityTenorComparison ||</span>
			org.drip.analytics.support.Helper.LEFT_TENOR_GREATER == iPeriodMaturityTenorComparison) {
<span class="fc" id="L371">			lsEdgeDate.add (dtEffective.julian());</span>

<span class="fc" id="L373">			lsEdgeDate.add (iMaturityDate);</span>

<span class="fc" id="L375">			return lsEdgeDate;</span>
		}

		try {
<span class="fc" id="L379">			iPeriodTenorMonth = org.drip.analytics.support.Helper.TenorToMonths (strPeriodTenor);</span>

<span class="fc" id="L381">			iMaturityTenorMonth = org.drip.analytics.support.Helper.TenorToMonths (strMaturityTenor);</span>
<span class="nc" id="L382">		} catch (java.lang.Exception e) {</span>
<span class="nc" id="L383">			e.printStackTrace();</span>

<span class="nc" id="L385">			return null;</span>
<span class="fc" id="L386">		}</span>

<span class="fc" id="L388">		org.drip.analytics.date.JulianDate dtEdge = dtEffective;</span>
<span class="fc" id="L389">		int iNumPeriod = iMaturityTenorMonth / iPeriodTenorMonth;</span>

<span class="fc" id="L391">		lsEdgeDate.add (dtEdge.julian());</span>

<span class="fc bfc" id="L393" title="All 2 branches covered.">		for (int i = 0; i &lt; iNumPeriod; ++i) {</span>
<span class="fc" id="L394">			dtEdge = dtEdge.addTenor (strPeriodTenor);</span>

<span class="fc" id="L396">			int iEdgeDate = dtEdge.julian();</span>

<span class="fc bfc" id="L398" title="All 2 branches covered.">			if (iEdgeDate &lt; iMaturityDate) lsEdgeDate.add (DAPAdjust (iEdgeDate, dap));</span>
		}

<span class="fc" id="L401">		lsEdgeDate.add (iMaturityDate);</span>

<span class="fc" id="L403">		return lsEdgeDate;</span>
	}

	/**
	 * Generate a list of regular period edge dates forward from the start.
	 * 
	 * @param iStartDate Start Date
	 * @param iEndDate End Date
	 * @param strPeriodTenor Period Tenor
	 * @param dap Inner Date Adjustment Parameters
	 * 
	 * @return List of Period Edge Dates
	 */

	public static final java.util.List&lt;java.lang.Integer&gt; RegularEdgeDates (
		final int iStartDate,
		final int iEndDate,
		final java.lang.String strPeriodTenor,
		final org.drip.analytics.daycount.DateAdjustParams dap)
	{
<span class="pc bpc" id="L423" title="3 of 6 branches missed.">		if (iStartDate &gt;= iEndDate || null == strPeriodTenor || strPeriodTenor.isEmpty()) return null;</span>

<span class="fc" id="L425">		java.util.List&lt;java.lang.Integer&gt; lsEdgeDate = new java.util.ArrayList&lt;java.lang.Integer&gt;();</span>

<span class="fc" id="L427">		int iEdgeDate = iStartDate;</span>

<span class="fc" id="L429">		org.drip.analytics.date.JulianDate dtEdge = new org.drip.analytics.date.JulianDate (iStartDate);</span>

<span class="fc bfc" id="L431" title="All 2 branches covered.">		while (iEdgeDate &lt; iEndDate) {</span>
<span class="fc" id="L432">			int iAdjustedEdgeDate = DAPAdjust (iEdgeDate, dap);</span>

<span class="pc bpc" id="L434" title="1 of 2 branches missed.">			if (!lsEdgeDate.contains (iAdjustedEdgeDate)) lsEdgeDate.add (iAdjustedEdgeDate);</span>

<span class="pc bpc" id="L436" title="1 of 2 branches missed.">			if (null == (dtEdge = dtEdge.addTenor (strPeriodTenor))) return null;</span>

<span class="fc" id="L438">			iEdgeDate = dtEdge.julian();</span>
<span class="fc" id="L439">		}</span>

<span class="fc bfc" id="L441" title="All 2 branches covered.">		if (!lsEdgeDate.contains (iEndDate)) lsEdgeDate.add (iEndDate);</span>

<span class="fc" id="L443">		return lsEdgeDate;</span>
	}

	/**
	 * Generate a list of the IMM period edge dates forward from the spot date.
	 * 
	 * @param dtSpot Spot Date
	 * @param iRollMonths Number of Months to Roll to the Next IMM Date
	 * @param strPeriodTenor Period Tenor
	 * @param strMaturityTenor Period Tenor
	 * @param dap Inner Date Adjustment Parameters
	 * 
	 * @return List of IMM Period Edge Dates
	 */

	public static final java.util.List&lt;java.lang.Integer&gt; IMMEdgeDates (
		final org.drip.analytics.date.JulianDate dtSpot,
		final int iRollMonths,
		final java.lang.String strPeriodTenor,
		final java.lang.String strMaturityTenor,
		final org.drip.analytics.daycount.DateAdjustParams dap)
	{
<span class="pc bpc" id="L465" title="1 of 2 branches missed.">		if (null == dtSpot) return null;</span>

		try {
<span class="fc" id="L468">			return RegularEdgeDates (dtSpot.nextRatesFuturesIMM (iRollMonths), strPeriodTenor,</span>
				strMaturityTenor, dap);
<span class="nc" id="L470">		} catch (java.lang.Exception e) {</span>
<span class="nc" id="L471">			e.printStackTrace();</span>
		}

<span class="nc" id="L474">		return null;</span>
	}

	/**
	 * Generate the List of Overnight Edge Dates between the specified dates, using the specified Calendar
	 * 
	 * @param dtStart Start Date
	 * @param dtEnd End Date
	 * @param strCalendar Calendar
	 * 
	 * @return List of Overnight Edge Dates
	 */

	public static final java.util.List&lt;java.lang.Integer&gt; OvernightEdgeDates (
		final org.drip.analytics.date.JulianDate dtStart,
		final org.drip.analytics.date.JulianDate dtEnd,
		final java.lang.String strCalendar)
	{
<span class="pc bpc" id="L492" title="2 of 4 branches missed.">		if (null == dtStart || null == dtEnd) return null;</span>

<span class="fc" id="L494">		org.drip.analytics.date.JulianDate dtEdge = dtStart;</span>

<span class="fc" id="L496">		int iEndDate = dtEnd.julian();</span>

<span class="fc" id="L498">		int iEdgeDate = dtEdge.julian();</span>

<span class="pc bpc" id="L500" title="1 of 2 branches missed.">		if (iEndDate &lt;= iEdgeDate) return null;</span>

<span class="fc" id="L502">		java.util.List&lt;java.lang.Integer&gt; lsOvernightEdgeDate = new java.util.ArrayList&lt;java.lang.Integer&gt;();</span>

<span class="fc bfc" id="L504" title="All 2 branches covered.">		while (iEdgeDate &lt; iEndDate) {</span>
<span class="fc" id="L505">			lsOvernightEdgeDate.add (iEdgeDate);</span>

<span class="pc bpc" id="L507" title="1 of 2 branches missed.">			if (null == (dtEdge = dtEdge.addBusDays (1, strCalendar))) return null;</span>

<span class="fc" id="L509">			iEdgeDate = dtEdge.julian();</span>
		}

<span class="fc" id="L512">		lsOvernightEdgeDate.add (iEndDate);</span>

<span class="fc" id="L514">		return lsOvernightEdgeDate;</span>
	}

	/**
	 * Generate a single Spanning Edge Pair between the specified dates, using the specified Calendar
	 * 
	 * @param dtStart Start Date
	 * @param dtEnd End Date
	 * 
	 * @return List Containing the Pair
	 */

	public static final java.util.List&lt;java.lang.Integer&gt; EdgePair (
		final org.drip.analytics.date.JulianDate dtStart,
		final org.drip.analytics.date.JulianDate dtEnd)
	{
<span class="pc bpc" id="L530" title="2 of 4 branches missed.">		if (null == dtStart || null == dtEnd) return null;</span>

<span class="fc" id="L532">		int iEndDate = dtEnd.julian();</span>

<span class="fc" id="L534">		int iStartDate = dtStart.julian();</span>

<span class="pc bpc" id="L536" title="1 of 2 branches missed.">		if (iEndDate &lt;= iStartDate) return null;</span>

<span class="fc" id="L538">		java.util.List&lt;java.lang.Integer&gt; lsOvernightEdgeDate = new java.util.ArrayList&lt;java.lang.Integer&gt;();</span>

<span class="fc" id="L540">		lsOvernightEdgeDate.add (iStartDate);</span>

<span class="fc" id="L542">		lsOvernightEdgeDate.add (iEndDate);</span>

<span class="fc" id="L544">		return lsOvernightEdgeDate;</span>
	}

	/**
	 * Construct a Reference Period using the Start/End Dates, the Floater Label, and the Reference Period
	 *  Arrears Type
	 * 
	 * @param dtStart Start Date
	 * @param dtEnd End Date
	 * @param floaterLabel Floater Label
	 * @param iReferencePeriodArrearsType Reference Period Arrears Type
	 * 
	 * @return The Reference Period
	 */

	public static final org.drip.analytics.cashflow.ReferenceIndexPeriod ReferencePeriod (
		final org.drip.analytics.date.JulianDate dtStart,
		final org.drip.analytics.date.JulianDate dtEnd,
		final org.drip.state.identifier.FloaterLabel floaterLabel,
		final int iReferencePeriodArrearsType)
	{
<span class="pc bpc" id="L565" title="3 of 6 branches missed.">		if (null == dtStart || null == dtEnd || null == floaterLabel) return null;</span>

<span class="fc" id="L567">		java.lang.String strForwardTenor = &quot;&quot;;</span>

<span class="fc bfc" id="L569" title="All 2 branches covered.">		if (floaterLabel instanceof org.drip.state.identifier.ForwardLabel)</span>
<span class="fc" id="L570">			strForwardTenor = floaterLabel.tenor();</span>
<span class="pc bpc" id="L571" title="1 of 2 branches missed.">		else if (floaterLabel instanceof org.drip.state.identifier.OTCFixFloatLabel)</span>
<span class="fc" id="L572">			strForwardTenor = ((org.drip.state.identifier.OTCFixFloatLabel) floaterLabel).fixFloatTenor();</span>

		try {
<span class="fc bfc" id="L575" title="All 2 branches covered.">			return org.drip.analytics.cashflow.ReferenceIndexPeriod.Standard (</span>
				REFERENCE_PERIOD_IN_ARREARS == iReferencePeriodArrearsType ? dtStart.addTenor
<span class="fc bfc" id="L577" title="All 2 branches covered.">					(strForwardTenor).julian() : dtStart.julian(),</span>
				REFERENCE_PERIOD_IN_ARREARS == iReferencePeriodArrearsType ? dtEnd.addTenor
<span class="fc" id="L579">					(strForwardTenor).julian() : dtEnd.julian(),</span>
				floaterLabel
			);
<span class="nc" id="L582">		} catch (java.lang.Exception e) {</span>
<span class="nc" id="L583">			e.printStackTrace();</span>
		}

<span class="nc" id="L586">		return null;</span>
	}

	/**
	 * Generate a list of period edge dates forward from the start.
	 * 
	 * @param iEffective Effective Date
	 * @param iMaturity Maturity Date
	 * @param strTenor Period Tenor
	 * @param dap Inner Date Adjustment Parameters
	 * @param iPSEC Period Set Edge Customizer Setting
	 * 
	 * @return List of Period Edge Dates
	 */

	public static final java.util.List&lt;java.lang.Integer&gt; ForwardEdgeDates (
		final int iEffective,
		final int iMaturity,
		final java.lang.String strTenor,
		final org.drip.analytics.daycount.DateAdjustParams dap,
		final int iPSEC)
	{
<span class="nc" id="L608">		return ForwardEdgeDates (new org.drip.analytics.date.JulianDate (iEffective), new</span>
			org.drip.analytics.date.JulianDate (iMaturity), strTenor, dap, iPSEC);
	}

	/**
	 * Generate a list of period edge dates backward from the end.
	 * 
	 * @param iEffective Effective Date
	 * @param iMaturity Maturity Date
	 * @param strTenor Period Tenor
	 * @param dap Inner Date Adjustment Parameters
	 * @param iPSEC Period Set Edge Customizer Setting
	 * 
	 * @return List of Period Edge Dates
	 */

	public static final java.util.List&lt;java.lang.Integer&gt; BackwardEdgeDates (
		final int iEffective,
		final int iMaturity,
		final java.lang.String strTenor,
		final org.drip.analytics.daycount.DateAdjustParams dap,
		final int iPSEC)
	{
<span class="nc" id="L631">		return BackwardEdgeDates (new org.drip.analytics.date.JulianDate (iEffective), new</span>
			org.drip.analytics.date.JulianDate (iMaturity), strTenor, dap, iPSEC);
	}

	/**
	 * Generate a list of regular period edge dates forward from the start.
	 * 
	 * @param iEffective Effective Date
	 * @param strPeriodTenor Period Tenor
	 * @param strMaturityTenor Period Tenor
	 * @param dap Inner Date Adjustment Parameters
	 * 
	 * @return List of Period Edge Dates
	 */

	public static final java.util.List&lt;java.lang.Integer&gt; RegularEdgeDates (
		final int iEffective,
		final java.lang.String strPeriodTenor,
		final java.lang.String strMaturityTenor,
		final org.drip.analytics.daycount.DateAdjustParams dap)
	{
<span class="fc" id="L652">		return RegularEdgeDates (new org.drip.analytics.date.JulianDate (iEffective), strPeriodTenor,</span>
			strMaturityTenor, dap);
	}

	/**
	 * Generate the List of Overnight Edge Dates between the specified dates, using the specified Calendar
	 * 
	 * @param iStartDate Start Date
	 * @param iEndDate End Date
	 * @param strCalendar Calendar
	 * 
	 * @return List of Overnight Edge Dates
	 */

	public static final java.util.List&lt;java.lang.Integer&gt; OvernightEdgeDates (
		final int iStartDate,
		final int iEndDate,
		final java.lang.String strCalendar)
	{
<span class="fc" id="L671">		return OvernightEdgeDates (new org.drip.analytics.date.JulianDate (iStartDate), new</span>
			org.drip.analytics.date.JulianDate (iEndDate), strCalendar);
	}

	/**
	 * Construct a Reference Index Period using the Start/End Dates, the Floater Label, and the Reference
	 *  Period Arrears Type
	 * 
	 * @param iStartDate Start Date
	 * @param iEndDate End Date
	 * @param floaterLabel Floater Label
	 * @param iReferencePeriodArrearsType Reference Period Arrears Type
	 * 
	 * @return The Reference Period
	 */

	public static final org.drip.analytics.cashflow.ReferenceIndexPeriod ReferencePeriod (
		final int iStartDate,
		final int iEndDate,
		final org.drip.state.identifier.FloaterLabel floaterLabel,
		final int iReferencePeriodArrearsType)
	{
<span class="fc" id="L693">		return ReferencePeriod (</span>
			new org.drip.analytics.date.JulianDate (iStartDate),
			new org.drip.analytics.date.JulianDate (iEndDate),
			floaterLabel,
			iReferencePeriodArrearsType
		);
	}

	/**
	 * Retrieve the List of Edge Dates across all Units
	 * 
	 * @param iUnitPeriodStartDate Unit Period Start Date
	 * @param iUnitPeriodEndDate Unit Period End Date
	 * @param strCalendar Unit Date Generation Calendar
	 * @param cubs Composable Unit Builder Setting
	 * 
	 * @return List of Edge Dates across all Units
	 */

	public static final java.util.List&lt;java.lang.Integer&gt; UnitDateEdges (
		final int iUnitPeriodStartDate,
		final int iUnitPeriodEndDate,
		final java.lang.String strCalendar,
		final org.drip.param.period.ComposableUnitBuilderSetting cubs)
	{
<span class="pc bpc" id="L718" title="1 of 2 branches missed.">		if (null == cubs) return null;</span>

<span class="fc" id="L720">		int iEdgeDateSequenceScheme = cubs.edgeDateSequenceScheme();</span>

<span class="fc bfc" id="L722" title="All 2 branches covered.">		if (EDGE_DATE_SEQUENCE_SINGLE == iEdgeDateSequenceScheme) {</span>
<span class="pc bpc" id="L723" title="1 of 2 branches missed.">			if (iUnitPeriodStartDate &gt;= iUnitPeriodEndDate) return null;</span>

<span class="fc" id="L725">			java.util.List&lt;java.lang.Integer&gt; lsEdgeDates = new java.util.ArrayList&lt;java.lang.Integer&gt;();</span>

<span class="fc" id="L727">			lsEdgeDates.add (iUnitPeriodStartDate);</span>

<span class="fc" id="L729">			lsEdgeDates.add (iUnitPeriodEndDate);</span>

<span class="fc" id="L731">			return lsEdgeDates;</span>
		}

<span class="fc bfc" id="L734" title="All 2 branches covered.">		if (EDGE_DATE_SEQUENCE_REGULAR == iEdgeDateSequenceScheme)</span>
<span class="fc" id="L735">			return RegularEdgeDates (iUnitPeriodStartDate, iUnitPeriodEndDate, cubs.tenor(), cubs.dapEdge());</span>

<span class="pc bpc" id="L737" title="1 of 2 branches missed.">		if (EDGE_DATE_SEQUENCE_OVERNIGHT == iEdgeDateSequenceScheme)</span>
<span class="fc" id="L738">			return OvernightEdgeDates (iUnitPeriodStartDate, iUnitPeriodEndDate, strCalendar);</span>

<span class="nc" id="L740">		return null;</span>
	}

	/**
	 * Construct the List of Composable Fixed Units from the inputs
	 * 
	 * @param iUnitPeriodStartDate Unit Period Start Date
	 * @param iUnitPeriodEndDate Unit Period End Date
	 * @param ucas Unit Coupon/Accrual Setting
	 * @param cfus Composable Fixed Unit Setting
	 * 
	 * @return The List of Composable Floating Units
	 */

	public static final java.util.List&lt;org.drip.analytics.cashflow.ComposableUnitPeriod&gt; FixedUnits (
		final int iUnitPeriodStartDate,
		final int iUnitPeriodEndDate,
		final org.drip.param.period.UnitCouponAccrualSetting ucas,
		final org.drip.param.period.ComposableFixedUnitSetting cfus)
	{
<span class="pc bpc" id="L760" title="1 of 2 branches missed.">		if (null == cfus) return null;</span>

<span class="fc" id="L762">		java.util.List&lt;java.lang.Integer&gt; lsUnitEdgeDate = UnitDateEdges (iUnitPeriodStartDate,</span>
<span class="fc" id="L763">			iUnitPeriodEndDate, ucas.calendar(), cfus);</span>

<span class="pc bpc" id="L765" title="1 of 2 branches missed.">		if (null == lsUnitEdgeDate) return null;</span>

<span class="fc" id="L767">		int iNumDate = lsUnitEdgeDate.size();</span>

<span class="pc bpc" id="L769" title="1 of 2 branches missed.">		if (2 &gt; iNumDate) return null;</span>

<span class="fc" id="L771">		java.util.List&lt;org.drip.analytics.cashflow.ComposableUnitPeriod&gt; lsCUP = new</span>
			java.util.ArrayList&lt;org.drip.analytics.cashflow.ComposableUnitPeriod&gt;();

<span class="fc bfc" id="L774" title="All 2 branches covered.">		for (int i = 1; i &lt; iNumDate; ++i) {</span>
			try {
<span class="fc" id="L776">				lsCUP.add (new org.drip.analytics.cashflow.ComposableUnitFixedPeriod (lsUnitEdgeDate.get</span>
<span class="fc" id="L777">					(i - 1), lsUnitEdgeDate.get (i), ucas, cfus));</span>
<span class="nc" id="L778">			} catch (java.lang.Exception e) {</span>
<span class="nc" id="L779">				e.printStackTrace();</span>

<span class="nc" id="L781">				return null;</span>
<span class="fc" id="L782">			}</span>
		}

<span class="fc" id="L785">		return lsCUP;</span>
	}

	/**
	 * Construct the List of Composable Floating Units from the inputs
	 * 
	 * @param iUnitPeriodStartDate Unit Period Start Date
	 * @param iUnitPeriodEndDate Unit Period End Date
	 * @param cfus Composable Floating Unit Setting
	 * 
	 * @return The List of Composable Floating Units
	 */

	public static final java.util.List&lt;org.drip.analytics.cashflow.ComposableUnitPeriod&gt; FloatingUnits (
		final int iUnitPeriodStartDate,
		final int iUnitPeriodEndDate,
		final org.drip.param.period.ComposableFloatingUnitSetting cfus)
	{
<span class="pc bpc" id="L803" title="1 of 2 branches missed.">		if (null == cfus) return null;</span>

<span class="fc" id="L805">		org.drip.state.identifier.FloaterLabel floaterLabel = cfus.floaterLabel();</span>

<span class="fc" id="L807">		java.lang.String strCalendar = floaterLabel.floaterIndex().calendar();</span>

<span class="fc" id="L809">		java.util.List&lt;java.lang.Integer&gt; lsUnitEdgeDate = UnitDateEdges (iUnitPeriodStartDate,</span>
			iUnitPeriodEndDate, strCalendar, cfus);

<span class="pc bpc" id="L812" title="1 of 2 branches missed.">		if (null == lsUnitEdgeDate) return null;</span>

<span class="fc" id="L814">		int iNumDate = lsUnitEdgeDate.size();</span>

<span class="pc bpc" id="L816" title="1 of 2 branches missed.">		if (2 &gt; iNumDate) return null;</span>

<span class="fc" id="L818">		java.util.List&lt;org.drip.analytics.cashflow.ComposableUnitPeriod&gt; lsCUP = new</span>
			java.util.ArrayList&lt;org.drip.analytics.cashflow.ComposableUnitPeriod&gt;();

<span class="fc" id="L821">		double dblSpread = cfus.spread();</span>

<span class="fc" id="L823">		java.lang.String strUnitTenor = cfus.tenor();</span>

<span class="fc" id="L825">		java.lang.String strForwardTenor = floaterLabel.tenor();</span>

<span class="fc" id="L827">		int iReferencePeriodArrearsType = cfus.referencePeriodArrearsType();</span>

<span class="fc" id="L829">		boolean bComposableForwardPeriodsMatch = cfus.tenor().equalsIgnoreCase (strForwardTenor);</span>

<span class="fc bfc" id="L831" title="All 2 branches covered.">		for (int i = 1; i &lt; iNumDate; ++i) {</span>
<span class="fc" id="L832">			int iUnitStartDate = lsUnitEdgeDate.get (i - 1);</span>

<span class="fc" id="L834">			int iUnitEndDate = lsUnitEdgeDate.get (i);</span>

<span class="fc" id="L836">			int iReferencePeriodEndDate = iUnitEndDate;</span>

<span class="fc bfc" id="L838" title="All 2 branches covered.">			int iReferencePeriodStartDate = bComposableForwardPeriodsMatch ? iUnitStartDate : new</span>
<span class="fc" id="L839">				org.drip.analytics.date.JulianDate (iUnitEndDate).subtractTenorAndAdjust (strForwardTenor,</span>
<span class="fc" id="L840">					strCalendar).julian();</span>

			try {
<span class="fc" id="L843">				lsCUP.add (</span>
					new org.drip.analytics.cashflow.ComposableUnitFloatingPeriod (
						iUnitStartDate,
						iUnitEndDate,
						strUnitTenor,
<span class="fc" id="L848">						ReferencePeriod (</span>
							iReferencePeriodStartDate,
							iReferencePeriodEndDate,
							floaterLabel,
							iReferencePeriodArrearsType
						),
						dblSpread
					)
				);
<span class="nc" id="L857">			} catch (java.lang.Exception e) {</span>
<span class="nc" id="L858">				e.printStackTrace();</span>

<span class="nc" id="L860">				return null;</span>
<span class="fc" id="L861">			}</span>
		}

<span class="fc" id="L864">		return lsCUP;</span>
	}

	/**
	 * Construct the List of Composite Fixed Periods from the corresponding Composable Fixed Period Units
	 * 
	 * @param lsCompositeEdgeDate The Composite Period Edge Dates
	 * @param cps Composite Period Setting Instance
	 * @param ucas Unit Coupon/Accrual Setting
	 * @param cfus Composable Fixed Unit Setting
	 * 
	 * @return List of Composite Fixed Periods
	 */

	public static final java.util.List&lt;org.drip.analytics.cashflow.CompositePeriod&gt; FixedCompositeUnit (
		final java.util.List&lt;java.lang.Integer&gt; lsCompositeEdgeDate,
		final org.drip.param.period.CompositePeriodSetting cps,
		final org.drip.param.period.UnitCouponAccrualSetting ucas,
		final org.drip.param.period.ComposableFixedUnitSetting cfus)
	{
<span class="pc bpc" id="L884" title="1 of 2 branches missed.">		if (null == lsCompositeEdgeDate) return null;</span>

<span class="fc" id="L886">		int iNumEdge = lsCompositeEdgeDate.size();</span>

<span class="pc bpc" id="L888" title="1 of 2 branches missed.">		if (2 &gt; iNumEdge) return null;</span>

<span class="fc" id="L890">		java.util.List&lt;org.drip.analytics.cashflow.CompositePeriod&gt; lsCFP = new</span>
			java.util.ArrayList&lt;org.drip.analytics.cashflow.CompositePeriod&gt;();

<span class="fc bfc" id="L893" title="All 2 branches covered.">		for (int i = 1; i &lt; iNumEdge; ++i) {</span>
			try {
<span class="fc" id="L895">				lsCFP.add (new org.drip.analytics.cashflow.CompositeFixedPeriod (cps, FixedUnits</span>
<span class="fc" id="L896">					(lsCompositeEdgeDate.get (i - 1), lsCompositeEdgeDate.get (i), ucas, cfus)));</span>
<span class="nc" id="L897">			} catch (java.lang.Exception e) {</span>
<span class="nc" id="L898">				e.printStackTrace();</span>

<span class="nc" id="L900">				return null;</span>
<span class="fc" id="L901">			}</span>
		}

<span class="fc" id="L904">		return lsCFP;</span>
	}

	/**
	 * Construct the List of Composite Floating Period from the corresponding Composable Floating Period
	 *  Units
	 * 
	 * @param lsCompositeEdgeDate The Composite Period Edge Dates
	 * @param cps Composite Period Setting Instance
	 * @param cfus Composable Floating Unit Setting
	 * 
	 * @return List of Composite Floating Periods
	 */

	public static final java.util.List&lt;org.drip.analytics.cashflow.CompositePeriod&gt; FloatingCompositeUnit (
		final java.util.List&lt;java.lang.Integer&gt; lsCompositeEdgeDate,
		final org.drip.param.period.CompositePeriodSetting cps,
		final org.drip.param.period.ComposableFloatingUnitSetting cfus)
	{
<span class="pc bpc" id="L923" title="1 of 2 branches missed.">		if (null == lsCompositeEdgeDate) return null;</span>

<span class="fc" id="L925">		int iNumEdge = lsCompositeEdgeDate.size();</span>

<span class="pc bpc" id="L927" title="1 of 2 branches missed.">		if (2 &gt; iNumEdge) return null;</span>

<span class="fc" id="L929">		java.util.List&lt;org.drip.analytics.cashflow.CompositePeriod&gt; lsCFP = new</span>
			java.util.ArrayList&lt;org.drip.analytics.cashflow.CompositePeriod&gt;();

<span class="fc bfc" id="L932" title="All 2 branches covered.">		for (int i = 1; i &lt; iNumEdge; ++i) {</span>
			try {
<span class="fc" id="L934">				lsCFP.add (new org.drip.analytics.cashflow.CompositeFloatingPeriod (cps, FloatingUnits</span>
<span class="fc" id="L935">					(lsCompositeEdgeDate.get (i - 1), lsCompositeEdgeDate.get (i), cfus)));</span>
<span class="nc" id="L936">			} catch (java.lang.Exception e) {</span>
<span class="nc" id="L937">				e.printStackTrace();</span>

<span class="nc" id="L939">				return null;</span>
<span class="fc" id="L940">			}</span>
		}

<span class="fc" id="L943">		return lsCFP;</span>
	}
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.7.9.201702052155</span></div></body></html>