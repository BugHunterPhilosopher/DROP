<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>LatentMarketStateBuilder.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">DROP</a> &gt; <a href="index.source.html" class="el_package">org.drip.service.template</a> &gt; <span class="el_source">LatentMarketStateBuilder.java</span></div><h1>LatentMarketStateBuilder.java</h1><pre class="source lang-java linenums">
package org.drip.service.template;

/*
 * -*- mode: java; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*-
 */

/*!
 * Copyright (C) 2019 Lakshmi Krishnamurthy
 * Copyright (C) 2018 Lakshmi Krishnamurthy
 * Copyright (C) 2017 Lakshmi Krishnamurthy
 * Copyright (C) 2016 Lakshmi Krishnamurthy
 * Copyright (C) 2015 Lakshmi Krishnamurthy
 * 
 *  This file is part of DROP, an open-source library targeting risk, transaction costs, exposure, margin
 *  	calculations, and portfolio construction within and across fixed income, credit, commodity, equity,
 *  	FX, and structured products.
 *  
 *  	https://lakshmidrip.github.io/DROP/
 *  
 *  DROP is composed of three main modules:
 *  
 *  - DROP Analytics Core - https://lakshmidrip.github.io/DROP-Analytics-Core/
 *  - DROP Portfolio Core - https://lakshmidrip.github.io/DROP-Portfolio-Core/
 *  - DROP Numerical Core - https://lakshmidrip.github.io/DROP-Numerical-Core/
 * 
 * 	DROP Analytics Core implements libraries for the following:
 * 	- Fixed Income Analytics
 * 	- Asset Backed Analytics
 * 	- XVA Analytics
 * 	- Exposure and Margin Analytics
 * 
 * 	DROP Portfolio Core implements libraries for the following:
 * 	- Asset Allocation Analytics
 * 	- Transaction Cost Analytics
 * 
 * 	DROP Numerical Core implements libraries for the following:
 * 	- Statistical Learning Library
 * 	- Numerical Optimizer Library
 * 	- Machine Learning Library
 * 	- Spline Builder Library
 * 
 * 	Documentation for DROP is Spread Over:
 * 
 * 	- Main                     =&gt; https://lakshmidrip.github.io/DROP/
 * 	- Wiki                     =&gt; https://github.com/lakshmiDRIP/DROP/wiki
 * 	- GitHub                   =&gt; https://github.com/lakshmiDRIP/DROP
 * 	- Javadoc                  =&gt; https://lakshmidrip.github.io/DROP/Javadoc/index.html
 * 	- Technical Specifications =&gt; https://github.com/lakshmiDRIP/DROP/tree/master/Docs/Internal
 * 	- Release Versions         =&gt; https://lakshmidrip.github.io/DROP/version.html
 * 	- Community Credits        =&gt; https://lakshmidrip.github.io/DROP/credits.html
 * 	- Issues Catalog           =&gt; https://github.com/lakshmiDRIP/DROP/issues
 * 	- JUnit                    =&gt; https://lakshmidrip.github.io/DROP/junit/index.html
 * 	- Jacoco                   =&gt; https://lakshmidrip.github.io/DROP/jacoco/index.html
 * 
 *  Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 *   	you may not use this file except in compliance with the License.
 *   
 *  You may obtain a copy of the License at
 *  	http://www.apache.org/licenses/LICENSE-2.0
 *  
 *  Unless required by applicable law or agreed to in writing, software
 *  	distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 *  	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  
 *  See the License for the specific language governing permissions and
 *  	limitations under the License.
 */

/**
 * &lt;i&gt;LatentMarketStateBuilder&lt;/i&gt; contains static Helper API to facilitate Construction of the Latent Market
 * States as Curves/Surfaces.
 * 
 * &lt;br&gt;&lt;br&gt;
 *  &lt;ul&gt;
 *		&lt;li&gt;&lt;b&gt;Module &lt;/b&gt; = &lt;a href = &quot;https://github.com/lakshmiDRIP/DROP/tree/master/NumericalCore.md&quot;&gt;Numerical Core Module&lt;/a&gt;&lt;/li&gt;
 *		&lt;li&gt;&lt;b&gt;Library&lt;/b&gt; = &lt;a href = &quot;https://github.com/lakshmiDRIP/DROP/tree/master/AlgorithmSupportLibrary.md&quot;&gt;Algorithm Support Library&lt;/a&gt;&lt;/li&gt;
 *		&lt;li&gt;&lt;b&gt;Project&lt;/b&gt; = &lt;a href = &quot;https://github.com/lakshmiDRIP/DROP/tree/master/src/main/java/org/drip/service&quot;&gt;Service&lt;/a&gt;&lt;/li&gt;
 *		&lt;li&gt;&lt;b&gt;Package&lt;/b&gt; = &lt;a href = &quot;https://github.com/lakshmiDRIP/DROP/tree/master/src/main/java/org/drip/service/template&quot;&gt;Curve Construction Product Builder Templates&lt;/a&gt;&lt;/li&gt;
 *  &lt;/ul&gt;
 * &lt;br&gt;&lt;br&gt;
 *
 * @author Lakshmi Krishnamurthy
 */

<span class="nc" id="L86">public class LatentMarketStateBuilder {</span>

	/**
	 * Shape Preserving Latent State
	 */

	public static final int SHAPE_PRESERVING = 0;

	/**
	 * Smoothened Latent State
	 */

	public static final int SMOOTH = 1;

	/**
	 * Construct a Funding Curve Based off of the Input Exchange/OTC Market Instruments Using the specified
	 *  Spline
	 * 
	 * @param dtSpot The Spot Date
	 * @param strCurrency Currency
	 * @param astrDepositMaturityTenor Array of Deposit Maturity Tenors
	 * @param adblDepositQuote Array of Deposit Quotes
	 * @param strDepositMeasure Deposit Calibration Measure
	 * @param adblFuturesQuote Array of Futures Quotes
	 * @param strFuturesMeasure Futures Calibration Measure
	 * @param astrFixFloatMaturityTenor Array of Fix Float Swap Maturity Tenors
	 * @param adblFixFloatQuote Array of Fix Float Swap Quotes
	 * @param strFixFloatMeasure Fix Float Calibration Measure
	 * @param scbc Segment Custom Builder Control
	 * 
	 * @return The Funding Curve Instance
	 */

	public static final org.drip.state.discount.MergedDiscountForwardCurve FundingCurve (
		final org.drip.analytics.date.JulianDate dtSpot,
		final java.lang.String strCurrency,
		final java.lang.String[] astrDepositMaturityTenor,
		final double[] adblDepositQuote,
		final java.lang.String strDepositMeasure,
		final double[] adblFuturesQuote,
		final java.lang.String strFuturesMeasure,
		final java.lang.String[] astrFixFloatMaturityTenor,
		final double[] adblFixFloatQuote,
		final java.lang.String strFixFloatMeasure,
		final org.drip.spline.params.SegmentCustomBuilderControl scbc)
	{
<span class="pc bpc" id="L132" title="2 of 6 branches missed.">		if (null == dtSpot || null == strCurrency || strCurrency.isEmpty()) return null;</span>

<span class="fc" id="L134">		org.drip.analytics.date.JulianDate dtEffective = dtSpot.addBusDays (0, strCurrency);</span>

<span class="fc" id="L136">		org.drip.state.inference.LatentStateStretchSpec lsssDeposit = null;</span>
<span class="fc" id="L137">		org.drip.state.inference.LatentStateStretchSpec lsssFutures = null;</span>
<span class="fc" id="L138">		org.drip.state.inference.LatentStateStretchSpec lsssFixFloat = null;</span>
<span class="fc bfc" id="L139" title="All 2 branches covered.">		int iNumFuturesComp = null == adblFuturesQuote ? 0 : adblFuturesQuote.length;</span>
<span class="pc bpc" id="L140" title="1 of 2 branches missed.">		int iNumDepositQuote = null == adblDepositQuote ? 0 : adblDepositQuote.length;</span>
<span class="fc bfc" id="L141" title="All 2 branches covered.">		int iNumFixFloatQuote = null == adblFixFloatQuote ? 0 : adblFixFloatQuote.length;</span>
<span class="pc bpc" id="L142" title="1 of 2 branches missed.">		int iNumDepositComp = null == astrDepositMaturityTenor ? 0 : astrDepositMaturityTenor.length;</span>
<span class="fc bfc" id="L143" title="All 2 branches covered.">		int iNumFixFloatComp = null == astrFixFloatMaturityTenor ? 0 : astrFixFloatMaturityTenor.length;</span>

<span class="pc bpc" id="L145" title="2 of 4 branches missed.">		if (iNumDepositQuote != iNumDepositComp || iNumFixFloatQuote != iNumFixFloatComp) return null;</span>

<span class="pc bpc" id="L147" title="1 of 2 branches missed.">		if (0 != iNumDepositComp)</span>
<span class="fc" id="L148">			lsssDeposit = org.drip.state.estimator.LatentStateStretchBuilder.ForwardFundingStretchSpec</span>
<span class="fc" id="L149">				(&quot;DEPOSIT&quot;, org.drip.service.template.OTCInstrumentBuilder.FundingDeposit (dtEffective,</span>
					strCurrency, astrDepositMaturityTenor), strDepositMeasure, adblDepositQuote);

<span class="fc bfc" id="L152" title="All 2 branches covered.">		if (0 != iNumFuturesComp)</span>
<span class="fc" id="L153">			lsssFutures = org.drip.state.estimator.LatentStateStretchBuilder.ForwardFundingStretchSpec</span>
<span class="fc" id="L154">				(&quot;FUTURES&quot;, org.drip.service.template.ExchangeInstrumentBuilder.ForwardRateFuturesPack</span>
<span class="fc" id="L155">					(dtEffective, iNumFuturesComp, strCurrency), strFuturesMeasure, adblFuturesQuote);</span>

<span class="fc bfc" id="L157" title="All 2 branches covered.">		if (0 != iNumFixFloatComp)</span>
<span class="fc" id="L158">			lsssFixFloat = org.drip.state.estimator.LatentStateStretchBuilder.ForwardFundingStretchSpec</span>
<span class="fc" id="L159">				(&quot;FIXFLOAT&quot;, org.drip.service.template.OTCInstrumentBuilder.FixFloatStandard (dtEffective,</span>
					strCurrency, &quot;ALL&quot;, astrFixFloatMaturityTenor, &quot;MAIN&quot;, 0.), strFixFloatMeasure,
						adblFixFloatQuote);

		try {
<span class="fc" id="L164">			org.drip.state.inference.LinearLatentStateCalibrator lcc = new</span>
				org.drip.state.inference.LinearLatentStateCalibrator (scbc,
<span class="fc" id="L166">					org.drip.spline.stretch.BoundarySettings.NaturalStandard(),</span>
						org.drip.spline.stretch.MultiSegmentSequence.CALIBRATE, null, null);

<span class="fc" id="L169">			return org.drip.state.creator.ScenarioDiscountCurveBuilder.ShapePreservingDFBuild (strCurrency,</span>
				lcc, new org.drip.state.inference.LatentStateStretchSpec[] {lsssDeposit, lsssFutures,
<span class="fc" id="L171">					lsssFixFloat}, org.drip.param.valuation.ValuationParams.Spot (dtSpot.julian()), null,</span>
						null, null, 1.);
<span class="nc" id="L173">		} catch (java.lang.Exception e) {</span>
<span class="nc" id="L174">			e.printStackTrace();</span>
		}

<span class="nc" id="L177">		return null;</span>
	}

	/**
	 * Construct a Single Stretch Funding Curve Based off of the Input Exchange/OTC Market Instruments Using
	 *  the specified Spline
	 * 
	 * @param dtSpot The Spot Date
	 * @param strCurrency Currency
	 * @param astrDepositMaturityTenor Array of Deposit Maturity Tenors
	 * @param adblDepositQuote Array of Deposit Quotes
	 * @param strDepositMeasure Deposit Calibration Measure
	 * @param adblFuturesQuote Array of Futures Quotes
	 * @param strFuturesMeasure Futures Calibration Measure
	 * @param astrFixFloatMaturityTenor Array of Fix Float Swap Maturity Tenors
	 * @param adblFixFloatQuote Array of Fix Float Swap Quotes
	 * @param strFixFloatMeasure Fix Float Calibration Measure
	 * @param scbc Segment Custom Builder Control
	 * 
	 * @return The Funding Curve Instance
	 */

	public static final org.drip.state.discount.MergedDiscountForwardCurve SingleStretchFundingCurve (
		final org.drip.analytics.date.JulianDate dtSpot,
		final java.lang.String strCurrency,
		final java.lang.String[] astrDepositMaturityTenor,
		final double[] adblDepositQuote,
		final java.lang.String strDepositMeasure,
		final double[] adblFuturesQuote,
		final java.lang.String strFuturesMeasure,
		final java.lang.String[] astrFixFloatMaturityTenor,
		final double[] adblFixFloatQuote,
		final java.lang.String strFixFloatMeasure,
		final org.drip.spline.params.SegmentCustomBuilderControl scbc)
	{
<span class="pc bpc" id="L212" title="3 of 6 branches missed.">		if (null == dtSpot || null == strCurrency || strCurrency.isEmpty()) return null;</span>

<span class="fc" id="L214">		org.drip.analytics.date.JulianDate dtEffective = dtSpot.addBusDays (0, strCurrency);</span>

<span class="pc bpc" id="L216" title="1 of 2 branches missed.">		int iNumFixFloatComp = null == astrFixFloatMaturityTenor ? 0 : astrFixFloatMaturityTenor.length;</span>
<span class="pc bpc" id="L217" title="1 of 2 branches missed.">		int iNumDepositComp = null == astrDepositMaturityTenor ? 0 : astrDepositMaturityTenor.length;</span>
<span class="pc bpc" id="L218" title="1 of 2 branches missed.">		int iNumFixFloatQuote = null == adblFixFloatQuote ? 0 : adblFixFloatQuote.length;</span>
<span class="pc bpc" id="L219" title="1 of 2 branches missed.">		int iNumDepositQuote = null == adblDepositQuote ? 0 : adblDepositQuote.length;</span>
<span class="pc bpc" id="L220" title="1 of 2 branches missed.">		int iNumFuturesComp = null == adblFuturesQuote ? 0 : adblFuturesQuote.length;</span>
<span class="fc" id="L221">		org.drip.state.inference.LatentStateStretchSpec lsssDepositFutures = null;</span>
<span class="fc" id="L222">		org.drip.state.inference.LatentStateStretchSpec lsssFixFloat = null;</span>
<span class="fc" id="L223">		int iNumDepositFuturesComp = iNumDepositComp + iNumFuturesComp;</span>
<span class="fc" id="L224">		double[] adblDepositFuturesQuote = new double[iNumDepositFuturesComp];</span>

<span class="pc bpc" id="L226" title="2 of 4 branches missed.">		if (iNumDepositQuote != iNumDepositComp || iNumFixFloatQuote != iNumFixFloatComp) return null;</span>

<span class="fc bfc" id="L228" title="All 2 branches covered.">		for (int i = 0; i &lt; iNumDepositFuturesComp; ++i)</span>
<span class="fc bfc" id="L229" title="All 2 branches covered.">			adblDepositFuturesQuote[i] = i &lt; iNumDepositComp ? adblDepositQuote[i] :</span>
				adblFuturesQuote[i - iNumDepositComp];

<span class="pc bpc" id="L232" title="1 of 2 branches missed.">		if (0 != iNumDepositComp)</span>
<span class="fc" id="L233">			lsssDepositFutures = org.drip.state.estimator.LatentStateStretchBuilder.ForwardFundingStretchSpec</span>
<span class="fc" id="L234">				(&quot;DEPOSIT&quot;, org.drip.service.template.OTCInstrumentBuilder.FundingDepositFutures</span>
<span class="fc" id="L235">					(dtEffective, strCurrency, astrDepositMaturityTenor, iNumFuturesComp), strDepositMeasure,</span>
						adblDepositFuturesQuote);

<span class="pc bpc" id="L238" title="1 of 2 branches missed.">		if (0 != iNumFixFloatComp)</span>
<span class="fc" id="L239">			lsssFixFloat = org.drip.state.estimator.LatentStateStretchBuilder.ForwardFundingStretchSpec</span>
<span class="fc" id="L240">				(&quot;FIXFLOAT&quot;, org.drip.service.template.OTCInstrumentBuilder.FixFloatStandard (dtEffective,</span>
					strCurrency, &quot;ALL&quot;, astrFixFloatMaturityTenor, &quot;MAIN&quot;, 0.), strFixFloatMeasure,
						adblFixFloatQuote);

		try {
<span class="fc" id="L245">			org.drip.state.inference.LinearLatentStateCalibrator lcc = new</span>
				org.drip.state.inference.LinearLatentStateCalibrator (scbc,
<span class="fc" id="L247">					org.drip.spline.stretch.BoundarySettings.NaturalStandard(),</span>
						org.drip.spline.stretch.MultiSegmentSequence.CALIBRATE, null, null);

<span class="fc" id="L250">			return org.drip.state.creator.ScenarioDiscountCurveBuilder.ShapePreservingDFBuild (strCurrency,</span>
				lcc, new org.drip.state.inference.LatentStateStretchSpec[] {lsssDepositFutures,
<span class="fc" id="L252">					lsssFixFloat}, org.drip.param.valuation.ValuationParams.Spot (dtSpot.julian()), null,</span>
						null, null, 1.);
<span class="nc" id="L254">		} catch (java.lang.Exception e) {</span>
<span class="nc" id="L255">			e.printStackTrace();</span>
		}

<span class="nc" id="L258">		return null;</span>
	}

	/**
	 * Construct a Shape Preserving Single Stretch Funding Curve Based off of the Input Exchange/OTC Market
	 *  Instruments
	 * 
	 * @param dtSpot The Spot Date
	 * @param strCurrency Currency
	 * @param astrDepositMaturityTenor Array of Deposit Maturity Tenors
	 * @param adblDepositQuote Array of Deposit Quotes
	 * @param strDepositMeasure Deposit Calibration Measure
	 * @param adblFuturesQuote Array of Futures Quotes
	 * @param strFuturesMeasure Futures Calibration Measure
	 * @param astrFixFloatMaturityTenor Array of Fix Float Swap Maturity Tenors
	 * @param adblFixFloatQuote Array of Fix Float Swap Quotes
	 * @param strFixFloatMeasure Fix Float Calibration Measure
	 * 
	 * @return The Single Stretch Funding Curve Instance
	 */

	public static final org.drip.state.discount.MergedDiscountForwardCurve SingleStretchShapePreservingFundingCurve (
		final org.drip.analytics.date.JulianDate dtSpot,
		final java.lang.String strCurrency,
		final java.lang.String[] astrDepositMaturityTenor,
		final double[] adblDepositQuote,
		final java.lang.String strDepositMeasure,
		final double[] adblFuturesQuote,
		final java.lang.String strFuturesMeasure,
		final java.lang.String[] astrFixFloatMaturityTenor,
		final double[] adblFixFloatQuote,
		final java.lang.String strFixFloatMeasure)
	{
		try {
<span class="fc" id="L292">			return SingleStretchFundingCurve (dtSpot, strCurrency, astrDepositMaturityTenor, adblDepositQuote,</span>
				strDepositMeasure, adblFuturesQuote, strFuturesMeasure, astrFixFloatMaturityTenor,
					adblFixFloatQuote, strFixFloatMeasure, new
						org.drip.spline.params.SegmentCustomBuilderControl
							(org.drip.spline.stretch.MultiSegmentSequenceBuilder.BASIS_SPLINE_POLYNOMIAL, new
								org.drip.spline.basis.PolynomialFunctionSetParams (2),
<span class="fc" id="L298">									org.drip.spline.params.SegmentInelasticDesignControl.Create (0, 2), new</span>
										org.drip.spline.params.ResponseScalingShapeControl (true, new
											org.drip.function.r1tor1.QuadraticRationalShapeControl (0.)),
												null));
<span class="nc" id="L302">		} catch (java.lang.Exception e) {</span>
<span class="nc" id="L303">			e.printStackTrace();</span>
		}

<span class="nc" id="L306">		return null;</span>
	}

	/**
	 * Construct a Shape Preserving Funding Curve Based off of the Input Exchange/OTC Market Instruments
	 * 
	 * @param dtSpot The Spot Date
	 * @param strCurrency Currency
	 * @param astrDepositMaturityTenor Array of Deposit Maturity Tenors
	 * @param adblDepositQuote Array of Deposit Quotes
	 * @param strDepositMeasure Deposit Calibration Measure
	 * @param adblFuturesQuote Array of Futures Quotes
	 * @param strFuturesMeasure Futures Calibration Measure
	 * @param astrFixFloatMaturityTenor Array of Fix Float Swap Maturity Tenors
	 * @param adblFixFloatQuote Array of Fix Float Swap Quotes
	 * @param strFixFloatMeasure Fix Float Calibration Measure
	 * 
	 * @return The Funding Curve Instance
	 */

	public static final org.drip.state.discount.MergedDiscountForwardCurve ShapePreservingFundingCurve (
		final org.drip.analytics.date.JulianDate dtSpot,
		final java.lang.String strCurrency,
		final java.lang.String[] astrDepositMaturityTenor,
		final double[] adblDepositQuote,
		final java.lang.String strDepositMeasure,
		final double[] adblFuturesQuote,
		final java.lang.String strFuturesMeasure,
		final java.lang.String[] astrFixFloatMaturityTenor,
		final double[] adblFixFloatQuote,
		final java.lang.String strFixFloatMeasure)
	{
		try {
<span class="nc" id="L339">			return FundingCurve (dtSpot, strCurrency, astrDepositMaturityTenor, adblDepositQuote,</span>
				strDepositMeasure, adblFuturesQuote, strFuturesMeasure, astrFixFloatMaturityTenor,
					adblFixFloatQuote, strFixFloatMeasure, new
						org.drip.spline.params.SegmentCustomBuilderControl
							(org.drip.spline.stretch.MultiSegmentSequenceBuilder.BASIS_SPLINE_POLYNOMIAL, new
								org.drip.spline.basis.PolynomialFunctionSetParams (2),
<span class="nc" id="L345">									org.drip.spline.params.SegmentInelasticDesignControl.Create (0, 2), new</span>
										org.drip.spline.params.ResponseScalingShapeControl (true, new
											org.drip.function.r1tor1.QuadraticRationalShapeControl (0.)),
												null));
<span class="nc" id="L349">		} catch (java.lang.Exception e) {</span>
<span class="nc" id="L350">			e.printStackTrace();</span>
		}

<span class="nc" id="L353">		return null;</span>
	}

	/**
	 * Construct a Smooth Funding Curve Based off of the Input Exchange/OTC Market Instruments
	 * 
	 * @param dtSpot The Spot Date
	 * @param strCurrency Currency
	 * @param astrDepositMaturityTenor Array of Deposit Maturity Tenors
	 * @param adblDepositQuote Array of Deposit Quotes
	 * @param strDepositMeasure Deposit Calibration Measure
	 * @param adblFuturesQuote Array of Futures Quotes
	 * @param strFuturesMeasure Futures Calibration Measure
	 * @param astrFixFloatMaturityTenor Array of Fix Float Swap Maturity Tenors
	 * @param adblFixFloatQuote Array of Fix Float Swap Quotes
	 * @param strFixFloatMeasure Fix Float Calibration Measure
	 * 
	 * @return The Funding Curve Instance
	 */

	public static final org.drip.state.discount.MergedDiscountForwardCurve SmoothFundingCurve (
		final org.drip.analytics.date.JulianDate dtSpot,
		final java.lang.String strCurrency,
		final java.lang.String[] astrDepositMaturityTenor,
		final double[] adblDepositQuote,
		final java.lang.String strDepositMeasure,
		final double[] adblFuturesQuote,
		final java.lang.String strFuturesMeasure,
		final java.lang.String[] astrFixFloatMaturityTenor,
		final double[] adblFixFloatQuote,
		final java.lang.String strFixFloatMeasure)
	{
		try {
<span class="fc" id="L386">			return FundingCurve (dtSpot, strCurrency, astrDepositMaturityTenor, adblDepositQuote,</span>
				strDepositMeasure, adblFuturesQuote, strFuturesMeasure, astrFixFloatMaturityTenor,
					adblFixFloatQuote, strFixFloatMeasure, new
						org.drip.spline.params.SegmentCustomBuilderControl
							(org.drip.spline.stretch.MultiSegmentSequenceBuilder.BASIS_SPLINE_POLYNOMIAL, new
								org.drip.spline.basis.PolynomialFunctionSetParams (4),
<span class="fc" id="L392">									org.drip.spline.params.SegmentInelasticDesignControl.Create (2, 2), new</span>
										org.drip.spline.params.ResponseScalingShapeControl (true, new
											org.drip.function.r1tor1.QuadraticRationalShapeControl (0.)),
												null));
<span class="nc" id="L396">		} catch (java.lang.Exception e) {</span>
<span class="nc" id="L397">			e.printStackTrace();</span>
		}

<span class="nc" id="L400">		return null;</span>
	}

	/**
	 * Construct a Smooth Single Stretch Funding Curve Based off of the Input Exchange/OTC Market Instruments
	 * 
	 * @param dtSpot The Spot Date
	 * @param strCurrency Currency
	 * @param astrDepositMaturityTenor Array of Deposit Maturity Tenors
	 * @param adblDepositQuote Array of Deposit Quotes
	 * @param strDepositMeasure Deposit Calibration Measure
	 * @param adblFuturesQuote Array of Futures Quotes
	 * @param strFuturesMeasure Futures Calibration Measure
	 * @param astrFixFloatMaturityTenor Array of Fix Float Swap Maturity Tenors
	 * @param adblFixFloatQuote Array of Fix Float Swap Quotes
	 * @param strFixFloatMeasure Fix Float Calibration Measure
	 * 
	 * @return The Single Stretch Funding Curve Instance
	 */

	public static final org.drip.state.discount.MergedDiscountForwardCurve SingleStretchSmoothFundingCurve (
		final org.drip.analytics.date.JulianDate dtSpot,
		final java.lang.String strCurrency,
		final java.lang.String[] astrDepositMaturityTenor,
		final double[] adblDepositQuote,
		final java.lang.String strDepositMeasure,
		final double[] adblFuturesQuote,
		final java.lang.String strFuturesMeasure,
		final java.lang.String[] astrFixFloatMaturityTenor,
		final double[] adblFixFloatQuote,
		final java.lang.String strFixFloatMeasure)
	{
		try {
<span class="nc" id="L433">			return SingleStretchFundingCurve (dtSpot, strCurrency, astrDepositMaturityTenor,</span>
				adblDepositQuote, strDepositMeasure, adblFuturesQuote, strFuturesMeasure,
					astrFixFloatMaturityTenor, adblFixFloatQuote, strFixFloatMeasure, new
						org.drip.spline.params.SegmentCustomBuilderControl
							(org.drip.spline.stretch.MultiSegmentSequenceBuilder.BASIS_SPLINE_POLYNOMIAL, new
								org.drip.spline.basis.PolynomialFunctionSetParams (4),
<span class="nc" id="L439">									org.drip.spline.params.SegmentInelasticDesignControl.Create (2, 2), new</span>
										org.drip.spline.params.ResponseScalingShapeControl (true, new
											org.drip.function.r1tor1.QuadraticRationalShapeControl (0.)),
												null));
<span class="nc" id="L443">		} catch (java.lang.Exception e) {</span>
<span class="nc" id="L444">			e.printStackTrace();</span>
		}

<span class="nc" id="L447">		return null;</span>
	}

	/**
	 * Construct a Funding Curve Based off of the Input Exchange/OTC Market Instruments
	 * 
	 * @param dtSpot The Spot Date
	 * @param strCurrency Currency
	 * @param astrDepositMaturityTenor Array of Deposit Maturity Tenors
	 * @param adblDepositQuote Array of Deposit Quotes
	 * @param strDepositMeasure Deposit Calibration Measure
	 * @param adblFuturesQuote Array of Futures Quotes
	 * @param strFuturesMeasure Futures Calibration Measure
	 * @param astrFixFloatMaturityTenor Array of Fix Float Swap Maturity Tenors
	 * @param adblFixFloatQuote Array of Fix Float Swap Quotes
	 * @param strFixFloatMeasure Fix Float Calibration Measure
	 * @param iLatentStateType SHAPE_PRESERVING/SMOOTH
	 * 
	 * @return The Funding Curve Instance
	 */

	public static final org.drip.state.discount.MergedDiscountForwardCurve FundingCurve (
		final org.drip.analytics.date.JulianDate dtSpot,
		final java.lang.String strCurrency,
		final java.lang.String[] astrDepositMaturityTenor,
		final double[] adblDepositQuote,
		final java.lang.String strDepositMeasure,
		final double[] adblFuturesQuote,
		final java.lang.String strFuturesMeasure,
		final java.lang.String[] astrFixFloatMaturityTenor,
		final double[] adblFixFloatQuote,
		final java.lang.String strFixFloatMeasure,
		final int iLatentStateType)
	{
<span class="pc bpc" id="L481" title="1 of 2 branches missed.">		if (SHAPE_PRESERVING == iLatentStateType)</span>
<span class="nc" id="L482">			return ShapePreservingFundingCurve (dtSpot, strCurrency, astrDepositMaturityTenor, adblDepositQuote,</span>
				strDepositMeasure, adblFuturesQuote, strFuturesMeasure, astrFixFloatMaturityTenor,
					adblFixFloatQuote, strFixFloatMeasure);

<span class="pc bpc" id="L486" title="1 of 2 branches missed.">		if (SMOOTH == iLatentStateType)</span>
<span class="fc" id="L487">			return SmoothFundingCurve (dtSpot, strCurrency, astrDepositMaturityTenor, adblDepositQuote,</span>
				strDepositMeasure, adblFuturesQuote, strFuturesMeasure, astrFixFloatMaturityTenor,
					adblFixFloatQuote, strFixFloatMeasure);

<span class="nc" id="L491">		return null;</span>
	}

	/**
	 * Construct a Single Stretch Funding Curve Based off of the Input Exchange/OTC Market Instruments
	 * 
	 * @param dtSpot The Spot Date
	 * @param strCurrency Currency
	 * @param astrDepositMaturityTenor Array of Deposit Maturity Tenors
	 * @param adblDepositQuote Array of Deposit Quotes
	 * @param strDepositMeasure Deposit Calibration Measure
	 * @param adblFuturesQuote Array of Futures Quotes
	 * @param strFuturesMeasure Futures Calibration Measure
	 * @param astrFixFloatMaturityTenor Array of Fix Float Swap Maturity Tenors
	 * @param adblFixFloatQuote Array of Fix Float Swap Quotes
	 * @param strFixFloatMeasure Fix Float Calibration Measure
	 * @param iLatentStateType SHAPE_PRESERVING/SMOOTH
	 * 
	 * @return The Single Stretch Funding Curve Instance
	 */

	public static final org.drip.state.discount.MergedDiscountForwardCurve SingleStretchFundingCurve (
		final org.drip.analytics.date.JulianDate dtSpot,
		final java.lang.String strCurrency,
		final java.lang.String[] astrDepositMaturityTenor,
		final double[] adblDepositQuote,
		final java.lang.String strDepositMeasure,
		final double[] adblFuturesQuote,
		final java.lang.String strFuturesMeasure,
		final java.lang.String[] astrFixFloatMaturityTenor,
		final double[] adblFixFloatQuote,
		final java.lang.String strFixFloatMeasure,
		final int iLatentStateType)
	{
<span class="pc bpc" id="L525" title="1 of 2 branches missed.">		if (SHAPE_PRESERVING == iLatentStateType)</span>
<span class="fc" id="L526">			return SingleStretchShapePreservingFundingCurve (dtSpot, strCurrency, astrDepositMaturityTenor,</span>
				adblDepositQuote, strDepositMeasure, adblFuturesQuote, strFuturesMeasure,
					astrFixFloatMaturityTenor, adblFixFloatQuote, strFixFloatMeasure);

<span class="nc bnc" id="L530" title="All 2 branches missed.">		if (SMOOTH == iLatentStateType)</span>
<span class="nc" id="L531">			return SingleStretchSmoothFundingCurve (dtSpot, strCurrency, astrDepositMaturityTenor,</span>
				adblDepositQuote, strDepositMeasure, adblFuturesQuote, strFuturesMeasure,
					astrFixFloatMaturityTenor, adblFixFloatQuote, strFixFloatMeasure);

<span class="nc" id="L535">		return null;</span>
	}

	/**
	 * Construct a Instance of the Forward Curve off of Exchange/OTC Market Instruments
	 * 
	 * @param dtSpot Spot Date
	 * @param forwardLabel Forward Label
	 * @param astrDepositMaturityTenor Array of Deposit Maturity Tenors
	 * @param adblDepositQuote Array of the Deposit Instrument Quotes
	 * @param strDepositMeasure The Deposit Instrument Calibration Measure
	 * @param astrFRAMaturityTenor Array of FRA Maturity Tenors
	 * @param adblFRAQuote Array of the FRA Instrument Quotes
	 * @param strFRAMeasure The FRA Instrument Calibration Measure
	 * @param astrFixFloatMaturityTenor Array of Fix-Float Maturity Tenors
	 * @param adblFixFloatQuote Array of the Fix-Float Quotes
	 * @param strFixFloatMeasure The Fix-Float Calibration Measure
	 * @param astrFloatFloatMaturityTenor Array of Float-Float Maturity Tenors
	 * @param adblFloatFloatQuote Array of the Float-Float Quotes
	 * @param strFloatFloatMeasure The Float-Float Calibration Measure
	 * @param astrSyntheticFloatFloatMaturityTenor Array of Synthetic Float-Float Maturity Tenors
	 * @param adblSyntheticFloatFloatQuote Array of the Synthetic Float-Float Quotes
	 * @param strSyntheticFloatFloatMeasure The Synthetic Float-Float Calibration Measure
	 * @param dc The Base Discount Curve
	 * @param fcReference The Reference Forward Curve
	 * @param scbc Segment Custom Builder Control Parameters
	 * 
	 * @return Instance of the Forward Curve
	 */

	public static final org.drip.state.forward.ForwardCurve ForwardCurve (
		final org.drip.analytics.date.JulianDate dtSpot,
		final org.drip.state.identifier.ForwardLabel forwardLabel,
		final java.lang.String[] astrDepositMaturityTenor,
		final double[] adblDepositQuote,
		final java.lang.String strDepositMeasure,
		final java.lang.String[] astrFRAMaturityTenor,
		final double[] adblFRAQuote,
		final java.lang.String strFRAMeasure,
		final java.lang.String[] astrFixFloatMaturityTenor,
		final double[] adblFixFloatQuote,
		final java.lang.String strFixFloatMeasure,
		final java.lang.String[] astrFloatFloatMaturityTenor,
		final double[] adblFloatFloatQuote,
		final java.lang.String strFloatFloatMeasure,
		final java.lang.String[] astrSyntheticFloatFloatMaturityTenor,
		final double[] adblSyntheticFloatFloatQuote,
		final java.lang.String strSyntheticFloatFloatMeasure,
		final org.drip.state.discount.MergedDiscountForwardCurve dc,
		final org.drip.state.forward.ForwardCurve fcReference,
		final org.drip.spline.params.SegmentCustomBuilderControl scbc)
	{
<span class="pc bpc" id="L587" title="3 of 6 branches missed.">		if (null == dtSpot || null == forwardLabel || null == dc) return null;</span>

<span class="fc" id="L589">		java.lang.String strCurrency = forwardLabel.currency();</span>

<span class="fc" id="L591">		org.drip.analytics.date.JulianDate dtEffective = dtSpot.addBusDays (0, strCurrency);</span>

<span class="fc" id="L593">		org.drip.state.inference.LatentStateStretchSpec lsssFRA = null;</span>
<span class="fc" id="L594">		org.drip.state.inference.LinearLatentStateCalibrator lcc = null;</span>
<span class="fc bfc" id="L595" title="All 2 branches covered.">		int iNumFRAQuote = null == adblFRAQuote ? 0 : adblFRAQuote.length;</span>
<span class="fc" id="L596">		org.drip.state.inference.LatentStateStretchSpec lsssDeposit = null;</span>
<span class="fc" id="L597">		org.drip.state.inference.LatentStateStretchSpec lsssFixFloat = null;</span>
<span class="fc" id="L598">		org.drip.state.inference.LatentStateStretchSpec lsssFloatFloat = null;</span>
<span class="pc bpc" id="L599" title="1 of 2 branches missed.">		int iNumDepositQuote = null == adblDepositQuote ? 0 : adblDepositQuote.length;</span>
<span class="fc" id="L600">		org.drip.state.inference.LatentStateStretchSpec lsssSyntheticFloatFloat = null;</span>
<span class="fc bfc" id="L601" title="All 2 branches covered.">		int iNumFRAComp = null == astrFRAMaturityTenor ? 0 : astrFRAMaturityTenor.length;</span>
<span class="pc bpc" id="L602" title="1 of 2 branches missed.">		int iNumFixFloatQuote = null == adblFixFloatQuote ? 0 : adblFixFloatQuote.length;</span>
<span class="pc bpc" id="L603" title="1 of 2 branches missed.">		int iNumFloatFloatQuote = null == adblFloatFloatQuote ? 0 : adblFloatFloatQuote.length;</span>
<span class="pc bpc" id="L604" title="1 of 2 branches missed.">		int iNumDepositComp = null == astrDepositMaturityTenor ? 0 : astrDepositMaturityTenor.length;</span>
<span class="pc bpc" id="L605" title="1 of 2 branches missed.">		int iNumFixFloatComp = null == astrFixFloatMaturityTenor ? 0 : astrFixFloatMaturityTenor.length;</span>
<span class="pc bpc" id="L606" title="1 of 2 branches missed.">		int iNumFloatFloatComp = null == astrFloatFloatMaturityTenor ? 0 :</span>
			astrFloatFloatMaturityTenor.length;
<span class="fc bfc" id="L608" title="All 2 branches covered.">		int iNumSyntheticFloatFloatQuote = null == adblSyntheticFloatFloatQuote ? 0 :</span>
			adblSyntheticFloatFloatQuote.length;
<span class="fc bfc" id="L610" title="All 2 branches covered.">		int iNumSyntheticFloatFloatComp = null == astrSyntheticFloatFloatMaturityTenor ? 0 :</span>
			astrSyntheticFloatFloatMaturityTenor.length;

<span class="pc bpc" id="L613" title="5 of 10 branches missed.">		if (iNumDepositQuote != iNumDepositComp || iNumFRAQuote != iNumFRAComp || iNumFixFloatQuote !=</span>
			iNumFixFloatComp || iNumFloatFloatQuote != iNumFloatFloatComp || iNumSyntheticFloatFloatQuote !=
				iNumSyntheticFloatFloatComp)
<span class="nc" id="L616">			return null;</span>

<span class="pc bpc" id="L618" title="1 of 2 branches missed.">		if (0 != iNumDepositComp)</span>
<span class="fc" id="L619">			lsssDeposit = org.drip.state.estimator.LatentStateStretchBuilder.ForwardStretchSpec (&quot;DEPOSIT&quot;,</span>
<span class="fc" id="L620">				org.drip.service.template.OTCInstrumentBuilder.ForwardRateDeposit (dtEffective,</span>
					astrDepositMaturityTenor, forwardLabel), strDepositMeasure, adblDepositQuote);

<span class="fc bfc" id="L623" title="All 2 branches covered.">		if (0 != iNumFRAComp)</span>
<span class="fc" id="L624">			lsssFRA = org.drip.state.estimator.LatentStateStretchBuilder.ForwardStretchSpec (&quot;FRA&quot;,</span>
<span class="fc" id="L625">				org.drip.service.template.OTCInstrumentBuilder.FRAStandard (dtEffective, forwardLabel,</span>
					astrFRAMaturityTenor, adblFRAQuote), strFRAMeasure, adblFRAQuote);

<span class="pc bpc" id="L628" title="1 of 2 branches missed.">		if (0 != iNumFixFloatComp)</span>
<span class="fc" id="L629">			lsssFixFloat = org.drip.state.estimator.LatentStateStretchBuilder.ForwardStretchSpec (&quot;FIXFLOAT&quot;,</span>
<span class="fc" id="L630">				org.drip.service.template.OTCInstrumentBuilder.FixFloatCustom (dtEffective, forwardLabel,</span>
					astrFixFloatMaturityTenor), strFixFloatMeasure, adblFixFloatQuote);

<span class="pc bpc" id="L633" title="1 of 2 branches missed.">		if (0 != iNumFloatFloatComp)</span>
<span class="nc" id="L634">			lsssFloatFloat = org.drip.state.estimator.LatentStateStretchBuilder.ForwardStretchSpec</span>
<span class="nc" id="L635">				(&quot;FLOATFLOAT&quot;, org.drip.service.template.OTCInstrumentBuilder.FloatFloat (dtEffective,</span>
<span class="nc" id="L636">					strCurrency, forwardLabel.tenor(), astrFloatFloatMaturityTenor, 0.),</span>
						strFloatFloatMeasure, adblFloatFloatQuote);

<span class="fc bfc" id="L639" title="All 2 branches covered.">		if (0 != iNumSyntheticFloatFloatComp)</span>
<span class="fc" id="L640">			lsssSyntheticFloatFloat = org.drip.state.estimator.LatentStateStretchBuilder.ForwardStretchSpec</span>
<span class="fc" id="L641">				(&quot;SYNTHETICFLOATFLOAT&quot;, org.drip.service.template.OTCInstrumentBuilder.FloatFloat</span>
<span class="fc" id="L642">					(dtEffective, strCurrency, forwardLabel.tenor(), astrSyntheticFloatFloatMaturityTenor,</span>
						0.), strSyntheticFloatFloatMeasure, adblSyntheticFloatFloatQuote);

<span class="fc" id="L645">		org.drip.state.inference.LatentStateStretchSpec[] aStretchSpec = new</span>
			org.drip.state.inference.LatentStateStretchSpec[] {lsssDeposit, lsssFRA, lsssFixFloat,
				lsssFloatFloat, lsssSyntheticFloatFloat};

		try {
<span class="fc" id="L650">			lcc = new org.drip.state.inference.LinearLatentStateCalibrator (scbc,</span>
<span class="fc" id="L651">				org.drip.spline.stretch.BoundarySettings.NaturalStandard(),</span>
					org.drip.spline.stretch.MultiSegmentSequence.CALIBRATE, null, null);

<span class="fc" id="L654">			return org.drip.state.creator.ScenarioForwardCurveBuilder.ShapePreservingForwardCurve (lcc,</span>
				aStretchSpec, forwardLabel, org.drip.param.valuation.ValuationParams.Spot
<span class="pc bpc" id="L656" title="1 of 2 branches missed.">					(dtEffective.julian()), null, org.drip.param.creator.MarketParamsBuilder.Create (dc,</span>
						fcReference, null, null, null, null, null, null), null, 0 == iNumDepositComp ?
							adblFRAQuote[0] : adblDepositQuote[0]);
<span class="nc" id="L659">		} catch (java.lang.Exception e) {</span>
<span class="nc" id="L660">			e.printStackTrace();</span>
		}

<span class="nc" id="L663">		return null;</span>
	}

	/**
	 * Construct a Instance of the Shape Preserving Forward Curve off of Exchange/OTC Market Instruments
	 * 
	 * @param dtSpot Spot Date
	 * @param forwardLabel Forward Label
	 * @param astrDepositMaturityTenor Array of Deposit Maturity Tenors
	 * @param adblDepositQuote Array of the Deposit Instrument Quotes
	 * @param strDepositMeasure The Deposit Instrument Calibration Measure
	 * @param astrFRAMaturityTenor Array of FRA Maturity Tenors
	 * @param adblFRAQuote Array of the FRA Instrument Quotes
	 * @param strFRAMeasure The FRA Instrument Calibration Measure
	 * @param astrFixFloatMaturityTenor Array of Fix-Float Maturity Tenors
	 * @param adblFixFloatQuote Array of the Fix-Float Quotes
	 * @param strFixFloatMeasure The Fix-Float Calibration Measure
	 * @param astrFloatFloatMaturityTenor Array of Float-Float Maturity Tenors
	 * @param adblFloatFloatQuote Array of the Float-Float Quotes
	 * @param strFloatFloatMeasure The Float-Float Calibration Measure
	 * @param astrSyntheticFloatFloatMaturityTenor Array of Synthetic Float-Float Maturity Tenors
	 * @param adblSyntheticFloatFloatQuote Array of the Synthetic Float-Float Quotes
	 * @param strSyntheticFloatFloatMeasure The Synthetic Float-Float Calibration Measure
	 * @param dc The Base Discount Curve
	 * @param fcReference The Reference Forward Curve
	 * 
	 * @return Instance of the Forward Curve
	 */

	public static final org.drip.state.forward.ForwardCurve ShapePreservingForwardCurve (
		final org.drip.analytics.date.JulianDate dtSpot,
		final org.drip.state.identifier.ForwardLabel forwardLabel,
		final java.lang.String[] astrDepositMaturityTenor,
		final double[] adblDepositQuote,
		final java.lang.String strDepositMeasure,
		final java.lang.String[] astrFRAMaturityTenor,
		final double[] adblFRAQuote,
		final java.lang.String strFRAMeasure,
		final java.lang.String[] astrFixFloatMaturityTenor,
		final double[] adblFixFloatQuote,
		final java.lang.String strFixFloatMeasure,
		final java.lang.String[] astrFloatFloatMaturityTenor,
		final double[] adblFloatFloatQuote,
		final java.lang.String strFloatFloatMeasure,
		final java.lang.String[] astrSyntheticFloatFloatMaturityTenor,
		final double[] adblSyntheticFloatFloatQuote,
		final java.lang.String strSyntheticFloatFloatMeasure,
		final org.drip.state.discount.MergedDiscountForwardCurve dc,
		final org.drip.state.forward.ForwardCurve fcReference)
	{
		try {
<span class="fc" id="L714">			return ForwardCurve (dtSpot, forwardLabel, astrDepositMaturityTenor, adblDepositQuote,</span>
				strDepositMeasure, astrFRAMaturityTenor, adblFRAQuote, strFRAMeasure,
					astrFixFloatMaturityTenor, adblFixFloatQuote, strFixFloatMeasure,
						astrFloatFloatMaturityTenor, adblFloatFloatQuote, strFloatFloatMeasure,
							astrSyntheticFloatFloatMaturityTenor, adblSyntheticFloatFloatQuote,
								strSyntheticFloatFloatMeasure, dc, fcReference, new
									org.drip.spline.params.SegmentCustomBuilderControl
										(org.drip.spline.stretch.MultiSegmentSequenceBuilder.BASIS_SPLINE_POLYNOMIAL,
				new org.drip.spline.basis.PolynomialFunctionSetParams (2),
<span class="fc" id="L723">					org.drip.spline.params.SegmentInelasticDesignControl.Create (0, 2), new</span>
						org.drip.spline.params.ResponseScalingShapeControl (true, new
							org.drip.function.r1tor1.QuadraticRationalShapeControl (0.)), null));
<span class="nc" id="L726">		} catch (java.lang.Exception e) {</span>
<span class="nc" id="L727">			e.printStackTrace();</span>
		}

<span class="nc" id="L730">		return null;</span>
	}

	/**
	 * Construct a Instance of Smooth Forward Curve off of Exchange/OTC Market Instruments
	 * 
	 * @param dtSpot Spot Date
	 * @param forwardLabel Forward Label
	 * @param astrDepositMaturityTenor Array of Deposit Maturity Tenors
	 * @param adblDepositQuote Array of the Deposit Instrument Quotes
	 * @param strDepositMeasure The Deposit Instrument Calibration Measure
	 * @param astrFRAMaturityTenor Array of FRA Maturity Tenors
	 * @param adblFRAQuote Array of the FRA Instrument Quotes
	 * @param strFRAMeasure The FRA Instrument Calibration Measure
	 * @param astrFixFloatMaturityTenor Array of Fix-Float Maturity Tenors
	 * @param adblFixFloatQuote Array of the Fix-Float Quotes
	 * @param strFixFloatMeasure The Fix-Float Calibration Measure
	 * @param astrFloatFloatMaturityTenor Array of Float-Float Maturity Tenors
	 * @param adblFloatFloatQuote Array of the Float-Float Quotes
	 * @param strFloatFloatMeasure The Float-Float Calibration Measure
	 * @param astrSyntheticFloatFloatMaturityTenor Array of Synthetic Float-Float Maturity Tenors
	 * @param adblSyntheticFloatFloatQuote Array of the Synthetic Float-Float Quotes
	 * @param strSyntheticFloatFloatMeasure The Synthetic Float-Float Calibration Measure
	 * @param dc The Base Discount Curve
	 * @param fcReference The Reference Forward Curve
	 * 
	 * @return Instance of the Forward Curve
	 */

	public static final org.drip.state.forward.ForwardCurve SmoothForwardCurve (
		final org.drip.analytics.date.JulianDate dtSpot,
		final org.drip.state.identifier.ForwardLabel forwardLabel,
		final java.lang.String[] astrDepositMaturityTenor,
		final double[] adblDepositQuote,
		final java.lang.String strDepositMeasure,
		final java.lang.String[] astrFRAMaturityTenor,
		final double[] adblFRAQuote,
		final java.lang.String strFRAMeasure,
		final java.lang.String[] astrFixFloatMaturityTenor,
		final double[] adblFixFloatQuote,
		final java.lang.String strFixFloatMeasure,
		final java.lang.String[] astrFloatFloatMaturityTenor,
		final double[] adblFloatFloatQuote,
		final java.lang.String strFloatFloatMeasure,
		final java.lang.String[] astrSyntheticFloatFloatMaturityTenor,
		final double[] adblSyntheticFloatFloatQuote,
		final java.lang.String strSyntheticFloatFloatMeasure,
		final org.drip.state.discount.MergedDiscountForwardCurve dc,
		final org.drip.state.forward.ForwardCurve fcReference)
	{
		try {
<span class="fc" id="L781">			return ForwardCurve (dtSpot, forwardLabel, astrDepositMaturityTenor, adblDepositQuote,</span>
				strDepositMeasure, astrFRAMaturityTenor, adblFRAQuote, strFRAMeasure,
					astrFixFloatMaturityTenor, adblFixFloatQuote, strFixFloatMeasure,
						astrFloatFloatMaturityTenor, adblFloatFloatQuote, strFloatFloatMeasure,
							astrSyntheticFloatFloatMaturityTenor, adblSyntheticFloatFloatQuote,
								strSyntheticFloatFloatMeasure, dc, fcReference, new
									org.drip.spline.params.SegmentCustomBuilderControl
										(org.drip.spline.stretch.MultiSegmentSequenceBuilder.BASIS_SPLINE_POLYNOMIAL,
				new org.drip.spline.basis.PolynomialFunctionSetParams (4),
<span class="fc" id="L790">					org.drip.spline.params.SegmentInelasticDesignControl.Create (2, 2), new</span>
						org.drip.spline.params.ResponseScalingShapeControl (true, new
							org.drip.function.r1tor1.QuadraticRationalShapeControl (0.)), null));
<span class="nc" id="L793">		} catch (java.lang.Exception e) {</span>
<span class="nc" id="L794">			e.printStackTrace();</span>
		}

<span class="nc" id="L797">		return null;</span>
	}

	/**
	 * Construct a Instance of the Smooth/Shape Preserving Forward Curve off of Exchange/OTC Market
	 *  Instruments
	 * 
	 * @param dtSpot Spot Date
	 * @param forwardLabel Forward Label
	 * @param astrDepositMaturityTenor Array of Deposit Maturity Tenors
	 * @param adblDepositQuote Array of the Deposit Instrument Quotes
	 * @param strDepositMeasure The Deposit Instrument Calibration Measure
	 * @param astrFRAMaturityTenor Array of FRA Maturity Tenors
	 * @param adblFRAQuote Array of the FRA Instrument Quotes
	 * @param strFRAMeasure The FRA Instrument Calibration Measure
	 * @param astrFixFloatMaturityTenor Array of Fix-Float Maturity Tenors
	 * @param adblFixFloatQuote Array of the Fix-Float Quotes
	 * @param strFixFloatMeasure The Fix-Float Calibration Measure
	 * @param astrFloatFloatMaturityTenor Array of Float-Float Maturity Tenors
	 * @param adblFloatFloatQuote Array of the Float-Float Quotes
	 * @param strFloatFloatMeasure The Float-Float Calibration Measure
	 * @param astrSyntheticFloatFloatMaturityTenor Array of Synthetic Float-Float Maturity Tenors
	 * @param adblSyntheticFloatFloatQuote Array of the Synthetic Float-Float Quotes
	 * @param strSyntheticFloatFloatMeasure The Synthetic Float-Float Calibration Measure
	 * @param dc The Base Discount Curve
	 * @param fcReference The Reference Forward Curve
	 * @param iLatentStateType SHAPE_PRESERVING/SMOOTH
	 * 
	 * @return Instance of the Forward Curve
	 */

	public static final org.drip.state.forward.ForwardCurve ForwardCurve (
		final org.drip.analytics.date.JulianDate dtSpot,
		final org.drip.state.identifier.ForwardLabel forwardLabel,
		final java.lang.String[] astrDepositMaturityTenor,
		final double[] adblDepositQuote,
		final java.lang.String strDepositMeasure,
		final java.lang.String[] astrFRAMaturityTenor,
		final double[] adblFRAQuote,
		final java.lang.String strFRAMeasure,
		final java.lang.String[] astrFixFloatMaturityTenor,
		final double[] adblFixFloatQuote,
		final java.lang.String strFixFloatMeasure,
		final java.lang.String[] astrFloatFloatMaturityTenor,
		final double[] adblFloatFloatQuote,
		final java.lang.String strFloatFloatMeasure,
		final java.lang.String[] astrSyntheticFloatFloatMaturityTenor,
		final double[] adblSyntheticFloatFloatQuote,
		final java.lang.String strSyntheticFloatFloatMeasure,
		final org.drip.state.discount.MergedDiscountForwardCurve dc,
		final org.drip.state.forward.ForwardCurve fcReference,
		final int iLatentStateType)
	{
<span class="pc bpc" id="L850" title="1 of 2 branches missed.">		if (SHAPE_PRESERVING == iLatentStateType)</span>
<span class="nc" id="L851">			return ShapePreservingForwardCurve (dtSpot, forwardLabel, astrDepositMaturityTenor,</span>
				adblDepositQuote, strDepositMeasure, astrFRAMaturityTenor, adblFRAQuote, strFRAMeasure,
					astrFixFloatMaturityTenor, adblFixFloatQuote, strFixFloatMeasure,
						astrFloatFloatMaturityTenor, adblFloatFloatQuote, strFloatFloatMeasure,
							astrSyntheticFloatFloatMaturityTenor, adblSyntheticFloatFloatQuote,
								strSyntheticFloatFloatMeasure, dc, fcReference);

<span class="pc bpc" id="L858" title="1 of 2 branches missed.">		if (SMOOTH == iLatentStateType)</span>
<span class="fc" id="L859">			return SmoothForwardCurve (dtSpot, forwardLabel, astrDepositMaturityTenor, adblDepositQuote,</span>
				strDepositMeasure, astrFRAMaturityTenor, adblFRAQuote, strFRAMeasure,
					astrFixFloatMaturityTenor, adblFixFloatQuote, strFixFloatMeasure,
						astrFloatFloatMaturityTenor, adblFloatFloatQuote, strFloatFloatMeasure,
							astrSyntheticFloatFloatMaturityTenor, adblSyntheticFloatFloatQuote,
								strSyntheticFloatFloatMeasure, dc, fcReference);

<span class="nc" id="L866">		return null;</span>
	}

	/**
	 * Construct an Overnight Curve from Overnight Exchange/OTC Market Instruments
	 * 
	 * @param dtSpot Spot Date
	 * @param strCurrency Currency
	 * @param astrDepositMaturityTenor Array of Deposit Maturity Tenors
	 * @param adblDepositQuote Array of Deposit Quotes
	 * @param strDepositMeasure Deposit Measure
	 * @param astrShortEndOISMaturityTenor Array of Short End OIS Maturity Tenors
	 * @param adblShortEndOISQuote Array of Short End OIS Quotes
	 * @param strShortEndOISMeasure Short End OIS Measure
	 * @param astrOISFuturesEffectiveTenor Array of OIS Futures Effective Tenors
	 * @param astrOISFuturesMaturityTenor Array of OIS Futures Maturity Tenors
	 * @param adblOISFuturesQuote Array of OIS Futures Quotes
	 * @param strOISFuturesMeasure OIS Futures Measure
	 * @param astrLongEndOISMaturityTenor Array of Long End OIS Maturity Tenors
	 * @param adblLongEndOISQuote Array of Long End OIS Quotes
	 * @param strLongEndOISMeasure Long End OIS Measure
	 * @param scbc Segment Custom Builder Control
	 * 
	 * @return Overnight Curve from Overnight OTC Instruments
	 */

	public static final org.drip.state.discount.MergedDiscountForwardCurve OvernightCurve (
		final org.drip.analytics.date.JulianDate dtSpot,
		final String strCurrency,
		final java.lang.String[] astrDepositMaturityTenor,
		final double[] adblDepositQuote,
		final java.lang.String strDepositMeasure,
		final java.lang.String[] astrShortEndOISMaturityTenor,
		final double[] adblShortEndOISQuote,
		final java.lang.String strShortEndOISMeasure,
		final java.lang.String[] astrOISFuturesEffectiveTenor,
		final java.lang.String[] astrOISFuturesMaturityTenor,
		final double[] adblOISFuturesQuote,
		final java.lang.String strOISFuturesMeasure,
		final java.lang.String[] astrLongEndOISMaturityTenor,
		final double[] adblLongEndOISQuote,
		final java.lang.String strLongEndOISMeasure,
		final org.drip.spline.params.SegmentCustomBuilderControl scbc)
	{
<span class="pc bpc" id="L910" title="1 of 2 branches missed.">		if (null == dtSpot) return null;</span>

<span class="fc" id="L912">		org.drip.state.inference.LatentStateStretchSpec lsssDeposit = null;</span>
<span class="fc" id="L913">		org.drip.state.inference.LatentStateStretchSpec lsssOISFutures = null;</span>
<span class="fc" id="L914">		org.drip.state.inference.LatentStateStretchSpec lsssLongEndOIS = null;</span>
<span class="fc" id="L915">		org.drip.state.inference.LatentStateStretchSpec lsssShortEndOIS = null;</span>
<span class="pc bpc" id="L916" title="1 of 2 branches missed.">		int iNumDepositQuote = null == adblDepositQuote ? 0 : adblDepositQuote.length;</span>
<span class="fc bfc" id="L917" title="All 2 branches covered.">		int iNumOISFuturesQuote = null == adblOISFuturesQuote ? 0 : adblOISFuturesQuote.length;</span>
<span class="fc bfc" id="L918" title="All 2 branches covered.">		int iNumLongEndOISQuote = null == adblLongEndOISQuote ? 0 : adblLongEndOISQuote.length;</span>
<span class="pc bpc" id="L919" title="1 of 2 branches missed.">		int iNumShortEndOISQuote = null == adblShortEndOISQuote ? 0 : adblShortEndOISQuote.length;</span>
<span class="pc bpc" id="L920" title="1 of 2 branches missed.">		int iNumDepositComp = null == astrDepositMaturityTenor ? 0 : astrDepositMaturityTenor.length;</span>
<span class="fc bfc" id="L921" title="All 2 branches covered.">		int iNumOISFuturesComp = null == astrOISFuturesMaturityTenor ? 0 :</span>
			astrOISFuturesMaturityTenor.length;
<span class="fc bfc" id="L923" title="All 2 branches covered.">		int iNumOISFuturesComp2 = null == astrOISFuturesEffectiveTenor ? 0 :</span>
			astrOISFuturesEffectiveTenor.length;
<span class="fc bfc" id="L925" title="All 2 branches covered.">		int iNumLongEndOISComp = null == astrLongEndOISMaturityTenor ? 0 :</span>
			astrLongEndOISMaturityTenor.length;
<span class="pc bpc" id="L927" title="1 of 2 branches missed.">		int iNumShortEndOISComp = null == astrShortEndOISMaturityTenor ? 0 :</span>
			astrShortEndOISMaturityTenor.length;

<span class="pc bpc" id="L930" title="5 of 10 branches missed.">		if (iNumDepositQuote != iNumDepositComp || iNumShortEndOISQuote != iNumShortEndOISComp ||</span>
			iNumOISFuturesQuote != iNumOISFuturesComp || iNumOISFuturesComp2 != iNumOISFuturesComp ||
				iNumLongEndOISQuote != iNumLongEndOISComp)
<span class="nc" id="L933">			return null;</span>

<span class="fc" id="L935">		org.drip.analytics.date.JulianDate dtEffective = dtSpot.addBusDays (0, strCurrency);</span>

<span class="pc bpc" id="L937" title="1 of 2 branches missed.">		if (0 != iNumDepositComp)</span>
<span class="fc" id="L938">			lsssDeposit = org.drip.state.estimator.LatentStateStretchBuilder.ForwardFundingStretchSpec</span>
<span class="fc" id="L939">				(&quot;DEPOSIT&quot;, org.drip.service.template.OTCInstrumentBuilder.OvernightDeposit (dtEffective,</span>
					strCurrency, astrDepositMaturityTenor), strDepositMeasure, adblDepositQuote);

<span class="pc bpc" id="L942" title="1 of 2 branches missed.">		if (0 != iNumShortEndOISComp)</span>
<span class="fc" id="L943">			lsssShortEndOIS = org.drip.state.estimator.LatentStateStretchBuilder.ForwardFundingStretchSpec</span>
<span class="fc" id="L944">				(&quot;SHORTENDOIS&quot;, org.drip.service.template.OTCInstrumentBuilder.OISFixFloat (dtEffective,</span>
					strCurrency, astrShortEndOISMaturityTenor, adblShortEndOISQuote, false),
						strShortEndOISMeasure, adblShortEndOISQuote);

<span class="fc bfc" id="L948" title="All 2 branches covered.">		if (0 != iNumOISFuturesComp)</span>
<span class="fc" id="L949">			lsssOISFutures = org.drip.state.estimator.LatentStateStretchBuilder.ForwardFundingStretchSpec</span>
<span class="fc" id="L950">				(&quot;OISFUTURES&quot;, org.drip.service.template.OTCInstrumentBuilder.OISFixFloatFutures</span>
<span class="fc" id="L951">					(dtEffective, strCurrency, astrOISFuturesEffectiveTenor, astrOISFuturesMaturityTenor,</span>
						adblOISFuturesQuote, false), strOISFuturesMeasure, adblOISFuturesQuote);

<span class="fc bfc" id="L954" title="All 2 branches covered.">		if (0 != iNumLongEndOISComp)</span>
<span class="fc" id="L955">			lsssLongEndOIS = org.drip.state.estimator.LatentStateStretchBuilder.ForwardFundingStretchSpec</span>
<span class="fc" id="L956">				(&quot;LONGENDOIS&quot;, org.drip.service.template.OTCInstrumentBuilder.OISFixFloat (dtEffective,</span>
					strCurrency, astrLongEndOISMaturityTenor, adblLongEndOISQuote, false),
						strLongEndOISMeasure, adblLongEndOISQuote);

		try {
<span class="fc" id="L961">			org.drip.state.inference.LinearLatentStateCalibrator lcc = new</span>
				org.drip.state.inference.LinearLatentStateCalibrator (scbc,
<span class="fc" id="L963">					org.drip.spline.stretch.BoundarySettings.NaturalStandard(),</span>
						org.drip.spline.stretch.MultiSegmentSequence.CALIBRATE, null, null);

<span class="fc" id="L966">			return org.drip.state.creator.ScenarioDiscountCurveBuilder.ShapePreservingDFBuild (strCurrency,</span>
				lcc, new org.drip.state.inference.LatentStateStretchSpec[] {lsssDeposit, lsssShortEndOIS,
					lsssOISFutures, lsssLongEndOIS}, org.drip.param.valuation.ValuationParams.Spot
<span class="fc" id="L969">						(dtEffective.julian()), null, null, null, 1.);</span>
<span class="nc" id="L970">		} catch (java.lang.Exception e) {</span>
<span class="nc" id="L971">			e.printStackTrace();</span>
		}

<span class="nc" id="L974">		return null;</span>
	}

	/**
	 * Construct a Shape Preserving Overnight Curve from Overnight Exchange/OTC Market Instruments
	 * 
	 * @param dtSpot Spot Date
	 * @param strCurrency Currency
	 * @param astrDepositMaturityTenor Array of Deposit Maturity Tenors
	 * @param adblDepositQuote Array of Deposit Quotes
	 * @param strDepositMeasure Deposit Measure
	 * @param astrShortEndOISMaturityTenor Array of Short End OIS Maturity Tenors
	 * @param adblShortEndOISQuote Array of Short End OIS Quotes
	 * @param strShortEndOISMeasure Short End OIS Measure
	 * @param astrOISFuturesEffectiveTenor Array of OIS Futures Effective Tenors
	 * @param astrOISFuturesMaturityTenor Array of OIS Futures Maturity Tenors
	 * @param adblOISFuturesQuote Array of OIS Futures Quotes
	 * @param strOISFuturesMeasure OIS Futures Measure
	 * @param astrLongEndOISMaturityTenor Array of Long End OIS Maturity Tenors
	 * @param adblLongEndOISQuote Array of Long End OIS Quotes
	 * @param strLongEndOISMeasure Long End OIS Measure
	 * 
	 * @return Overnight Curve from Overnight OTC Instruments
	 */

	public static final org.drip.state.discount.MergedDiscountForwardCurve ShapePreservingOvernightCurve (
		final org.drip.analytics.date.JulianDate dtSpot,
		final String strCurrency,
		final java.lang.String[] astrDepositMaturityTenor,
		final double[] adblDepositQuote,
		final java.lang.String strDepositMeasure,
		final java.lang.String[] astrShortEndOISMaturityTenor,
		final double[] adblShortEndOISQuote,
		final java.lang.String strShortEndOISMeasure,
		final java.lang.String[] astrOISFuturesEffectiveTenor,
		final java.lang.String[] astrOISFuturesMaturityTenor,
		final double[] adblOISFuturesQuote,
		final java.lang.String strOISFuturesMeasure,
		final java.lang.String[] astrLongEndOISMaturityTenor,
		final double[] adblLongEndOISQuote,
		final java.lang.String strLongEndOISMeasure)
	{
		try {
<span class="nc" id="L1017">			return OvernightCurve (dtSpot, strCurrency, astrDepositMaturityTenor, adblDepositQuote,</span>
				strDepositMeasure, astrShortEndOISMaturityTenor, adblShortEndOISQuote, strShortEndOISMeasure,
					astrOISFuturesEffectiveTenor, astrOISFuturesMaturityTenor, adblOISFuturesQuote,
						strOISFuturesMeasure, astrLongEndOISMaturityTenor, adblLongEndOISQuote,
							strLongEndOISMeasure, new org.drip.spline.params.SegmentCustomBuilderControl
								(org.drip.spline.stretch.MultiSegmentSequenceBuilder.BASIS_SPLINE_POLYNOMIAL,
									new org.drip.spline.basis.PolynomialFunctionSetParams (2),
<span class="nc" id="L1024">										org.drip.spline.params.SegmentInelasticDesignControl.Create (0, 2),</span>
											new org.drip.spline.params.ResponseScalingShapeControl (true, new
												org.drip.function.r1tor1.QuadraticRationalShapeControl (0.)),
													null));
<span class="nc" id="L1028">		} catch (java.lang.Exception e) {</span>
<span class="nc" id="L1029">			e.printStackTrace();</span>
		}

<span class="nc" id="L1032">		return null;</span>
	}

	/**
	 * Construct a Smooth Overnight Curve from Overnight Exchange/OTC Market Instruments
	 * 
	 * @param dtSpot Spot Date
	 * @param strCurrency Currency
	 * @param astrDepositMaturityTenor Array of Deposit Maturity Tenors
	 * @param adblDepositQuote Array of Deposit Quotes
	 * @param strDepositMeasure Deposit Measure
	 * @param astrShortEndOISMaturityTenor Array of Short End OIS Maturity Tenors
	 * @param adblShortEndOISQuote Array of Short End OIS Quotes
	 * @param strShortEndOISMeasure Short End OIS Measure
	 * @param astrOISFuturesEffectiveTenor Array of OIS Futures Effective Tenors
	 * @param astrOISFuturesMaturityTenor Array of OIS Futures Maturity Tenors
	 * @param adblOISFuturesQuote Array of OIS Futures Quotes
	 * @param strOISFuturesMeasure OIS Futures Measure
	 * @param astrLongEndOISMaturityTenor Array of Long End OIS Maturity Tenors
	 * @param adblLongEndOISQuote Array of Long End OIS Quotes
	 * @param strLongEndOISMeasure Long End OIS Measure
	 * 
	 * @return Overnight Curve from Overnight OTC Instruments
	 */

	public static final org.drip.state.discount.MergedDiscountForwardCurve SmoothOvernightCurve (
		final org.drip.analytics.date.JulianDate dtSpot,
		final String strCurrency,
		final java.lang.String[] astrDepositMaturityTenor,
		final double[] adblDepositQuote,
		final java.lang.String strDepositMeasure,
		final java.lang.String[] astrShortEndOISMaturityTenor,
		final double[] adblShortEndOISQuote,
		final java.lang.String strShortEndOISMeasure,
		final java.lang.String[] astrOISFuturesEffectiveTenor,
		final java.lang.String[] astrOISFuturesMaturityTenor,
		final double[] adblOISFuturesQuote,
		final java.lang.String strOISFuturesMeasure,
		final java.lang.String[] astrLongEndOISMaturityTenor,
		final double[] adblLongEndOISQuote,
		final java.lang.String strLongEndOISMeasure)
	{
		try {
<span class="fc" id="L1075">			return OvernightCurve (dtSpot, strCurrency, astrDepositMaturityTenor, adblDepositQuote,</span>
				strDepositMeasure, astrShortEndOISMaturityTenor, adblShortEndOISQuote, strShortEndOISMeasure,
					astrOISFuturesEffectiveTenor, astrOISFuturesMaturityTenor, adblOISFuturesQuote,
						strOISFuturesMeasure, astrLongEndOISMaturityTenor, adblLongEndOISQuote,
							strLongEndOISMeasure, new org.drip.spline.params.SegmentCustomBuilderControl
								(org.drip.spline.stretch.MultiSegmentSequenceBuilder.BASIS_SPLINE_POLYNOMIAL,
									new org.drip.spline.basis.PolynomialFunctionSetParams (4),
<span class="fc" id="L1082">										org.drip.spline.params.SegmentInelasticDesignControl.Create (2, 2),</span>
											new org.drip.spline.params.ResponseScalingShapeControl (true, new
												org.drip.function.r1tor1.QuadraticRationalShapeControl (0.)),
													null));
<span class="nc" id="L1086">		} catch (java.lang.Exception e) {</span>
<span class="nc" id="L1087">			e.printStackTrace();</span>
		}

<span class="nc" id="L1090">		return null;</span>
	}

	/**
	 * Construct an Overnight Curve from Overnight Exchange/OTC Market Instruments
	 * 
	 * @param dtSpot Spot Date
	 * @param strCurrency Currency
	 * @param astrDepositMaturityTenor Array of Deposit Maturity Tenors
	 * @param adblDepositQuote Array of Deposit Quotes
	 * @param strDepositMeasure Deposit Measure
	 * @param astrShortEndOISMaturityTenor Array of Short End OIS Maturity Tenors
	 * @param adblShortEndOISQuote Array of Short End OIS Quotes
	 * @param strShortEndOISMeasure Short End OIS Measure
	 * @param astrOISFuturesEffectiveTenor Array of OIS Futures Effective Tenors
	 * @param astrOISFuturesMaturityTenor Array of OIS Futures Maturity Tenors
	 * @param adblOISFuturesQuote Array of OIS Futures Quotes
	 * @param strOISFuturesMeasure OIS Futures Measure
	 * @param astrLongEndOISMaturityTenor Array of Long End OIS Maturity Tenors
	 * @param adblLongEndOISQuote Array of Long End OIS Quotes
	 * @param strLongEndOISMeasure Long End OIS Measure
	 * @param iLatentStateType SHAPE PRESERVING/SMOOTH
	 * 
	 * @return Overnight Curve from Overnight OTC Instruments
	 */

	public static final org.drip.state.discount.MergedDiscountForwardCurve OvernightCurve (
		final org.drip.analytics.date.JulianDate dtSpot,
		final String strCurrency,
		final java.lang.String[] astrDepositMaturityTenor,
		final double[] adblDepositQuote,
		final java.lang.String strDepositMeasure,
		final java.lang.String[] astrShortEndOISMaturityTenor,
		final double[] adblShortEndOISQuote,
		final java.lang.String strShortEndOISMeasure,
		final java.lang.String[] astrOISFuturesEffectiveTenor,
		final java.lang.String[] astrOISFuturesMaturityTenor,
		final double[] adblOISFuturesQuote,
		final java.lang.String strOISFuturesMeasure,
		final java.lang.String[] astrLongEndOISMaturityTenor,
		final double[] adblLongEndOISQuote,
		final java.lang.String strLongEndOISMeasure,
		final int iLatentStateType)
	{
<span class="pc bpc" id="L1134" title="1 of 2 branches missed.">		if (SHAPE_PRESERVING == iLatentStateType)</span>
<span class="nc" id="L1135">			return ShapePreservingOvernightCurve (dtSpot, strCurrency, astrDepositMaturityTenor,</span>
				adblDepositQuote, strDepositMeasure, astrShortEndOISMaturityTenor, adblShortEndOISQuote,
					strShortEndOISMeasure, astrOISFuturesEffectiveTenor, astrOISFuturesMaturityTenor,
						adblOISFuturesQuote, strOISFuturesMeasure, astrLongEndOISMaturityTenor,
							adblLongEndOISQuote, strLongEndOISMeasure);

<span class="pc bpc" id="L1141" title="1 of 2 branches missed.">		if (SMOOTH == iLatentStateType)</span>
<span class="fc" id="L1142">			return SmoothOvernightCurve (dtSpot, strCurrency, astrDepositMaturityTenor, adblDepositQuote,</span>
				strDepositMeasure, astrShortEndOISMaturityTenor, adblShortEndOISQuote, strShortEndOISMeasure,
					astrOISFuturesEffectiveTenor, astrOISFuturesMaturityTenor, adblOISFuturesQuote,
						strOISFuturesMeasure, astrLongEndOISMaturityTenor, adblLongEndOISQuote,
							strLongEndOISMeasure);

<span class="nc" id="L1148">		return null;</span>
	}

	/**
	 * Construct a Credit Curve from Overnight Exchange/OTC Market Instruments
	 * 
	 * @param dtSpot Spot Date
	 * @param strCredit Credit Curve
	 * @param astrMaturityTenor Maturity Tenor
	 * @param adblCoupon Coupon Array
	 * @param adblQuote Array of Market Quotes
	 * @param strMeasure Calibration Measure
	 * @param dc Discount Curve
	 * 
	 * @return The Credit Curve Instance
	 */

	public static final org.drip.state.credit.CreditCurve CreditCurve (
		final org.drip.analytics.date.JulianDate dtSpot,
		final java.lang.String strCredit,
		final java.lang.String[] astrMaturityTenor,
		final double[] adblCoupon,
		final double[] adblQuote,
		final java.lang.String strMeasure,
		final org.drip.state.discount.MergedDiscountForwardCurve dc)
	{
<span class="pc bpc" id="L1174" title="2 of 4 branches missed.">		if (null == dtSpot || null == dc) return null;</span>

<span class="fc" id="L1176">		java.lang.String strCurrency = dc.currency();</span>

<span class="fc" id="L1178">		org.drip.analytics.date.JulianDate dtEffective = dtSpot.addBusDays (0, strCurrency);</span>

<span class="fc" id="L1180">		org.drip.product.definition.CreditDefaultSwap[] aCDS =</span>
<span class="fc" id="L1181">			org.drip.service.template.OTCInstrumentBuilder.CDS (dtEffective, astrMaturityTenor, adblCoupon,</span>
				strCurrency, strCredit);

<span class="pc bpc" id="L1184" title="1 of 2 branches missed.">		if (null == aCDS) return null;</span>

<span class="fc" id="L1186">		int iNumCDS = aCDS.length;</span>
<span class="fc" id="L1187">		java.lang.String[] astrMeasure = new java.lang.String[iNumCDS];</span>

<span class="pc bpc" id="L1189" title="1 of 2 branches missed.">		if (0 == iNumCDS) return null;</span>

<span class="fc bfc" id="L1191" title="All 2 branches covered.">		for (int i = 0; i &lt; iNumCDS; ++i)</span>
<span class="fc" id="L1192">			astrMeasure[i] = strMeasure;</span>

<span class="fc" id="L1194">		return org.drip.state.creator.ScenarioCreditCurveBuilder.Custom (strCredit, dtEffective, aCDS, dc,</span>
<span class="pc bpc" id="L1195" title="1 of 2 branches missed.">			adblQuote, astrMeasure, &quot;CAD&quot;.equalsIgnoreCase (strCurrency) || &quot;EUR&quot;.equalsIgnoreCase</span>
<span class="pc bpc" id="L1196" title="2 of 6 branches missed.">				(strCurrency) || &quot;GBP&quot;.equalsIgnoreCase (strCurrency) || &quot;HKD&quot;.equalsIgnoreCase (strCurrency)</span>
<span class="pc bpc" id="L1197" title="1 of 2 branches missed.">					|| &quot;USD&quot;.equalsIgnoreCase (strCurrency) ? 0.40 : 0.25, &quot;QuotedSpread&quot;.equals</span>
<span class="fc" id="L1198">						(strMeasure));</span>
	}

	/**
	 * Construct a Credit Curve from the specified Calibration CDS Instruments
	 * 
	 * @param dtSpot Spot Date
	 * @param aCDS Array of the Calibration CDS Instruments
	 * @param adblQuote Array of Market Quotes
	 * @param strMeasure Calibration Measure
	 * @param dc Discount Curve
	 * 
	 * @return The Credit Curve Instance
	 */

	public static final org.drip.state.credit.CreditCurve CreditCurve (
		final org.drip.analytics.date.JulianDate dtSpot,
		final org.drip.product.definition.CreditDefaultSwap[] aCDS,
		final double[] adblQuote,
		final java.lang.String strMeasure,
		final org.drip.state.discount.MergedDiscountForwardCurve dc)
	{
<span class="nc bnc" id="L1220" title="All 4 branches missed.">		if (null == dtSpot || null == dc) return null;</span>

<span class="nc" id="L1222">		java.lang.String strCurrency = dc.currency();</span>

<span class="nc bnc" id="L1224" title="All 2 branches missed.">		if (null == aCDS) return null;</span>

<span class="nc" id="L1226">		int iNumCDS = aCDS.length;</span>
<span class="nc" id="L1227">		java.lang.String[] astrMeasure = new java.lang.String[iNumCDS];</span>

<span class="nc bnc" id="L1229" title="All 2 branches missed.">		if (0 == iNumCDS) return null;</span>

<span class="nc bnc" id="L1231" title="All 2 branches missed.">		for (int i = 0; i &lt; iNumCDS; ++i)</span>
<span class="nc" id="L1232">			astrMeasure[i] = strMeasure;</span>

<span class="nc" id="L1234">		return org.drip.state.creator.ScenarioCreditCurveBuilder.Custom</span>
<span class="nc" id="L1235">			(aCDS[0].creditLabel().referenceEntity(), dtSpot, aCDS, dc, adblQuote, astrMeasure,</span>
<span class="nc bnc" id="L1236" title="All 4 branches missed.">				&quot;CAD&quot;.equalsIgnoreCase (strCurrency) || &quot;EUR&quot;.equalsIgnoreCase (strCurrency) ||</span>
<span class="nc bnc" id="L1237" title="All 4 branches missed.">					&quot;GBP&quot;.equalsIgnoreCase (strCurrency) || &quot;HKD&quot;.equalsIgnoreCase (strCurrency) ||</span>
<span class="nc bnc" id="L1238" title="All 2 branches missed.">						&quot;USD&quot;.equalsIgnoreCase (strCurrency) ? 0.40 : 0.25, &quot;QuotedSpread&quot;.equals</span>
<span class="nc" id="L1239">							(strMeasure));</span>
	}

	/**
	 * Construct a Govvie Curve from the Treasury Instruments
	 * 
	 * @param strCode Treasury Code
	 * @param dtSpot Spot Date
	 * @param adtEffective Array of Effective Dates
	 * @param adtMaturity Array of Maturity Dates
	 * @param adblCoupon Array of Coupons
	 * @param adblQuote Array of Market Quotes
	 * @param strMeasure Calibration Measure
	 * @param scbc Segment Custom Builder Control Parameters
	 * 
	 * @return The Govvie Curve Instance
	 */

	public static final org.drip.state.govvie.GovvieCurve GovvieCurve (
		final java.lang.String strCode,
		final org.drip.analytics.date.JulianDate dtSpot,
		final org.drip.analytics.date.JulianDate[] adtEffective,
		final org.drip.analytics.date.JulianDate[] adtMaturity,
		final double[] adblCoupon,
		final double[] adblQuote,
		final java.lang.String strMeasure,
		final org.drip.spline.params.SegmentCustomBuilderControl scbc)
	{
<span class="fc" id="L1267">		org.drip.product.credit.BondComponent[] aTreasury =</span>
<span class="fc" id="L1268">			org.drip.service.template.TreasuryBuilder.FromCode (strCode, adtEffective, adtMaturity,</span>
				adblCoupon);

<span class="pc bpc" id="L1271" title="1 of 2 branches missed.">		if (null == aTreasury) return null;</span>

<span class="fc" id="L1273">		int iNumTreasury = aTreasury.length;</span>
<span class="fc" id="L1274">		int[] aiDate = new int[iNumTreasury];</span>

<span class="pc bpc" id="L1276" title="2 of 4 branches missed.">		if (0 == iNumTreasury || adblQuote.length != iNumTreasury) return null;</span>

<span class="fc bfc" id="L1278" title="All 2 branches covered.">		for (int i = 0; i &lt; iNumTreasury; ++i)</span>
<span class="fc" id="L1279">			aiDate[i] = adtMaturity[i].julian();</span>

<span class="fc" id="L1281">		java.lang.String strCurrency = aTreasury[0].currency();</span>

<span class="fc" id="L1283">		java.lang.String strBenchmarkTreasuryCode =</span>
<span class="fc" id="L1284">			org.drip.market.issue.TreasurySettingContainer.CurrencyBenchmarkCode (strCurrency);</span>

<span class="pc bpc" id="L1286" title="2 of 4 branches missed.">		return null == strBenchmarkTreasuryCode || strBenchmarkTreasuryCode.isEmpty() ? null :</span>
<span class="fc" id="L1287">			org.drip.state.creator.ScenarioGovvieCurveBuilder.CustomSplineCurve (strBenchmarkTreasuryCode,</span>
				dtSpot, strBenchmarkTreasuryCode, strCurrency, aiDate, adblQuote, scbc);
	}

	/**
	 * Construct a Shape Preserving Govvie Curve from the Treasury Instruments
	 * 
	 * @param strCode Treasury Code
	 * @param dtSpot Spot Date
	 * @param adtEffective Array of Effective Dates
	 * @param adtMaturity Array of Maturity Dates
	 * @param adblCoupon Array of Coupons
	 * @param adblQuote Array of Market Quotes
	 * @param strMeasure Calibration Measure
	 * 
	 * @return The Govvie Curve Instance
	 */

	public static final org.drip.state.govvie.GovvieCurve ShapePreservingGovvieCurve (
		final java.lang.String strCode,
		final org.drip.analytics.date.JulianDate dtSpot,
		final org.drip.analytics.date.JulianDate[] adtEffective,
		final org.drip.analytics.date.JulianDate[] adtMaturity,
		final double[] adblCoupon,
		final double[] adblQuote,
		final java.lang.String strMeasure)
	{
		try {
<span class="fc" id="L1315">			return GovvieCurve (strCode, dtSpot, adtEffective, adtMaturity, adblCoupon, adblQuote,</span>
				strMeasure, new org.drip.spline.params.SegmentCustomBuilderControl
					(org.drip.spline.stretch.MultiSegmentSequenceBuilder.BASIS_SPLINE_POLYNOMIAL, new
						org.drip.spline.basis.PolynomialFunctionSetParams (2),
<span class="fc" id="L1319">							org.drip.spline.params.SegmentInelasticDesignControl.Create (0, 2), null, null));</span>
<span class="nc" id="L1320">		} catch (java.lang.Exception e) {</span>
<span class="nc" id="L1321">			e.printStackTrace();</span>
		}

<span class="nc" id="L1324">		return null;</span>
	}

	/**
	 * Construct a Smooth Govvie Curve from the Treasury Instruments
	 * 
	 * @param strCode Treasury Code
	 * @param dtSpot Spot Date
	 * @param adtEffective Array of Effective Dates
	 * @param adtMaturity Array of Maturity Dates
	 * @param adblCoupon Array of Coupons
	 * @param adblQuote Array of Market Quotes
	 * @param strMeasure Calibration Measure
	 * 
	 * @return The Govvie Curve Instance
	 */

	public static final org.drip.state.govvie.GovvieCurve SmoothGovvieCurve (
		final java.lang.String strCode,
		final org.drip.analytics.date.JulianDate dtSpot,
		final org.drip.analytics.date.JulianDate[] adtEffective,
		final org.drip.analytics.date.JulianDate[] adtMaturity,
		final double[] adblCoupon,
		final double[] adblQuote,
		final java.lang.String strMeasure)
	{
		try {
<span class="nc" id="L1351">			return GovvieCurve (strCode, dtSpot, adtEffective, adtMaturity, adblCoupon, adblQuote,</span>
				strMeasure, new org.drip.spline.params.SegmentCustomBuilderControl
					(org.drip.spline.stretch.MultiSegmentSequenceBuilder.BASIS_SPLINE_POLYNOMIAL, new
						org.drip.spline.basis.PolynomialFunctionSetParams (4),
<span class="nc" id="L1355">							org.drip.spline.params.SegmentInelasticDesignControl.Create (2, 2), null, null));</span>
<span class="nc" id="L1356">		} catch (java.lang.Exception e) {</span>
<span class="nc" id="L1357">			e.printStackTrace();</span>
		}

<span class="nc" id="L1360">		return null;</span>
	}

	/**
	 * Construct a Govvie Curve from the Treasury Instruments
	 * 
	 * @param strCode Treasury Code
	 * @param dtSpot Spot Date
	 * @param adtEffective Array of Effective Dates
	 * @param adtMaturity Array of Maturity Dates
	 * @param adblCoupon Array of Coupons
	 * @param adblQuote Array of Market Quotes
	 * @param strMeasure Calibration Measure
	 * @param iLatentStateType SHAPE PRESERVING/SMOOTH
	 * 
	 * @return The Govvie Curve Instance
	 */

	public static final org.drip.state.govvie.GovvieCurve GovvieCurve (
		final java.lang.String strCode,
		final org.drip.analytics.date.JulianDate dtSpot,
		final org.drip.analytics.date.JulianDate[] adtEffective,
		final org.drip.analytics.date.JulianDate[] adtMaturity,
		final double[] adblCoupon,
		final double[] adblQuote,
		final java.lang.String strMeasure,
		final int iLatentStateType)
	{
<span class="pc bpc" id="L1388" title="1 of 2 branches missed.">		if (SHAPE_PRESERVING == iLatentStateType)</span>
<span class="fc" id="L1389">			return ShapePreservingGovvieCurve (strCode, dtSpot, adtEffective, adtMaturity, adblCoupon,</span>
				adblQuote, strMeasure);

<span class="nc bnc" id="L1392" title="All 2 branches missed.">		if (SMOOTH == iLatentStateType)</span>
<span class="nc" id="L1393">			return SmoothGovvieCurve (strCode, dtSpot, adtEffective, adtMaturity, adblCoupon, adblQuote,</span>
				strMeasure);

<span class="nc" id="L1396">		return null;</span>
	}

	/**
	 * Construct an FX Curve from the FX Forward Instruments
	 * 
	 * @param dtSpot Spot Date
	 * @param cp The FX Currency Pair
	 * @param astrMaturityTenor Array of Maturity Tenors
	 * @param adblQuote Array of FX Forwards
	 * @param strMeasure Calibration Measure
	 * @param dblFXSpot FX Spot
	 * @param scbc Segment Custom Builder Builder Parameters
	 * 
	 * @return The FX Curve Instance
	 */

	public static final org.drip.state.fx.FXCurve FXCurve (
		final org.drip.analytics.date.JulianDate dtSpot,
		final org.drip.product.params.CurrencyPair cp,
		final java.lang.String[] astrMaturityTenor,
		final double[] adblQuote,
		final java.lang.String strMeasure,
		final double dblFXSpot,
		final org.drip.spline.params.SegmentCustomBuilderControl scbc)
	{
<span class="pc bpc" id="L1422" title="2 of 4 branches missed.">		if (null == dtSpot || null == cp) return null;</span>

<span class="fc" id="L1424">		org.drip.analytics.date.JulianDate dtEffective = dtSpot.addBusDays (0, cp.denomCcy());</span>

<span class="fc" id="L1426">		org.drip.product.fx.FXForwardComponent[] aFXFC =</span>
<span class="fc" id="L1427">			org.drip.service.template.OTCInstrumentBuilder.FXForward (dtEffective, cp, astrMaturityTenor);</span>

<span class="pc bpc" id="L1429" title="1 of 2 branches missed.">		if (null == aFXFC) return null;</span>

<span class="fc" id="L1431">		int iNumFXFC = aFXFC.length;</span>

<span class="pc bpc" id="L1433" title="2 of 4 branches missed.">		if (0 == iNumFXFC || adblQuote.length != iNumFXFC) return null;</span>

<span class="fc" id="L1435">		return org.drip.state.creator.ScenarioFXCurveBuilder.ShapePreservingFXCurve ( cp.code(), cp,</span>
<span class="fc" id="L1436">			org.drip.param.valuation.ValuationParams.Spot (dtEffective.julian()), null, null, null, aFXFC,</span>
				strMeasure, adblQuote, dblFXSpot, scbc);
	}

	/**
	 * Construct a Shape Preserving FX Curve from the FX Forward Instruments
	 * 
	 * @param dtSpot Spot Date
	 * @param cp The FX Currency Pair
	 * @param astrMaturityTenor Array of Maturity Tenors
	 * @param adblQuote Array of FX Forwards
	 * @param strMeasure Calibration Measure
	 * @param dblFXSpot FX Spot
	 * 
	 * @return The FX Curve Instance
	 */

	public static final org.drip.state.fx.FXCurve ShapePreservingFXCurve (
		final org.drip.analytics.date.JulianDate dtSpot,
		final org.drip.product.params.CurrencyPair cp,
		final java.lang.String[] astrMaturityTenor,
		final double[] adblQuote,
		final java.lang.String strMeasure,
		final double dblFXSpot)
	{
		try {
<span class="nc" id="L1462">			return FXCurve (dtSpot, cp, astrMaturityTenor, adblQuote, strMeasure, dblFXSpot, new</span>
				org.drip.spline.params.SegmentCustomBuilderControl
					(org.drip.spline.stretch.MultiSegmentSequenceBuilder.BASIS_SPLINE_POLYNOMIAL, new
						org.drip.spline.basis.PolynomialFunctionSetParams (2),
<span class="nc" id="L1466">							org.drip.spline.params.SegmentInelasticDesignControl.Create (0, 2), null, null));</span>
<span class="nc" id="L1467">		} catch (java.lang.Exception e) {</span>
<span class="nc" id="L1468">			e.printStackTrace();</span>
		}

<span class="nc" id="L1471">		return null;</span>
	}

	/**
	 * Construct a Smooth FX Curve from the FX Forward Instruments
	 * 
	 * @param dtSpot Spot Date
	 * @param cp The FX Currency Pair
	 * @param astrMaturityTenor Array of Maturity Tenors
	 * @param adblQuote Array of FX Forwards
	 * @param strMeasure Calibration Measure
	 * @param dblFXSpot FX Spot
	 * 
	 * @return The FX Curve Instance
	 */

	public static final org.drip.state.fx.FXCurve SmoothFXCurve (
		final org.drip.analytics.date.JulianDate dtSpot,
		final org.drip.product.params.CurrencyPair cp,
		final java.lang.String[] astrMaturityTenor,
		final double[] adblQuote,
		final java.lang.String strMeasure,
		final double dblFXSpot)
	{
		try {
<span class="fc" id="L1496">			return FXCurve (dtSpot, cp, astrMaturityTenor, adblQuote, strMeasure, dblFXSpot, new</span>
				org.drip.spline.params.SegmentCustomBuilderControl
					(org.drip.spline.stretch.MultiSegmentSequenceBuilder.BASIS_SPLINE_POLYNOMIAL, new
						org.drip.spline.basis.PolynomialFunctionSetParams (4),
<span class="fc" id="L1500">							org.drip.spline.params.SegmentInelasticDesignControl.Create (2, 2), null, null));</span>
<span class="nc" id="L1501">		} catch (java.lang.Exception e) {</span>
<span class="nc" id="L1502">			e.printStackTrace();</span>
		}

<span class="nc" id="L1505">		return null;</span>
	}

	/**
	 * Construct an FX Curve from the FX Forward Instruments
	 * 
	 * @param dtSpot Spot Date
	 * @param cp The FX Currency Pair
	 * @param astrMaturityTenor Array of Maturity Tenors
	 * @param adblQuote Array of FX Forwards
	 * @param strMeasure Calibration Measure
	 * @param dblFXSpot FX Spot
	 * @param iLatentStateType SHAPE PRESERVING/SMOOTH
	 * 
	 * @return The FX Curve Instance
	 */

	public static final org.drip.state.fx.FXCurve FXCurve (
		final org.drip.analytics.date.JulianDate dtSpot,
		final org.drip.product.params.CurrencyPair cp,
		final java.lang.String[] astrMaturityTenor,
		final double[] adblQuote,
		final java.lang.String strMeasure,
		final double dblFXSpot,
		final int iLatentStateType)
	{
<span class="pc bpc" id="L1531" title="1 of 2 branches missed.">		if (SHAPE_PRESERVING == iLatentStateType)</span>
<span class="nc" id="L1532">			return ShapePreservingFXCurve (dtSpot, cp, astrMaturityTenor, adblQuote, strMeasure, dblFXSpot);</span>

<span class="pc bpc" id="L1534" title="1 of 2 branches missed.">		if (SMOOTH == iLatentStateType)</span>
<span class="fc" id="L1535">			return SmoothFXCurve (dtSpot, cp, astrMaturityTenor, adblQuote, strMeasure, dblFXSpot);</span>

<span class="nc" id="L1537">		return null;</span>
	}

	/**
	 * Forward Rate Volatility Latent State Construction from Cap/Floor Instruments
	 * 
	 * @param dtSpot Spot Date
	 * @param forwardLabel Forward Label
	 * @param bIsCap TRUE - Create and Use Array of Caps
	 * @param astrMaturityTenor Array of Cap/floor Maturities
	 * @param adblStrike Array of Cap/Floor Strikes
	 * @param adblQuote Array of Cap/Floor Quotes
	 * @param strMeasure Calibration Measure
	 * @param dc Discount Curve Instance
	 * @param fc Forward Curve Instance
	 * 
	 * @return Instance of the Forward Rate Volatility Curve
	 */

	public static final org.drip.state.volatility.VolatilityCurve ForwardRateVolatilityCurve (
		final org.drip.analytics.date.JulianDate dtSpot,
		final org.drip.state.identifier.ForwardLabel forwardLabel,
		final boolean bIsCap,
		final java.lang.String[] astrMaturityTenor,
		final double[] adblStrike,
		final double[] adblQuote,
		final java.lang.String strMeasure,
		final org.drip.state.discount.MergedDiscountForwardCurve dc,
		final org.drip.state.forward.ForwardCurve fc)
	{
<span class="pc bpc" id="L1567" title="3 of 6 branches missed.">		if (null == dtSpot || null == astrMaturityTenor || null == dc) return null;</span>

<span class="fc" id="L1569">		org.drip.analytics.date.JulianDate dtEffective = dtSpot.addBusDays (0, dc.currency());</span>

<span class="fc" id="L1571">		int iNumComp = astrMaturityTenor.length;</span>
<span class="fc" id="L1572">		java.lang.String[] astrCalibMeasure = new java.lang.String[iNumComp];</span>

<span class="pc bpc" id="L1574" title="1 of 2 branches missed.">		if (0 == iNumComp) return null;</span>

<span class="fc bfc" id="L1576" title="All 2 branches covered.">		for (int i = 0; i &lt; iNumComp; ++i)</span>
<span class="fc" id="L1577">			astrCalibMeasure[i] = strMeasure;</span>

<span class="fc" id="L1579">		return org.drip.state.creator.ScenarioLocalVolatilityBuilder.NonlinearBuild</span>
<span class="fc" id="L1580">			(forwardLabel.fullyQualifiedName() + &quot;::VOL&quot;, dtEffective, forwardLabel,</span>
<span class="fc" id="L1581">				org.drip.service.template.OTCInstrumentBuilder.CapFloor (dtEffective, forwardLabel,</span>
					astrMaturityTenor, adblStrike, bIsCap), adblQuote, astrCalibMeasure, dc, fc, null);
	}

	/**
	 * Construct a Map of Tenor Bumped Funding Curve Based off of the Input Exchange/OTC Market Instruments
	 * 
	 * @param dtSpot The Spot Date
	 * @param strCurrency Currency
	 * @param astrDepositMaturityTenor Array of Deposit Maturity Tenors
	 * @param adblDepositQuote Array of Deposit Quotes
	 * @param strDepositMeasure Deposit Calibration Measure
	 * @param adblFuturesQuote Array of Futures Quotes
	 * @param strFuturesMeasure Futures Calibration Measure
	 * @param astrFixFloatMaturityTenor Array of Fix Float Swap Maturity Tenors
	 * @param adblFixFloatQuote Array of Fix Float Swap Quotes
	 * @param strFixFloatMeasure Fix Float Calibration Measure
	 * @param iLatentStateType SHAPE_PRESERVING/SMOOTH
	 * @param dblBump The Tenor Node Bump Amount
	 * @param bIsProportional TRUE - The Bump Applied is Proportional
	 * 
	 * @return The Tenor Bumped Funding Curve Map
	 */

	public static final
		org.drip.analytics.support.CaseInsensitiveTreeMap&lt;org.drip.state.discount.MergedDiscountForwardCurve&gt;
			BumpedFundingCurve (
				final org.drip.analytics.date.JulianDate dtSpot,
				final java.lang.String strCurrency,
				final java.lang.String[] astrDepositMaturityTenor,
				final double[] adblDepositQuote,
				final java.lang.String strDepositMeasure,
				final double[] adblFuturesQuote,
				final java.lang.String strFuturesMeasure,
				final java.lang.String[] astrFixFloatMaturityTenor,
				final double[] adblFixFloatQuote,
				final java.lang.String strFixFloatMeasure,
				final int iLatentStateType,
				final double dblBump,
				final boolean bIsProportional)
	{
<span class="pc bpc" id="L1622" title="1 of 2 branches missed.">		if (!org.drip.quant.common.NumberUtil.IsValid (dblBump)) return null;</span>

		org.drip.analytics.support.CaseInsensitiveTreeMap&lt;org.drip.state.discount.MergedDiscountForwardCurve&gt;
<span class="fc" id="L1625">			mapBumpedCurve = new</span>
				org.drip.analytics.support.CaseInsensitiveTreeMap&lt;org.drip.state.discount.MergedDiscountForwardCurve&gt;();

		try {
<span class="fc" id="L1629">			org.drip.param.definition.ManifestMeasureTweak mmtFLAT = new</span>
				org.drip.param.definition.ManifestMeasureTweak
					(org.drip.param.definition.ManifestMeasureTweak.FLAT, bIsProportional, dblBump);

<span class="pc bpc" id="L1633" title="1 of 2 branches missed.">			if (null != adblDepositQuote) {</span>
<span class="fc" id="L1634">				int iNumDeposit = adblDepositQuote.length;</span>

<span class="fc bfc" id="L1636" title="All 2 branches covered.">				for (int i = 0; i &lt; iNumDeposit; ++i) {</span>
<span class="fc" id="L1637">					org.drip.state.discount.MergedDiscountForwardCurve dcDepositQuoteBumped = FundingCurve</span>
<span class="fc" id="L1638">						(dtSpot, strCurrency, astrDepositMaturityTenor,</span>
<span class="fc" id="L1639">							org.drip.analytics.support.Helper.TweakManifestMeasure (adblDepositQuote, new</span>
								org.drip.param.definition.ManifestMeasureTweak (i, bIsProportional,
									dblBump)), strDepositMeasure, adblFuturesQuote, strFuturesMeasure,
										astrFixFloatMaturityTenor, adblFixFloatQuote, strFixFloatMeasure,
											iLatentStateType);

<span class="pc bpc" id="L1645" title="1 of 2 branches missed.">					if (null != dcDepositQuoteBumped)</span>
<span class="fc" id="L1646">						mapBumpedCurve.put (&quot;DEPOSIT::&quot; + astrDepositMaturityTenor[i],</span>
							dcDepositQuoteBumped);
				}
			}

<span class="fc" id="L1651">			double[] adblDepositParallelBump = org.drip.analytics.support.Helper.TweakManifestMeasure</span>
<span class="fc" id="L1652">				(adblDepositQuote, mmtFLAT);</span>

<span class="fc" id="L1654">			org.drip.state.discount.MergedDiscountForwardCurve dcDepositQuoteBumped = FundingCurve (dtSpot,</span>
				strCurrency, astrDepositMaturityTenor, adblDepositParallelBump, strDepositMeasure,
					adblFuturesQuote, strFuturesMeasure, astrFixFloatMaturityTenor, adblFixFloatQuote,
						strFixFloatMeasure, iLatentStateType);

<span class="pc bpc" id="L1659" title="1 of 2 branches missed.">			if (null != dcDepositQuoteBumped) mapBumpedCurve.put (&quot;DEPOSIT::PLL&quot;, dcDepositQuoteBumped);</span>

<span class="pc bpc" id="L1661" title="1 of 2 branches missed.">			if (null != adblFuturesQuote) {</span>
<span class="fc" id="L1662">				int iNumFutures = adblFuturesQuote.length;</span>

<span class="fc bfc" id="L1664" title="All 2 branches covered.">			for (int i = 0; i &lt; iNumFutures; ++i) {</span>
<span class="fc" id="L1665">				org.drip.state.discount.MergedDiscountForwardCurve dcFuturesQuoteBumped = FundingCurve</span>
<span class="fc" id="L1666">					(dtSpot, strCurrency, astrDepositMaturityTenor, adblDepositQuote, strDepositMeasure,</span>
<span class="fc" id="L1667">						org.drip.analytics.support.Helper.TweakManifestMeasure (adblFuturesQuote, new</span>
							org.drip.param.definition.ManifestMeasureTweak (i, bIsProportional, dblBump)),
								strFuturesMeasure, astrFixFloatMaturityTenor, adblFixFloatQuote,
									strFixFloatMeasure, iLatentStateType);

<span class="pc bpc" id="L1672" title="1 of 2 branches missed.">				if (null != dcFuturesQuoteBumped) mapBumpedCurve.put (&quot;FUTURES::&quot; + i, dcFuturesQuoteBumped);</span>
				}
			}

<span class="fc" id="L1676">			double[] adblFuturesParallelBump = org.drip.analytics.support.Helper.TweakManifestMeasure</span>
<span class="fc" id="L1677">				(adblFuturesQuote, mmtFLAT);</span>

<span class="fc" id="L1679">			org.drip.state.discount.MergedDiscountForwardCurve dcFuturesQuoteBumped = FundingCurve (dtSpot,</span>
				strCurrency, astrDepositMaturityTenor, adblDepositQuote, strDepositMeasure,
					adblFuturesParallelBump, strFuturesMeasure, astrFixFloatMaturityTenor, adblFixFloatQuote,
						strFixFloatMeasure, iLatentStateType);

<span class="pc bpc" id="L1684" title="1 of 2 branches missed.">			if (null != dcFuturesQuoteBumped) mapBumpedCurve.put (&quot;FUTURES::P&quot;, dcFuturesQuoteBumped);</span>

<span class="pc bpc" id="L1686" title="1 of 2 branches missed.">			if (null != adblFixFloatQuote) {</span>
<span class="fc" id="L1687">				int iNumFixFloat = adblFixFloatQuote.length;</span>

<span class="fc bfc" id="L1689" title="All 2 branches covered.">				for (int i = 0; i &lt; iNumFixFloat; ++i) {</span>
<span class="fc" id="L1690">					org.drip.state.discount.MergedDiscountForwardCurve dcFixFloatQuoteBumped = FundingCurve</span>
<span class="fc" id="L1691">						(dtSpot, strCurrency, astrDepositMaturityTenor, adblDepositQuote, strDepositMeasure,</span>
							adblFuturesQuote, strFuturesMeasure, astrFixFloatMaturityTenor,
<span class="fc" id="L1693">								org.drip.analytics.support.Helper.TweakManifestMeasure (adblFixFloatQuote,</span>
									new org.drip.param.definition.ManifestMeasureTweak (i, bIsProportional,
										dblBump)), strFixFloatMeasure, iLatentStateType);

<span class="pc bpc" id="L1697" title="1 of 2 branches missed.">					if (null != dcFixFloatQuoteBumped)</span>
<span class="fc" id="L1698">						mapBumpedCurve.put (&quot;FIXFLOAT::&quot; + astrFixFloatMaturityTenor[i],</span>
							dcFixFloatQuoteBumped);
				}

<span class="fc" id="L1702">				double[] adblFixFloatParallelBump = org.drip.analytics.support.Helper.TweakManifestMeasure</span>
<span class="fc" id="L1703">					(adblFixFloatQuote, mmtFLAT);</span>

<span class="fc" id="L1705">				org.drip.state.discount.MergedDiscountForwardCurve dcFixFloatQuoteBumped = FundingCurve</span>
<span class="fc" id="L1706">					(dtSpot, strCurrency, astrDepositMaturityTenor, adblDepositQuote, strDepositMeasure,</span>
						adblFuturesQuote, strFuturesMeasure, astrFixFloatMaturityTenor,
							adblFixFloatParallelBump, strFixFloatMeasure, iLatentStateType);

<span class="pc bpc" id="L1710" title="1 of 2 branches missed.">				if (null != dcFixFloatQuoteBumped)</span>
<span class="fc" id="L1711">					mapBumpedCurve.put (&quot;FIXFLOAT::PLL&quot;, dcFixFloatQuoteBumped);</span>

<span class="fc" id="L1713">				org.drip.state.discount.MergedDiscountForwardCurve dcFundingBase = FundingCurve (dtSpot,</span>
					strCurrency, astrDepositMaturityTenor, adblDepositQuote, strDepositMeasure,
						adblFuturesQuote, strFuturesMeasure, astrFixFloatMaturityTenor, adblFixFloatQuote,
							strFixFloatMeasure, iLatentStateType);

<span class="pc bpc" id="L1718" title="1 of 2 branches missed.">				if (null != dcFundingBase) mapBumpedCurve.put (&quot;BASE&quot;, dcFundingBase);</span>

<span class="fc" id="L1720">				org.drip.state.discount.MergedDiscountForwardCurve dcFundingBumped = FundingCurve (dtSpot,</span>
					strCurrency, astrDepositMaturityTenor, adblDepositParallelBump, strDepositMeasure,
						adblFuturesParallelBump, strFuturesMeasure, astrFixFloatMaturityTenor,
							adblFixFloatParallelBump, strFixFloatMeasure, iLatentStateType);

<span class="pc bpc" id="L1725" title="1 of 2 branches missed.">				if (null != dcFundingBumped) mapBumpedCurve.put (&quot;BUMP&quot;, dcFundingBumped);</span>
			}
<span class="nc" id="L1727">		} catch (java.lang.Exception e) {</span>
<span class="nc" id="L1728">			e.printStackTrace();</span>
<span class="fc" id="L1729">		}</span>

<span class="fc" id="L1731">		return mapBumpedCurve;</span>
	}

	/**
	 * Construct a Map of Tenor Bumped Funding Curve Based off of the Underlying Forward Curve Shift
	 * 
	 * @param dtSpot The Spot Date
	 * @param strCurrency Currency
	 * @param astrDepositMaturityTenor Array of Deposit Maturity Tenors
	 * @param adblDepositQuote Array of Deposit Quotes
	 * @param strDepositMeasure Deposit Calibration Measure
	 * @param adblFuturesQuote Array of Futures Quotes
	 * @param strFuturesMeasure Futures Calibration Measure
	 * @param astrFixFloatMaturityTenor Array of Fix Float Swap Maturity Tenors
	 * @param adblFixFloatQuote Array of Fix Float Swap Quotes
	 * @param strFixFloatMeasure Fix Float Calibration Measure
	 * @param iLatentStateType SHAPE_PRESERVING/SMOOTH
	 * @param dblBump The Tenor Node Bump Amount
	 * @param bIsProportional TRUE - The Bump Applied is Proportional
	 * 
	 * @return The Tenor Bumped Funding Curve Map
	 */

	public static final
		org.drip.analytics.support.CaseInsensitiveTreeMap&lt;org.drip.state.discount.MergedDiscountForwardCurve&gt;
			BumpedForwardFundingCurve (
				final org.drip.analytics.date.JulianDate dtSpot,
				final java.lang.String strCurrency,
				final java.lang.String[] astrDepositMaturityTenor,
				final double[] adblDepositQuote,
				final java.lang.String strDepositMeasure,
				final double[] adblFuturesQuote,
				final java.lang.String strFuturesMeasure,
				final java.lang.String[] astrFixFloatMaturityTenor,
				final double[] adblFixFloatQuote,
				final java.lang.String strFixFloatMeasure,
				final int iLatentStateType,
				final double dblBump,
				final boolean bIsProportional)
	{
<span class="pc bpc" id="L1771" title="1 of 2 branches missed.">		if (!org.drip.quant.common.NumberUtil.IsValid (dblBump)) return null;</span>

		org.drip.analytics.support.CaseInsensitiveTreeMap&lt;org.drip.state.discount.MergedDiscountForwardCurve&gt;
<span class="fc" id="L1774">			mapBumpedCurve = new</span>
				org.drip.analytics.support.CaseInsensitiveTreeMap&lt;org.drip.state.discount.MergedDiscountForwardCurve&gt;();

<span class="fc" id="L1777">		org.drip.state.discount.MergedDiscountForwardCurve dcFundingBase = SingleStretchFundingCurve (dtSpot, strCurrency,</span>
			astrDepositMaturityTenor, adblDepositQuote, strDepositMeasure, adblFuturesQuote,
				strFuturesMeasure, astrFixFloatMaturityTenor, adblFixFloatQuote, strFixFloatMeasure,
					iLatentStateType);

<span class="pc bpc" id="L1782" title="1 of 2 branches missed.">		if (null == dcFundingBase) return null;</span>

<span class="pc bpc" id="L1784" title="1 of 2 branches missed.">		int iNumDeposit = null == astrDepositMaturityTenor ? 0 : astrDepositMaturityTenor.length;</span>
<span class="pc bpc" id="L1785" title="1 of 2 branches missed.">		int iNumFixFloat = null == adblFixFloatQuote ? 0 : adblFixFloatQuote.length;</span>
<span class="pc bpc" id="L1786" title="1 of 2 branches missed.">		int iNumFutures = null == adblFuturesQuote ? 0 : adblFuturesQuote.length;</span>
<span class="fc" id="L1787">		int iNumDepositFutures = iNumDeposit + iNumFutures;</span>
<span class="fc" id="L1788">		int iNumDepositFuturesFixFloat = iNumDepositFutures + iNumFixFloat;</span>
<span class="fc" id="L1789">		int[] aiDate = new int[iNumDepositFuturesFixFloat];</span>

<span class="fc" id="L1791">		org.drip.product.rates.SingleStreamComponent[] aSSC =</span>
<span class="fc" id="L1792">			org.drip.service.template.ExchangeInstrumentBuilder.ForwardRateFuturesPack (dtSpot, iNumFutures,</span>
				strCurrency);

<span class="fc bfc" id="L1795" title="All 2 branches covered.">		for (int i = 0; i &lt; iNumDeposit; ++i)</span>
<span class="fc" id="L1796">			aiDate[i] = dtSpot.addTenor (astrDepositMaturityTenor[i]).julian();</span>

<span class="fc bfc" id="L1798" title="All 2 branches covered.">		for (int i = iNumDeposit; i &lt; iNumDepositFutures; ++i)</span>
<span class="fc" id="L1799">			aiDate[i] = aSSC[i - iNumDeposit].maturityDate().julian();</span>

<span class="fc bfc" id="L1801" title="All 2 branches covered.">		for (int i = iNumDepositFutures; i &lt; iNumDepositFuturesFixFloat; ++i)</span>
<span class="fc" id="L1802">			aiDate[i] = dtSpot.addTenor (astrFixFloatMaturityTenor[i - iNumDepositFutures]).julian();</span>

<span class="fc" id="L1804">		org.drip.state.nonlinear.FlatForwardDiscountCurve ffdc = dcFundingBase.flatNativeForward (aiDate,</span>
			0.);

<span class="pc bpc" id="L1807" title="1 of 2 branches missed.">		if (null == ffdc) return null;</span>

<span class="fc" id="L1809">		mapBumpedCurve.put (&quot;base&quot;, ffdc);</span>

<span class="fc" id="L1811">		org.drip.state.nonlinear.FlatForwardDiscountCurve ffdcBumped = dcFundingBase.flatNativeForward</span>
<span class="fc" id="L1812">			(aiDate, dblBump);</span>

<span class="pc bpc" id="L1814" title="1 of 2 branches missed.">		if (null == ffdcBumped) return null;</span>

<span class="fc" id="L1816">		mapBumpedCurve.put (&quot;bump&quot;, ffdcBumped);</span>

<span class="fc bfc" id="L1818" title="All 2 branches covered.">		for (int i = 0; i &lt; iNumDepositFuturesFixFloat; ++i) {</span>
<span class="fc" id="L1819">			org.drip.state.nonlinear.FlatForwardDiscountCurve ffdcTenorBumped =</span>
<span class="fc" id="L1820">				dcFundingBase.flatNativeForwardEI (aiDate, i, dblBump);</span>

<span class="pc bpc" id="L1822" title="1 of 2 branches missed.">			if (null == ffdcTenorBumped) return null;</span>

<span class="fc" id="L1824">			mapBumpedCurve.put (&quot;tenor::&quot; + i, ffdcTenorBumped);</span>
		}

<span class="fc" id="L1827">		return mapBumpedCurve;</span>
	}

	/**
	 * Construct a Map of Tenor Bumped Forward Curve Based off of the Input Exchange/OTC Market Instruments
	 * 
	 * @param dtSpot Spot Date
	 * @param forwardLabel Forward Label
	 * @param astrDepositMaturityTenor Array of Deposit Maturity Tenors
	 * @param adblDepositQuote Array of the Deposit Instrument Quotes
	 * @param strDepositMeasure The Deposit Instrument Calibration Measure
	 * @param astrFRAMaturityTenor Array of FRA Maturity Tenors
	 * @param adblFRAQuote Array of the FRA Instrument Quotes
	 * @param strFRAMeasure The FRA Instrument Calibration Measure
	 * @param astrFixFloatMaturityTenor Array of Fix-Float Maturity Tenors
	 * @param adblFixFloatQuote Array of the Fix-Float Quotes
	 * @param strFixFloatMeasure The Fix-Float Calibration Measure
	 * @param astrFloatFloatMaturityTenor Array of Float-Float Maturity Tenors
	 * @param adblFloatFloatQuote Array of the Float-Float Quotes
	 * @param strFloatFloatMeasure The Float-Float Calibration Measure
	 * @param astrSyntheticFloatFloatMaturityTenor Array of Synthetic Float-Float Maturity Tenors
	 * @param adblSyntheticFloatFloatQuote Array of the Synthetic Float-Float Quotes
	 * @param strSyntheticFloatFloatMeasure The Synthetic Float-Float Calibration Measure
	 * @param dc The Base Discount Curve
	 * @param fcReference The Reference Forward Curve
	 * @param iLatentStateType SHAPE_PRESERVING/SMOOTH
	 * @param dblBump The Tenor Node Bump Amount
	 * @param bIsProportional TRUE - The Bump Applied is Proportional
	 * 
	 * @return The Tenor Bumped Forward Curve Map
	 */

	public static final
		org.drip.analytics.support.CaseInsensitiveTreeMap&lt;org.drip.state.forward.ForwardCurve&gt;
			BumpedForwardCurve (
				final org.drip.analytics.date.JulianDate dtSpot,
				final org.drip.state.identifier.ForwardLabel forwardLabel,
				final java.lang.String[] astrDepositMaturityTenor,
				final double[] adblDepositQuote,
				final java.lang.String strDepositMeasure,
				final java.lang.String[] astrFRAMaturityTenor,
				final double[] adblFRAQuote,
				final java.lang.String strFRAMeasure,
				final java.lang.String[] astrFixFloatMaturityTenor,
				final double[] adblFixFloatQuote,
				final java.lang.String strFixFloatMeasure,
				final java.lang.String[] astrFloatFloatMaturityTenor,
				final double[] adblFloatFloatQuote,
				final java.lang.String strFloatFloatMeasure,
				final java.lang.String[] astrSyntheticFloatFloatMaturityTenor,
				final double[] adblSyntheticFloatFloatQuote,
				final java.lang.String strSyntheticFloatFloatMeasure,
				final org.drip.state.discount.MergedDiscountForwardCurve dc,
				final org.drip.state.forward.ForwardCurve fcReference,
				final int iLatentStateType,
				final double dblBump,
				final boolean bIsProportional)
	{
<span class="pc bpc" id="L1885" title="1 of 2 branches missed.">		if (!org.drip.quant.common.NumberUtil.IsValid (dblBump)) return null;</span>

		org.drip.analytics.support.CaseInsensitiveTreeMap&lt;org.drip.state.forward.ForwardCurve&gt;
<span class="fc" id="L1888">			mapBumpedCurve = new</span>
				org.drip.analytics.support.CaseInsensitiveTreeMap&lt;org.drip.state.forward.ForwardCurve&gt;();

		try {
<span class="fc" id="L1892">			org.drip.param.definition.ManifestMeasureTweak mmtFLAT = new</span>
				org.drip.param.definition.ManifestMeasureTweak
					(org.drip.param.definition.ManifestMeasureTweak.FLAT, bIsProportional, dblBump);

<span class="pc bpc" id="L1896" title="1 of 2 branches missed.">			if (null != adblDepositQuote) {</span>
<span class="fc" id="L1897">				int iNumDeposit = adblDepositQuote.length;</span>

<span class="fc bfc" id="L1899" title="All 2 branches covered.">				for (int i = 0; i &lt; iNumDeposit; ++i) {</span>
<span class="fc" id="L1900">					org.drip.state.forward.ForwardCurve fcDepositQuoteBumped = ForwardCurve (dtSpot,</span>
						forwardLabel, astrDepositMaturityTenor,
<span class="fc" id="L1902">							org.drip.analytics.support.Helper.TweakManifestMeasure (adblDepositQuote, new</span>
								org.drip.param.definition.ManifestMeasureTweak (i, bIsProportional,
									dblBump)), strDepositMeasure, astrFRAMaturityTenor, adblFRAQuote,
										strFRAMeasure, astrFixFloatMaturityTenor, adblFixFloatQuote,
											strFixFloatMeasure, astrFloatFloatMaturityTenor,
												adblFloatFloatQuote, strFloatFloatMeasure,
													astrSyntheticFloatFloatMaturityTenor,
														adblSyntheticFloatFloatQuote,
															strSyntheticFloatFloatMeasure, dc, fcReference,
																iLatentStateType);

<span class="pc bpc" id="L1913" title="1 of 2 branches missed.">					if (null != fcDepositQuoteBumped)</span>
<span class="fc" id="L1914">						mapBumpedCurve.put (&quot;DEPOSIT::&quot; + astrDepositMaturityTenor[i],</span>
							fcDepositQuoteBumped);
				}
			}

<span class="fc" id="L1919">			double[] adblDepositParallelBump = org.drip.analytics.support.Helper.TweakManifestMeasure</span>
<span class="fc" id="L1920">				(adblDepositQuote, mmtFLAT);</span>

<span class="fc" id="L1922">			org.drip.state.forward.ForwardCurve fcDepositQuoteBumped = ForwardCurve (dtSpot, forwardLabel,</span>
				astrDepositMaturityTenor, adblDepositParallelBump, strDepositMeasure, astrFRAMaturityTenor,
					adblFRAQuote, strFRAMeasure, astrFixFloatMaturityTenor, adblFixFloatQuote,
						strFixFloatMeasure, astrFloatFloatMaturityTenor, adblFloatFloatQuote,
							strFloatFloatMeasure, astrSyntheticFloatFloatMaturityTenor,
								adblSyntheticFloatFloatQuote, strSyntheticFloatFloatMeasure, dc,
									fcReference, iLatentStateType);

<span class="pc bpc" id="L1930" title="1 of 2 branches missed.">			if (null != fcDepositQuoteBumped) mapBumpedCurve.put (&quot;DEPOSIT::PLL&quot;, fcDepositQuoteBumped);</span>

<span class="pc bpc" id="L1932" title="1 of 2 branches missed.">			if (null != adblFRAQuote) {</span>
<span class="fc" id="L1933">				int iNumFRA = adblFRAQuote.length;</span>

<span class="fc bfc" id="L1935" title="All 2 branches covered.">				for (int i = 0; i &lt; iNumFRA; ++i) {</span>
<span class="fc" id="L1936">					org.drip.state.forward.ForwardCurve fcFRAQuoteBumped = ForwardCurve (dtSpot,</span>
						forwardLabel, astrDepositMaturityTenor, adblDepositQuote, strDepositMeasure,
							astrFRAMaturityTenor, org.drip.analytics.support.Helper.TweakManifestMeasure
<span class="fc" id="L1939">								(adblFRAQuote, new org.drip.param.definition.ManifestMeasureTweak (i,</span>
									bIsProportional, dblBump)), strFRAMeasure, astrFixFloatMaturityTenor,
										adblFixFloatQuote, strFixFloatMeasure, astrFloatFloatMaturityTenor,
											adblFloatFloatQuote, strFloatFloatMeasure,
												astrSyntheticFloatFloatMaturityTenor,
													adblSyntheticFloatFloatQuote,
														strSyntheticFloatFloatMeasure, dc, fcReference,
															iLatentStateType);

<span class="pc bpc" id="L1948" title="1 of 2 branches missed.">					if (null != fcFRAQuoteBumped)</span>
<span class="fc" id="L1949">						mapBumpedCurve.put (&quot;FRA::&quot; + astrFRAMaturityTenor[i], fcFRAQuoteBumped);</span>
				}
			}

<span class="fc" id="L1953">			double[] adblFRAParallelBump = org.drip.analytics.support.Helper.TweakManifestMeasure</span>
<span class="fc" id="L1954">				(adblFRAQuote, mmtFLAT);</span>

<span class="fc" id="L1956">			org.drip.state.forward.ForwardCurve fcFRAQuoteBumped = ForwardCurve (dtSpot, forwardLabel,</span>
				astrDepositMaturityTenor, adblDepositQuote, strDepositMeasure, astrFRAMaturityTenor,
					adblFRAParallelBump, strFRAMeasure, astrFixFloatMaturityTenor, adblFixFloatQuote,
						strFixFloatMeasure, astrFloatFloatMaturityTenor, adblFloatFloatQuote,
							strFloatFloatMeasure, astrSyntheticFloatFloatMaturityTenor,
								adblSyntheticFloatFloatQuote, strSyntheticFloatFloatMeasure, dc,
									fcReference, iLatentStateType);

<span class="pc bpc" id="L1964" title="1 of 2 branches missed.">			if (null != fcFRAQuoteBumped) mapBumpedCurve.put (&quot;FRA::PLL&quot;, fcFRAQuoteBumped);</span>

<span class="pc bpc" id="L1966" title="1 of 2 branches missed.">			if (null != adblFixFloatQuote) {</span>
<span class="fc" id="L1967">				int iNumFixFloat = adblFixFloatQuote.length;</span>

<span class="fc bfc" id="L1969" title="All 2 branches covered.">				for (int i = 0; i &lt; iNumFixFloat; ++i) {</span>
<span class="fc" id="L1970">					org.drip.state.forward.ForwardCurve fcFixFloatQuoteBumped = ForwardCurve (dtSpot,</span>
						forwardLabel, astrDepositMaturityTenor, adblDepositQuote, strDepositMeasure,
							astrFRAMaturityTenor, adblFRAQuote, strFRAMeasure, astrFixFloatMaturityTenor,
<span class="fc" id="L1973">								org.drip.analytics.support.Helper.TweakManifestMeasure (adblFixFloatQuote,</span>
									new org.drip.param.definition.ManifestMeasureTweak (i, bIsProportional,
										dblBump)), strFixFloatMeasure, astrFloatFloatMaturityTenor,
											adblFloatFloatQuote, strFloatFloatMeasure,
												astrSyntheticFloatFloatMaturityTenor,
													adblSyntheticFloatFloatQuote,
														strSyntheticFloatFloatMeasure, dc, fcReference,
															iLatentStateType);

<span class="pc bpc" id="L1982" title="1 of 2 branches missed.">					if (null != fcFixFloatQuoteBumped)</span>
<span class="fc" id="L1983">						mapBumpedCurve.put (&quot;FIXFLOAT::&quot; + astrFixFloatMaturityTenor[i],</span>
							fcFixFloatQuoteBumped);
				}
			}

<span class="fc" id="L1988">			double[] adblFixFloatParallelBump = org.drip.analytics.support.Helper.TweakManifestMeasure</span>
<span class="fc" id="L1989">				(adblFixFloatQuote, mmtFLAT);</span>

<span class="fc" id="L1991">			org.drip.state.forward.ForwardCurve fcFixFloatQuoteBumped = ForwardCurve (dtSpot, forwardLabel,</span>
				astrDepositMaturityTenor, adblDepositQuote, strDepositMeasure, astrFRAMaturityTenor,
					adblFRAQuote, strFRAMeasure, astrFixFloatMaturityTenor, adblFixFloatParallelBump,
						strFixFloatMeasure, astrFloatFloatMaturityTenor, adblFloatFloatQuote,
							strFloatFloatMeasure, astrSyntheticFloatFloatMaturityTenor,
								adblSyntheticFloatFloatQuote, strSyntheticFloatFloatMeasure, dc,
									fcReference, iLatentStateType);

<span class="pc bpc" id="L1999" title="1 of 2 branches missed.">			if (null != fcFixFloatQuoteBumped) mapBumpedCurve.put (&quot;FIXFLOAT::PLL&quot;, fcFixFloatQuoteBumped);</span>

<span class="pc bpc" id="L2001" title="1 of 2 branches missed.">			if (null != adblFloatFloatQuote) {</span>
<span class="nc" id="L2002">				int iNumFloatFloat = adblFloatFloatQuote.length;</span>

<span class="nc bnc" id="L2004" title="All 2 branches missed.">				for (int i = 0; i &lt; iNumFloatFloat; ++i) {</span>
<span class="nc" id="L2005">					org.drip.state.forward.ForwardCurve fcFloatFloatQuoteBumped = ForwardCurve (dtSpot,</span>
						forwardLabel, astrDepositMaturityTenor, adblDepositQuote, strDepositMeasure,
							astrFRAMaturityTenor, adblFRAQuote, strFRAMeasure, astrFixFloatMaturityTenor,
								adblFRAQuote, strFixFloatMeasure, astrFloatFloatMaturityTenor,
									org.drip.analytics.support.Helper.TweakManifestMeasure
<span class="nc" id="L2010">										(adblFloatFloatQuote, new</span>
											org.drip.param.definition.ManifestMeasureTweak (i,
												bIsProportional, dblBump)), strFloatFloatMeasure,
													astrSyntheticFloatFloatMaturityTenor,
														adblSyntheticFloatFloatQuote,
															strSyntheticFloatFloatMeasure, dc, fcReference,
																iLatentStateType);

<span class="nc bnc" id="L2018" title="All 2 branches missed.">					if (null != fcFloatFloatQuoteBumped)</span>
<span class="nc" id="L2019">						mapBumpedCurve.put (&quot;FLOATFLOAT::&quot; + astrFloatFloatMaturityTenor[i],</span>
							fcFloatFloatQuoteBumped);
				}
			}

<span class="fc" id="L2024">			double[] adblFloatFloatParallelBump = org.drip.analytics.support.Helper.TweakManifestMeasure</span>
<span class="fc" id="L2025">				(adblFloatFloatQuote, mmtFLAT);</span>

<span class="fc" id="L2027">			org.drip.state.forward.ForwardCurve fcFloatFloatQuoteBumped = ForwardCurve (dtSpot, forwardLabel,</span>
				astrDepositMaturityTenor, adblDepositQuote, strDepositMeasure, astrFRAMaturityTenor,
					adblFRAQuote, strFRAMeasure, astrFixFloatMaturityTenor, adblFixFloatQuote,
						strFixFloatMeasure, astrFloatFloatMaturityTenor, adblFloatFloatParallelBump,
							strFloatFloatMeasure, astrSyntheticFloatFloatMaturityTenor,
								adblSyntheticFloatFloatQuote, strSyntheticFloatFloatMeasure, dc,
									fcReference, iLatentStateType);

<span class="pc bpc" id="L2035" title="1 of 2 branches missed.">			if (null != fcFloatFloatQuoteBumped)</span>
<span class="fc" id="L2036">				mapBumpedCurve.put (&quot;FLOATFLOAT::PLL&quot;, fcFloatFloatQuoteBumped);</span>

<span class="fc bfc" id="L2038" title="All 2 branches covered.">			if (null != adblSyntheticFloatFloatQuote) {</span>
<span class="fc" id="L2039">				int iNumSyntheticFloatFloat = adblSyntheticFloatFloatQuote.length;</span>

<span class="fc bfc" id="L2041" title="All 2 branches covered.">				for (int i = 0; i &lt; iNumSyntheticFloatFloat; ++i) {</span>
<span class="fc" id="L2042">					org.drip.state.forward.ForwardCurve fcSyntheticFloatFloatQuoteBumped = ForwardCurve</span>
<span class="fc" id="L2043">						(dtSpot, forwardLabel, astrDepositMaturityTenor, adblDepositQuote, strDepositMeasure,</span>
							astrFRAMaturityTenor, adblFRAQuote, strFRAMeasure, astrFixFloatMaturityTenor,
								adblFixFloatQuote, strFixFloatMeasure, astrFloatFloatMaturityTenor,
									adblFloatFloatQuote, strFloatFloatMeasure,
										astrSyntheticFloatFloatMaturityTenor,
											org.drip.analytics.support.Helper.TweakManifestMeasure
<span class="fc" id="L2049">												(adblSyntheticFloatFloatQuote, new</span>
													org.drip.param.definition.ManifestMeasureTweak (i,
														bIsProportional, dblBump)),
															strSyntheticFloatFloatMeasure, dc, fcReference,
																iLatentStateType);

<span class="pc bpc" id="L2055" title="1 of 2 branches missed.">					if (null != fcSyntheticFloatFloatQuoteBumped)</span>
<span class="fc" id="L2056">						mapBumpedCurve.put (&quot;SYNTHETICFLOATFLOAT::&quot; +</span>
							astrSyntheticFloatFloatMaturityTenor[i], fcSyntheticFloatFloatQuoteBumped);
				}
			}

<span class="fc" id="L2061">			double[] adblSyntheticFloatFloatParallelBump =</span>
<span class="fc" id="L2062">				org.drip.analytics.support.Helper.TweakManifestMeasure (adblSyntheticFloatFloatQuote,</span>
					mmtFLAT);

<span class="fc" id="L2065">			org.drip.state.forward.ForwardCurve fcSyntheticFloatFloatQuoteBumped = ForwardCurve (dtSpot,</span>
				forwardLabel, astrDepositMaturityTenor, adblDepositQuote, strDepositMeasure,
					astrFRAMaturityTenor, adblFRAQuote, strFRAMeasure, astrFixFloatMaturityTenor,
						adblFixFloatQuote, strFixFloatMeasure, astrFloatFloatMaturityTenor,
							adblFloatFloatQuote, strFloatFloatMeasure, astrSyntheticFloatFloatMaturityTenor,
								adblSyntheticFloatFloatParallelBump, strSyntheticFloatFloatMeasure, dc,
									fcReference, iLatentStateType);

<span class="pc bpc" id="L2073" title="1 of 2 branches missed.">			if (null != fcSyntheticFloatFloatQuoteBumped)</span>
<span class="fc" id="L2074">				mapBumpedCurve.put (&quot;SYNTHETICFLOATFLOAT::PLL&quot;, fcSyntheticFloatFloatQuoteBumped);</span>

<span class="fc" id="L2076">			org.drip.state.forward.ForwardCurve fcQuoteBase = ForwardCurve (dtSpot, forwardLabel,</span>
				astrDepositMaturityTenor, adblDepositQuote, strDepositMeasure, astrFRAMaturityTenor,
					adblFRAQuote, strFRAMeasure, astrFixFloatMaturityTenor, adblFixFloatQuote,
						strFixFloatMeasure, astrFloatFloatMaturityTenor, adblFloatFloatQuote,
							strFloatFloatMeasure, astrSyntheticFloatFloatMaturityTenor,
								adblSyntheticFloatFloatQuote, strSyntheticFloatFloatMeasure, dc,
									fcReference, iLatentStateType);

<span class="pc bpc" id="L2084" title="1 of 2 branches missed.">			if (null != fcQuoteBase) mapBumpedCurve.put (&quot;BASE&quot;, fcQuoteBase);</span>

<span class="fc" id="L2086">			org.drip.state.forward.ForwardCurve fcQuoteBump = ForwardCurve (dtSpot, forwardLabel,</span>
				astrDepositMaturityTenor, adblDepositParallelBump, strDepositMeasure, astrFRAMaturityTenor,
					adblFRAParallelBump, strFRAMeasure, astrFixFloatMaturityTenor, adblFixFloatParallelBump,
						strFixFloatMeasure, astrFloatFloatMaturityTenor, adblFloatFloatParallelBump,
							strFloatFloatMeasure, astrSyntheticFloatFloatMaturityTenor,
								adblSyntheticFloatFloatParallelBump, strSyntheticFloatFloatMeasure, dc,
									fcReference, iLatentStateType);

<span class="pc bpc" id="L2094" title="1 of 2 branches missed.">			if (null != fcQuoteBump) mapBumpedCurve.put (&quot;BUMP&quot;, fcQuoteBump);</span>
<span class="nc" id="L2095">		} catch (java.lang.Exception e) {</span>
<span class="nc" id="L2096">			e.printStackTrace();</span>
<span class="fc" id="L2097">		}</span>

<span class="fc" id="L2099">		return mapBumpedCurve;</span>
	}

	/**
	 * Construct a Map of Tenor + Parallel Bumped Overnight Curves
	 * 
	 * @param dtSpot Spot Date
	 * @param strCurrency Currency
	 * @param astrDepositMaturityTenor Array of Deposit Maturity Tenors
	 * @param adblDepositQuote Array of Deposit Quotes
	 * @param strDepositMeasure Deposit Measure
	 * @param astrShortEndOISMaturityTenor Array of Short End OIS Maturity Tenors
	 * @param adblShortEndOISQuote Array of Short End OIS Quotes
	 * @param strShortEndOISMeasure Short End OIS Measure
	 * @param astrOISFuturesEffectiveTenor Array of OIS Futures Effective Tenors
	 * @param astrOISFuturesMaturityTenor Array of OIS Futures Maturity Tenors
	 * @param adblOISFuturesQuote Array of OIS Futures Quotes
	 * @param strOISFuturesMeasure OIS Futures Measure
	 * @param astrLongEndOISMaturityTenor Array of Long End OIS Maturity Tenors
	 * @param adblLongEndOISQuote Array of Long End OIS Quotes
	 * @param strLongEndOISMeasure Long End OIS Measure
	 * @param iLatentStateType SHAPE PRESERVING/SMOOTH
	 * @param dblBump The Tenor Node Bump Amount
	 * @param bIsProportional TRUE - The Bump Applied is Proportional
	 * 
	 * @return Map of Overnight Curves
	 */

	public static final
		org.drip.analytics.support.CaseInsensitiveTreeMap&lt;org.drip.state.discount.MergedDiscountForwardCurve&gt;
			BumpedOvernightCurve (
		final org.drip.analytics.date.JulianDate dtSpot,
		final String strCurrency,
		final java.lang.String[] astrDepositMaturityTenor,
		final double[] adblDepositQuote,
		final java.lang.String strDepositMeasure,
		final java.lang.String[] astrShortEndOISMaturityTenor,
		final double[] adblShortEndOISQuote,
		final java.lang.String strShortEndOISMeasure,
		final java.lang.String[] astrOISFuturesEffectiveTenor,
		final java.lang.String[] astrOISFuturesMaturityTenor,
		final double[] adblOISFuturesQuote,
		final java.lang.String strOISFuturesMeasure,
		final java.lang.String[] astrLongEndOISMaturityTenor,
		final double[] adblLongEndOISQuote,
		final java.lang.String strLongEndOISMeasure,
		final int iLatentStateType,
		final double dblBump,
		final boolean bIsProportional)
	{
<span class="pc bpc" id="L2149" title="1 of 2 branches missed.">		if (!org.drip.quant.common.NumberUtil.IsValid (dblBump)) return null;</span>

		org.drip.analytics.support.CaseInsensitiveTreeMap&lt;org.drip.state.discount.MergedDiscountForwardCurve&gt;
<span class="fc" id="L2152">			mapBumpedCurve = new</span>
				org.drip.analytics.support.CaseInsensitiveTreeMap&lt;org.drip.state.discount.MergedDiscountForwardCurve&gt;();

		try {
<span class="fc" id="L2156">			org.drip.param.definition.ManifestMeasureTweak mmtFLAT = new</span>
				org.drip.param.definition.ManifestMeasureTweak
					(org.drip.param.definition.ManifestMeasureTweak.FLAT, bIsProportional, dblBump);

<span class="pc bpc" id="L2160" title="1 of 2 branches missed.">			if (null != adblDepositQuote) {</span>
<span class="fc" id="L2161">				int iNumDeposit = adblDepositQuote.length;</span>

<span class="fc bfc" id="L2163" title="All 2 branches covered.">				for (int i = 0; i &lt; iNumDeposit; ++i) {</span>
<span class="fc" id="L2164">					org.drip.state.discount.MergedDiscountForwardCurve dcOvernightDepositBumped =</span>
<span class="fc" id="L2165">						OvernightCurve (dtSpot, strCurrency, astrDepositMaturityTenor,</span>
<span class="fc" id="L2166">							org.drip.analytics.support.Helper.TweakManifestMeasure (adblDepositQuote, new</span>
								org.drip.param.definition.ManifestMeasureTweak (i, bIsProportional,
									dblBump)), strDepositMeasure, astrShortEndOISMaturityTenor,
										adblShortEndOISQuote, strShortEndOISMeasure,
											astrOISFuturesEffectiveTenor, astrOISFuturesMaturityTenor,
												adblOISFuturesQuote, strOISFuturesMeasure,
													astrLongEndOISMaturityTenor, adblLongEndOISQuote,
														strLongEndOISMeasure, iLatentStateType);

<span class="pc bpc" id="L2175" title="1 of 2 branches missed.">					if (null != dcOvernightDepositBumped)</span>
<span class="fc" id="L2176">						mapBumpedCurve.put (&quot;DEPOSIT::&quot; + astrDepositMaturityTenor[i],</span>
							dcOvernightDepositBumped);
				}
			}

<span class="fc" id="L2181">			double[] adblDepositParallelBump = org.drip.analytics.support.Helper.TweakManifestMeasure</span>
<span class="fc" id="L2182">				(adblDepositQuote, mmtFLAT);</span>

<span class="fc" id="L2184">			org.drip.state.discount.MergedDiscountForwardCurve dcOvernightDepositBumped = OvernightCurve</span>
<span class="fc" id="L2185">				(dtSpot, strCurrency, astrDepositMaturityTenor, adblDepositParallelBump, strDepositMeasure,</span>
					astrShortEndOISMaturityTenor, adblShortEndOISQuote, strShortEndOISMeasure,
						astrOISFuturesEffectiveTenor, astrOISFuturesMaturityTenor, adblOISFuturesQuote,
							strOISFuturesMeasure, astrLongEndOISMaturityTenor, adblLongEndOISQuote,
								strLongEndOISMeasure, iLatentStateType);

<span class="pc bpc" id="L2191" title="1 of 2 branches missed.">			if (null != dcOvernightDepositBumped)</span>
<span class="fc" id="L2192">				mapBumpedCurve.put (&quot;DEPOSIT::PLL&quot;, dcOvernightDepositBumped);</span>

<span class="pc bpc" id="L2194" title="1 of 2 branches missed.">			if (null != adblShortEndOISQuote) {</span>
<span class="fc" id="L2195">				int iNumShortEndOIS = adblShortEndOISQuote.length;</span>

<span class="fc bfc" id="L2197" title="All 2 branches covered.">				for (int i = 0; i &lt; iNumShortEndOIS; ++i) {</span>
<span class="fc" id="L2198">					org.drip.state.discount.MergedDiscountForwardCurve dcOvernightShortEndOISBumped =</span>
<span class="fc" id="L2199">						OvernightCurve (dtSpot, strCurrency, astrDepositMaturityTenor, adblDepositQuote,</span>
							strDepositMeasure, astrShortEndOISMaturityTenor,
<span class="fc" id="L2201">								org.drip.analytics.support.Helper.TweakManifestMeasure (adblShortEndOISQuote,</span>
									new org.drip.param.definition.ManifestMeasureTweak (i, bIsProportional,
										dblBump)), strShortEndOISMeasure, astrOISFuturesEffectiveTenor,
											astrOISFuturesMaturityTenor, adblOISFuturesQuote,
												strOISFuturesMeasure, astrLongEndOISMaturityTenor,
													adblLongEndOISQuote, strLongEndOISMeasure,
														iLatentStateType);

<span class="pc bpc" id="L2209" title="1 of 2 branches missed.">					if (null != dcOvernightShortEndOISBumped)</span>
<span class="fc" id="L2210">						mapBumpedCurve.put (&quot;SHORTENDOIS::&quot; + astrShortEndOISMaturityTenor[i],</span>
							dcOvernightShortEndOISBumped);
				}
			}

<span class="fc" id="L2215">			double[] adblShortEndOISParallelBump = org.drip.analytics.support.Helper.TweakManifestMeasure</span>
<span class="fc" id="L2216">				(adblShortEndOISQuote, mmtFLAT);</span>

<span class="fc" id="L2218">			org.drip.state.discount.MergedDiscountForwardCurve dcOvernightShortEndOISBumped = OvernightCurve</span>
<span class="fc" id="L2219">				(dtSpot, strCurrency, astrDepositMaturityTenor, adblDepositQuote, strDepositMeasure,</span>
					astrShortEndOISMaturityTenor, adblShortEndOISParallelBump, strShortEndOISMeasure,
						astrOISFuturesEffectiveTenor, astrOISFuturesMaturityTenor,
							adblOISFuturesQuote, strOISFuturesMeasure, astrLongEndOISMaturityTenor,
								adblLongEndOISQuote, strLongEndOISMeasure, iLatentStateType);

<span class="pc bpc" id="L2225" title="1 of 2 branches missed.">			if (null != dcOvernightShortEndOISBumped)</span>
<span class="fc" id="L2226">				mapBumpedCurve.put (&quot;SHORTENDOIS::PLL&quot;, dcOvernightShortEndOISBumped);</span>

<span class="pc bpc" id="L2228" title="1 of 2 branches missed.">			if (null != adblOISFuturesQuote) {</span>
<span class="fc" id="L2229">				int iNumOISFutures = adblOISFuturesQuote.length;</span>

<span class="fc bfc" id="L2231" title="All 2 branches covered.">				for (int i = 0; i &lt; iNumOISFutures; ++i) {</span>
<span class="fc" id="L2232">					org.drip.state.discount.MergedDiscountForwardCurve dcOvernightOISFuturesBumped =</span>
<span class="fc" id="L2233">						OvernightCurve (dtSpot, strCurrency, astrDepositMaturityTenor, adblDepositQuote,</span>
							strDepositMeasure, astrShortEndOISMaturityTenor, adblShortEndOISQuote,
								strShortEndOISMeasure, astrOISFuturesEffectiveTenor,
									astrOISFuturesMaturityTenor,
										org.drip.analytics.support.Helper.TweakManifestMeasure
<span class="fc" id="L2238">											(adblOISFuturesQuote, new</span>
												org.drip.param.definition.ManifestMeasureTweak (i,
													bIsProportional, dblBump)), strOISFuturesMeasure,
														astrLongEndOISMaturityTenor, adblLongEndOISQuote,
															strLongEndOISMeasure, iLatentStateType);

<span class="pc bpc" id="L2244" title="1 of 2 branches missed.">					if (null != dcOvernightOISFuturesBumped)</span>
<span class="fc" id="L2245">						mapBumpedCurve.put (&quot;OISFUTURES::&quot; + astrOISFuturesEffectiveTenor[i] + &quot; x &quot; +</span>
							astrOISFuturesMaturityTenor[i], dcOvernightOISFuturesBumped);
				}
			}

<span class="fc" id="L2250">			double[] adblOISFuturesParallelBump = org.drip.analytics.support.Helper.TweakManifestMeasure</span>
<span class="fc" id="L2251">				(adblOISFuturesQuote, mmtFLAT);</span>

<span class="fc" id="L2253">			org.drip.state.discount.MergedDiscountForwardCurve dcOvernightOISFuturesBumped = OvernightCurve</span>
<span class="fc" id="L2254">				(dtSpot, strCurrency, astrDepositMaturityTenor, adblDepositQuote, strDepositMeasure,</span>
					astrShortEndOISMaturityTenor, adblShortEndOISQuote, strShortEndOISMeasure,
						astrOISFuturesEffectiveTenor, astrOISFuturesMaturityTenor,
							adblOISFuturesParallelBump, strOISFuturesMeasure, astrLongEndOISMaturityTenor,
								adblLongEndOISQuote, strLongEndOISMeasure, iLatentStateType);

<span class="pc bpc" id="L2260" title="1 of 2 branches missed.">			if (null != dcOvernightOISFuturesBumped)</span>
<span class="fc" id="L2261">				mapBumpedCurve.put (&quot;OISFUTURES::PARALLEL&quot;, dcOvernightOISFuturesBumped);</span>

<span class="pc bpc" id="L2263" title="1 of 2 branches missed.">			if (null != adblLongEndOISQuote) {</span>
<span class="fc" id="L2264">				int iNumLongEndOIS = adblLongEndOISQuote.length;</span>

<span class="fc bfc" id="L2266" title="All 2 branches covered.">				for (int i = 0; i &lt; iNumLongEndOIS; ++i) {</span>
<span class="fc" id="L2267">					org.drip.state.discount.MergedDiscountForwardCurve dcOvernightLongEndOISBumped =</span>
<span class="fc" id="L2268">						OvernightCurve (dtSpot, strCurrency, astrDepositMaturityTenor, adblDepositQuote,</span>
							strDepositMeasure, astrShortEndOISMaturityTenor, adblShortEndOISQuote,
								strShortEndOISMeasure, astrOISFuturesEffectiveTenor,
									astrOISFuturesMaturityTenor, adblOISFuturesQuote, strOISFuturesMeasure,
										astrLongEndOISMaturityTenor,
											org.drip.analytics.support.Helper.TweakManifestMeasure
<span class="fc" id="L2274">												(adblLongEndOISQuote, new</span>
													org.drip.param.definition.ManifestMeasureTweak (i,
														bIsProportional, dblBump)), strLongEndOISMeasure,
															iLatentStateType);

<span class="pc bpc" id="L2279" title="1 of 2 branches missed.">					if (null != dcOvernightLongEndOISBumped)</span>
<span class="fc" id="L2280">						mapBumpedCurve.put (&quot;LONGENDOIS::&quot; + astrLongEndOISMaturityTenor[i],</span>
							dcOvernightLongEndOISBumped);
				}
			}

<span class="fc" id="L2285">			double[] adblLongEndOISParallelBump = org.drip.analytics.support.Helper.TweakManifestMeasure</span>
<span class="fc" id="L2286">				(adblLongEndOISQuote, mmtFLAT);</span>

<span class="fc" id="L2288">			org.drip.state.discount.MergedDiscountForwardCurve dcOvernightLongEndOISBumped = OvernightCurve</span>
<span class="fc" id="L2289">				(dtSpot, strCurrency, astrDepositMaturityTenor, adblDepositQuote, strDepositMeasure,</span>
					astrShortEndOISMaturityTenor, adblShortEndOISQuote, strShortEndOISMeasure,
						astrOISFuturesEffectiveTenor, astrOISFuturesMaturityTenor, adblOISFuturesQuote,
							strOISFuturesMeasure, astrLongEndOISMaturityTenor, adblLongEndOISParallelBump,
								strLongEndOISMeasure, iLatentStateType);

<span class="pc bpc" id="L2295" title="1 of 2 branches missed.">			if (null != dcOvernightLongEndOISBumped)</span>
<span class="fc" id="L2296">				mapBumpedCurve.put (&quot;LONGENDOIS::PLL&quot;, dcOvernightLongEndOISBumped);</span>

<span class="fc" id="L2298">			org.drip.state.discount.MergedDiscountForwardCurve dcOvernightBase = OvernightCurve (dtSpot,</span>
				strCurrency, astrDepositMaturityTenor, adblDepositQuote, strDepositMeasure,
					astrShortEndOISMaturityTenor, adblShortEndOISQuote, strShortEndOISMeasure,
						astrOISFuturesEffectiveTenor, astrOISFuturesMaturityTenor, adblOISFuturesQuote,
							strOISFuturesMeasure, astrLongEndOISMaturityTenor, adblLongEndOISQuote,
								strLongEndOISMeasure, iLatentStateType);

<span class="pc bpc" id="L2305" title="1 of 2 branches missed.">			if (null != dcOvernightBase) mapBumpedCurve.put (&quot;BASE&quot;, dcOvernightBase);</span>

<span class="fc" id="L2307">			org.drip.state.discount.MergedDiscountForwardCurve dcOvernightBump = OvernightCurve (dtSpot,</span>
				strCurrency, astrDepositMaturityTenor, adblDepositParallelBump, strDepositMeasure,
					astrShortEndOISMaturityTenor, adblShortEndOISParallelBump, strShortEndOISMeasure,
						astrOISFuturesEffectiveTenor, astrOISFuturesMaturityTenor,
							adblOISFuturesParallelBump, strOISFuturesMeasure, astrLongEndOISMaturityTenor,
								adblLongEndOISParallelBump, strLongEndOISMeasure, iLatentStateType);

<span class="pc bpc" id="L2314" title="1 of 2 branches missed.">			if (null != dcOvernightBump) mapBumpedCurve.put (&quot;BUMP&quot;, dcOvernightBump);</span>
<span class="nc" id="L2315">		} catch (java.lang.Exception e) {</span>
<span class="nc" id="L2316">			e.printStackTrace();</span>

<span class="nc" id="L2318">			return null;</span>
<span class="fc" id="L2319">		}</span>

<span class="fc" id="L2321">		return mapBumpedCurve;</span>
	}

	/**
	 * Construct a Tenor + Parallel Map of Bumped Credit Curves from Overnight Exchange/OTC Market Instruments
	 * 
	 * @param dtSpot Spot Date
	 * @param strCredit Credit Curve
	 * @param astrMaturityTenor Maturity Tenor
	 * @param adblCoupon Coupon Array
	 * @param adblQuote Array of Market Quotes
	 * @param strMeasure Calibration Measure
	 * @param dc Discount Curve
	 * @param dblBump The Tenor Node Bump Amount
	 * @param bIsProportional TRUE - The Bump Applied is Proportional
	 * 
	 * @return Map of Bumped Credit Curves
	 */

	public static final org.drip.analytics.support.CaseInsensitiveTreeMap&lt;org.drip.state.credit.CreditCurve&gt;
		BumpedCreditCurve (
			final org.drip.analytics.date.JulianDate dtSpot,
			final java.lang.String strCredit,
			final java.lang.String[] astrMaturityTenor,
			final double[] adblCoupon,
			final double[] adblQuote,
			final java.lang.String strMeasure,
			final org.drip.state.discount.MergedDiscountForwardCurve dc,
			final double dblBump,
			final boolean bIsProportional)
	{
<span class="pc bpc" id="L2352" title="1 of 2 branches missed.">		if (!org.drip.quant.common.NumberUtil.IsValid (dblBump)) return null;</span>

<span class="fc" id="L2354">		org.drip.analytics.support.CaseInsensitiveTreeMap&lt;org.drip.state.credit.CreditCurve&gt; mapBumpedCurve =</span>
			new org.drip.analytics.support.CaseInsensitiveTreeMap&lt;org.drip.state.credit.CreditCurve&gt;();

<span class="pc bpc" id="L2357" title="1 of 2 branches missed.">		if (null != adblQuote) {</span>
<span class="fc" id="L2358">			int iNumComp = adblQuote.length;</span>

<span class="fc bfc" id="L2360" title="All 2 branches covered.">			for (int i = 0; i &lt; iNumComp; ++i) {</span>
				try {
<span class="fc" id="L2362">					org.drip.state.credit.CreditCurve ccBumped = CreditCurve (dtSpot, strCredit,</span>
						astrMaturityTenor, adblCoupon, org.drip.analytics.support.Helper.TweakManifestMeasure
<span class="fc" id="L2364">							(adblQuote, new org.drip.param.definition.ManifestMeasureTweak (i,</span>
								bIsProportional, dblBump)), strMeasure, dc);

<span class="pc bpc" id="L2367" title="1 of 2 branches missed.">					if (null != ccBumped) mapBumpedCurve.put (&quot;CDS::&quot; + astrMaturityTenor[i], ccBumped);</span>
<span class="nc" id="L2368">				} catch (java.lang.Exception e) {</span>
<span class="nc" id="L2369">					e.printStackTrace();</span>
<span class="fc" id="L2370">				}</span>
			}
		}

		try {
<span class="fc" id="L2375">			org.drip.state.credit.CreditCurve ccBase = CreditCurve (dtSpot, strCredit, astrMaturityTenor,</span>
				adblCoupon, adblQuote, strMeasure, dc);

<span class="pc bpc" id="L2378" title="1 of 2 branches missed.">			if (null != ccBase) mapBumpedCurve.put (&quot;BASE&quot;, ccBase);</span>

<span class="fc" id="L2380">			org.drip.state.credit.CreditCurve ccBumped = CreditCurve (dtSpot, strCredit, astrMaturityTenor,</span>
<span class="fc" id="L2381">				adblCoupon, org.drip.analytics.support.Helper.TweakManifestMeasure (adblQuote, new</span>
					org.drip.param.definition.ManifestMeasureTweak
						(org.drip.param.definition.ManifestMeasureTweak.FLAT, bIsProportional, dblBump)),
							strMeasure, dc);

<span class="pc bpc" id="L2386" title="1 of 2 branches missed.">			if (null != ccBumped) mapBumpedCurve.put (&quot;BUMP&quot;, ccBumped);</span>
<span class="nc" id="L2387">		} catch (java.lang.Exception e) {</span>
<span class="nc" id="L2388">			e.printStackTrace();</span>
<span class="fc" id="L2389">		}</span>

<span class="fc" id="L2391">		return mapBumpedCurve;</span>
	}

	/**
	 * Construct a Tenor + Parallel Map of Govvie Curves from the Treasury Instruments
	 * 
	 * @param strCode The Govvie Code
	 * @param dtSpot Spot Date
	 * @param adtEffective Array of Effective Dates
	 * @param adtMaturity Array of Maturity Dates
	 * @param adblCoupon Array of Coupons
	 * @param adblQuote Array of Market Quotes
	 * @param strMeasure Calibration Measure
	 * @param iLatentStateType SHAPE PRESERVING/SMOOTH
	 * @param dblBump The Tenor Node Bump Amount
	 * @param bIsProportional TRUE - The Bump Applied is Proportional
	 * 
	 * @return Map of Govvie Curve Instance
	 */

	public static final org.drip.analytics.support.CaseInsensitiveTreeMap&lt;org.drip.state.govvie.GovvieCurve&gt;
		BumpedGovvieCurve (
			final java.lang.String strCode,
			final org.drip.analytics.date.JulianDate dtSpot,
			final org.drip.analytics.date.JulianDate[] adtEffective,
			final org.drip.analytics.date.JulianDate[] adtMaturity,
			final double[] adblCoupon,
			final double[] adblQuote,
			final java.lang.String strMeasure,
			final int iLatentStateType,
			final double dblBump,
			final boolean bIsProportional)
	{
<span class="pc bpc" id="L2424" title="1 of 2 branches missed.">		if (!org.drip.quant.common.NumberUtil.IsValid (dblBump)) return null;</span>

<span class="fc" id="L2426">		org.drip.analytics.support.CaseInsensitiveTreeMap&lt;org.drip.state.govvie.GovvieCurve&gt; mapBumpedCurve =</span>
			new org.drip.analytics.support.CaseInsensitiveTreeMap&lt;org.drip.state.govvie.GovvieCurve&gt;();

<span class="pc bpc" id="L2429" title="1 of 2 branches missed.">		if (null != adblQuote) {</span>
<span class="fc" id="L2430">			int iNumComp = adblQuote.length;</span>

<span class="fc bfc" id="L2432" title="All 2 branches covered.">			for (int i = 0; i &lt; iNumComp; ++i) {</span>
				try {
<span class="fc" id="L2434">					org.drip.state.govvie.GovvieCurve gcBumped = GovvieCurve (strCode, dtSpot, adtEffective,</span>
						adtMaturity, adblCoupon, org.drip.analytics.support.Helper.TweakManifestMeasure
<span class="fc" id="L2436">							(adblQuote, new org.drip.param.definition.ManifestMeasureTweak (i,</span>
								bIsProportional, dblBump)), strMeasure, iLatentStateType);

<span class="pc bpc" id="L2439" title="1 of 2 branches missed.">					if (null != gcBumped) mapBumpedCurve.put (&quot;TSY::&quot; + adtMaturity[i], gcBumped);</span>
<span class="nc" id="L2440">				} catch (java.lang.Exception e) {</span>
<span class="nc" id="L2441">					e.printStackTrace();</span>
<span class="fc" id="L2442">				}</span>
			}
		}

		try {
<span class="fc" id="L2447">			org.drip.state.govvie.GovvieCurve gcBase = GovvieCurve (strCode, dtSpot, adtEffective,</span>
				adtMaturity, adblCoupon, adblQuote, strMeasure, iLatentStateType);

<span class="pc bpc" id="L2450" title="1 of 2 branches missed.">			if (null != gcBase) mapBumpedCurve.put (&quot;BASE&quot;, gcBase);</span>

<span class="fc" id="L2452">			org.drip.state.govvie.GovvieCurve gcBumped = GovvieCurve (strCode, dtSpot, adtEffective,</span>
<span class="fc" id="L2453">				adtMaturity, adblCoupon, org.drip.analytics.support.Helper.TweakManifestMeasure (adblQuote,</span>
					new org.drip.param.definition.ManifestMeasureTweak
						(org.drip.param.definition.ManifestMeasureTweak.FLAT, bIsProportional, dblBump)),
							strMeasure, iLatentStateType);

<span class="pc bpc" id="L2458" title="1 of 2 branches missed.">			if (null != gcBumped) mapBumpedCurve.put (&quot;BUMP&quot;, gcBumped);</span>
<span class="nc" id="L2459">		} catch (java.lang.Exception e) {</span>
<span class="nc" id="L2460">			e.printStackTrace();</span>
<span class="fc" id="L2461">		}</span>

<span class="fc" id="L2463">		return mapBumpedCurve;</span>
	}

	/**
	 * Construct a Tenor + Parallel Map of FX Curve from the FX Instruments
	 * 
	 * @param dtSpot Spot Date
	 * @param cp The FX Currency Pair
	 * @param astrMaturityTenor Array of Maturity Tenors
	 * @param adblQuote Array of FX Forwards
	 * @param strMeasure Calibration Measure
	 * @param dblFXSpot FX Spot
	 * @param iLatentStateType SHAPE PRESERVING/SMOOTH
	 * @param dblBump The Tenor Node Bump Amount
	 * @param bIsProportional TRUE - The Bump Applied is Proportional
	 * 
	 * @return Map of FX Curve Instance
	 */

	public static final org.drip.analytics.support.CaseInsensitiveTreeMap&lt;org.drip.state.fx.FXCurve&gt;
		BumpedFXCurve (
			final org.drip.analytics.date.JulianDate dtSpot,
			final org.drip.product.params.CurrencyPair cp,
			final java.lang.String[] astrMaturityTenor,
			final double[] adblQuote,
			final java.lang.String strMeasure,
			final double dblFXSpot,
			final int iLatentStateType,
			final double dblBump,
			final boolean bIsProportional)
	{
<span class="pc bpc" id="L2494" title="1 of 2 branches missed.">		if (!org.drip.quant.common.NumberUtil.IsValid (dblBump)) return null;</span>

<span class="fc" id="L2496">		org.drip.analytics.support.CaseInsensitiveTreeMap&lt;org.drip.state.fx.FXCurve&gt; mapBumpedCurve = new</span>
			org.drip.analytics.support.CaseInsensitiveTreeMap&lt;org.drip.state.fx.FXCurve&gt;();

<span class="pc bpc" id="L2499" title="1 of 2 branches missed.">		if (null != adblQuote) {</span>
<span class="fc" id="L2500">			int iNumComp = adblQuote.length;</span>

<span class="fc bfc" id="L2502" title="All 2 branches covered.">			for (int i = 0; i &lt; iNumComp; ++i) {</span>
				try {
<span class="fc" id="L2504">					org.drip.state.fx.FXCurve fxCurveBumped = FXCurve (dtSpot, cp, astrMaturityTenor,</span>
<span class="fc" id="L2505">						org.drip.analytics.support.Helper.TweakManifestMeasure (adblQuote, new</span>
							org.drip.param.definition.ManifestMeasureTweak (i, bIsProportional, dblBump)),
								strMeasure, dblFXSpot, iLatentStateType);

<span class="pc bpc" id="L2509" title="1 of 2 branches missed.">					if (null != fxCurveBumped)</span>
<span class="fc" id="L2510">						mapBumpedCurve.put (&quot;FXFWD::&quot; + astrMaturityTenor[i], fxCurveBumped);</span>
<span class="nc" id="L2511">				} catch (java.lang.Exception e) {</span>
<span class="nc" id="L2512">					e.printStackTrace();</span>
<span class="fc" id="L2513">				}</span>
			}
		}

		try {
<span class="fc" id="L2518">			org.drip.state.fx.FXCurve fxCurveBase = FXCurve (dtSpot, cp, astrMaturityTenor, adblQuote,</span>
				strMeasure, dblFXSpot, iLatentStateType);

<span class="pc bpc" id="L2521" title="1 of 2 branches missed.">			if (null != fxCurveBase) mapBumpedCurve.put (&quot;BASE&quot;, fxCurveBase);</span>

<span class="fc" id="L2523">			org.drip.state.fx.FXCurve fxCurveBump = FXCurve (dtSpot, cp, astrMaturityTenor,</span>
<span class="fc" id="L2524">				org.drip.analytics.support.Helper.TweakManifestMeasure (adblQuote, new</span>
					org.drip.param.definition.ManifestMeasureTweak
						(org.drip.param.definition.ManifestMeasureTweak.FLAT, bIsProportional, dblBump)),
							strMeasure, dblFXSpot, iLatentStateType);

<span class="pc bpc" id="L2529" title="1 of 2 branches missed.">			if (null != fxCurveBump) mapBumpedCurve.put (&quot;BUMP&quot;, fxCurveBump);</span>
<span class="nc" id="L2530">		} catch (java.lang.Exception e) {</span>
<span class="nc" id="L2531">			e.printStackTrace();</span>
<span class="fc" id="L2532">		}</span>

<span class="fc" id="L2534">		return mapBumpedCurve;</span>
	}

	/**
	 * Construct a Tenor + Parallel Forward Volatility Latent State Construction from Cap/Floor Instruments
	 * 
	 * @param dtSpot Spot Date
	 * @param forwardLabel Forward Label
	 * @param bIsCap TRUE - Create and Use Array of Caps
	 * @param astrMaturityTenor Array of Cap/floor Maturities
	 * @param adblStrike Array of Cap/Floor Strikes
	 * @param adblQuote Array of Cap/Floor Quotes
	 * @param strMeasure Calibration Measure
	 * @param dc Discount Curve Instance
	 * @param fc Forward Curve Instance
	 * @param dblBump The Tenor Node Bump Amount
	 * @param bIsProportional TRUE - The Bump Applied is Proportional
	 * 
	 * @return Map of Forward Volatility Curve Instance
	 */

	public static final
		org.drip.analytics.support.CaseInsensitiveTreeMap&lt;org.drip.state.volatility.VolatilityCurve&gt;
			BumpedForwardVolatilityCurve (
				final org.drip.analytics.date.JulianDate dtSpot,
				final org.drip.state.identifier.ForwardLabel forwardLabel,
				final boolean bIsCap,
				final java.lang.String[] astrMaturityTenor,
				final double[] adblStrike,
				final double[] adblQuote,
				final java.lang.String strMeasure,
				final org.drip.state.discount.MergedDiscountForwardCurve dc,
				final org.drip.state.forward.ForwardCurve fc,
				final double dblBump,
				final boolean bIsProportional)
	{
<span class="pc bpc" id="L2570" title="1 of 2 branches missed.">		if (!org.drip.quant.common.NumberUtil.IsValid (dblBump)) return null;</span>

		org.drip.analytics.support.CaseInsensitiveTreeMap&lt;org.drip.state.volatility.VolatilityCurve&gt;
<span class="fc" id="L2573">			mapBumpedCurve = new</span>
				org.drip.analytics.support.CaseInsensitiveTreeMap&lt;org.drip.state.volatility.VolatilityCurve&gt;();

<span class="pc bpc" id="L2576" title="1 of 2 branches missed.">		if (null != adblQuote) {</span>
<span class="fc" id="L2577">			int iNumComp = adblQuote.length;</span>

<span class="fc bfc" id="L2579" title="All 2 branches covered.">			for (int i = 0; i &lt; iNumComp; ++i) {</span>
				try {
<span class="fc" id="L2581">					org.drip.state.volatility.VolatilityCurve forwardVolatilityCurveBumped =</span>
<span class="fc" id="L2582">						ForwardRateVolatilityCurve (dtSpot, forwardLabel, bIsCap, astrMaturityTenor,</span>
<span class="fc" id="L2583">							adblStrike, org.drip.analytics.support.Helper.TweakManifestMeasure (adblQuote,</span>
								new org.drip.param.definition.ManifestMeasureTweak (i, bIsProportional,
									dblBump)), strMeasure, dc, fc);

<span class="pc bpc" id="L2587" title="1 of 2 branches missed.">					if (null != forwardVolatilityCurveBumped)</span>
<span class="fc" id="L2588">						mapBumpedCurve.put (&quot;CAPFLOOR::&quot; + astrMaturityTenor[i],</span>
							forwardVolatilityCurveBumped);
<span class="nc" id="L2590">				} catch (java.lang.Exception e) {</span>
<span class="nc" id="L2591">					e.printStackTrace();</span>
<span class="fc" id="L2592">				}</span>
			}
		}

		try {
<span class="fc" id="L2597">			org.drip.state.volatility.VolatilityCurve forwardVolatilityCurveBase = ForwardRateVolatilityCurve</span>
<span class="fc" id="L2598">				(dtSpot, forwardLabel, bIsCap, astrMaturityTenor, adblStrike, adblQuote, strMeasure, dc, fc);</span>

<span class="pc bpc" id="L2600" title="1 of 2 branches missed.">			if (null != forwardVolatilityCurveBase) mapBumpedCurve.put (&quot;BASE&quot;, forwardVolatilityCurveBase);</span>

<span class="fc" id="L2602">			org.drip.state.volatility.VolatilityCurve forwardVolatilityCurveBumped =</span>
<span class="fc" id="L2603">				ForwardRateVolatilityCurve (dtSpot, forwardLabel, bIsCap, astrMaturityTenor, adblStrike,</span>
<span class="fc" id="L2604">					org.drip.analytics.support.Helper.TweakManifestMeasure (adblQuote, new</span>
						org.drip.param.definition.ManifestMeasureTweak
							(org.drip.param.definition.ManifestMeasureTweak.FLAT, bIsProportional, dblBump)),
								strMeasure, dc, fc);

<span class="pc bpc" id="L2609" title="1 of 2 branches missed.">			if (null != forwardVolatilityCurveBumped)</span>
<span class="fc" id="L2610">				mapBumpedCurve.put (&quot;BUMP&quot;, forwardVolatilityCurveBumped);</span>
<span class="nc" id="L2611">		} catch (java.lang.Exception e) {</span>
<span class="nc" id="L2612">			e.printStackTrace();</span>
<span class="fc" id="L2613">		}</span>

<span class="fc" id="L2615">		return mapBumpedCurve;</span>
	}
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.7.9.201702052155</span></div></body></html>