<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>FundingGroupPath.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">DROP</a> &gt; <a href="index.source.html" class="el_package">org.drip.xva.netting</a> &gt; <span class="el_source">FundingGroupPath.java</span></div><h1>FundingGroupPath.java</h1><pre class="source lang-java linenums">
package org.drip.xva.netting;

/*
 * -*- mode: java; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*-
 */

/*!
 * Copyright (C) 2020 Lakshmi Krishnamurthy
 * Copyright (C) 2019 Lakshmi Krishnamurthy
 * Copyright (C) 2018 Lakshmi Krishnamurthy
 * Copyright (C) 2017 Lakshmi Krishnamurthy
 * 
 *  This file is part of DROP, an open-source library targeting analytics/risk, transaction cost analytics,
 *  	asset liability management analytics, capital, exposure, and margin analytics, valuation adjustment
 *  	analytics, and portfolio construction analytics within and across fixed income, credit, commodity,
 *  	equity, FX, and structured products. It also includes auxiliary libraries for algorithm support,
 *  	numerical analysis, numerical optimization, spline builder, model validation, statistical learning,
 *  	and computational support.
 *  
 *  	https://lakshmidrip.github.io/DROP/
 *  
 *  DROP is composed of three modules:
 *  
 *  - DROP Product Core - https://lakshmidrip.github.io/DROP-Product-Core/
 *  - DROP Portfolio Core - https://lakshmidrip.github.io/DROP-Portfolio-Core/
 *  - DROP Computational Core - https://lakshmidrip.github.io/DROP-Computational-Core/
 * 
 * 	DROP Product Core implements libraries for the following:
 * 	- Fixed Income Analytics
 * 	- Loan Analytics
 * 	- Transaction Cost Analytics
 * 
 * 	DROP Portfolio Core implements libraries for the following:
 * 	- Asset Allocation Analytics
 *  - Asset Liability Management Analytics
 * 	- Capital Estimation Analytics
 * 	- Exposure Analytics
 * 	- Margin Analytics
 * 	- XVA Analytics
 * 
 * 	DROP Computational Core implements libraries for the following:
 * 	- Algorithm Support
 * 	- Computation Support
 * 	- Function Analysis
 *  - Model Validation
 * 	- Numerical Analysis
 * 	- Numerical Optimizer
 * 	- Spline Builder
 *  - Statistical Learning
 * 
 * 	Documentation for DROP is Spread Over:
 * 
 * 	- Main                     =&gt; https://lakshmidrip.github.io/DROP/
 * 	- Wiki                     =&gt; https://github.com/lakshmiDRIP/DROP/wiki
 * 	- GitHub                   =&gt; https://github.com/lakshmiDRIP/DROP
 * 	- Repo Layout Taxonomy     =&gt; https://github.com/lakshmiDRIP/DROP/blob/master/Taxonomy.md
 * 	- Javadoc                  =&gt; https://lakshmidrip.github.io/DROP/Javadoc/index.html
 * 	- Technical Specifications =&gt; https://github.com/lakshmiDRIP/DROP/tree/master/Docs/Internal
 * 	- Release Versions         =&gt; https://lakshmidrip.github.io/DROP/version.html
 * 	- Community Credits        =&gt; https://lakshmidrip.github.io/DROP/credits.html
 * 	- Issues Catalog           =&gt; https://github.com/lakshmiDRIP/DROP/issues
 * 	- JUnit                    =&gt; https://lakshmidrip.github.io/DROP/junit/index.html
 * 	- Jacoco                   =&gt; https://lakshmidrip.github.io/DROP/jacoco/index.html
 * 
 *  Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 *   	you may not use this file except in compliance with the License.
 *   
 *  You may obtain a copy of the License at
 *  	http://www.apache.org/licenses/LICENSE-2.0
 *  
 *  Unless required by applicable law or agreed to in writing, software
 *  	distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 *  	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  
 *  See the License for the specific language governing permissions and
 *  	limitations under the License.
 */

/**
 * &lt;i&gt;FundingGroupPath&lt;/i&gt; holds up the Strategy Abstract Realizations of the Sequence in a Single Path
 * Projection Run over Multiple Collateral Groups onto a Single Funding Group - the Purpose being to
 * calculate Funding Valuation Adjustments. The References are:
 *
 *  &lt;br&gt;&lt;br&gt;
 *  &lt;ul&gt;
 *  	&lt;li&gt;
 *  		Burgard, C., and M. Kjaer (2014): PDE Representations of Derivatives with Bilateral Counter-party
 *  			Risk and Funding Costs &lt;i&gt;Journal of Credit Risk&lt;/i&gt; &lt;b&gt;7 (3)&lt;/b&gt; 1-19
 *  	&lt;/li&gt;
 *  	&lt;li&gt;
 *  		Burgard, C., and M. Kjaer (2014): In the Balance &lt;i&gt;Risk&lt;/i&gt; &lt;b&gt;24 (11)&lt;/b&gt; 72-75
 *  	&lt;/li&gt;
 *  	&lt;li&gt;
 *  		Gregory, J. (2009): Being Two-faced over Counter-party Credit Risk &lt;i&gt;Risk&lt;/i&gt; &lt;b&gt;20 (2)&lt;/b&gt;
 *  			86-90
 *  	&lt;/li&gt;
 *  	&lt;li&gt;
 *  		Li, B., and Y. Tang (2007): &lt;i&gt;Quantitative Analysis, Derivatives Modeling, and Trading
 *  			Strategies in the Presence of Counter-party Credit Risk for the Fixed Income Market&lt;/i&gt;
 *  			&lt;b&gt;World Scientific Publishing&lt;/b&gt; Singapore
 *  	&lt;/li&gt;
 *  	&lt;li&gt;
 *  		Piterbarg, V. (2010): Funding Beyond Discounting: Collateral Agreements and Derivatives Pricing
 *  			&lt;i&gt;Risk&lt;/i&gt; &lt;b&gt;21 (2)&lt;/b&gt; 97-102
 *  	&lt;/li&gt;
 *  &lt;/ul&gt;
 *
 *  &lt;br&gt;&lt;br&gt;
 *  &lt;ul&gt;
 *		&lt;li&gt;&lt;b&gt;Module &lt;/b&gt; = &lt;a href = &quot;https://github.com/lakshmiDRIP/DROP/tree/master/PortfolioCore.md&quot;&gt;Portfolio Core Module&lt;/a&gt;&lt;/li&gt;
 *		&lt;li&gt;&lt;b&gt;Library&lt;/b&gt; = &lt;a href = &quot;https://github.com/lakshmiDRIP/DROP/tree/master/XVAAnalyticsLibrary.md&quot;&gt;XVA Analytics Library&lt;/a&gt;&lt;/li&gt;
 *		&lt;li&gt;&lt;b&gt;Project&lt;/b&gt; = &lt;a href = &quot;https://github.com/lakshmiDRIP/DROP/tree/master/src/main/java/org/drip/xva/README.md&quot;&gt;Valuation Adjustments that account for Collateral, CC Credit/Debt and Funding Overhead&lt;/a&gt;&lt;/li&gt;
 *		&lt;li&gt;&lt;b&gt;Package&lt;/b&gt; = &lt;a href = &quot;https://github.com/lakshmiDRIP/DROP/tree/master/src/main/java/org/drip/xva/netting/README.md&quot;&gt;Credit/Debt/Funding Netting Groups&lt;/a&gt;&lt;/li&gt;
 *  &lt;/ul&gt;
 * &lt;br&gt;&lt;br&gt;
 * 
 * @author Lakshmi Krishnamurthy
 */

public abstract class FundingGroupPath
{
<span class="fc" id="L123">	private org.drip.exposure.universe.MarketPath _marketPath = null;</span>
<span class="fc" id="L124">	private org.drip.xva.netting.CreditDebtGroupPath[] _creditDebtGroupPathArray = null;</span>

	protected FundingGroupPath (
		final org.drip.xva.netting.CreditDebtGroupPath[] creditDebtGroupPathArray,
		final org.drip.exposure.universe.MarketPath marketPath)
		throws java.lang.Exception
<span class="fc" id="L130">	{</span>
<span class="pc bpc" id="L131" title="2 of 4 branches missed.">		if (null == (_creditDebtGroupPathArray = creditDebtGroupPathArray) ||</span>
			null == (_marketPath = marketPath))
		{
<span class="nc" id="L134">			throw new java.lang.Exception (&quot;FundingGroupPath Constructor =&gt; Invalid Inputs&quot;);</span>
		}
<span class="fc" id="L136">	}</span>

	/**
	 * Retrieve the Array of CreditDebtGroupPath
	 * 
	 * @return The Array of CreditDebtGroupPath
	 */

	public org.drip.xva.netting.CreditDebtGroupPath[] creditDebtGroupPathArray()
	{
<span class="nc" id="L146">		return _creditDebtGroupPathArray;</span>
	}

	/**
	 * Retrieve the Market Path
	 * 
	 * @return The Market Path
	 */

	public org.drip.exposure.universe.MarketPath marketPath()
	{
<span class="nc" id="L157">		return _marketPath;</span>
	}

	/**
	 * Retrieve the Array of the Vertex Anchor Dates
	 * 
	 * @return The Array of the Vertex Anchor Dates
	 */

	public org.drip.analytics.date.JulianDate[] vertexDates()
	{
<span class="fc" id="L168">		return _creditDebtGroupPathArray[0].vertexDates();</span>
	}

	/**
	 * Compute Path Symmetric Funding Value Spread 01
	 * 
	 * @return The Path Symmetric Funding Value Spread 01
	 */

	public double symmetricFundingValueSpread01()
	{
<span class="nc" id="L179">		double symmetricFundingSpread01 = 0.;</span>
<span class="nc" id="L180">		int creditDebtGroupCount = _creditDebtGroupPathArray.length;</span>

<span class="nc bnc" id="L182" title="All 2 branches missed.">		for (int creditDebtGroupIndex = 0; creditDebtGroupIndex &lt; creditDebtGroupCount;</span>
<span class="nc" id="L183">			++creditDebtGroupIndex)</span>
		{
<span class="nc" id="L185">			symmetricFundingSpread01 +=</span>
<span class="nc" id="L186">				_creditDebtGroupPathArray[creditDebtGroupIndex].symmetricFundingValueSpread01();</span>
		}

<span class="nc" id="L189">		return symmetricFundingSpread01;</span>
	}

	/**
	 * Compute Path Unilateral Funding Value Spread 01
	 * 
	 * @return The Path Unilateral Funding Value Spread 01
	 */

	public double unilateralFundingValueSpread01()
	{
<span class="nc" id="L200">		double unilateralFundingValueSpread01 = 0.;</span>
<span class="nc" id="L201">		int creditDebtGroupCount = _creditDebtGroupPathArray.length;</span>

<span class="nc bnc" id="L203" title="All 2 branches missed.">		for (int creditDebtGroupIndex = 0; creditDebtGroupIndex &lt; creditDebtGroupCount;</span>
<span class="nc" id="L204">			++creditDebtGroupIndex)</span>
		{
<span class="nc" id="L206">			unilateralFundingValueSpread01 +=</span>
<span class="nc" id="L207">				_creditDebtGroupPathArray[creditDebtGroupIndex].unilateralFundingValueSpread01();</span>
		}

<span class="nc bnc" id="L210" title="All 2 branches missed.">		return 0. &gt; unilateralFundingValueSpread01 ? 0. : unilateralFundingValueSpread01;</span>
	}

	/**
	 * Compute Path Bilateral Funding Value Spread 01
	 * 
	 * @return The Path Bilateral Funding Value Spread 01
	 */

	public double bilateralFundingValueSpread01()
	{
<span class="nc" id="L221">		double bilateralFundingValueSpread01 = 0.;</span>
<span class="nc" id="L222">		int creditDebtGroupCount = _creditDebtGroupPathArray.length;</span>

<span class="nc bnc" id="L224" title="All 2 branches missed.">		for (int creditDebtGroupIndex = 0; creditDebtGroupIndex &lt; creditDebtGroupCount;</span>
<span class="nc" id="L225">			++creditDebtGroupIndex)</span>
		{
<span class="nc" id="L227">			bilateralFundingValueSpread01 +=</span>
<span class="nc" id="L228">				_creditDebtGroupPathArray[creditDebtGroupIndex].bilateralFundingValueSpread01();</span>
		}

<span class="nc bnc" id="L231" title="All 2 branches missed.">		return 0. &gt; bilateralFundingValueSpread01 ? 0. : bilateralFundingValueSpread01;</span>
	}

	/**
	 * Compute Period Symmetric Funding Value Spread 01
	 * 
	 * @return The Period Symmetric Funding Value Spread 01
	 */

	public double[] periodSymmetricFundingValueSpread01()
	{
<span class="fc" id="L242">		org.drip.exposure.universe.MarketVertex[] marketVertexArray = _marketPath.marketVertexArray();</span>

<span class="fc" id="L244">		int periodCount = marketVertexArray.length - 1;</span>
<span class="fc" id="L245">		int creditDebtGroupCount = _creditDebtGroupPathArray.length;</span>
<span class="fc" id="L246">		double[] periodSymmetricFundingValueSpread01 = new double[periodCount];</span>

<span class="fc bfc" id="L248" title="All 2 branches covered.">		for (int periodIndex = 0; periodIndex &lt; periodCount; ++periodIndex)</span>
		{
<span class="fc" id="L250">			periodSymmetricFundingValueSpread01[periodIndex] = 0.;</span>
		}

<span class="fc bfc" id="L253" title="All 2 branches covered.">		for (int creditDebtGroupIndex = 0; creditDebtGroupIndex &lt; creditDebtGroupCount;</span>
<span class="fc" id="L254">			++creditDebtGroupIndex)</span>
		{
<span class="fc" id="L256">			double[] periodCreditDebtGroupSymmetricFundingValueSpread01 =</span>
<span class="fc" id="L257">				_creditDebtGroupPathArray[creditDebtGroupIndex].periodSymmetricFundingValueSpread01();</span>

<span class="fc bfc" id="L259" title="All 2 branches covered.">			for (int periodIndex = 0; periodIndex &lt; periodCount; ++periodIndex)</span>
			{
<span class="fc" id="L261">				periodSymmetricFundingValueSpread01[periodIndex] +=</span>
					periodCreditDebtGroupSymmetricFundingValueSpread01[periodIndex];
			}
		}

<span class="fc" id="L266">		return periodSymmetricFundingValueSpread01;</span>
	}

	/**
	 * Compute Period Unilateral Funding Value Spread 01
	 * 
	 * @return The Period Unilateral Funding Value Spread 01
	 */

	public double[] periodUnilateralFundingValueSpread01()
	{
<span class="fc" id="L277">		org.drip.exposure.universe.MarketVertex[] marketVertexArray = _marketPath.marketVertexArray();</span>

<span class="fc" id="L279">		int periodCount = marketVertexArray.length - 1;</span>
<span class="fc" id="L280">		int creditDebtGroupCount = _creditDebtGroupPathArray.length;</span>
<span class="fc" id="L281">		double[] periodUnilateralFundingValueSpread01 = new double[periodCount];</span>

<span class="fc bfc" id="L283" title="All 2 branches covered.">		for (int periodIndex = 0; periodIndex &lt; periodCount; ++periodIndex)</span>
		{
<span class="fc" id="L285">			periodUnilateralFundingValueSpread01[periodIndex] = 0.;</span>
		}

<span class="fc bfc" id="L288" title="All 2 branches covered.">		for (int creditDebtGroupIndex = 0; creditDebtGroupIndex &lt; creditDebtGroupCount;</span>
<span class="fc" id="L289">			++creditDebtGroupIndex)</span>
		{
<span class="fc" id="L291">			double[] periodCreditDebtGroupUnilateralFundingValueSpread01 =</span>
<span class="fc" id="L292">				_creditDebtGroupPathArray[creditDebtGroupIndex].periodUnilateralFundingValueSpread01();</span>

<span class="fc bfc" id="L294" title="All 2 branches covered.">			for (int periodIndex = 0; periodIndex &lt; periodCount; ++periodIndex)</span>
			{
<span class="fc" id="L296">				periodUnilateralFundingValueSpread01[periodIndex] +=</span>
					periodCreditDebtGroupUnilateralFundingValueSpread01[periodIndex];
			}
		}

<span class="fc bfc" id="L301" title="All 2 branches covered.">		for (int periodIndex = 0; periodIndex &lt; periodCount; ++periodIndex)</span>
		{
<span class="fc bfc" id="L303" title="All 2 branches covered.">			if (0. &gt; periodUnilateralFundingValueSpread01[periodIndex])</span>
			{
<span class="fc" id="L305">				periodUnilateralFundingValueSpread01[periodIndex] = 0.;</span>
			}
		}

<span class="fc" id="L309">		return periodUnilateralFundingValueSpread01;</span>
	}

	/**
	 * Compute Period Bilateral Funding Value Spread 01
	 * 
	 * @return The Period Bilateral Funding Value Spread 01
	 */

	public double[] periodBilateralFundingValueSpread01()
	{
<span class="fc" id="L320">		org.drip.exposure.universe.MarketVertex[] marketVertexArray = _marketPath.marketVertexArray();</span>

<span class="fc" id="L322">		int periodCount = marketVertexArray.length - 1;</span>
<span class="fc" id="L323">		int creditDebtGroupCount = _creditDebtGroupPathArray.length;</span>
<span class="fc" id="L324">		double[] periodBilateralFundingValueSpread01 = new double[periodCount];</span>

<span class="fc bfc" id="L326" title="All 2 branches covered.">		for (int periodIndex = 0; periodIndex &lt; periodCount; ++periodIndex)</span>
		{
<span class="fc" id="L328">			periodBilateralFundingValueSpread01[periodIndex] = 0.;</span>
		}

<span class="fc bfc" id="L331" title="All 2 branches covered.">		for (int creditDebtGroupIndex = 0; creditDebtGroupIndex &lt; creditDebtGroupCount;</span>
<span class="fc" id="L332">			++creditDebtGroupIndex)</span>
		{
<span class="fc" id="L334">			double[] periodCreditDebtGroupBilateralFundingValueSpread01 =</span>
<span class="fc" id="L335">				_creditDebtGroupPathArray[creditDebtGroupIndex].periodBilateralFundingValueSpread01();</span>

<span class="fc bfc" id="L337" title="All 2 branches covered.">			for (int periodIndex = 0; periodIndex &lt; periodCount; ++periodIndex)</span>
			{
<span class="fc" id="L339">				periodBilateralFundingValueSpread01[periodIndex] +=</span>
					periodCreditDebtGroupBilateralFundingValueSpread01[periodIndex];
			}
		}

<span class="fc bfc" id="L344" title="All 2 branches covered.">		for (int periodIndex = 0; periodIndex &lt; periodCount; ++periodIndex)</span>
		{
<span class="pc bpc" id="L346" title="1 of 2 branches missed.">			if (0. &gt; periodBilateralFundingValueSpread01[periodIndex])</span>
			{
<span class="nc" id="L348">				periodBilateralFundingValueSpread01[periodIndex] = 0.;</span>
			}
		}

<span class="fc" id="L352">		return periodBilateralFundingValueSpread01;</span>
	}

	/**
	 * Compute Path Symmetric Funding Value Adjustment
	 * 
	 * @return The Path Symmetric Funding Value Adjustment
	 */

	public double symmetricFundingValueAdjustment()
	{
<span class="fc" id="L363">		double[] periodSymmetricFundingValueSpread01 = periodSymmetricFundingValueSpread01();</span>

<span class="fc" id="L365">		org.drip.exposure.universe.MarketVertex[] marketVertexArray = _marketPath.marketVertexArray();</span>

<span class="fc" id="L367">		int periodCount = periodSymmetricFundingValueSpread01.length;</span>
<span class="fc" id="L368">		double symmetricFundingValueAdjustment = 0.;</span>

<span class="fc bfc" id="L370" title="All 2 branches covered.">		for (int periodIndex = 0; periodIndex &lt; periodCount; ++periodIndex)</span>
		{
<span class="fc" id="L372">			symmetricFundingValueAdjustment +=</span>
				0.5 * periodSymmetricFundingValueSpread01[periodIndex] * (
<span class="fc" id="L374">					marketVertexArray[periodIndex].dealer().seniorFundingSpread() +</span>
<span class="fc" id="L375">					marketVertexArray[periodIndex + 1].dealer().seniorFundingSpread()</span>
				);
		}

<span class="fc" id="L379">		return symmetricFundingValueAdjustment;</span>
	}

	/**
	 * Compute Path Unilateral Funding Value Adjustment
	 * 
	 * @return The Path Unilateral Funding Value Adjustment
	 */

	public double unilateralFundingValueAdjustment()
	{
<span class="fc" id="L390">		double[] periodUnilateralFundingValueSpread01 = periodUnilateralFundingValueSpread01();</span>

<span class="fc" id="L392">		org.drip.exposure.universe.MarketVertex[] marketVertexArray = _marketPath.marketVertexArray();</span>

<span class="fc" id="L394">		int periodCount = periodUnilateralFundingValueSpread01.length;</span>
<span class="fc" id="L395">		double unilateralFundingValueAdjustment = 0.;</span>

<span class="fc bfc" id="L397" title="All 2 branches covered.">		for (int periodIndex = 0; periodIndex &lt; periodCount; ++periodIndex)</span>
		{
<span class="fc" id="L399">			unilateralFundingValueAdjustment -=</span>
				0.5 * periodUnilateralFundingValueSpread01[periodIndex] * (
<span class="fc" id="L401">					marketVertexArray[periodIndex].dealer().seniorFundingSpread() +</span>
<span class="fc" id="L402">					marketVertexArray[periodIndex + 1].dealer().seniorFundingSpread()</span>
				);
		}

<span class="fc" id="L406">		return unilateralFundingValueAdjustment;</span>
	}

	/**
	 * Compute Path Bilateral Funding Value Adjustment
	 * 
	 * @return The Path Bilateral Funding Value Adjustment
	 */

	public double bilateralFundingValueAdjustment()
	{
<span class="nc" id="L417">		double[] periodBilateralFundingValueSpread01 = periodBilateralFundingValueSpread01();</span>

<span class="nc" id="L419">		org.drip.exposure.universe.MarketVertex[] marketVertexArray = _marketPath.marketVertexArray();</span>

<span class="nc" id="L421">		int periodCount = periodBilateralFundingValueSpread01.length;</span>
<span class="nc" id="L422">		double bilateralFundingValueAdjustment = 0.;</span>

<span class="nc bnc" id="L424" title="All 2 branches missed.">		for (int periodIndex = 0; periodIndex &lt; periodCount; ++periodIndex)</span>
		{
<span class="nc" id="L426">			bilateralFundingValueAdjustment -=</span>
				0.5 * periodBilateralFundingValueSpread01[periodIndex] * (
<span class="nc" id="L428">					marketVertexArray[periodIndex].dealer().seniorFundingSpread() +</span>
<span class="nc" id="L429">					marketVertexArray[periodIndex + 1].dealer().seniorFundingSpread()</span>
				);
		}

<span class="nc" id="L433">		return bilateralFundingValueAdjustment;</span>
	}

	/**
	 * Compute Path Unilateral Funding Debt Adjustment
	 * 
	 * @return The Path Unilateral Funding Debt Adjustment
	 */

	public double unilateralFundingDebtAdjustment()
	{
<span class="fc" id="L444">		double[] periodUnilateralFundingDebtAdjustment = periodUnilateralFundingDebtAdjustment();</span>

<span class="fc" id="L446">		int periodCount = periodUnilateralFundingDebtAdjustment.length;</span>
<span class="fc" id="L447">		double unilateralFundingDebtAdjustment = 0.;</span>

<span class="fc bfc" id="L449" title="All 2 branches covered.">		for (int periodIndex = 0; periodIndex &lt; periodCount; ++periodIndex)</span>
		{
<span class="fc" id="L451">			unilateralFundingDebtAdjustment += periodUnilateralFundingDebtAdjustment[periodIndex];</span>
		}

<span class="fc" id="L454">		return unilateralFundingDebtAdjustment;</span>
	}

	/**
	 * Compute Path Bilateral Funding Debt Adjustment
	 * 
	 * @return The Path Bilateral Funding Debt Adjustment
	 */

	public double bilateralFundingDebtAdjustment()
	{
<span class="nc" id="L465">		double[] periodBilateralFundingDebtAdjustment = periodBilateralFundingDebtAdjustment();</span>

<span class="nc" id="L467">		int periodCount = periodBilateralFundingDebtAdjustment.length;</span>
<span class="nc" id="L468">		double bilateralFundingDebtAdjustment = 0.;</span>

<span class="nc bnc" id="L470" title="All 2 branches missed.">		for (int periodIndex = 0; periodIndex &lt; periodCount; ++periodIndex)</span>
		{
<span class="nc" id="L472">			bilateralFundingDebtAdjustment += periodBilateralFundingDebtAdjustment[periodIndex];</span>
		}

<span class="nc" id="L475">		return bilateralFundingDebtAdjustment;</span>
	}

	/**
	 * Compute Vertex Path Collateralized Exposure
	 * 
	 * @return The Vertex Path Collateralized Exposure
	 */

	public double[] vertexCollateralizedExposure()
	{
<span class="fc" id="L486">		org.drip.exposure.universe.MarketVertex[] marketVertexArray = _marketPath.marketVertexArray();</span>

<span class="fc" id="L488">		int vertexCount = marketVertexArray.length;</span>
<span class="fc" id="L489">		int creditDebtGroupCount = _creditDebtGroupPathArray.length;</span>
<span class="fc" id="L490">		double[] vertexCollateralizedExposure = new double[vertexCount];</span>

<span class="fc bfc" id="L492" title="All 2 branches covered.">		for (int vertexIndex = 0; vertexIndex &lt; vertexCount; ++vertexIndex)</span>
		{
<span class="fc" id="L494">			vertexCollateralizedExposure[vertexIndex] = 0.;</span>
		}

<span class="fc bfc" id="L497" title="All 2 branches covered.">		for (int creditDebtGroupIndex = 0; creditDebtGroupIndex &lt; creditDebtGroupCount;</span>
<span class="fc" id="L498">			++creditDebtGroupIndex)</span>
		{
<span class="fc" id="L500">			double[] creditDebtGroupVertexCollateralizedExposure =</span>
<span class="fc" id="L501">				_creditDebtGroupPathArray[creditDebtGroupIndex].vertexCollateralizedExposure();</span>

<span class="fc bfc" id="L503" title="All 2 branches covered.">			for (int vertexIndex = 0; vertexIndex &lt; vertexCount; ++vertexIndex)</span>
			{
<span class="fc" id="L505">				vertexCollateralizedExposure[vertexIndex] +=</span>
					creditDebtGroupVertexCollateralizedExposure[vertexIndex];
			}
		}

<span class="fc" id="L510">		return vertexCollateralizedExposure;</span>
	}

	/**
	 * Compute Vertex Path Collateralized Exposure PV
	 * 
	 * @return The Vertex Path Collateralized Exposure PV
	 */

	public double[] vertexCollateralizedExposurePV()
	{
<span class="fc" id="L521">		org.drip.exposure.universe.MarketVertex[] marketVertexArray = _marketPath.marketVertexArray();</span>

<span class="fc" id="L523">		int vertexCount = marketVertexArray.length;</span>
<span class="fc" id="L524">		int creditDebtGroupCount = _creditDebtGroupPathArray.length;</span>
<span class="fc" id="L525">		double[] vertexCollateralizedExposurePV = new double[vertexCount];</span>

<span class="fc bfc" id="L527" title="All 2 branches covered.">		for (int vertexIndex = 0; vertexIndex &lt; vertexCount; ++vertexIndex)</span>
		{
<span class="fc" id="L529">			vertexCollateralizedExposurePV[vertexIndex] = 0.;</span>
		}

<span class="fc bfc" id="L532" title="All 2 branches covered.">		for (int creditDebtGroupIndex = 0; creditDebtGroupIndex &lt; creditDebtGroupCount;</span>
<span class="fc" id="L533">			++creditDebtGroupIndex)</span>
		{
<span class="fc" id="L535">			double[] creditDebtGroupVertexCollateralizedExposurePV =</span>
<span class="fc" id="L536">				_creditDebtGroupPathArray[creditDebtGroupIndex].vertexCollateralizedExposurePV();</span>

<span class="fc bfc" id="L538" title="All 2 branches covered.">			for (int vertexIndex = 0; vertexIndex &lt; vertexCount; ++vertexIndex)</span>
			{
<span class="fc" id="L540">				vertexCollateralizedExposurePV[vertexIndex] +=</span>
					creditDebtGroupVertexCollateralizedExposurePV[vertexIndex];
			}
		}

<span class="fc" id="L545">		return vertexCollateralizedExposurePV;</span>
	}

	/**
	 * Compute Vertex Path Collateralized Positive Exposure
	 * 
	 * @return The Vertex Path Collateralized Positive Exposure
	 */

	public double[] vertexCollateralizedPositiveExposure()
	{
<span class="fc" id="L556">		org.drip.exposure.universe.MarketVertex[] marketVertexArray = _marketPath.marketVertexArray();</span>

<span class="fc" id="L558">		int vertexCount = marketVertexArray.length;</span>
<span class="fc" id="L559">		int creditDebtGroupCount = _creditDebtGroupPathArray.length;</span>
<span class="fc" id="L560">		double[] vertexCollateralizedPositiveExposure = new double[vertexCount];</span>

<span class="fc bfc" id="L562" title="All 2 branches covered.">		for (int vertexIndex = 0; vertexIndex &lt; vertexCount; ++vertexIndex)</span>
		{
<span class="fc" id="L564">			vertexCollateralizedPositiveExposure[vertexIndex] = 0.;</span>
		}

<span class="fc bfc" id="L567" title="All 2 branches covered.">		for (int creditDebtGroupIndex = 0; creditDebtGroupIndex &lt; creditDebtGroupCount;</span>
<span class="fc" id="L568">			++creditDebtGroupIndex)</span>
		{
<span class="fc" id="L570">			double[] creditDebtGroupVertexCollateralizedPositiveExposure =</span>
<span class="fc" id="L571">				_creditDebtGroupPathArray[creditDebtGroupIndex].vertexCollateralizedPositiveExposure();</span>

<span class="fc bfc" id="L573" title="All 2 branches covered.">			for (int vertexIndex = 0; vertexIndex &lt; vertexCount; ++vertexIndex)</span>
			{
<span class="fc" id="L575">				vertexCollateralizedPositiveExposure[vertexIndex] +=</span>
					creditDebtGroupVertexCollateralizedPositiveExposure[vertexIndex];
			}
		}

<span class="fc" id="L580">		return vertexCollateralizedPositiveExposure;</span>
	}

	/**
	 * Compute Vertex Path Collateralized Positive Exposure PV
	 * 
	 * @return The Vertex Path Collateralized Positive Exposure PV
	 */

	public double[] vertexCollateralizedPositiveExposurePV()
	{
<span class="fc" id="L591">		org.drip.exposure.universe.MarketVertex[] marketVertexArray = _marketPath.marketVertexArray();</span>

<span class="fc" id="L593">		int vertexCount = marketVertexArray.length;</span>
<span class="fc" id="L594">		int creditDebtGroupCount = _creditDebtGroupPathArray.length;</span>
<span class="fc" id="L595">		double[] vertexCollateralizedPositiveExposurePV = new double[vertexCount];</span>

<span class="fc bfc" id="L597" title="All 2 branches covered.">		for (int vertexIndex = 0; vertexIndex &lt; vertexCount; ++vertexIndex)</span>
		{
<span class="fc" id="L599">			vertexCollateralizedPositiveExposurePV[vertexIndex] = 0.;</span>
		}

<span class="fc bfc" id="L602" title="All 2 branches covered.">		for (int creditDebtGroupIndex = 0; creditDebtGroupIndex &lt; creditDebtGroupCount;</span>
<span class="fc" id="L603">			++creditDebtGroupIndex)</span>
		{
<span class="fc" id="L605">			double[] creditDebtGroupVertexCollateralizedPositiveExposurePV =</span>
<span class="fc" id="L606">				_creditDebtGroupPathArray[creditDebtGroupIndex].vertexCollateralizedPositiveExposurePV();</span>

<span class="fc bfc" id="L608" title="All 2 branches covered.">			for (int vertexIndex = 0; vertexIndex &lt; vertexCount; ++vertexIndex)</span>
			{
<span class="fc" id="L610">				vertexCollateralizedPositiveExposurePV[vertexIndex] +=</span>
					creditDebtGroupVertexCollateralizedPositiveExposurePV[vertexIndex];
			}
		}

<span class="fc" id="L615">		return vertexCollateralizedPositiveExposurePV;</span>
	}

	/**
	 * Compute Vertex Path Collateralized Negative Exposure
	 * 
	 * @return The Vertex Path Collateralized Negative Exposure
	 */

	public double[] vertexCollateralizedNegativeExposure()
	{
<span class="fc" id="L626">		org.drip.exposure.universe.MarketVertex[] marketVertexArray = _marketPath.marketVertexArray();</span>

<span class="fc" id="L628">		int vertexCount = marketVertexArray.length;</span>
<span class="fc" id="L629">		int creditDebtGroupCount = _creditDebtGroupPathArray.length;</span>
<span class="fc" id="L630">		double[] vertexCollateralizedNegativeExposure = new double[vertexCount];</span>

<span class="fc bfc" id="L632" title="All 2 branches covered.">		for (int vertexIndex = 0; vertexIndex &lt; vertexCount; ++vertexIndex)</span>
		{
<span class="fc" id="L634">			vertexCollateralizedNegativeExposure[vertexIndex] = 0.;</span>
		}

<span class="fc bfc" id="L637" title="All 2 branches covered.">		for (int creditDebtGroupIndex = 0; creditDebtGroupIndex &lt; creditDebtGroupCount;</span>
<span class="fc" id="L638">			++creditDebtGroupIndex)</span>
		{
<span class="fc" id="L640">			double[] creditDebtGroupVertexCollateralizedNegativeExposure =</span>
<span class="fc" id="L641">				_creditDebtGroupPathArray[creditDebtGroupIndex].vertexCollateralizedNegativeExposure();</span>

<span class="fc bfc" id="L643" title="All 2 branches covered.">			for (int vertexIndex = 0; vertexIndex &lt; vertexCount; ++vertexIndex)</span>
			{
<span class="fc" id="L645">				vertexCollateralizedNegativeExposure[vertexIndex] +=</span>
					creditDebtGroupVertexCollateralizedNegativeExposure[vertexIndex];
			}
		}

<span class="fc" id="L650">		return vertexCollateralizedNegativeExposure;</span>
	}

	/**
	 * Compute Vertex Path Collateralized Negative Exposure PV
	 * 
	 * @return The Vertex Path Collateralized Negative Exposure PV
	 */

	public double[] vertexCollateralizedNegativeExposurePV()
	{
<span class="fc" id="L661">		org.drip.exposure.universe.MarketVertex[] marketVertexArray = _marketPath.marketVertexArray();</span>

<span class="fc" id="L663">		int vertexCount = marketVertexArray.length;</span>
<span class="fc" id="L664">		int creditDebtGroupCount = _creditDebtGroupPathArray.length;</span>
<span class="fc" id="L665">		double[] vertexCollateralizedNegativeExposurePV = new double[vertexCount];</span>

<span class="fc bfc" id="L667" title="All 2 branches covered.">		for (int vertexIndex = 0; vertexIndex &lt; vertexCount; ++vertexIndex)</span>
		{
<span class="fc" id="L669">			vertexCollateralizedNegativeExposurePV[vertexIndex] = 0.;</span>
		}

<span class="fc bfc" id="L672" title="All 2 branches covered.">		for (int creditDebtGroupIndex = 0; creditDebtGroupIndex &lt; creditDebtGroupCount;</span>
<span class="fc" id="L673">			++creditDebtGroupIndex)</span>
		{
<span class="fc" id="L675">			double[] creditDebtGroupVertexCollateralizedNegativeExposurePV =</span>
<span class="fc" id="L676">				_creditDebtGroupPathArray[creditDebtGroupIndex].vertexCollateralizedNegativeExposurePV();</span>

<span class="fc bfc" id="L678" title="All 2 branches covered.">			for (int vertexIndex = 0; vertexIndex &lt; vertexCount; ++vertexIndex)</span>
			{
<span class="fc" id="L680">				vertexCollateralizedNegativeExposurePV[vertexIndex] +=</span>
					creditDebtGroupVertexCollateralizedNegativeExposurePV[vertexIndex];
			}
		}

<span class="fc" id="L685">		return vertexCollateralizedNegativeExposurePV;</span>
	}

	/**
	 * Compute Vertex Path Uncollateralized Exposure
	 * 
	 * @return The Vertex Path Uncollateralized Exposure
	 */

	public double[] vertexUncollateralizedExposure()
	{
<span class="fc" id="L696">		org.drip.exposure.universe.MarketVertex[] marketVertexArray = _marketPath.marketVertexArray();</span>

<span class="fc" id="L698">		int vertexCount = marketVertexArray.length;</span>
<span class="fc" id="L699">		int creditDebtGroupCount = _creditDebtGroupPathArray.length;</span>
<span class="fc" id="L700">		double[] vertexUncollateralizedExposure = new double[vertexCount];</span>

<span class="fc bfc" id="L702" title="All 2 branches covered.">		for (int vertexIndex = 0; vertexIndex &lt; vertexCount; ++vertexIndex)</span>
		{
<span class="fc" id="L704">			vertexUncollateralizedExposure[vertexIndex] = 0.;</span>
		}

<span class="fc bfc" id="L707" title="All 2 branches covered.">		for (int creditDebtGroupIndex = 0; creditDebtGroupIndex &lt; creditDebtGroupCount;</span>
<span class="fc" id="L708">			++creditDebtGroupIndex)</span>
		{
<span class="fc" id="L710">			double[] creditDebtGroupVertexCollateralizedExposure =</span>
<span class="fc" id="L711">				_creditDebtGroupPathArray[creditDebtGroupIndex].vertexUncollateralizedExposure();</span>

<span class="fc bfc" id="L713" title="All 2 branches covered.">			for (int vertexIndex = 0; vertexIndex &lt; vertexCount; ++vertexIndex)</span>
			{
<span class="fc" id="L715">				vertexUncollateralizedExposure[vertexIndex] +=</span>
					creditDebtGroupVertexCollateralizedExposure[vertexIndex];
			}
		}

<span class="fc" id="L720">		return vertexUncollateralizedExposure;</span>
	}

	/**
	 * Compute Vertex Path Uncollateralized Exposure PV
	 * 
	 * @return The Vertex Path Uncollateralized Exposure PV
	 */

	public double[] vertexUncollateralizedExposurePV()
	{
<span class="fc" id="L731">		org.drip.exposure.universe.MarketVertex[] marketVertexArray = _marketPath.marketVertexArray();</span>

<span class="fc" id="L733">		int vertexCount = marketVertexArray.length;</span>
<span class="fc" id="L734">		int creditDebtGroupCount = _creditDebtGroupPathArray.length;</span>
<span class="fc" id="L735">		double[] vertexUncollateralizedExposurePV = new double[vertexCount];</span>

<span class="fc bfc" id="L737" title="All 2 branches covered.">		for (int vertexIndex = 0; vertexIndex &lt; vertexCount; ++vertexIndex)</span>
		{
<span class="fc" id="L739">			vertexUncollateralizedExposurePV[vertexIndex] = 0.;</span>
		}

<span class="fc bfc" id="L742" title="All 2 branches covered.">		for (int creditDebtGroupIndex = 0; creditDebtGroupIndex &lt; creditDebtGroupCount;</span>
<span class="fc" id="L743">			++creditDebtGroupIndex)</span>
		{
<span class="fc" id="L745">			double[] creditDebtGroupVertexCollateralizedExposurePV =</span>
<span class="fc" id="L746">				_creditDebtGroupPathArray[creditDebtGroupIndex].vertexUncollateralizedExposurePV();</span>

<span class="fc bfc" id="L748" title="All 2 branches covered.">			for (int vertexIndex = 0; vertexIndex &lt; vertexCount; ++vertexIndex)</span>
			{
<span class="fc" id="L750">				vertexUncollateralizedExposurePV[vertexIndex] +=</span>
					creditDebtGroupVertexCollateralizedExposurePV[vertexIndex];
			}
		}

<span class="fc" id="L755">		return vertexUncollateralizedExposurePV;</span>
	}

	/**
	 * Compute Vertex Path Uncollateralized Positive Exposure
	 * 
	 * @return The Vertex Path Uncollateralized Positive Exposure
	 */

	public double[] vertexUncollateralizedPositiveExposure()
	{
<span class="fc" id="L766">		org.drip.exposure.universe.MarketVertex[] marketVertexArray = _marketPath.marketVertexArray();</span>

<span class="fc" id="L768">		int vertexCount = marketVertexArray.length;</span>
<span class="fc" id="L769">		int creditDebtGroupCount = _creditDebtGroupPathArray.length;</span>
<span class="fc" id="L770">		double[] vertexUncollateralizedPositiveExposure = new double[vertexCount];</span>

<span class="fc bfc" id="L772" title="All 2 branches covered.">		for (int vertexIndex = 0; vertexIndex &lt; vertexCount; ++vertexIndex)</span>
		{
<span class="fc" id="L774">			vertexUncollateralizedPositiveExposure[vertexIndex] = 0.;</span>
		}

<span class="fc bfc" id="L777" title="All 2 branches covered.">		for (int creditDebtGroupIndex = 0; creditDebtGroupIndex &lt; creditDebtGroupCount;</span>
<span class="fc" id="L778">			++creditDebtGroupIndex)</span>
		{
<span class="fc" id="L780">			double[] creditDebtGroupVertexUncollateralizedPositiveExposure =</span>
<span class="fc" id="L781">				_creditDebtGroupPathArray[creditDebtGroupIndex].vertexUncollateralizedPositiveExposure();</span>

<span class="fc bfc" id="L783" title="All 2 branches covered.">			for (int vertexIndex = 0; vertexIndex &lt; vertexCount; ++vertexIndex)</span>
			{
<span class="fc" id="L785">				vertexUncollateralizedPositiveExposure[vertexIndex] +=</span>
					creditDebtGroupVertexUncollateralizedPositiveExposure[vertexIndex];
			}
		}

<span class="fc" id="L790">		return vertexUncollateralizedPositiveExposure;</span>
	}

	/**
	 * Compute Vertex Path Uncollateralized Positive Exposure PV
	 * 
	 * @return The Vertex Path Uncollateralized Positive Exposure PV
	 */

	public double[] vertexUncollateralizedPositiveExposurePV()
	{
<span class="fc" id="L801">		org.drip.exposure.universe.MarketVertex[] marketVertexArray = _marketPath.marketVertexArray();</span>

<span class="fc" id="L803">		int vertexCount = marketVertexArray.length;</span>
<span class="fc" id="L804">		int creditDebtGroupCount = _creditDebtGroupPathArray.length;</span>
<span class="fc" id="L805">		double[] vertexUncollateralizedPositiveExposurePV = new double[vertexCount];</span>

<span class="fc bfc" id="L807" title="All 2 branches covered.">		for (int vertexIndex = 0; vertexIndex &lt; vertexCount; ++vertexIndex)</span>
		{
<span class="fc" id="L809">			vertexUncollateralizedPositiveExposurePV[vertexIndex] = 0.;</span>
		}

<span class="fc bfc" id="L812" title="All 2 branches covered.">		for (int creditDebtGroupIndex = 0; creditDebtGroupIndex &lt; creditDebtGroupCount;</span>
<span class="fc" id="L813">			++creditDebtGroupIndex)</span>
		{
<span class="fc" id="L815">			double[] creditDebtGroupVertexUncollateralizedPositiveExposurePV =</span>
<span class="fc" id="L816">				_creditDebtGroupPathArray[creditDebtGroupIndex].vertexUncollateralizedPositiveExposurePV();</span>

<span class="fc bfc" id="L818" title="All 2 branches covered.">			for (int vertexIndex = 0; vertexIndex &lt; vertexCount; ++vertexIndex)</span>
			{
<span class="fc" id="L820">				vertexUncollateralizedPositiveExposurePV[vertexIndex] +=</span>
					creditDebtGroupVertexUncollateralizedPositiveExposurePV[vertexIndex];
			}
		}

<span class="fc" id="L825">		return vertexUncollateralizedPositiveExposurePV;</span>
	}

	/**
	 * Compute Vertex Path Uncollateralized Negative Exposure
	 * 
	 * @return The Vertex Path Uncollateralized Negative Exposure
	 */

	public double[] vertexUncollateralizedNegativeExposure()
	{
<span class="fc" id="L836">		org.drip.exposure.universe.MarketVertex[] marketVertexArray = _marketPath.marketVertexArray();</span>

<span class="fc" id="L838">		int vertexCount = marketVertexArray.length;</span>
<span class="fc" id="L839">		int creditDebtGroupCount = _creditDebtGroupPathArray.length;</span>
<span class="fc" id="L840">		double[] vertexUncollateralizedNegativeExposure = new double[vertexCount];</span>

<span class="fc bfc" id="L842" title="All 2 branches covered.">		for (int vertexIndex = 0; vertexIndex &lt; vertexCount; ++vertexIndex)</span>
		{
<span class="fc" id="L844">			vertexUncollateralizedNegativeExposure[vertexIndex] = 0.;</span>
		}

<span class="fc bfc" id="L847" title="All 2 branches covered.">		for (int creditDebtGroupIndex = 0; creditDebtGroupIndex &lt; creditDebtGroupCount;</span>
<span class="fc" id="L848">			++creditDebtGroupIndex)</span>
		{
<span class="fc" id="L850">			double[] creditDebtGroupVertexUncollateralizedNegativeExposure =</span>
<span class="fc" id="L851">				_creditDebtGroupPathArray[creditDebtGroupIndex].vertexUncollateralizedNegativeExposure();</span>

<span class="fc bfc" id="L853" title="All 2 branches covered.">			for (int vertexIndex = 0; vertexIndex &lt; vertexCount; ++vertexIndex)</span>
			{
<span class="fc" id="L855">				vertexUncollateralizedNegativeExposure[vertexIndex] +=</span>
					creditDebtGroupVertexUncollateralizedNegativeExposure[vertexIndex];
			}
		}

<span class="fc" id="L860">		return vertexUncollateralizedNegativeExposure;</span>
	}

	/**
	 * Compute Vertex Path Uncollateralized Negative Exposure PV
	 * 
	 * @return The Vertex Path Uncollateralized Negative Exposure PV
	 */

	public double[] vertexUncollateralizedNegativeExposurePV()
	{
<span class="fc" id="L871">		org.drip.exposure.universe.MarketVertex[] marketVertexArray = _marketPath.marketVertexArray();</span>

<span class="fc" id="L873">		int vertexCount = marketVertexArray.length;</span>
<span class="fc" id="L874">		int creditDebtGroupCount = _creditDebtGroupPathArray.length;</span>
<span class="fc" id="L875">		double[] vertexUncollateralizedNegativeExposurePV = new double[vertexCount];</span>

<span class="fc bfc" id="L877" title="All 2 branches covered.">		for (int vertexIndex = 0; vertexIndex &lt; vertexCount; ++vertexIndex)</span>
		{
<span class="fc" id="L879">			vertexUncollateralizedNegativeExposurePV[vertexIndex] = 0.;</span>
		}

<span class="fc bfc" id="L882" title="All 2 branches covered.">		for (int creditDebtGroupIndex = 0; creditDebtGroupIndex &lt; creditDebtGroupCount;</span>
<span class="fc" id="L883">			++creditDebtGroupIndex)</span>
		{
<span class="fc" id="L885">			double[] creditDebtGroupVertexUncollateralizedNegativeExposurePV =</span>
<span class="fc" id="L886">				_creditDebtGroupPathArray[creditDebtGroupIndex].vertexUncollateralizedNegativeExposurePV();</span>

<span class="fc bfc" id="L888" title="All 2 branches covered.">			for (int vertexIndex = 0; vertexIndex &lt; vertexCount; ++vertexIndex)</span>
			{
<span class="fc" id="L890">				vertexUncollateralizedNegativeExposurePV[vertexIndex] +=</span>
					creditDebtGroupVertexUncollateralizedNegativeExposurePV[vertexIndex];
			}
		}

<span class="fc" id="L895">		return vertexUncollateralizedNegativeExposurePV;</span>
	}

	/**
	 * Compute Vertex Path Funding Exposure
	 * 
	 * @return The Vertex Path Funding Exposure
	 */

	public double[] vertexFundingExposure()
	{
<span class="fc" id="L906">		org.drip.exposure.universe.MarketVertex[] marketVertexArray = _marketPath.marketVertexArray();</span>

<span class="fc" id="L908">		int vertexCount = marketVertexArray.length;</span>
<span class="fc" id="L909">		double[] vertexFundingExposure = new double[vertexCount];</span>
<span class="fc" id="L910">		int creditDebtGroupCount = _creditDebtGroupPathArray.length;</span>

<span class="fc bfc" id="L912" title="All 2 branches covered.">		for (int vertexIndex = 0; vertexIndex &lt; vertexCount; ++vertexIndex)</span>
		{
<span class="fc" id="L914">			vertexFundingExposure[vertexIndex] = 0.;</span>
		}

<span class="fc bfc" id="L917" title="All 2 branches covered.">		for (int creditDebtGroupIndex = 0; creditDebtGroupIndex &lt; creditDebtGroupCount;</span>
<span class="fc" id="L918">			++creditDebtGroupIndex)</span>
		{
<span class="fc" id="L920">			double[] creditDebtGroupVertexFundingExposure =</span>
<span class="fc" id="L921">				_creditDebtGroupPathArray[creditDebtGroupIndex].vertexFundingExposure();</span>

<span class="fc bfc" id="L923" title="All 2 branches covered.">			for (int vertexIndex = 0; vertexIndex &lt; vertexCount; ++vertexIndex)</span>
			{
<span class="fc" id="L925">				vertexFundingExposure[vertexIndex] += creditDebtGroupVertexFundingExposure[vertexIndex];</span>
			}
		}

<span class="fc bfc" id="L929" title="All 2 branches covered.">		for (int vertexIndex = 0; vertexIndex &lt; vertexCount; ++vertexIndex)</span>
		{
<span class="fc bfc" id="L931" title="All 2 branches covered.">			if (0. &gt; vertexFundingExposure[vertexIndex])</span>
			{
<span class="fc" id="L933">				vertexFundingExposure[vertexIndex] = 0.;</span>
			}
		}

<span class="fc" id="L937">		return vertexFundingExposure;</span>
	}

	/**
	 * Compute Vertex Path Funding Exposure PV
	 * 
	 * @return The Vertex Path Funding Exposure PV
	 */

	public double[] vertexFundingExposurePV()
	{
<span class="fc" id="L948">		org.drip.exposure.universe.MarketVertex[] marketVertexArray = _marketPath.marketVertexArray();</span>

<span class="fc" id="L950">		int vertexCount = marketVertexArray.length;</span>
<span class="fc" id="L951">		double[] vertexFundingExposurePV = new double[vertexCount];</span>
<span class="fc" id="L952">		int creditDebtGroupCount = _creditDebtGroupPathArray.length;</span>

<span class="fc bfc" id="L954" title="All 2 branches covered.">		for (int vertexIndex = 0; vertexIndex &lt; vertexCount; ++vertexIndex)</span>
		{
<span class="fc" id="L956">			vertexFundingExposurePV[vertexIndex] = 0.;</span>
		}

<span class="fc bfc" id="L959" title="All 2 branches covered.">		for (int creditDebtGroupIndex = 0; creditDebtGroupIndex &lt; creditDebtGroupCount;</span>
<span class="fc" id="L960">			++creditDebtGroupIndex)</span>
		{
<span class="fc" id="L962">			double[] creditDebtGroupVertexFundingExposurePV =</span>
<span class="fc" id="L963">				_creditDebtGroupPathArray[creditDebtGroupIndex].vertexFundingExposurePV();</span>

<span class="fc bfc" id="L965" title="All 2 branches covered.">			for (int vertexIndex = 0; vertexIndex &lt; vertexCount; ++vertexIndex)</span>
			{
<span class="fc" id="L967">				vertexFundingExposurePV[vertexIndex] += creditDebtGroupVertexFundingExposurePV[vertexIndex];</span>
			}
		}

<span class="fc bfc" id="L971" title="All 2 branches covered.">		for (int vertexIndex = 0; vertexIndex &lt; vertexCount; ++vertexIndex)</span>
		{
<span class="fc bfc" id="L973" title="All 2 branches covered.">			if (0. &gt; vertexFundingExposurePV[vertexIndex])</span>
			{
<span class="fc" id="L975">				vertexFundingExposurePV[vertexIndex] = 0.;</span>
			}
		}

<span class="fc" id="L979">		return vertexFundingExposurePV;</span>
	}

	/**
	 * Compute Period-wise Path Symmetric Funding Value Adjustment
	 * 
	 * @return The Period-wise Path Symmetric Funding Value Adjustment
	 */

	public double[] periodSymmetricFundingValueAdjustment()
	{
<span class="fc" id="L990">		org.drip.exposure.universe.MarketVertex[] marketVertexArray = _marketPath.marketVertexArray();</span>

<span class="fc" id="L992">		double[] periodSymmetricFundingValueSpread01 = periodSymmetricFundingValueSpread01();</span>

<span class="fc" id="L994">		int periodCount = periodSymmetricFundingValueSpread01.length;</span>
<span class="fc" id="L995">		double[] periodSymmetricFundingValueAdjustment = new double[periodCount];</span>

<span class="fc bfc" id="L997" title="All 2 branches covered.">		for (int periodIndex = 0; periodIndex &lt; periodCount; ++periodIndex)</span>
		{
<span class="fc" id="L999">			periodSymmetricFundingValueAdjustment[periodIndex] =</span>
				0.5 * periodSymmetricFundingValueSpread01[periodIndex] * (
<span class="fc" id="L1001">					marketVertexArray[periodIndex].dealer().seniorFundingSpread() +</span>
<span class="fc" id="L1002">					marketVertexArray[periodIndex + 1].dealer().seniorFundingSpread()</span>
				);
		}

<span class="fc" id="L1006">		return periodSymmetricFundingValueAdjustment;</span>
	}

	/**
	 * Compute Period-wise Unilateral Path Funding Value Adjustment
	 * 
	 * @return The Period-wise Unilateral Path Funding Value Adjustment
	 */

	public double[] periodUnilateralFundingValueAdjustment()
	{
<span class="fc" id="L1017">		double[] periodUnilateralFundingValueSpread01 = periodUnilateralFundingValueSpread01();</span>

<span class="fc" id="L1019">		int periodCount = periodUnilateralFundingValueSpread01.length;</span>
<span class="fc" id="L1020">		double[] periodUnilateralFundingValueAdjustment = new double[periodCount];</span>

<span class="fc" id="L1022">		org.drip.exposure.universe.MarketVertex[] marketVertexArray = _marketPath.marketVertexArray();</span>

<span class="fc bfc" id="L1024" title="All 2 branches covered.">		for (int periodIndex = 0; periodIndex &lt; periodCount; ++periodIndex)</span>
		{
<span class="fc" id="L1026">			periodUnilateralFundingValueAdjustment[periodIndex] =</span>
				0.5 * periodUnilateralFundingValueSpread01[periodIndex] * (
<span class="fc" id="L1028">					marketVertexArray[periodIndex].dealer().seniorFundingSpread() +</span>
<span class="fc" id="L1029">					marketVertexArray[periodIndex + 1].dealer().seniorFundingSpread()</span>
				);
		}

<span class="fc" id="L1033">		return periodUnilateralFundingValueAdjustment;</span>
	}

	/**
	 * Compute Period-wise Bilateral Path Funding Value Adjustment
	 * 
	 * @return The Period-wise Bilateral Path Funding Value Adjustment
	 */

	public double[] periodBilateralFundingValueAdjustment()
	{
<span class="fc" id="L1044">		double[] periodBilateralFundingValueSpread01 = periodBilateralFundingValueSpread01();</span>

<span class="fc" id="L1046">		int periodCount = periodBilateralFundingValueSpread01.length;</span>
<span class="fc" id="L1047">		double[] periodBilateralFundingValueAdjustment = new double[periodCount];</span>

<span class="fc" id="L1049">		org.drip.exposure.universe.MarketVertex[] marketVertexArray = _marketPath.marketVertexArray();</span>

<span class="fc bfc" id="L1051" title="All 2 branches covered.">		for (int periodIndex = 0; periodIndex &lt; periodCount; ++periodIndex)</span>
		{
<span class="fc" id="L1053">			periodBilateralFundingValueAdjustment[periodIndex] =</span>
				0.5 * periodBilateralFundingValueSpread01[periodIndex] * (
<span class="fc" id="L1055">					marketVertexArray[periodIndex].dealer().seniorFundingSpread() +</span>
<span class="fc" id="L1056">					marketVertexArray[periodIndex + 1].dealer().seniorFundingSpread()</span>
				);
		}

<span class="fc" id="L1060">		return periodBilateralFundingValueAdjustment;</span>
	}

	/**
	 * Compute Period-wise Path Unilateral Funding Debt Adjustment
	 * 
	 * @return The Period-wise Path Unilateral Funding Debt Adjustment
	 */

	public double[] periodUnilateralFundingDebtAdjustment()
	{
<span class="fc" id="L1071">		org.drip.exposure.universe.MarketVertex[] marketVertexArray = _marketPath.marketVertexArray();</span>

<span class="fc" id="L1073">		int periodCount = marketVertexArray.length - 1;</span>
<span class="fc" id="L1074">		int creditDebtGroupCount = _creditDebtGroupPathArray.length;</span>
<span class="fc" id="L1075">		double[] periodUnilateralFundingDebtAdjustment = new double[periodCount];</span>

<span class="fc bfc" id="L1077" title="All 2 branches covered.">		for (int periodIndex = 0; periodIndex &lt; periodCount; ++periodIndex)</span>
		{
<span class="fc" id="L1079">			periodUnilateralFundingDebtAdjustment[periodIndex] = 0.;</span>
		}

<span class="fc bfc" id="L1082" title="All 2 branches covered.">		for (int creditDebtGroupIndex = 0; creditDebtGroupIndex &lt; creditDebtGroupCount;</span>
<span class="fc" id="L1083">			++creditDebtGroupIndex)</span>
		{
<span class="fc" id="L1085">			double[] periodUnilateralFundingDebtAdjustmentCreditDebtGroup =</span>
<span class="fc" id="L1086">				_creditDebtGroupPathArray[creditDebtGroupIndex].periodUnilateralFundingDebtAdjustment();</span>

<span class="fc bfc" id="L1088" title="All 2 branches covered.">			for (int periodIndex = 0; periodIndex &lt; periodCount; ++periodIndex)</span>
			{
<span class="fc" id="L1090">				periodUnilateralFundingDebtAdjustment[periodIndex] +=</span>
					periodUnilateralFundingDebtAdjustmentCreditDebtGroup[periodIndex];
			}
		}

<span class="fc" id="L1095">		return periodUnilateralFundingDebtAdjustment;</span>
	}

	/**
	 * Compute Period-wise Path Bilateral Funding Debt Adjustment
	 * 
	 * @return The Period-wise Path Bilateral Funding Debt Adjustment
	 */

	public double[] periodBilateralFundingDebtAdjustment()
	{
<span class="fc" id="L1106">		org.drip.exposure.universe.MarketVertex[] marketVertexArray = _marketPath.marketVertexArray();</span>

<span class="fc" id="L1108">		int periodCount = marketVertexArray.length - 1;</span>
<span class="fc" id="L1109">		int creditDebtGroupCount = _creditDebtGroupPathArray.length;</span>
<span class="fc" id="L1110">		double[] periodBilateralFundingDebtAdjustment = new double[periodCount];</span>

<span class="fc bfc" id="L1112" title="All 2 branches covered.">		for (int periodIndex = 0; periodIndex &lt; periodCount; ++periodIndex)</span>
		{
<span class="fc" id="L1114">			periodBilateralFundingDebtAdjustment[periodIndex] = 0.;</span>
		}

<span class="fc bfc" id="L1117" title="All 2 branches covered.">		for (int creditDebtGroupIndex = 0; creditDebtGroupIndex &lt; creditDebtGroupCount;</span>
<span class="fc" id="L1118">			++creditDebtGroupIndex)</span>
		{
<span class="fc" id="L1120">			double[] periodBilateralFundingDebtAdjustmentCreditDebtGroup =</span>
<span class="fc" id="L1121">				_creditDebtGroupPathArray[creditDebtGroupIndex].periodBilateralFundingDebtAdjustment();</span>

<span class="fc bfc" id="L1123" title="All 2 branches covered.">			for (int periodIndex = 0; periodIndex &lt; periodCount; ++periodIndex)</span>
			{
<span class="fc" id="L1125">				periodBilateralFundingDebtAdjustment[periodIndex] +=</span>
					periodBilateralFundingDebtAdjustmentCreditDebtGroup[periodIndex];
			}
		}

<span class="fc" id="L1130">		return periodBilateralFundingDebtAdjustment;</span>
	}

	/**
	 * Compute Path Unilateral Credit Value Adjustment
	 * 
	 * @return The Path Unilateral Credit Value Adjustment
	 */

	public double unilateralCreditAdjustment()
	{
<span class="fc" id="L1141">		double unilateralCreditAdjustment = 0.;</span>
<span class="fc" id="L1142">		int creditDebtGroupCount = _creditDebtGroupPathArray.length;</span>

<span class="fc bfc" id="L1144" title="All 2 branches covered.">		for (int creditDebtGroupIndex = 0; creditDebtGroupIndex &lt; creditDebtGroupCount;</span>
<span class="fc" id="L1145">			++creditDebtGroupIndex)</span>
		{
<span class="fc" id="L1147">			unilateralCreditAdjustment +=</span>
<span class="fc" id="L1148">				_creditDebtGroupPathArray[creditDebtGroupIndex].unilateralCreditAdjustment();</span>
		}

<span class="fc" id="L1151">		return unilateralCreditAdjustment;</span>
	}

	/**
	 * Compute Path Bilateral Credit Value Adjustment
	 * 
	 * @return The Path Bilateral Credit Value Adjustment
	 */

	public double bilateralCreditAdjustment()
	{
<span class="fc" id="L1162">		double bilateralCreditAdjustment = 0.;</span>
<span class="fc" id="L1163">		int creditDebtGroupCount = _creditDebtGroupPathArray.length;</span>

<span class="fc bfc" id="L1165" title="All 2 branches covered.">		for (int creditDebtGroupIndex = 0; creditDebtGroupIndex &lt; creditDebtGroupCount;</span>
<span class="fc" id="L1166">			++creditDebtGroupIndex)</span>
		{
<span class="fc" id="L1168">			bilateralCreditAdjustment +=</span>
<span class="fc" id="L1169">				_creditDebtGroupPathArray[creditDebtGroupIndex].bilateralCreditAdjustment();</span>
		}

<span class="fc" id="L1172">		return bilateralCreditAdjustment;</span>
	}

	/**
	 * Compute Path Contra-Liability Credit Adjustment
	 * 
	 * @return The Path Contra-Liability Credit Adjustment
	 */

	public double contraLiabilityCreditAdjustment()
	{
<span class="fc" id="L1183">		double contraLiabilityCreditAdjustment = 0.;</span>
<span class="fc" id="L1184">		int creditDebtGroupCount = _creditDebtGroupPathArray.length;</span>

<span class="fc bfc" id="L1186" title="All 2 branches covered.">		for (int creditDebtGroupIndex = 0; creditDebtGroupIndex &lt; creditDebtGroupCount;</span>
<span class="fc" id="L1187">			++creditDebtGroupIndex)</span>
		{
<span class="fc" id="L1189">			contraLiabilityCreditAdjustment +=</span>
<span class="fc" id="L1190">				_creditDebtGroupPathArray[creditDebtGroupIndex].contraLiabilityCreditAdjustment();</span>
		}

<span class="fc" id="L1193">		return contraLiabilityCreditAdjustment;</span>
	}

	/**
	 * Compute Path Unilateral Debt Value Adjustment
	 * 
	 * @return The Path Unilateral Debt Value Adjustment
	 */

	public double unilateralDebtAdjustment()
	{
<span class="fc" id="L1204">		double unilateralDebtAdjustment = 0.;</span>
<span class="fc" id="L1205">		int creditDebtGroupCount = _creditDebtGroupPathArray.length;</span>

<span class="fc bfc" id="L1207" title="All 2 branches covered.">		for (int creditDebtGroupIndex = 0; creditDebtGroupIndex &lt; creditDebtGroupCount;</span>
<span class="fc" id="L1208">			++creditDebtGroupIndex)</span>
		{
<span class="fc" id="L1210">			unilateralDebtAdjustment +=</span>
<span class="fc" id="L1211">				_creditDebtGroupPathArray[creditDebtGroupIndex].unilateralDebtAdjustment();</span>
		}

<span class="fc" id="L1214">		return unilateralDebtAdjustment;</span>
	}

	/**
	 * Compute Path Bilateral Debt Value Adjustment
	 * 
	 * @return The Path Bilateral Credit Value Adjustment
	 */

	public double bilateralDebtAdjustment()
	{
<span class="nc" id="L1225">		double bilateralDebtAdjustment = 0.;</span>
<span class="nc" id="L1226">		int creditDebtGroupCount = _creditDebtGroupPathArray.length;</span>

<span class="nc bnc" id="L1228" title="All 2 branches missed.">		for (int creditDebtGroupIndex = 0; creditDebtGroupIndex &lt; creditDebtGroupCount;</span>
<span class="nc" id="L1229">			++creditDebtGroupIndex)</span>
		{
<span class="nc" id="L1231">			bilateralDebtAdjustment +=</span>
<span class="nc" id="L1232">				_creditDebtGroupPathArray[creditDebtGroupIndex].bilateralDebtAdjustment();</span>
		}

<span class="nc" id="L1235">		return bilateralDebtAdjustment;</span>
	}

	/**
	 * Compute Path Contra-Asset Debt Adjustment
	 * 
	 * @return The Path Contra-Asset Debt Adjustment
	 */

	public double contraAssetDebtAdjustment()
	{
<span class="nc" id="L1246">		double contraAssetDebtAdjustment = 0.;</span>
<span class="nc" id="L1247">		int creditDebtGroupCount = _creditDebtGroupPathArray.length;</span>

<span class="nc bnc" id="L1249" title="All 2 branches missed.">		for (int creditDebtGroupIndex = 0; creditDebtGroupIndex &lt; creditDebtGroupCount;</span>
<span class="nc" id="L1250">			++creditDebtGroupIndex)</span>
		{
<span class="nc" id="L1252">			contraAssetDebtAdjustment +=</span>
<span class="nc" id="L1253">				_creditDebtGroupPathArray[creditDebtGroupIndex].contraAssetDebtAdjustment();</span>
		}

<span class="nc" id="L1256">		return contraAssetDebtAdjustment;</span>
	}

	/**
	 * Compute Path Unilateral Collateral Value Adjustment
	 * 
	 * @return The Path Unilateral Collateral Value Adjustment
	 */

	public double unilateralCollateralAdjustment()
	{
<span class="nc" id="L1267">		double unilateralCollateralAdjustment = 0.;</span>
<span class="nc" id="L1268">		int creditDebtGroupCount = _creditDebtGroupPathArray.length;</span>

<span class="nc bnc" id="L1270" title="All 2 branches missed.">		for (int creditDebtGroupIndex = 0; creditDebtGroupIndex &lt; creditDebtGroupCount;</span>
<span class="nc" id="L1271">			++creditDebtGroupIndex)</span>
		{
<span class="nc" id="L1273">			unilateralCollateralAdjustment +=</span>
<span class="nc" id="L1274">				_creditDebtGroupPathArray[creditDebtGroupIndex].unilateralCollateralAdjustment();</span>
		}

<span class="nc" id="L1277">		return unilateralCollateralAdjustment;</span>
	}

	/**
	 * Compute Path Bilateral Collateral Value Adjustment
	 * 
	 * @return The Path Bilateral Collateral Value Adjustment
	 */

	public double bilateralCollateralAdjustment()
	{
<span class="fc" id="L1288">		double bilateralCollateralAdjustment = 0.;</span>
<span class="fc" id="L1289">		int creditDebtGroupCount = _creditDebtGroupPathArray.length;</span>

<span class="fc bfc" id="L1291" title="All 2 branches covered.">		for (int creditDebtGroupIndex = 0; creditDebtGroupIndex &lt; creditDebtGroupCount;</span>
<span class="fc" id="L1292">			++creditDebtGroupIndex)</span>
		{
<span class="fc" id="L1294">			bilateralCollateralAdjustment +=</span>
<span class="fc" id="L1295">				_creditDebtGroupPathArray[creditDebtGroupIndex].bilateralCollateralAdjustment();</span>
		}

<span class="fc" id="L1298">		return bilateralCollateralAdjustment;</span>
	}

	/**
	 * Compute Path Funding Value Adjustment
	 * 
	 * @return The Path Funding Value Adjustment
	 */

	public abstract double fundingValueAdjustment();

	/**
	 * Compute Path Funding Debt Adjustment
	 * 
	 * @return The Path Funding Debt Adjustment
	 */

	public abstract double fundingDebtAdjustment();

	/**
	 * Compute Path Funding Cost Adjustment
	 * 
	 * @return The Path Funding Cost Adjustment
	 */

	public abstract double fundingCostAdjustment();

	/**
	 * Compute Path Funding Benefit Adjustment
	 * 
	 * @return The Path Funding Benefit Adjustment
	 */

	public abstract double fundingBenefitAdjustment();

	/**
	 * Compute Period-wise Path Funding Value Adjustment
	 * 
	 * @return The Period-wise Path Funding Value Adjustment
	 */

	public abstract double[] periodFundingValueAdjustment();

	/**
	 * Compute Period-wise Path Funding Debt Adjustment
	 * 
	 * @return The Period-wise Path Funding Debt Adjustment
	 */

	public abstract double[] periodFundingDebtAdjustment();

	/**
	 * Compute Period-wise Path Funding Cost Adjustment
	 * 
	 * @return The Period-wise Path Funding Cost Adjustment
	 */

	public abstract double[] periodFundingCostAdjustment();

	/**
	 * Compute Period-wise Path Funding Benefit Adjustment
	 * 
	 * @return The Period-wise Path Funding Benefit Adjustment
	 */

	public abstract double[] periodFundingBenefitAdjustment();
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.7.9.201702052155</span></div></body></html>