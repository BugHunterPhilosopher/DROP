<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>FundingGroupPath.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">DROP</a> &gt; <a href="index.source.html" class="el_package">org.drip.xva.netting</a> &gt; <span class="el_source">FundingGroupPath.java</span></div><h1>FundingGroupPath.java</h1><pre class="source lang-java linenums">
package org.drip.xva.netting;

/*
 * -*- mode: java; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*-
 */

/*!
 * Copyright (C) 2018 Lakshmi Krishnamurthy
 * Copyright (C) 2017 Lakshmi Krishnamurthy
 * 
 *  This file is part of DRIP, a free-software/open-source library for buy/side financial/trading model
 *  	libraries targeting analysts and developers
 *  	https://lakshmidrip.github.io/DRIP/
 *  
 *  DRIP is composed of four main libraries:
 *  
 *  - DRIP Fixed Income - https://lakshmidrip.github.io/DRIP-Fixed-Income/
 *  - DRIP Asset Allocation - https://lakshmidrip.github.io/DRIP-Asset-Allocation/
 *  - DRIP Numerical Optimizer - https://lakshmidrip.github.io/DRIP-Numerical-Optimizer/
 *  - DRIP Statistical Learning - https://lakshmidrip.github.io/DRIP-Statistical-Learning/
 * 
 *  - DRIP Fixed Income: Library for Instrument/Trading Conventions, Treasury Futures/Options,
 *  	Funding/Forward/Overnight Curves, Multi-Curve Construction/Valuation, Collateral Valuation and XVA
 *  	Metric Generation, Calibration and Hedge Attributions, Statistical Curve Construction, Bond RV
 *  	Metrics, Stochastic Evolution and Option Pricing, Interest Rate Dynamics and Option Pricing, LMM
 *  	Extensions/Calibrations/Greeks, Algorithmic Differentiation, and Asset Backed Models and Analytics.
 * 
 *  - DRIP Asset Allocation: Library for model libraries for MPT framework, Black Litterman Strategy
 *  	Incorporator, Holdings Constraint, and Transaction Costs.
 * 
 *  - DRIP Numerical Optimizer: Library for Numerical Optimization and Spline Functionality.
 * 
 *  - DRIP Statistical Learning: Library for Statistical Evaluation and Machine Learning.
 * 
 *  Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 *   	you may not use this file except in compliance with the License.
 *   
 *  You may obtain a copy of the License at
 *  	http://www.apache.org/licenses/LICENSE-2.0
 *  
 *  Unless required by applicable law or agreed to in writing, software
 *  	distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 *  	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  
 *  See the License for the specific language governing permissions and
 *  	limitations under the License.
 */

/**
 * FundingGroupPath holds up the Strategy Abstract Realizations of the Sequence in a Single Path Projection
 *  Run over Multiple Collateral Groups onto a Single Funding Group - the Purpose being to calculate Funding
 *  Valuation Adjustments. The References are:
 *  
 *  - Burgard, C., and M. Kjaer (2014): PDE Representations of Derivatives with Bilateral Counter-party Risk
 *  	and Funding Costs, Journal of Credit Risk, 7 (3) 1-19.
 *  
 *  - Burgard, C., and M. Kjaer (2014): In the Balance, Risk, 24 (11) 72-75.
 *  
 *  - Gregory, J. (2009): Being Two-faced over Counter-party Credit Risk, Risk 20 (2) 86-90.
 *  
 *  - Li, B., and Y. Tang (2007): Quantitative Analysis, Derivatives Modeling, and Trading Strategies in the
 *  	Presence of Counter-party Credit Risk for the Fixed Income Market, World Scientific Publishing,
 *  	Singapore.
 * 
 *  - Piterbarg, V. (2010): Funding Beyond Discounting: Collateral Agreements and Derivatives Pricing, Risk
 *  	21 (2) 97-102.
 * 
 * @author Lakshmi Krishnamurthy
 */

public abstract class FundingGroupPath
{
<span class="fc" id="L74">	private org.drip.exposure.universe.MarketPath _marketPath = null;</span>
<span class="fc" id="L75">	private org.drip.xva.netting.CreditDebtGroupPath[] _creditDebtGroupPathArray = null;</span>

	protected FundingGroupPath (
		final org.drip.xva.netting.CreditDebtGroupPath[] creditDebtGroupPathArray,
		final org.drip.exposure.universe.MarketPath marketPath)
		throws java.lang.Exception
<span class="fc" id="L81">	{</span>
<span class="pc bpc" id="L82" title="2 of 4 branches missed.">		if (null == (_creditDebtGroupPathArray = creditDebtGroupPathArray) ||</span>
			null == (_marketPath = marketPath))
		{
<span class="nc" id="L85">			throw new java.lang.Exception (&quot;FundingGroupPath Constructor =&gt; Invalid Inputs&quot;);</span>
		}
<span class="fc" id="L87">	}</span>

	/**
	 * Retrieve the Array of CreditDebtGroupPath
	 * 
	 * @return The Array of CreditDebtGroupPath
	 */

	public org.drip.xva.netting.CreditDebtGroupPath[] creditDebtGroupPathArray()
	{
<span class="nc" id="L97">		return _creditDebtGroupPathArray;</span>
	}

	/**
	 * Retrieve the Market Path
	 * 
	 * @return The Market Path
	 */

	public org.drip.exposure.universe.MarketPath marketPath()
	{
<span class="nc" id="L108">		return _marketPath;</span>
	}

	/**
	 * Retrieve the Array of the Vertex Anchor Dates
	 * 
	 * @return The Array of the Vertex Anchor Dates
	 */

	public org.drip.analytics.date.JulianDate[] vertexDates()
	{
<span class="fc" id="L119">		return _creditDebtGroupPathArray[0].vertexDates();</span>
	}

	/**
	 * Compute Path Symmetric Funding Value Spread 01
	 * 
	 * @return The Path Symmetric Funding Value Spread 01
	 */

	public double symmetricFundingValueSpread01()
	{
<span class="nc" id="L130">		double symmetricFundingSpread01 = 0.;</span>
<span class="nc" id="L131">		int creditDebtGroupCount = _creditDebtGroupPathArray.length;</span>

<span class="nc bnc" id="L133" title="All 2 branches missed.">		for (int creditDebtGroupIndex = 0; creditDebtGroupIndex &lt; creditDebtGroupCount;</span>
<span class="nc" id="L134">			++creditDebtGroupIndex)</span>
		{
<span class="nc" id="L136">			symmetricFundingSpread01 +=</span>
<span class="nc" id="L137">				_creditDebtGroupPathArray[creditDebtGroupIndex].symmetricFundingValueSpread01();</span>
		}

<span class="nc" id="L140">		return symmetricFundingSpread01;</span>
	}

	/**
	 * Compute Path Unilateral Funding Value Spread 01
	 * 
	 * @return The Path Unilateral Funding Value Spread 01
	 */

	public double unilateralFundingValueSpread01()
	{
<span class="nc" id="L151">		double unilateralFundingValueSpread01 = 0.;</span>
<span class="nc" id="L152">		int creditDebtGroupCount = _creditDebtGroupPathArray.length;</span>

<span class="nc bnc" id="L154" title="All 2 branches missed.">		for (int creditDebtGroupIndex = 0; creditDebtGroupIndex &lt; creditDebtGroupCount;</span>
<span class="nc" id="L155">			++creditDebtGroupIndex)</span>
		{
<span class="nc" id="L157">			unilateralFundingValueSpread01 +=</span>
<span class="nc" id="L158">				_creditDebtGroupPathArray[creditDebtGroupIndex].unilateralFundingValueSpread01();</span>
		}

<span class="nc bnc" id="L161" title="All 2 branches missed.">		return 0. &gt; unilateralFundingValueSpread01 ? 0. : unilateralFundingValueSpread01;</span>
	}

	/**
	 * Compute Path Bilateral Funding Value Spread 01
	 * 
	 * @return The Path Bilateral Funding Value Spread 01
	 */

	public double bilateralFundingValueSpread01()
	{
<span class="nc" id="L172">		double bilateralFundingValueSpread01 = 0.;</span>
<span class="nc" id="L173">		int creditDebtGroupCount = _creditDebtGroupPathArray.length;</span>

<span class="nc bnc" id="L175" title="All 2 branches missed.">		for (int creditDebtGroupIndex = 0; creditDebtGroupIndex &lt; creditDebtGroupCount;</span>
<span class="nc" id="L176">			++creditDebtGroupIndex)</span>
		{
<span class="nc" id="L178">			bilateralFundingValueSpread01 +=</span>
<span class="nc" id="L179">				_creditDebtGroupPathArray[creditDebtGroupIndex].bilateralFundingValueSpread01();</span>
		}

<span class="nc bnc" id="L182" title="All 2 branches missed.">		return 0. &gt; bilateralFundingValueSpread01 ? 0. : bilateralFundingValueSpread01;</span>
	}

	/**
	 * Compute Period Symmetric Funding Value Spread 01
	 * 
	 * @return The Period Symmetric Funding Value Spread 01
	 */

	public double[] periodSymmetricFundingValueSpread01()
	{
<span class="fc" id="L193">		org.drip.exposure.universe.MarketVertex[] marketVertexArray = _marketPath.marketVertexArray();</span>

<span class="fc" id="L195">		int periodCount = marketVertexArray.length - 1;</span>
<span class="fc" id="L196">		int creditDebtGroupCount = _creditDebtGroupPathArray.length;</span>
<span class="fc" id="L197">		double[] periodSymmetricFundingValueSpread01 = new double[periodCount];</span>

<span class="fc bfc" id="L199" title="All 2 branches covered.">		for (int periodIndex = 0; periodIndex &lt; periodCount; ++periodIndex)</span>
		{
<span class="fc" id="L201">			periodSymmetricFundingValueSpread01[periodIndex] = 0.;</span>
		}

<span class="fc bfc" id="L204" title="All 2 branches covered.">		for (int creditDebtGroupIndex = 0; creditDebtGroupIndex &lt; creditDebtGroupCount;</span>
<span class="fc" id="L205">			++creditDebtGroupIndex)</span>
		{
<span class="fc" id="L207">			double[] periodCreditDebtGroupSymmetricFundingValueSpread01 =</span>
<span class="fc" id="L208">				_creditDebtGroupPathArray[creditDebtGroupIndex].periodSymmetricFundingValueSpread01();</span>

<span class="fc bfc" id="L210" title="All 2 branches covered.">			for (int periodIndex = 0; periodIndex &lt; periodCount; ++periodIndex)</span>
			{
<span class="fc" id="L212">				periodSymmetricFundingValueSpread01[periodIndex] +=</span>
					periodCreditDebtGroupSymmetricFundingValueSpread01[periodIndex];
			}
		}

<span class="fc" id="L217">		return periodSymmetricFundingValueSpread01;</span>
	}

	/**
	 * Compute Period Unilateral Funding Value Spread 01
	 * 
	 * @return The Period Unilateral Funding Value Spread 01
	 */

	public double[] periodUnilateralFundingValueSpread01()
	{
<span class="fc" id="L228">		org.drip.exposure.universe.MarketVertex[] marketVertexArray = _marketPath.marketVertexArray();</span>

<span class="fc" id="L230">		int periodCount = marketVertexArray.length - 1;</span>
<span class="fc" id="L231">		int creditDebtGroupCount = _creditDebtGroupPathArray.length;</span>
<span class="fc" id="L232">		double[] periodUnilateralFundingValueSpread01 = new double[periodCount];</span>

<span class="fc bfc" id="L234" title="All 2 branches covered.">		for (int periodIndex = 0; periodIndex &lt; periodCount; ++periodIndex)</span>
		{
<span class="fc" id="L236">			periodUnilateralFundingValueSpread01[periodIndex] = 0.;</span>
		}

<span class="fc bfc" id="L239" title="All 2 branches covered.">		for (int creditDebtGroupIndex = 0; creditDebtGroupIndex &lt; creditDebtGroupCount;</span>
<span class="fc" id="L240">			++creditDebtGroupIndex)</span>
		{
<span class="fc" id="L242">			double[] periodCreditDebtGroupUnilateralFundingValueSpread01 =</span>
<span class="fc" id="L243">				_creditDebtGroupPathArray[creditDebtGroupIndex].periodUnilateralFundingValueSpread01();</span>

<span class="fc bfc" id="L245" title="All 2 branches covered.">			for (int periodIndex = 0; periodIndex &lt; periodCount; ++periodIndex)</span>
			{
<span class="fc" id="L247">				periodUnilateralFundingValueSpread01[periodIndex] +=</span>
					periodCreditDebtGroupUnilateralFundingValueSpread01[periodIndex];
			}
		}

<span class="fc bfc" id="L252" title="All 2 branches covered.">		for (int periodIndex = 0; periodIndex &lt; periodCount; ++periodIndex)</span>
		{
<span class="fc bfc" id="L254" title="All 2 branches covered.">			if (0. &gt; periodUnilateralFundingValueSpread01[periodIndex])</span>
			{
<span class="fc" id="L256">				periodUnilateralFundingValueSpread01[periodIndex] = 0.;</span>
			}
		}

<span class="fc" id="L260">		return periodUnilateralFundingValueSpread01;</span>
	}

	/**
	 * Compute Period Bilateral Funding Value Spread 01
	 * 
	 * @return The Period Bilateral Funding Value Spread 01
	 */

	public double[] periodBilateralFundingValueSpread01()
	{
<span class="fc" id="L271">		org.drip.exposure.universe.MarketVertex[] marketVertexArray = _marketPath.marketVertexArray();</span>

<span class="fc" id="L273">		int periodCount = marketVertexArray.length - 1;</span>
<span class="fc" id="L274">		int creditDebtGroupCount = _creditDebtGroupPathArray.length;</span>
<span class="fc" id="L275">		double[] periodBilateralFundingValueSpread01 = new double[periodCount];</span>

<span class="fc bfc" id="L277" title="All 2 branches covered.">		for (int periodIndex = 0; periodIndex &lt; periodCount; ++periodIndex)</span>
		{
<span class="fc" id="L279">			periodBilateralFundingValueSpread01[periodIndex] = 0.;</span>
		}

<span class="fc bfc" id="L282" title="All 2 branches covered.">		for (int creditDebtGroupIndex = 0; creditDebtGroupIndex &lt; creditDebtGroupCount;</span>
<span class="fc" id="L283">			++creditDebtGroupIndex)</span>
		{
<span class="fc" id="L285">			double[] periodCreditDebtGroupBilateralFundingValueSpread01 =</span>
<span class="fc" id="L286">				_creditDebtGroupPathArray[creditDebtGroupIndex].periodBilateralFundingValueSpread01();</span>

<span class="fc bfc" id="L288" title="All 2 branches covered.">			for (int periodIndex = 0; periodIndex &lt; periodCount; ++periodIndex)</span>
			{
<span class="fc" id="L290">				periodBilateralFundingValueSpread01[periodIndex] +=</span>
					periodCreditDebtGroupBilateralFundingValueSpread01[periodIndex];
			}
		}

<span class="fc bfc" id="L295" title="All 2 branches covered.">		for (int periodIndex = 0; periodIndex &lt; periodCount; ++periodIndex)</span>
		{
<span class="pc bpc" id="L297" title="1 of 2 branches missed.">			if (0. &gt; periodBilateralFundingValueSpread01[periodIndex])</span>
			{
<span class="nc" id="L299">				periodBilateralFundingValueSpread01[periodIndex] = 0.;</span>
			}
		}

<span class="fc" id="L303">		return periodBilateralFundingValueSpread01;</span>
	}

	/**
	 * Compute Path Symmetric Funding Value Adjustment
	 * 
	 * @return The Path Symmetric Funding Value Adjustment
	 */

	public double symmetricFundingValueAdjustment()
	{
<span class="fc" id="L314">		double[] periodSymmetricFundingValueSpread01 = periodSymmetricFundingValueSpread01();</span>

<span class="fc" id="L316">		org.drip.exposure.universe.MarketVertex[] marketVertexArray = _marketPath.marketVertexArray();</span>

<span class="fc" id="L318">		int periodCount = periodSymmetricFundingValueSpread01.length;</span>
<span class="fc" id="L319">		double symmetricFundingValueAdjustment = 0.;</span>

<span class="fc bfc" id="L321" title="All 2 branches covered.">		for (int periodIndex = 0; periodIndex &lt; periodCount; ++periodIndex)</span>
		{
<span class="fc" id="L323">			symmetricFundingValueAdjustment +=</span>
				0.5 * periodSymmetricFundingValueSpread01[periodIndex] * (
<span class="fc" id="L325">					marketVertexArray[periodIndex].dealer().seniorFundingSpread() +</span>
<span class="fc" id="L326">					marketVertexArray[periodIndex + 1].dealer().seniorFundingSpread()</span>
				);
		}

<span class="fc" id="L330">		return symmetricFundingValueAdjustment;</span>
	}

	/**
	 * Compute Path Unilateral Funding Value Adjustment
	 * 
	 * @return The Path Unilateral Funding Value Adjustment
	 */

	public double unilateralFundingValueAdjustment()
	{
<span class="fc" id="L341">		double[] periodUnilateralFundingValueSpread01 = periodUnilateralFundingValueSpread01();</span>

<span class="fc" id="L343">		org.drip.exposure.universe.MarketVertex[] marketVertexArray = _marketPath.marketVertexArray();</span>

<span class="fc" id="L345">		int periodCount = periodUnilateralFundingValueSpread01.length;</span>
<span class="fc" id="L346">		double unilateralFundingValueAdjustment = 0.;</span>

<span class="fc bfc" id="L348" title="All 2 branches covered.">		for (int periodIndex = 0; periodIndex &lt; periodCount; ++periodIndex)</span>
		{
<span class="fc" id="L350">			unilateralFundingValueAdjustment -=</span>
				0.5 * periodUnilateralFundingValueSpread01[periodIndex] * (
<span class="fc" id="L352">					marketVertexArray[periodIndex].dealer().seniorFundingSpread() +</span>
<span class="fc" id="L353">					marketVertexArray[periodIndex + 1].dealer().seniorFundingSpread()</span>
				);
		}

<span class="fc" id="L357">		return unilateralFundingValueAdjustment;</span>
	}

	/**
	 * Compute Path Bilateral Funding Value Adjustment
	 * 
	 * @return The Path Bilateral Funding Value Adjustment
	 */

	public double bilateralFundingValueAdjustment()
	{
<span class="nc" id="L368">		double[] periodBilateralFundingValueSpread01 = periodBilateralFundingValueSpread01();</span>

<span class="nc" id="L370">		org.drip.exposure.universe.MarketVertex[] marketVertexArray = _marketPath.marketVertexArray();</span>

<span class="nc" id="L372">		int periodCount = periodBilateralFundingValueSpread01.length;</span>
<span class="nc" id="L373">		double bilateralFundingValueAdjustment = 0.;</span>

<span class="nc bnc" id="L375" title="All 2 branches missed.">		for (int periodIndex = 0; periodIndex &lt; periodCount; ++periodIndex)</span>
		{
<span class="nc" id="L377">			bilateralFundingValueAdjustment -=</span>
				0.5 * periodBilateralFundingValueSpread01[periodIndex] * (
<span class="nc" id="L379">					marketVertexArray[periodIndex].dealer().seniorFundingSpread() +</span>
<span class="nc" id="L380">					marketVertexArray[periodIndex + 1].dealer().seniorFundingSpread()</span>
				);
		}

<span class="nc" id="L384">		return bilateralFundingValueAdjustment;</span>
	}

	/**
	 * Compute Path Unilateral Funding Debt Adjustment
	 * 
	 * @return The Path Unilateral Funding Debt Adjustment
	 */

	public double unilateralFundingDebtAdjustment()
	{
<span class="fc" id="L395">		double[] periodUnilateralFundingDebtAdjustment = periodUnilateralFundingDebtAdjustment();</span>

<span class="fc" id="L397">		int periodCount = periodUnilateralFundingDebtAdjustment.length;</span>
<span class="fc" id="L398">		double unilateralFundingDebtAdjustment = 0.;</span>

<span class="fc bfc" id="L400" title="All 2 branches covered.">		for (int periodIndex = 0; periodIndex &lt; periodCount; ++periodIndex)</span>
		{
<span class="fc" id="L402">			unilateralFundingDebtAdjustment += periodUnilateralFundingDebtAdjustment[periodIndex];</span>
		}

<span class="fc" id="L405">		return unilateralFundingDebtAdjustment;</span>
	}

	/**
	 * Compute Path Bilateral Funding Debt Adjustment
	 * 
	 * @return The Path Bilateral Funding Debt Adjustment
	 */

	public double bilateralFundingDebtAdjustment()
	{
<span class="nc" id="L416">		double[] periodBilateralFundingDebtAdjustment = periodBilateralFundingDebtAdjustment();</span>

<span class="nc" id="L418">		int periodCount = periodBilateralFundingDebtAdjustment.length;</span>
<span class="nc" id="L419">		double bilateralFundingDebtAdjustment = 0.;</span>

<span class="nc bnc" id="L421" title="All 2 branches missed.">		for (int periodIndex = 0; periodIndex &lt; periodCount; ++periodIndex)</span>
		{
<span class="nc" id="L423">			bilateralFundingDebtAdjustment += periodBilateralFundingDebtAdjustment[periodIndex];</span>
		}

<span class="nc" id="L426">		return bilateralFundingDebtAdjustment;</span>
	}

	/**
	 * Compute Vertex Path Collateralized Exposure
	 * 
	 * @return The Vertex Path Collateralized Exposure
	 */

	public double[] vertexCollateralizedExposure()
	{
<span class="fc" id="L437">		org.drip.exposure.universe.MarketVertex[] marketVertexArray = _marketPath.marketVertexArray();</span>

<span class="fc" id="L439">		int vertexCount = marketVertexArray.length;</span>
<span class="fc" id="L440">		int creditDebtGroupCount = _creditDebtGroupPathArray.length;</span>
<span class="fc" id="L441">		double[] vertexCollateralizedExposure = new double[vertexCount];</span>

<span class="fc bfc" id="L443" title="All 2 branches covered.">		for (int vertexIndex = 0; vertexIndex &lt; vertexCount; ++vertexIndex)</span>
		{
<span class="fc" id="L445">			vertexCollateralizedExposure[vertexIndex] = 0.;</span>
		}

<span class="fc bfc" id="L448" title="All 2 branches covered.">		for (int creditDebtGroupIndex = 0; creditDebtGroupIndex &lt; creditDebtGroupCount;</span>
<span class="fc" id="L449">			++creditDebtGroupIndex)</span>
		{
<span class="fc" id="L451">			double[] creditDebtGroupVertexCollateralizedExposure =</span>
<span class="fc" id="L452">				_creditDebtGroupPathArray[creditDebtGroupIndex].vertexCollateralizedExposure();</span>

<span class="fc bfc" id="L454" title="All 2 branches covered.">			for (int vertexIndex = 0; vertexIndex &lt; vertexCount; ++vertexIndex)</span>
			{
<span class="fc" id="L456">				vertexCollateralizedExposure[vertexIndex] +=</span>
					creditDebtGroupVertexCollateralizedExposure[vertexIndex];
			}
		}

<span class="fc" id="L461">		return vertexCollateralizedExposure;</span>
	}

	/**
	 * Compute Vertex Path Collateralized Exposure PV
	 * 
	 * @return The Vertex Path Collateralized Exposure PV
	 */

	public double[] vertexCollateralizedExposurePV()
	{
<span class="fc" id="L472">		org.drip.exposure.universe.MarketVertex[] marketVertexArray = _marketPath.marketVertexArray();</span>

<span class="fc" id="L474">		int vertexCount = marketVertexArray.length;</span>
<span class="fc" id="L475">		int creditDebtGroupCount = _creditDebtGroupPathArray.length;</span>
<span class="fc" id="L476">		double[] vertexCollateralizedExposurePV = new double[vertexCount];</span>

<span class="fc bfc" id="L478" title="All 2 branches covered.">		for (int vertexIndex = 0; vertexIndex &lt; vertexCount; ++vertexIndex)</span>
		{
<span class="fc" id="L480">			vertexCollateralizedExposurePV[vertexIndex] = 0.;</span>
		}

<span class="fc bfc" id="L483" title="All 2 branches covered.">		for (int creditDebtGroupIndex = 0; creditDebtGroupIndex &lt; creditDebtGroupCount;</span>
<span class="fc" id="L484">			++creditDebtGroupIndex)</span>
		{
<span class="fc" id="L486">			double[] creditDebtGroupVertexCollateralizedExposurePV =</span>
<span class="fc" id="L487">				_creditDebtGroupPathArray[creditDebtGroupIndex].vertexCollateralizedExposurePV();</span>

<span class="fc bfc" id="L489" title="All 2 branches covered.">			for (int vertexIndex = 0; vertexIndex &lt; vertexCount; ++vertexIndex)</span>
			{
<span class="fc" id="L491">				vertexCollateralizedExposurePV[vertexIndex] +=</span>
					creditDebtGroupVertexCollateralizedExposurePV[vertexIndex];
			}
		}

<span class="fc" id="L496">		return vertexCollateralizedExposurePV;</span>
	}

	/**
	 * Compute Vertex Path Collateralized Positive Exposure
	 * 
	 * @return The Vertex Path Collateralized Positive Exposure
	 */

	public double[] vertexCollateralizedPositiveExposure()
	{
<span class="fc" id="L507">		org.drip.exposure.universe.MarketVertex[] marketVertexArray = _marketPath.marketVertexArray();</span>

<span class="fc" id="L509">		int vertexCount = marketVertexArray.length;</span>
<span class="fc" id="L510">		int creditDebtGroupCount = _creditDebtGroupPathArray.length;</span>
<span class="fc" id="L511">		double[] vertexCollateralizedPositiveExposure = new double[vertexCount];</span>

<span class="fc bfc" id="L513" title="All 2 branches covered.">		for (int vertexIndex = 0; vertexIndex &lt; vertexCount; ++vertexIndex)</span>
		{
<span class="fc" id="L515">			vertexCollateralizedPositiveExposure[vertexIndex] = 0.;</span>
		}

<span class="fc bfc" id="L518" title="All 2 branches covered.">		for (int creditDebtGroupIndex = 0; creditDebtGroupIndex &lt; creditDebtGroupCount;</span>
<span class="fc" id="L519">			++creditDebtGroupIndex)</span>
		{
<span class="fc" id="L521">			double[] creditDebtGroupVertexCollateralizedPositiveExposure =</span>
<span class="fc" id="L522">				_creditDebtGroupPathArray[creditDebtGroupIndex].vertexCollateralizedPositiveExposure();</span>

<span class="fc bfc" id="L524" title="All 2 branches covered.">			for (int vertexIndex = 0; vertexIndex &lt; vertexCount; ++vertexIndex)</span>
			{
<span class="fc" id="L526">				vertexCollateralizedPositiveExposure[vertexIndex] +=</span>
					creditDebtGroupVertexCollateralizedPositiveExposure[vertexIndex];
			}
		}

<span class="fc" id="L531">		return vertexCollateralizedPositiveExposure;</span>
	}

	/**
	 * Compute Vertex Path Collateralized Positive Exposure PV
	 * 
	 * @return The Vertex Path Collateralized Positive Exposure PV
	 */

	public double[] vertexCollateralizedPositiveExposurePV()
	{
<span class="fc" id="L542">		org.drip.exposure.universe.MarketVertex[] marketVertexArray = _marketPath.marketVertexArray();</span>

<span class="fc" id="L544">		int vertexCount = marketVertexArray.length;</span>
<span class="fc" id="L545">		int creditDebtGroupCount = _creditDebtGroupPathArray.length;</span>
<span class="fc" id="L546">		double[] vertexCollateralizedPositiveExposurePV = new double[vertexCount];</span>

<span class="fc bfc" id="L548" title="All 2 branches covered.">		for (int vertexIndex = 0; vertexIndex &lt; vertexCount; ++vertexIndex)</span>
		{
<span class="fc" id="L550">			vertexCollateralizedPositiveExposurePV[vertexIndex] = 0.;</span>
		}

<span class="fc bfc" id="L553" title="All 2 branches covered.">		for (int creditDebtGroupIndex = 0; creditDebtGroupIndex &lt; creditDebtGroupCount;</span>
<span class="fc" id="L554">			++creditDebtGroupIndex)</span>
		{
<span class="fc" id="L556">			double[] creditDebtGroupVertexCollateralizedPositiveExposurePV =</span>
<span class="fc" id="L557">				_creditDebtGroupPathArray[creditDebtGroupIndex].vertexCollateralizedPositiveExposurePV();</span>

<span class="fc bfc" id="L559" title="All 2 branches covered.">			for (int vertexIndex = 0; vertexIndex &lt; vertexCount; ++vertexIndex)</span>
			{
<span class="fc" id="L561">				vertexCollateralizedPositiveExposurePV[vertexIndex] +=</span>
					creditDebtGroupVertexCollateralizedPositiveExposurePV[vertexIndex];
			}
		}

<span class="fc" id="L566">		return vertexCollateralizedPositiveExposurePV;</span>
	}

	/**
	 * Compute Vertex Path Collateralized Negative Exposure
	 * 
	 * @return The Vertex Path Collateralized Negative Exposure
	 */

	public double[] vertexCollateralizedNegativeExposure()
	{
<span class="fc" id="L577">		org.drip.exposure.universe.MarketVertex[] marketVertexArray = _marketPath.marketVertexArray();</span>

<span class="fc" id="L579">		int vertexCount = marketVertexArray.length;</span>
<span class="fc" id="L580">		int creditDebtGroupCount = _creditDebtGroupPathArray.length;</span>
<span class="fc" id="L581">		double[] vertexCollateralizedNegativeExposure = new double[vertexCount];</span>

<span class="fc bfc" id="L583" title="All 2 branches covered.">		for (int vertexIndex = 0; vertexIndex &lt; vertexCount; ++vertexIndex)</span>
		{
<span class="fc" id="L585">			vertexCollateralizedNegativeExposure[vertexIndex] = 0.;</span>
		}

<span class="fc bfc" id="L588" title="All 2 branches covered.">		for (int creditDebtGroupIndex = 0; creditDebtGroupIndex &lt; creditDebtGroupCount;</span>
<span class="fc" id="L589">			++creditDebtGroupIndex)</span>
		{
<span class="fc" id="L591">			double[] creditDebtGroupVertexCollateralizedNegativeExposure =</span>
<span class="fc" id="L592">				_creditDebtGroupPathArray[creditDebtGroupIndex].vertexCollateralizedNegativeExposure();</span>

<span class="fc bfc" id="L594" title="All 2 branches covered.">			for (int vertexIndex = 0; vertexIndex &lt; vertexCount; ++vertexIndex)</span>
			{
<span class="fc" id="L596">				vertexCollateralizedNegativeExposure[vertexIndex] +=</span>
					creditDebtGroupVertexCollateralizedNegativeExposure[vertexIndex];
			}
		}

<span class="fc" id="L601">		return vertexCollateralizedNegativeExposure;</span>
	}

	/**
	 * Compute Vertex Path Collateralized Negative Exposure PV
	 * 
	 * @return The Vertex Path Collateralized Negative Exposure PV
	 */

	public double[] vertexCollateralizedNegativeExposurePV()
	{
<span class="fc" id="L612">		org.drip.exposure.universe.MarketVertex[] marketVertexArray = _marketPath.marketVertexArray();</span>

<span class="fc" id="L614">		int vertexCount = marketVertexArray.length;</span>
<span class="fc" id="L615">		int creditDebtGroupCount = _creditDebtGroupPathArray.length;</span>
<span class="fc" id="L616">		double[] vertexCollateralizedNegativeExposurePV = new double[vertexCount];</span>

<span class="fc bfc" id="L618" title="All 2 branches covered.">		for (int vertexIndex = 0; vertexIndex &lt; vertexCount; ++vertexIndex)</span>
		{
<span class="fc" id="L620">			vertexCollateralizedNegativeExposurePV[vertexIndex] = 0.;</span>
		}

<span class="fc bfc" id="L623" title="All 2 branches covered.">		for (int creditDebtGroupIndex = 0; creditDebtGroupIndex &lt; creditDebtGroupCount;</span>
<span class="fc" id="L624">			++creditDebtGroupIndex)</span>
		{
<span class="fc" id="L626">			double[] creditDebtGroupVertexCollateralizedNegativeExposurePV =</span>
<span class="fc" id="L627">				_creditDebtGroupPathArray[creditDebtGroupIndex].vertexCollateralizedNegativeExposurePV();</span>

<span class="fc bfc" id="L629" title="All 2 branches covered.">			for (int vertexIndex = 0; vertexIndex &lt; vertexCount; ++vertexIndex)</span>
			{
<span class="fc" id="L631">				vertexCollateralizedNegativeExposurePV[vertexIndex] +=</span>
					creditDebtGroupVertexCollateralizedNegativeExposurePV[vertexIndex];
			}
		}

<span class="fc" id="L636">		return vertexCollateralizedNegativeExposurePV;</span>
	}

	/**
	 * Compute Vertex Path Uncollateralized Exposure
	 * 
	 * @return The Vertex Path Uncollateralized Exposure
	 */

	public double[] vertexUncollateralizedExposure()
	{
<span class="fc" id="L647">		org.drip.exposure.universe.MarketVertex[] marketVertexArray = _marketPath.marketVertexArray();</span>

<span class="fc" id="L649">		int vertexCount = marketVertexArray.length;</span>
<span class="fc" id="L650">		int creditDebtGroupCount = _creditDebtGroupPathArray.length;</span>
<span class="fc" id="L651">		double[] vertexUncollateralizedExposure = new double[vertexCount];</span>

<span class="fc bfc" id="L653" title="All 2 branches covered.">		for (int vertexIndex = 0; vertexIndex &lt; vertexCount; ++vertexIndex)</span>
		{
<span class="fc" id="L655">			vertexUncollateralizedExposure[vertexIndex] = 0.;</span>
		}

<span class="fc bfc" id="L658" title="All 2 branches covered.">		for (int creditDebtGroupIndex = 0; creditDebtGroupIndex &lt; creditDebtGroupCount;</span>
<span class="fc" id="L659">			++creditDebtGroupIndex)</span>
		{
<span class="fc" id="L661">			double[] creditDebtGroupVertexCollateralizedExposure =</span>
<span class="fc" id="L662">				_creditDebtGroupPathArray[creditDebtGroupIndex].vertexUncollateralizedExposure();</span>

<span class="fc bfc" id="L664" title="All 2 branches covered.">			for (int vertexIndex = 0; vertexIndex &lt; vertexCount; ++vertexIndex)</span>
			{
<span class="fc" id="L666">				vertexUncollateralizedExposure[vertexIndex] +=</span>
					creditDebtGroupVertexCollateralizedExposure[vertexIndex];
			}
		}

<span class="fc" id="L671">		return vertexUncollateralizedExposure;</span>
	}

	/**
	 * Compute Vertex Path Uncollateralized Exposure PV
	 * 
	 * @return The Vertex Path Uncollateralized Exposure PV
	 */

	public double[] vertexUncollateralizedExposurePV()
	{
<span class="fc" id="L682">		org.drip.exposure.universe.MarketVertex[] marketVertexArray = _marketPath.marketVertexArray();</span>

<span class="fc" id="L684">		int vertexCount = marketVertexArray.length;</span>
<span class="fc" id="L685">		int creditDebtGroupCount = _creditDebtGroupPathArray.length;</span>
<span class="fc" id="L686">		double[] vertexUncollateralizedExposurePV = new double[vertexCount];</span>

<span class="fc bfc" id="L688" title="All 2 branches covered.">		for (int vertexIndex = 0; vertexIndex &lt; vertexCount; ++vertexIndex)</span>
		{
<span class="fc" id="L690">			vertexUncollateralizedExposurePV[vertexIndex] = 0.;</span>
		}

<span class="fc bfc" id="L693" title="All 2 branches covered.">		for (int creditDebtGroupIndex = 0; creditDebtGroupIndex &lt; creditDebtGroupCount;</span>
<span class="fc" id="L694">			++creditDebtGroupIndex)</span>
		{
<span class="fc" id="L696">			double[] creditDebtGroupVertexCollateralizedExposurePV =</span>
<span class="fc" id="L697">				_creditDebtGroupPathArray[creditDebtGroupIndex].vertexUncollateralizedExposurePV();</span>

<span class="fc bfc" id="L699" title="All 2 branches covered.">			for (int vertexIndex = 0; vertexIndex &lt; vertexCount; ++vertexIndex)</span>
			{
<span class="fc" id="L701">				vertexUncollateralizedExposurePV[vertexIndex] +=</span>
					creditDebtGroupVertexCollateralizedExposurePV[vertexIndex];
			}
		}

<span class="fc" id="L706">		return vertexUncollateralizedExposurePV;</span>
	}

	/**
	 * Compute Vertex Path Uncollateralized Positive Exposure
	 * 
	 * @return The Vertex Path Uncollateralized Positive Exposure
	 */

	public double[] vertexUncollateralizedPositiveExposure()
	{
<span class="fc" id="L717">		org.drip.exposure.universe.MarketVertex[] marketVertexArray = _marketPath.marketVertexArray();</span>

<span class="fc" id="L719">		int vertexCount = marketVertexArray.length;</span>
<span class="fc" id="L720">		int creditDebtGroupCount = _creditDebtGroupPathArray.length;</span>
<span class="fc" id="L721">		double[] vertexUncollateralizedPositiveExposure = new double[vertexCount];</span>

<span class="fc bfc" id="L723" title="All 2 branches covered.">		for (int vertexIndex = 0; vertexIndex &lt; vertexCount; ++vertexIndex)</span>
		{
<span class="fc" id="L725">			vertexUncollateralizedPositiveExposure[vertexIndex] = 0.;</span>
		}

<span class="fc bfc" id="L728" title="All 2 branches covered.">		for (int creditDebtGroupIndex = 0; creditDebtGroupIndex &lt; creditDebtGroupCount;</span>
<span class="fc" id="L729">			++creditDebtGroupIndex)</span>
		{
<span class="fc" id="L731">			double[] creditDebtGroupVertexUncollateralizedPositiveExposure =</span>
<span class="fc" id="L732">				_creditDebtGroupPathArray[creditDebtGroupIndex].vertexUncollateralizedPositiveExposure();</span>

<span class="fc bfc" id="L734" title="All 2 branches covered.">			for (int vertexIndex = 0; vertexIndex &lt; vertexCount; ++vertexIndex)</span>
			{
<span class="fc" id="L736">				vertexUncollateralizedPositiveExposure[vertexIndex] +=</span>
					creditDebtGroupVertexUncollateralizedPositiveExposure[vertexIndex];
			}
		}

<span class="fc" id="L741">		return vertexUncollateralizedPositiveExposure;</span>
	}

	/**
	 * Compute Vertex Path Uncollateralized Positive Exposure PV
	 * 
	 * @return The Vertex Path Uncollateralized Positive Exposure PV
	 */

	public double[] vertexUncollateralizedPositiveExposurePV()
	{
<span class="fc" id="L752">		org.drip.exposure.universe.MarketVertex[] marketVertexArray = _marketPath.marketVertexArray();</span>

<span class="fc" id="L754">		int vertexCount = marketVertexArray.length;</span>
<span class="fc" id="L755">		int creditDebtGroupCount = _creditDebtGroupPathArray.length;</span>
<span class="fc" id="L756">		double[] vertexUncollateralizedPositiveExposurePV = new double[vertexCount];</span>

<span class="fc bfc" id="L758" title="All 2 branches covered.">		for (int vertexIndex = 0; vertexIndex &lt; vertexCount; ++vertexIndex)</span>
		{
<span class="fc" id="L760">			vertexUncollateralizedPositiveExposurePV[vertexIndex] = 0.;</span>
		}

<span class="fc bfc" id="L763" title="All 2 branches covered.">		for (int creditDebtGroupIndex = 0; creditDebtGroupIndex &lt; creditDebtGroupCount;</span>
<span class="fc" id="L764">			++creditDebtGroupIndex)</span>
		{
<span class="fc" id="L766">			double[] creditDebtGroupVertexUncollateralizedPositiveExposurePV =</span>
<span class="fc" id="L767">				_creditDebtGroupPathArray[creditDebtGroupIndex].vertexUncollateralizedPositiveExposurePV();</span>

<span class="fc bfc" id="L769" title="All 2 branches covered.">			for (int vertexIndex = 0; vertexIndex &lt; vertexCount; ++vertexIndex)</span>
			{
<span class="fc" id="L771">				vertexUncollateralizedPositiveExposurePV[vertexIndex] +=</span>
					creditDebtGroupVertexUncollateralizedPositiveExposurePV[vertexIndex];
			}
		}

<span class="fc" id="L776">		return vertexUncollateralizedPositiveExposurePV;</span>
	}

	/**
	 * Compute Vertex Path Uncollateralized Negative Exposure
	 * 
	 * @return The Vertex Path Uncollateralized Negative Exposure
	 */

	public double[] vertexUncollateralizedNegativeExposure()
	{
<span class="fc" id="L787">		org.drip.exposure.universe.MarketVertex[] marketVertexArray = _marketPath.marketVertexArray();</span>

<span class="fc" id="L789">		int vertexCount = marketVertexArray.length;</span>
<span class="fc" id="L790">		int creditDebtGroupCount = _creditDebtGroupPathArray.length;</span>
<span class="fc" id="L791">		double[] vertexUncollateralizedNegativeExposure = new double[vertexCount];</span>

<span class="fc bfc" id="L793" title="All 2 branches covered.">		for (int vertexIndex = 0; vertexIndex &lt; vertexCount; ++vertexIndex)</span>
		{
<span class="fc" id="L795">			vertexUncollateralizedNegativeExposure[vertexIndex] = 0.;</span>
		}

<span class="fc bfc" id="L798" title="All 2 branches covered.">		for (int creditDebtGroupIndex = 0; creditDebtGroupIndex &lt; creditDebtGroupCount;</span>
<span class="fc" id="L799">			++creditDebtGroupIndex)</span>
		{
<span class="fc" id="L801">			double[] creditDebtGroupVertexUncollateralizedNegativeExposure =</span>
<span class="fc" id="L802">				_creditDebtGroupPathArray[creditDebtGroupIndex].vertexUncollateralizedNegativeExposure();</span>

<span class="fc bfc" id="L804" title="All 2 branches covered.">			for (int vertexIndex = 0; vertexIndex &lt; vertexCount; ++vertexIndex)</span>
			{
<span class="fc" id="L806">				vertexUncollateralizedNegativeExposure[vertexIndex] +=</span>
					creditDebtGroupVertexUncollateralizedNegativeExposure[vertexIndex];
			}
		}

<span class="fc" id="L811">		return vertexUncollateralizedNegativeExposure;</span>
	}

	/**
	 * Compute Vertex Path Uncollateralized Negative Exposure PV
	 * 
	 * @return The Vertex Path Uncollateralized Negative Exposure PV
	 */

	public double[] vertexUncollateralizedNegativeExposurePV()
	{
<span class="fc" id="L822">		org.drip.exposure.universe.MarketVertex[] marketVertexArray = _marketPath.marketVertexArray();</span>

<span class="fc" id="L824">		int vertexCount = marketVertexArray.length;</span>
<span class="fc" id="L825">		int creditDebtGroupCount = _creditDebtGroupPathArray.length;</span>
<span class="fc" id="L826">		double[] vertexUncollateralizedNegativeExposurePV = new double[vertexCount];</span>

<span class="fc bfc" id="L828" title="All 2 branches covered.">		for (int vertexIndex = 0; vertexIndex &lt; vertexCount; ++vertexIndex)</span>
		{
<span class="fc" id="L830">			vertexUncollateralizedNegativeExposurePV[vertexIndex] = 0.;</span>
		}

<span class="fc bfc" id="L833" title="All 2 branches covered.">		for (int creditDebtGroupIndex = 0; creditDebtGroupIndex &lt; creditDebtGroupCount;</span>
<span class="fc" id="L834">			++creditDebtGroupIndex)</span>
		{
<span class="fc" id="L836">			double[] creditDebtGroupVertexUncollateralizedNegativeExposurePV =</span>
<span class="fc" id="L837">				_creditDebtGroupPathArray[creditDebtGroupIndex].vertexUncollateralizedNegativeExposurePV();</span>

<span class="fc bfc" id="L839" title="All 2 branches covered.">			for (int vertexIndex = 0; vertexIndex &lt; vertexCount; ++vertexIndex)</span>
			{
<span class="fc" id="L841">				vertexUncollateralizedNegativeExposurePV[vertexIndex] +=</span>
					creditDebtGroupVertexUncollateralizedNegativeExposurePV[vertexIndex];
			}
		}

<span class="fc" id="L846">		return vertexUncollateralizedNegativeExposurePV;</span>
	}

	/**
	 * Compute Vertex Path Funding Exposure
	 * 
	 * @return The Vertex Path Funding Exposure
	 */

	public double[] vertexFundingExposure()
	{
<span class="fc" id="L857">		org.drip.exposure.universe.MarketVertex[] marketVertexArray = _marketPath.marketVertexArray();</span>

<span class="fc" id="L859">		int vertexCount = marketVertexArray.length;</span>
<span class="fc" id="L860">		double[] vertexFundingExposure = new double[vertexCount];</span>
<span class="fc" id="L861">		int creditDebtGroupCount = _creditDebtGroupPathArray.length;</span>

<span class="fc bfc" id="L863" title="All 2 branches covered.">		for (int vertexIndex = 0; vertexIndex &lt; vertexCount; ++vertexIndex)</span>
		{
<span class="fc" id="L865">			vertexFundingExposure[vertexIndex] = 0.;</span>
		}

<span class="fc bfc" id="L868" title="All 2 branches covered.">		for (int creditDebtGroupIndex = 0; creditDebtGroupIndex &lt; creditDebtGroupCount;</span>
<span class="fc" id="L869">			++creditDebtGroupIndex)</span>
		{
<span class="fc" id="L871">			double[] creditDebtGroupVertexFundingExposure =</span>
<span class="fc" id="L872">				_creditDebtGroupPathArray[creditDebtGroupIndex].vertexFundingExposure();</span>

<span class="fc bfc" id="L874" title="All 2 branches covered.">			for (int vertexIndex = 0; vertexIndex &lt; vertexCount; ++vertexIndex)</span>
			{
<span class="fc" id="L876">				vertexFundingExposure[vertexIndex] += creditDebtGroupVertexFundingExposure[vertexIndex];</span>
			}
		}

<span class="fc bfc" id="L880" title="All 2 branches covered.">		for (int vertexIndex = 0; vertexIndex &lt; vertexCount; ++vertexIndex)</span>
		{
<span class="fc bfc" id="L882" title="All 2 branches covered.">			if (0. &gt; vertexFundingExposure[vertexIndex])</span>
			{
<span class="fc" id="L884">				vertexFundingExposure[vertexIndex] = 0.;</span>
			}
		}

<span class="fc" id="L888">		return vertexFundingExposure;</span>
	}

	/**
	 * Compute Vertex Path Funding Exposure PV
	 * 
	 * @return The Vertex Path Funding Exposure PV
	 */

	public double[] vertexFundingExposurePV()
	{
<span class="fc" id="L899">		org.drip.exposure.universe.MarketVertex[] marketVertexArray = _marketPath.marketVertexArray();</span>

<span class="fc" id="L901">		int vertexCount = marketVertexArray.length;</span>
<span class="fc" id="L902">		double[] vertexFundingExposurePV = new double[vertexCount];</span>
<span class="fc" id="L903">		int creditDebtGroupCount = _creditDebtGroupPathArray.length;</span>

<span class="fc bfc" id="L905" title="All 2 branches covered.">		for (int vertexIndex = 0; vertexIndex &lt; vertexCount; ++vertexIndex)</span>
		{
<span class="fc" id="L907">			vertexFundingExposurePV[vertexIndex] = 0.;</span>
		}

<span class="fc bfc" id="L910" title="All 2 branches covered.">		for (int creditDebtGroupIndex = 0; creditDebtGroupIndex &lt; creditDebtGroupCount;</span>
<span class="fc" id="L911">			++creditDebtGroupIndex)</span>
		{
<span class="fc" id="L913">			double[] creditDebtGroupVertexFundingExposurePV =</span>
<span class="fc" id="L914">				_creditDebtGroupPathArray[creditDebtGroupIndex].vertexFundingExposurePV();</span>

<span class="fc bfc" id="L916" title="All 2 branches covered.">			for (int vertexIndex = 0; vertexIndex &lt; vertexCount; ++vertexIndex)</span>
			{
<span class="fc" id="L918">				vertexFundingExposurePV[vertexIndex] += creditDebtGroupVertexFundingExposurePV[vertexIndex];</span>
			}
		}

<span class="fc bfc" id="L922" title="All 2 branches covered.">		for (int vertexIndex = 0; vertexIndex &lt; vertexCount; ++vertexIndex)</span>
		{
<span class="fc bfc" id="L924" title="All 2 branches covered.">			if (0. &gt; vertexFundingExposurePV[vertexIndex])</span>
			{
<span class="fc" id="L926">				vertexFundingExposurePV[vertexIndex] = 0.;</span>
			}
		}

<span class="fc" id="L930">		return vertexFundingExposurePV;</span>
	}

	/**
	 * Compute Period-wise Path Symmetric Funding Value Adjustment
	 * 
	 * @return The Period-wise Path Symmetric Funding Value Adjustment
	 */

	public double[] periodSymmetricFundingValueAdjustment()
	{
<span class="fc" id="L941">		org.drip.exposure.universe.MarketVertex[] marketVertexArray = _marketPath.marketVertexArray();</span>

<span class="fc" id="L943">		double[] periodSymmetricFundingValueSpread01 = periodSymmetricFundingValueSpread01();</span>

<span class="fc" id="L945">		int periodCount = periodSymmetricFundingValueSpread01.length;</span>
<span class="fc" id="L946">		double[] periodSymmetricFundingValueAdjustment = new double[periodCount];</span>

<span class="fc bfc" id="L948" title="All 2 branches covered.">		for (int periodIndex = 0; periodIndex &lt; periodCount; ++periodIndex)</span>
		{
<span class="fc" id="L950">			periodSymmetricFundingValueAdjustment[periodIndex] =</span>
				0.5 * periodSymmetricFundingValueSpread01[periodIndex] * (
<span class="fc" id="L952">					marketVertexArray[periodIndex].dealer().seniorFundingSpread() +</span>
<span class="fc" id="L953">					marketVertexArray[periodIndex + 1].dealer().seniorFundingSpread()</span>
				);
		}

<span class="fc" id="L957">		return periodSymmetricFundingValueAdjustment;</span>
	}

	/**
	 * Compute Period-wise Unilateral Path Funding Value Adjustment
	 * 
	 * @return The Period-wise Unilateral Path Funding Value Adjustment
	 */

	public double[] periodUnilateralFundingValueAdjustment()
	{
<span class="fc" id="L968">		double[] periodUnilateralFundingValueSpread01 = periodUnilateralFundingValueSpread01();</span>

<span class="fc" id="L970">		int periodCount = periodUnilateralFundingValueSpread01.length;</span>
<span class="fc" id="L971">		double[] periodUnilateralFundingValueAdjustment = new double[periodCount];</span>

<span class="fc" id="L973">		org.drip.exposure.universe.MarketVertex[] marketVertexArray = _marketPath.marketVertexArray();</span>

<span class="fc bfc" id="L975" title="All 2 branches covered.">		for (int periodIndex = 0; periodIndex &lt; periodCount; ++periodIndex)</span>
		{
<span class="fc" id="L977">			periodUnilateralFundingValueAdjustment[periodIndex] =</span>
				0.5 * periodUnilateralFundingValueSpread01[periodIndex] * (
<span class="fc" id="L979">					marketVertexArray[periodIndex].dealer().seniorFundingSpread() +</span>
<span class="fc" id="L980">					marketVertexArray[periodIndex + 1].dealer().seniorFundingSpread()</span>
				);
		}

<span class="fc" id="L984">		return periodUnilateralFundingValueAdjustment;</span>
	}

	/**
	 * Compute Period-wise Bilateral Path Funding Value Adjustment
	 * 
	 * @return The Period-wise Bilateral Path Funding Value Adjustment
	 */

	public double[] periodBilateralFundingValueAdjustment()
	{
<span class="fc" id="L995">		double[] periodBilateralFundingValueSpread01 = periodBilateralFundingValueSpread01();</span>

<span class="fc" id="L997">		int periodCount = periodBilateralFundingValueSpread01.length;</span>
<span class="fc" id="L998">		double[] periodBilateralFundingValueAdjustment = new double[periodCount];</span>

<span class="fc" id="L1000">		org.drip.exposure.universe.MarketVertex[] marketVertexArray = _marketPath.marketVertexArray();</span>

<span class="fc bfc" id="L1002" title="All 2 branches covered.">		for (int periodIndex = 0; periodIndex &lt; periodCount; ++periodIndex)</span>
		{
<span class="fc" id="L1004">			periodBilateralFundingValueAdjustment[periodIndex] =</span>
				0.5 * periodBilateralFundingValueSpread01[periodIndex] * (
<span class="fc" id="L1006">					marketVertexArray[periodIndex].dealer().seniorFundingSpread() +</span>
<span class="fc" id="L1007">					marketVertexArray[periodIndex + 1].dealer().seniorFundingSpread()</span>
				);
		}

<span class="fc" id="L1011">		return periodBilateralFundingValueAdjustment;</span>
	}

	/**
	 * Compute Period-wise Path Unilateral Funding Debt Adjustment
	 * 
	 * @return The Period-wise Path Unilateral Funding Debt Adjustment
	 */

	public double[] periodUnilateralFundingDebtAdjustment()
	{
<span class="fc" id="L1022">		org.drip.exposure.universe.MarketVertex[] marketVertexArray = _marketPath.marketVertexArray();</span>

<span class="fc" id="L1024">		int periodCount = marketVertexArray.length - 1;</span>
<span class="fc" id="L1025">		int creditDebtGroupCount = _creditDebtGroupPathArray.length;</span>
<span class="fc" id="L1026">		double[] periodUnilateralFundingDebtAdjustment = new double[periodCount];</span>

<span class="fc bfc" id="L1028" title="All 2 branches covered.">		for (int periodIndex = 0; periodIndex &lt; periodCount; ++periodIndex)</span>
		{
<span class="fc" id="L1030">			periodUnilateralFundingDebtAdjustment[periodIndex] = 0.;</span>
		}

<span class="fc bfc" id="L1033" title="All 2 branches covered.">		for (int creditDebtGroupIndex = 0; creditDebtGroupIndex &lt; creditDebtGroupCount;</span>
<span class="fc" id="L1034">			++creditDebtGroupIndex)</span>
		{
<span class="fc" id="L1036">			double[] periodUnilateralFundingDebtAdjustmentCreditDebtGroup =</span>
<span class="fc" id="L1037">				_creditDebtGroupPathArray[creditDebtGroupIndex].periodUnilateralFundingDebtAdjustment();</span>

<span class="fc bfc" id="L1039" title="All 2 branches covered.">			for (int periodIndex = 0; periodIndex &lt; periodCount; ++periodIndex)</span>
			{
<span class="fc" id="L1041">				periodUnilateralFundingDebtAdjustment[periodIndex] +=</span>
					periodUnilateralFundingDebtAdjustmentCreditDebtGroup[periodIndex];
			}
		}

<span class="fc" id="L1046">		return periodUnilateralFundingDebtAdjustment;</span>
	}

	/**
	 * Compute Period-wise Path Bilateral Funding Debt Adjustment
	 * 
	 * @return The Period-wise Path Bilateral Funding Debt Adjustment
	 */

	public double[] periodBilateralFundingDebtAdjustment()
	{
<span class="fc" id="L1057">		org.drip.exposure.universe.MarketVertex[] marketVertexArray = _marketPath.marketVertexArray();</span>

<span class="fc" id="L1059">		int periodCount = marketVertexArray.length - 1;</span>
<span class="fc" id="L1060">		int creditDebtGroupCount = _creditDebtGroupPathArray.length;</span>
<span class="fc" id="L1061">		double[] periodBilateralFundingDebtAdjustment = new double[periodCount];</span>

<span class="fc bfc" id="L1063" title="All 2 branches covered.">		for (int periodIndex = 0; periodIndex &lt; periodCount; ++periodIndex)</span>
		{
<span class="fc" id="L1065">			periodBilateralFundingDebtAdjustment[periodIndex] = 0.;</span>
		}

<span class="fc bfc" id="L1068" title="All 2 branches covered.">		for (int creditDebtGroupIndex = 0; creditDebtGroupIndex &lt; creditDebtGroupCount;</span>
<span class="fc" id="L1069">			++creditDebtGroupIndex)</span>
		{
<span class="fc" id="L1071">			double[] periodBilateralFundingDebtAdjustmentCreditDebtGroup =</span>
<span class="fc" id="L1072">				_creditDebtGroupPathArray[creditDebtGroupIndex].periodBilateralFundingDebtAdjustment();</span>

<span class="fc bfc" id="L1074" title="All 2 branches covered.">			for (int periodIndex = 0; periodIndex &lt; periodCount; ++periodIndex)</span>
			{
<span class="fc" id="L1076">				periodBilateralFundingDebtAdjustment[periodIndex] +=</span>
					periodBilateralFundingDebtAdjustmentCreditDebtGroup[periodIndex];
			}
		}

<span class="fc" id="L1081">		return periodBilateralFundingDebtAdjustment;</span>
	}

	/**
	 * Compute Path Unilateral Credit Value Adjustment
	 * 
	 * @return The Path Unilateral Credit Value Adjustment
	 */

	public double unilateralCreditAdjustment()
	{
<span class="fc" id="L1092">		double unilateralCreditAdjustment = 0.;</span>
<span class="fc" id="L1093">		int creditDebtGroupCount = _creditDebtGroupPathArray.length;</span>

<span class="fc bfc" id="L1095" title="All 2 branches covered.">		for (int creditDebtGroupIndex = 0; creditDebtGroupIndex &lt; creditDebtGroupCount;</span>
<span class="fc" id="L1096">			++creditDebtGroupIndex)</span>
		{
<span class="fc" id="L1098">			unilateralCreditAdjustment +=</span>
<span class="fc" id="L1099">				_creditDebtGroupPathArray[creditDebtGroupIndex].unilateralCreditAdjustment();</span>
		}

<span class="fc" id="L1102">		return unilateralCreditAdjustment;</span>
	}

	/**
	 * Compute Path Bilateral Credit Value Adjustment
	 * 
	 * @return The Path Bilateral Credit Value Adjustment
	 */

	public double bilateralCreditAdjustment()
	{
<span class="fc" id="L1113">		double bilateralCreditAdjustment = 0.;</span>
<span class="fc" id="L1114">		int creditDebtGroupCount = _creditDebtGroupPathArray.length;</span>

<span class="fc bfc" id="L1116" title="All 2 branches covered.">		for (int creditDebtGroupIndex = 0; creditDebtGroupIndex &lt; creditDebtGroupCount;</span>
<span class="fc" id="L1117">			++creditDebtGroupIndex)</span>
		{
<span class="fc" id="L1119">			bilateralCreditAdjustment +=</span>
<span class="fc" id="L1120">				_creditDebtGroupPathArray[creditDebtGroupIndex].bilateralCreditAdjustment();</span>
		}

<span class="fc" id="L1123">		return bilateralCreditAdjustment;</span>
	}

	/**
	 * Compute Path Contra-Liability Credit Adjustment
	 * 
	 * @return The Path Contra-Liability Credit Adjustment
	 */

	public double contraLiabilityCreditAdjustment()
	{
<span class="fc" id="L1134">		double contraLiabilityCreditAdjustment = 0.;</span>
<span class="fc" id="L1135">		int creditDebtGroupCount = _creditDebtGroupPathArray.length;</span>

<span class="fc bfc" id="L1137" title="All 2 branches covered.">		for (int creditDebtGroupIndex = 0; creditDebtGroupIndex &lt; creditDebtGroupCount;</span>
<span class="fc" id="L1138">			++creditDebtGroupIndex)</span>
		{
<span class="fc" id="L1140">			contraLiabilityCreditAdjustment +=</span>
<span class="fc" id="L1141">				_creditDebtGroupPathArray[creditDebtGroupIndex].contraLiabilityCreditAdjustment();</span>
		}

<span class="fc" id="L1144">		return contraLiabilityCreditAdjustment;</span>
	}

	/**
	 * Compute Path Unilateral Debt Value Adjustment
	 * 
	 * @return The Path Unilateral Debt Value Adjustment
	 */

	public double unilateralDebtAdjustment()
	{
<span class="fc" id="L1155">		double unilateralDebtAdjustment = 0.;</span>
<span class="fc" id="L1156">		int creditDebtGroupCount = _creditDebtGroupPathArray.length;</span>

<span class="fc bfc" id="L1158" title="All 2 branches covered.">		for (int creditDebtGroupIndex = 0; creditDebtGroupIndex &lt; creditDebtGroupCount;</span>
<span class="fc" id="L1159">			++creditDebtGroupIndex)</span>
		{
<span class="fc" id="L1161">			unilateralDebtAdjustment +=</span>
<span class="fc" id="L1162">				_creditDebtGroupPathArray[creditDebtGroupIndex].unilateralDebtAdjustment();</span>
		}

<span class="fc" id="L1165">		return unilateralDebtAdjustment;</span>
	}

	/**
	 * Compute Path Bilateral Debt Value Adjustment
	 * 
	 * @return The Path Bilateral Credit Value Adjustment
	 */

	public double bilateralDebtAdjustment()
	{
<span class="nc" id="L1176">		double bilateralDebtAdjustment = 0.;</span>
<span class="nc" id="L1177">		int creditDebtGroupCount = _creditDebtGroupPathArray.length;</span>

<span class="nc bnc" id="L1179" title="All 2 branches missed.">		for (int creditDebtGroupIndex = 0; creditDebtGroupIndex &lt; creditDebtGroupCount;</span>
<span class="nc" id="L1180">			++creditDebtGroupIndex)</span>
		{
<span class="nc" id="L1182">			bilateralDebtAdjustment +=</span>
<span class="nc" id="L1183">				_creditDebtGroupPathArray[creditDebtGroupIndex].bilateralDebtAdjustment();</span>
		}

<span class="nc" id="L1186">		return bilateralDebtAdjustment;</span>
	}

	/**
	 * Compute Path Contra-Asset Debt Adjustment
	 * 
	 * @return The Path Contra-Asset Debt Adjustment
	 */

	public double contraAssetDebtAdjustment()
	{
<span class="nc" id="L1197">		double contraAssetDebtAdjustment = 0.;</span>
<span class="nc" id="L1198">		int creditDebtGroupCount = _creditDebtGroupPathArray.length;</span>

<span class="nc bnc" id="L1200" title="All 2 branches missed.">		for (int creditDebtGroupIndex = 0; creditDebtGroupIndex &lt; creditDebtGroupCount;</span>
<span class="nc" id="L1201">			++creditDebtGroupIndex)</span>
		{
<span class="nc" id="L1203">			contraAssetDebtAdjustment +=</span>
<span class="nc" id="L1204">				_creditDebtGroupPathArray[creditDebtGroupIndex].contraAssetDebtAdjustment();</span>
		}

<span class="nc" id="L1207">		return contraAssetDebtAdjustment;</span>
	}

	/**
	 * Compute Path Unilateral Collateral Value Adjustment
	 * 
	 * @return The Path Unilateral Collateral Value Adjustment
	 */

	public double unilateralCollateralAdjustment()
	{
<span class="nc" id="L1218">		double unilateralCollateralAdjustment = 0.;</span>
<span class="nc" id="L1219">		int creditDebtGroupCount = _creditDebtGroupPathArray.length;</span>

<span class="nc bnc" id="L1221" title="All 2 branches missed.">		for (int creditDebtGroupIndex = 0; creditDebtGroupIndex &lt; creditDebtGroupCount;</span>
<span class="nc" id="L1222">			++creditDebtGroupIndex)</span>
		{
<span class="nc" id="L1224">			unilateralCollateralAdjustment +=</span>
<span class="nc" id="L1225">				_creditDebtGroupPathArray[creditDebtGroupIndex].unilateralCollateralAdjustment();</span>
		}

<span class="nc" id="L1228">		return unilateralCollateralAdjustment;</span>
	}

	/**
	 * Compute Path Bilateral Collateral Value Adjustment
	 * 
	 * @return The Path Bilateral Collateral Value Adjustment
	 */

	public double bilateralCollateralAdjustment()
	{
<span class="fc" id="L1239">		double bilateralCollateralAdjustment = 0.;</span>
<span class="fc" id="L1240">		int creditDebtGroupCount = _creditDebtGroupPathArray.length;</span>

<span class="fc bfc" id="L1242" title="All 2 branches covered.">		for (int creditDebtGroupIndex = 0; creditDebtGroupIndex &lt; creditDebtGroupCount;</span>
<span class="fc" id="L1243">			++creditDebtGroupIndex)</span>
		{
<span class="fc" id="L1245">			bilateralCollateralAdjustment +=</span>
<span class="fc" id="L1246">				_creditDebtGroupPathArray[creditDebtGroupIndex].bilateralCollateralAdjustment();</span>
		}

<span class="fc" id="L1249">		return bilateralCollateralAdjustment;</span>
	}

	/**
	 * Compute Path Funding Value Adjustment
	 * 
	 * @return The Path Funding Value Adjustment
	 */

	public abstract double fundingValueAdjustment();

	/**
	 * Compute Path Funding Debt Adjustment
	 * 
	 * @return The Path Funding Debt Adjustment
	 */

	public abstract double fundingDebtAdjustment();

	/**
	 * Compute Path Funding Cost Adjustment
	 * 
	 * @return The Path Funding Cost Adjustment
	 */

	public abstract double fundingCostAdjustment();

	/**
	 * Compute Path Funding Benefit Adjustment
	 * 
	 * @return The Path Funding Benefit Adjustment
	 */

	public abstract double fundingBenefitAdjustment();

	/**
	 * Compute Period-wise Path Funding Value Adjustment
	 * 
	 * @return The Period-wise Path Funding Value Adjustment
	 */

	public abstract double[] periodFundingValueAdjustment();

	/**
	 * Compute Period-wise Path Funding Debt Adjustment
	 * 
	 * @return The Period-wise Path Funding Debt Adjustment
	 */

	public abstract double[] periodFundingDebtAdjustment();

	/**
	 * Compute Period-wise Path Funding Cost Adjustment
	 * 
	 * @return The Period-wise Path Funding Cost Adjustment
	 */

	public abstract double[] periodFundingCostAdjustment();

	/**
	 * Compute Period-wise Path Funding Benefit Adjustment
	 * 
	 * @return The Period-wise Path Funding Benefit Adjustment
	 */

	public abstract double[] periodFundingBenefitAdjustment();
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.7.9.201702052155</span></div></body></html>