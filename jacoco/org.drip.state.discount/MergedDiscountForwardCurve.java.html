<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>MergedDiscountForwardCurve.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">DROP</a> &gt; <a href="index.source.html" class="el_package">org.drip.state.discount</a> &gt; <span class="el_source">MergedDiscountForwardCurve.java</span></div><h1>MergedDiscountForwardCurve.java</h1><pre class="source lang-java linenums">
package org.drip.state.discount;

/*
 * -*- mode: java; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*-
 */

/*!
 * Copyright (C) 2020 Lakshmi Krishnamurthy
 * Copyright (C) 2019 Lakshmi Krishnamurthy
 * Copyright (C) 2018 Lakshmi Krishnamurthy
 * Copyright (C) 2017 Lakshmi Krishnamurthy
 * Copyright (C) 2016 Lakshmi Krishnamurthy
 * Copyright (C) 2015 Lakshmi Krishnamurthy
 * Copyright (C) 2014 Lakshmi Krishnamurthy
 * Copyright (C) 2013 Lakshmi Krishnamurthy
 * 
 *  This file is part of DROP, an open-source library targeting analytics/risk, transaction cost analytics,
 *  	asset liability management analytics, capital, exposure, and margin analytics, valuation adjustment
 *  	analytics, and portfolio construction analytics within and across fixed income, credit, commodity,
 *  	equity, FX, and structured products. It also includes auxiliary libraries for algorithm support,
 *  	numerical analysis, numerical optimization, spline builder, model validation, statistical learning,
 *  	and computational support.
 *  
 *  	https://lakshmidrip.github.io/DROP/
 *  
 *  DROP is composed of three modules:
 *  
 *  - DROP Product Core - https://lakshmidrip.github.io/DROP-Product-Core/
 *  - DROP Portfolio Core - https://lakshmidrip.github.io/DROP-Portfolio-Core/
 *  - DROP Computational Core - https://lakshmidrip.github.io/DROP-Computational-Core/
 * 
 * 	DROP Product Core implements libraries for the following:
 * 	- Fixed Income Analytics
 * 	- Loan Analytics
 * 	- Transaction Cost Analytics
 * 
 * 	DROP Portfolio Core implements libraries for the following:
 * 	- Asset Allocation Analytics
 *  - Asset Liability Management Analytics
 * 	- Capital Estimation Analytics
 * 	- Exposure Analytics
 * 	- Margin Analytics
 * 	- XVA Analytics
 * 
 * 	DROP Computational Core implements libraries for the following:
 * 	- Algorithm Support
 * 	- Computation Support
 * 	- Function Analysis
 *  - Model Validation
 * 	- Numerical Analysis
 * 	- Numerical Optimizer
 * 	- Spline Builder
 *  - Statistical Learning
 * 
 * 	Documentation for DROP is Spread Over:
 * 
 * 	- Main                     =&gt; https://lakshmidrip.github.io/DROP/
 * 	- Wiki                     =&gt; https://github.com/lakshmiDRIP/DROP/wiki
 * 	- GitHub                   =&gt; https://github.com/lakshmiDRIP/DROP
 * 	- Repo Layout Taxonomy     =&gt; https://github.com/lakshmiDRIP/DROP/blob/master/Taxonomy.md
 * 	- Javadoc                  =&gt; https://lakshmidrip.github.io/DROP/Javadoc/index.html
 * 	- Technical Specifications =&gt; https://github.com/lakshmiDRIP/DROP/tree/master/Docs/Internal
 * 	- Release Versions         =&gt; https://lakshmidrip.github.io/DROP/version.html
 * 	- Community Credits        =&gt; https://lakshmidrip.github.io/DROP/credits.html
 * 	- Issues Catalog           =&gt; https://github.com/lakshmiDRIP/DROP/issues
 * 	- JUnit                    =&gt; https://lakshmidrip.github.io/DROP/junit/index.html
 * 	- Jacoco                   =&gt; https://lakshmidrip.github.io/DROP/jacoco/index.html
 * 
 *  Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 *   	you may not use this file except in compliance with the License.
 *   
 *  You may obtain a copy of the License at
 *  	http://www.apache.org/licenses/LICENSE-2.0
 *  
 *  Unless required by applicable law or agreed to in writing, software
 *  	distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 *  	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  
 *  See the License for the specific language governing permissions and
 *  	limitations under the License.
 */

/**
 * &lt;i&gt;MergedDiscountForwardCurve&lt;/i&gt; is the Stub for the Merged Discount and Forward Curve Functionality. It
 * extends the both the Curve and the DiscountFactorEstimator instances by implementing their functions, and
 * exposing the following:
 *
 *  &lt;br&gt;&lt;br&gt;
 *  &lt;ul&gt;
 *  	&lt;li&gt;
 * 			Forward Rate to a specific date/tenor, and effective rate between a date interval
 *  	&lt;/li&gt;
 *  	&lt;li&gt;
 * 			Discount Factor to a specific date/tenor, and effective discount factor between a date interval
 *  	&lt;/li&gt;
 *  	&lt;li&gt;
 * 			Zero Rate to a specific date/tenor
 *  	&lt;/li&gt;
 *  	&lt;li&gt;
 *  		Value Jacobian for Forward rate, discount factor, and zero rate
 *  	&lt;/li&gt;
 *  	&lt;li&gt;
 *  		Cross Jacobian between each of Forward rate, discount factor, and zero rate
 *  	&lt;/li&gt;
 *  	&lt;li&gt;
 *  		Quote Jacobian to Forward rate, discount factor, and zero rate
 *  	&lt;/li&gt;
 *  	&lt;li&gt;
 *  		QM (DF/Zero/Forward) to Quote Jacobian
 *  	&lt;/li&gt;
 *  	&lt;li&gt;
 *  		Latent State Quantification Metric, and the canonical truthness transformations
 *  	&lt;/li&gt;
 *  	&lt;li&gt;
 *  		Implied/embedded ForwardRateEstimator
 *  	&lt;/li&gt;
 *  	&lt;li&gt;
 *  		Turns set/unset/adjust
 *  	&lt;/li&gt;
 *  &lt;/ul&gt;
 *
 *  &lt;br&gt;&lt;br&gt;
 *  &lt;ul&gt;
 *		&lt;li&gt;&lt;b&gt;Module &lt;/b&gt; = &lt;a href = &quot;https://github.com/lakshmiDRIP/DROP/tree/master/ProductCore.md&quot;&gt;Product Core Module&lt;/a&gt;&lt;/li&gt;
 *		&lt;li&gt;&lt;b&gt;Library&lt;/b&gt; = &lt;a href = &quot;https://github.com/lakshmiDRIP/DROP/tree/master/FixedIncomeAnalyticsLibrary.md&quot;&gt;Fixed Income Analytics&lt;/a&gt;&lt;/li&gt;
 *		&lt;li&gt;&lt;b&gt;Project&lt;/b&gt; = &lt;a href = &quot;https://github.com/lakshmiDRIP/DROP/tree/master/src/main/java/org/drip/state/README.md&quot;&gt;Latent State Inference and Creation Utilities&lt;/a&gt;&lt;/li&gt;
 *		&lt;li&gt;&lt;b&gt;Package&lt;/b&gt; = &lt;a href = &quot;https://github.com/lakshmiDRIP/DROP/tree/master/src/main/java/org/drip/state/discount/README.md&quot;&gt;Discount Curve Spline Latent State&lt;/a&gt;&lt;/li&gt;
 *  &lt;/ul&gt;
 * &lt;br&gt;&lt;br&gt;
 *
 * @author Lakshmi Krishnamurthy
 */

public abstract class MergedDiscountForwardCurve extends org.drip.state.discount.DiscountCurve {
	private static final int NUM_DF_QUADRATURES = 5;

<span class="fc" id="L138">	protected java.lang.String _strCurrency = &quot;&quot;;</span>
<span class="fc" id="L139">	protected int _iEpochDate = java.lang.Integer.MIN_VALUE;</span>
<span class="fc" id="L140">	protected org.drip.state.discount.TurnListDiscountFactor _tldf = null;</span>
<span class="fc" id="L141">	protected org.drip.analytics.input.CurveConstructionInputSet _ccis = null;</span>

	protected MergedDiscountForwardCurve (
		final int iEpochDate,
		final java.lang.String strCurrency,
		final org.drip.state.discount.TurnListDiscountFactor tldf)
		throws java.lang.Exception
<span class="fc" id="L148">	{</span>
<span class="pc bpc" id="L149" title="2 of 4 branches missed.">		if (null == (_strCurrency = strCurrency) || _strCurrency.isEmpty() ||</span>
<span class="pc bpc" id="L150" title="1 of 2 branches missed.">			!org.drip.numerical.common.NumberUtil.IsValid (_iEpochDate = iEpochDate))</span>
<span class="nc" id="L151">			throw new java.lang.Exception (&quot;MergedDiscountForwardCurve ctr: Invalid Inputs&quot;);</span>

<span class="fc" id="L153">		_tldf = tldf;</span>
<span class="fc" id="L154">	}</span>

	@Override public org.drip.state.identifier.LatentStateLabel label()
	{
<span class="fc" id="L158">		return org.drip.state.identifier.FundingLabel.Standard (_strCurrency);</span>
	}

	@Override public java.lang.String currency()
	{
<span class="fc" id="L163">		return _strCurrency;</span>
	}

	@Override public org.drip.analytics.date.JulianDate epoch()
	{
		try {
<span class="fc" id="L169">			return new org.drip.analytics.date.JulianDate (_iEpochDate);</span>
<span class="nc" id="L170">		} catch (java.lang.Exception e) {</span>
<span class="nc" id="L171">			e.printStackTrace();</span>
		}

<span class="nc" id="L174">		return null;</span>
	}

	/**
	 * Set the Discount Curve Turns'
	 * 
	 * @param tldf Turn List Discount Factor
	 * 
	 * @return TRUE - Valid Turn List Discount Factor Set
	 */

	public boolean setTurns (
		final org.drip.state.discount.TurnListDiscountFactor tldf)
	{
<span class="pc bpc" id="L188" title="1 of 2 branches missed.">		return null != (_tldf = tldf);</span>
	}

	/**
	 * Apply the Turns' DF Adjustment
	 * 
	 * @param iStartDate Turn Start Date
	 * @param iFinishDate Turn Finish Date
	 * 
	 * @return Turns' DF Adjustment
	 * 
	 * @throws java.lang.Exception Thrown if the Inputs are invalid
	 */

	public double turnAdjust (
		final int iStartDate,
		final int iFinishDate)
		throws java.lang.Exception
	{
<span class="fc bfc" id="L207" title="All 2 branches covered.">		return null == _tldf ? 1. : _tldf.turnAdjust (iStartDate, iFinishDate);</span>
	}

	/**
	 * Apply the Turns' DF Adjustment
	 * 
	 * @param iFinishDate Turn Finish Date
	 * 
	 * @return Turns' DF Adjustment
	 * 
	 * @throws java.lang.Exception Thrown if the Inputs are invalid
	 */

	protected double turnAdjust (
		final int iFinishDate)
		throws java.lang.Exception
	{
<span class="nc" id="L224">		return turnAdjust (epoch().julian(), iFinishDate);</span>
	}

	/**
	 * Construct the Native Forward Curve for the given Tenor from the Discount Curve
	 * 
	 * @param strTenor The Tenor
	 * 
	 * @return The Tenor-Native Forward Curve
	 */

	public org.drip.state.forward.ForwardCurve nativeForwardCurve (
		final java.lang.String strTenor)
	{
<span class="pc bpc" id="L238" title="2 of 4 branches missed.">		if (null == strTenor || strTenor.isEmpty()) return null;</span>

		try {
<span class="fc" id="L241">			org.drip.state.forward.ForwardCurve fcNative = new org.drip.state.forward.ForwardCurve</span>
<span class="fc" id="L242">				(epoch().julian(), org.drip.state.identifier.ForwardLabel.Standard (_strCurrency + &quot;-&quot; +</span>
<span class="fc" id="L243">					strTenor)) {</span>
				@Override public double forward (
					final int iDate)
					throws java.lang.Exception
				{
<span class="fc" id="L248">					return forward (new org.drip.analytics.date.JulianDate (iDate));</span>
				}

				@Override public double forward (
					final org.drip.analytics.date.JulianDate dt)
					throws java.lang.Exception
				{
<span class="pc bpc" id="L255" title="1 of 2 branches missed.">					if (null == dt)</span>
<span class="nc" id="L256">						throw new java.lang.Exception</span>
							(&quot;MergedDiscountForwardCurve::nativeForwardCurve =&gt; Invalid Input&quot;);

<span class="fc" id="L259">					return libor (dt.subtractTenor (strTenor).julian(), strTenor);</span>
				}

				@Override public double forward (
					final java.lang.String strTenor)
					throws java.lang.Exception
				{
<span class="nc bnc" id="L266" title="All 4 branches missed.">					if (null == strTenor || strTenor.isEmpty())</span>
<span class="nc" id="L267">						throw new java.lang.Exception</span>
							(&quot;MergedDiscountForwardCurve::nativeForwardCurve =&gt; Invalid Input&quot;);

<span class="nc" id="L270">					return forward (epoch().addTenor (strTenor));</span>
				}

				@Override public org.drip.numerical.differentiation.WengertJacobian jackDForwardDManifestMeasure (
					final java.lang.String strManifestMeasure,
					final int iDate)
				{
<span class="nc" id="L277">					return null;</span>
				}
			};

<span class="fc" id="L281">			return fcNative;</span>
<span class="nc" id="L282">		} catch (java.lang.Exception e) {</span>
<span class="nc" id="L283">			e.printStackTrace();</span>
		}

<span class="nc" id="L286">		return null;</span>
	}

	@Override public double df (
		final org.drip.analytics.date.JulianDate dt)
		throws java.lang.Exception
	{
<span class="pc bpc" id="L293" title="1 of 2 branches missed.">		if (null == dt) throw new java.lang.Exception (&quot;MergedDiscountForwardCurve::df got null for date&quot;);</span>

<span class="fc" id="L295">		return df (dt.julian());</span>
	}

	@Override public double df (
		final java.lang.String strTenor)
		throws java.lang.Exception
	{
<span class="pc bpc" id="L302" title="2 of 4 branches missed.">		if (null == strTenor || strTenor.isEmpty())</span>
<span class="nc" id="L303">			throw new java.lang.Exception (&quot;MergedDiscountForwardCurve::df got bad tenor&quot;);</span>

<span class="fc" id="L305">		return df (epoch().addTenor (strTenor));</span>
	}

	@Override public double effectiveDF (
		final int iDate1,
		final int iDate2)
		throws java.lang.Exception
	{
<span class="fc bfc" id="L313" title="All 2 branches covered.">		if (iDate1 == iDate2) return df (iDate1);</span>

<span class="fc" id="L315">		int iNumQuadratures = 0;</span>
<span class="fc" id="L316">		double dblEffectiveDF = 0.;</span>
<span class="fc" id="L317">		int iQuadratureWidth = (iDate2 - iDate1) / NUM_DF_QUADRATURES;</span>

<span class="fc bfc" id="L319" title="All 2 branches covered.">		if (0 == iQuadratureWidth) iQuadratureWidth = 1;</span>

<span class="fc bfc" id="L321" title="All 2 branches covered.">		for (int iDate = iDate1; iDate &lt;= iDate2; iDate += iQuadratureWidth) {</span>
<span class="fc" id="L322">			++iNumQuadratures;</span>

<span class="fc" id="L324">			dblEffectiveDF += (df (iDate) + df (iDate + iQuadratureWidth));</span>
		}

<span class="fc" id="L327">		return dblEffectiveDF / (2. * iNumQuadratures);</span>
	}

	@Override public double effectiveDF (
		final org.drip.analytics.date.JulianDate dt1,
		final org.drip.analytics.date.JulianDate dt2)
		throws java.lang.Exception
	{
<span class="pc bpc" id="L335" title="2 of 4 branches missed.">		if (null == dt1 || null == dt2)</span>
<span class="nc" id="L336">			throw new java.lang.Exception (&quot;MergedDiscountForwardCurve::effectiveDF =&gt; Got null for date&quot;);</span>

<span class="fc" id="L338">		return effectiveDF (dt1.julian(), dt2.julian());</span>
	}

	@Override public double effectiveDF (
		final java.lang.String strTenor1,
		final java.lang.String strTenor2)
		throws java.lang.Exception
	{
<span class="pc bpc" id="L346" title="4 of 8 branches missed.">		if (null == strTenor1 || strTenor1.isEmpty() || null == strTenor2 || strTenor2.isEmpty())</span>
<span class="nc" id="L347">			throw new java.lang.Exception (&quot;MergedDiscountForwardCurve::effectiveDF =&gt; Got bad tenor&quot;);</span>

<span class="fc" id="L349">		org.drip.analytics.date.JulianDate dtStart = epoch();</span>

<span class="fc" id="L351">		return effectiveDF (dtStart.addTenor (strTenor1), dtStart.addTenor (strTenor2));</span>
	}

	/**
	 * Compute the Forward Rate between two Dates
	 * 
	 * @param iDate1 First Date
	 * @param iDate2 Second Date
	 * 
	 * @return The Forward Rate
	 * 
	 * @throws java.lang.Exception Thrown if the Forward Rate cannot be calculated
	 */

	public abstract double forward (
		final int iDate1,
		final int iDate2)
		throws java.lang.Exception;

	/**
	 * Compute the Forward Rate between two Tenors
	 * 
	 * @param strTenor1 Tenor Start
	 * @param strTenor2 Tenor End
	 * 
	 * @return The Forward Rate
	 * 
	 * @throws java.lang.Exception Thrown if the Forward Rate cannot be calculated
	 */

	public double forward (
		final java.lang.String strTenor1,
		final java.lang.String strTenor2)
		throws java.lang.Exception
	{
<span class="pc bpc" id="L386" title="4 of 8 branches missed.">		if (null == strTenor1 || strTenor1.isEmpty() || null == strTenor2 || strTenor2.isEmpty())</span>
<span class="nc" id="L387">			throw new java.lang.Exception (&quot;MergedDiscountForwardCurve::forward =&gt; Invalid Date&quot;);</span>

<span class="fc" id="L389">		org.drip.analytics.date.JulianDate dtStart = epoch();</span>

<span class="fc" id="L391">		return forward (dtStart.addTenor (strTenor1).julian(), dtStart.addTenor (strTenor2).julian());</span>
	}

	/**
	 * Calculate the implied rate to the given date
	 * 
	 * @param iDate Date
	 * 
	 * @return Implied rate
	 * 
	 * @throws java.lang.Exception Thrown if the discount factor cannot be calculated
	 */

	public abstract double zero (
		final int iDate)
		throws java.lang.Exception;

	/**
	 * Calculate the implied rate to the given tenor
	 * 
	 * @param strTenor Tenor
	 * 
	 * @return Implied rate
	 * 
	 * @throws java.lang.Exception Thrown if the discount factor cannot be calculated
	 */

	public double zero (
		final java.lang.String strTenor)
		throws java.lang.Exception
	{
<span class="pc bpc" id="L422" title="2 of 4 branches missed.">		if (null == strTenor || strTenor.isEmpty())</span>
<span class="nc" id="L423">			throw new java.lang.Exception (&quot;MergedDiscountForwardCurve::zero =&gt; Invalid date&quot;);</span>

<span class="fc" id="L425">		org.drip.analytics.date.JulianDate dtStart = epoch();</span>

<span class="fc" id="L427">		return forward (dtStart.julian(), dtStart.addTenor (strTenor).julian());</span>
	}

	/**
	 * Compute the LIBOR between 2 dates given the Day Count
	 * 
	 * @param iDate1 First Date
	 * @param iDate2 Second Date
	 * @param dblDCF Day Count Fraction
	 * 
	 * @return LIBOR
	 * 
	 * @throws java.lang.Exception Thrown if the discount factor cannot be calculated
	 */

	public double libor (
		final int iDate1,
		final int iDate2,
		final double dblDCF)
		throws java.lang.Exception
	{
<span class="pc bpc" id="L448" title="3 of 6 branches missed.">		if (iDate1 == iDate2 || !org.drip.numerical.common.NumberUtil.IsValid (dblDCF) || 0. == dblDCF)</span>
<span class="nc" id="L449">			throw new java.lang.Exception (&quot;MergedDiscountForwardCurve::libor =&gt; Invalid input dates&quot;);</span>

<span class="fc" id="L451">		return ((df (iDate1) / df (iDate2)) - 1.) / dblDCF;</span>
	}

	/**
	 * Compute the LIBOR between 2 dates
	 * 
	 * @param iDate1 First Date
	 * @param iDate2 Second Date
	 * 
	 * @return LIBOR
	 * 
	 * @throws java.lang.Exception Thrown if the discount factor cannot be calculated
	 */

	public double libor (
		final int iDate1,
		final int iDate2)
		throws java.lang.Exception
	{
<span class="pc bpc" id="L470" title="1 of 2 branches missed.">		if (iDate1 == iDate2)</span>
<span class="nc" id="L471">			throw new java.lang.Exception (&quot;MergedDiscountForwardCurve::libor =&gt; Invalid input dates&quot;);</span>

<span class="fc" id="L473">		return libor (iDate1, iDate2, org.drip.analytics.daycount.Convention.YearFraction (iDate1, iDate2,</span>
			&quot;Act/360&quot;, false, null, &quot;&quot;));
	}

	/**
	 * Calculate the LIBOR to the given tenor at the specified date
	 * 
	 * @param iStartDate Start Date
	 * @param strTenor Tenor
	 * 
	 * @return LIBOR
	 * 
	 * @throws java.lang.Exception Thrown if LIBOR cannot be calculated
	 */

	public double libor (
		final int iStartDate,
		final java.lang.String strTenor)
		throws java.lang.Exception
	{
<span class="pc bpc" id="L493" title="3 of 6 branches missed.">		if (!org.drip.numerical.common.NumberUtil.IsValid (iStartDate) || null == strTenor || strTenor.isEmpty())</span>
<span class="nc" id="L494">			throw new java.lang.Exception (&quot;MergedDiscountForwardCurve::libor =&gt; Invalid Inputs&quot;);</span>

<span class="fc" id="L496">		return libor (iStartDate, new org.drip.analytics.date.JulianDate (iStartDate).addTenor</span>
<span class="fc" id="L497">			(strTenor).julian());</span>
	}

	/**
	 * Calculate the LIBOR to the given tenor at the specified Julian Date
	 * 
	 * @param dt Julian Date
	 * @param strTenor Tenor
	 * 
	 * @return LIBOR
	 * 
	 * @throws java.lang.Exception Thrown if LIBOR cannot be calculated
	 */

	public double libor (
		final org.drip.analytics.date.JulianDate dt,
		final java.lang.String strTenor)
		throws java.lang.Exception
	{
<span class="pc bpc" id="L516" title="1 of 2 branches missed.">		if (null == dt)</span>
<span class="nc" id="L517">			throw new java.lang.Exception (&quot;MergedDiscountForwardCurve::libor =&gt; Invalid Inputs&quot;);</span>

<span class="fc" id="L519">		return libor (dt.julian(), strTenor);</span>
	}

	/**
	 * Calculate the DV01 of the Par Swap that Matures at the given date
	 * 
	 * @param iDate Date
	 * 
	 * @return DV01 of the Par Swap that Matures at the given date
	 * 
	 * @throws java.lang.Exception Thrown if DV01 cannot be calculated
	 */

	public double parSwapDV01 (
		final int iDate)
		throws java.lang.Exception
	{
<span class="fc" id="L536">		java.lang.String strCurrency = currency();</span>

<span class="fc" id="L538">		org.drip.analytics.date.JulianDate dtStart = epoch().addDays (2);</span>

<span class="fc" id="L540">		org.drip.param.period.UnitCouponAccrualSetting ucasFixed = new</span>
			org.drip.param.period.UnitCouponAccrualSetting (2, &quot;Act/360&quot;, false, &quot;Act/360&quot;, false,
				strCurrency, true,
					org.drip.analytics.support.CompositePeriodBuilder.ACCRUAL_COMPOUNDING_RULE_GEOMETRIC);

<span class="fc" id="L545">		org.drip.param.period.ComposableFixedUnitSetting cfusFixed = new</span>
			org.drip.param.period.ComposableFixedUnitSetting (&quot;6M&quot;,
				org.drip.analytics.support.CompositePeriodBuilder.EDGE_DATE_SEQUENCE_REGULAR, null, 0., 0.,
					strCurrency);

<span class="fc" id="L550">		org.drip.param.period.CompositePeriodSetting cpsFixed = new</span>
			org.drip.param.period.CompositePeriodSetting (2, &quot;6M&quot;, strCurrency, null, 1., null, null, null,
				null);

<span class="fc" id="L554">		java.util.List&lt;java.lang.Integer&gt; lsFixedStreamEdgeDate =</span>
<span class="fc" id="L555">			org.drip.analytics.support.CompositePeriodBuilder.BackwardEdgeDates (dtStart, new</span>
				org.drip.analytics.date.JulianDate (iDate), &quot;6M&quot;, null,
					org.drip.analytics.support.CompositePeriodBuilder.SHORT_STUB);

<span class="fc" id="L559">		org.drip.product.rates.Stream fixedStream = new org.drip.product.rates.Stream</span>
<span class="fc" id="L560">			(org.drip.analytics.support.CompositePeriodBuilder.FixedCompositeUnit (lsFixedStreamEdgeDate,</span>
				cpsFixed, ucasFixed, cfusFixed));

<span class="fc" id="L563">		org.drip.param.market.CurveSurfaceQuoteContainer csqs =</span>
<span class="fc" id="L564">			org.drip.param.creator.MarketParamsBuilder.Create (this, null, null, null, null, null, null,</span>
				null);

<span class="fc" id="L567">		java.util.Map&lt;java.lang.String, java.lang.Double&gt; mapFixStream = fixedStream.value</span>
<span class="fc" id="L568">			(org.drip.param.valuation.ValuationParams.Spot (dtStart, 0, &quot;&quot;,</span>
				org.drip.analytics.daycount.Convention.DATE_ROLL_ACTUAL), null, csqs, null);

<span class="fc" id="L571">		return mapFixStream.get (&quot;DV01&quot;);</span>
	}

	/**
	 * Estimate the manifest measure value for the given date
	 * 
	 * @param strManifestMeasure The Manifest Measure to be Estimated
	 * @param iDate Date
	 * 
	 * @return The estimated calibrated measure value
	 * 
	 * @throws java.lang.Exception Thrown if the estimated manifest measure cannot be computed
	 */

	public double estimateManifestMeasure (
		final java.lang.String strManifestMeasure,
		final int iDate)
		throws java.lang.Exception
	{
<span class="pc bpc" id="L590" title="2 of 4 branches missed.">		if (null == strManifestMeasure || strManifestMeasure.isEmpty())</span>
<span class="nc" id="L591">			throw new java.lang.Exception</span>
				(&quot;MergedDiscountForwardCurve::estimateManifestMeasure =&gt; Invalid input&quot;);

<span class="fc" id="L594">		org.drip.product.definition.CalibratableComponent[] aCalibComp = calibComp();</span>

<span class="pc bpc" id="L596" title="1 of 2 branches missed.">		if (null == aCalibComp)</span>
<span class="nc" id="L597">			throw new java.lang.Exception</span>
				(&quot;MergedDiscountForwardCurve::estimateManifestMeasure =&gt; Calib Components not available&quot;);

<span class="fc" id="L600">		int iNumComponent = aCalibComp.length;</span>

<span class="pc bpc" id="L602" title="1 of 2 branches missed.">		if (0 == iNumComponent)</span>
<span class="nc" id="L603">			throw new java.lang.Exception</span>
				(&quot;MergedDiscountForwardCurve::estimateManifestMeasure =&gt; Calib Components not available&quot;);

<span class="fc" id="L606">		java.util.List&lt;java.lang.Integer&gt; lsDate = new java.util.ArrayList&lt;java.lang.Integer&gt;();</span>

<span class="fc" id="L608">		java.util.List&lt;java.lang.Double&gt; lsQuote = new java.util.ArrayList&lt;java.lang.Double&gt;();</span>

<span class="fc bfc" id="L610" title="All 2 branches covered.">		for (int i = 0; i &lt; iNumComponent; ++i) {</span>
<span class="pc bpc" id="L611" title="1 of 2 branches missed.">			if (null == aCalibComp[i])</span>
<span class="nc" id="L612">				throw new java.lang.Exception</span>
					(&quot;MergedDiscountForwardCurve::estimateManifestMeasure =&gt; Cannot locate a component&quot;);

<span class="fc" id="L615">			org.drip.analytics.support.CaseInsensitiveTreeMap&lt;java.lang.Double&gt; mapManifestMeasure =</span>
<span class="fc" id="L616">				manifestMeasure (aCalibComp[i].primaryCode());</span>

<span class="fc bfc" id="L618" title="All 2 branches covered.">			if (mapManifestMeasure.containsKey (strManifestMeasure)) {</span>
<span class="fc" id="L619">				lsDate.add (aCalibComp[i].maturityDate().julian());</span>

<span class="fc" id="L621">				lsQuote.add (mapManifestMeasure.get (strManifestMeasure));</span>
			}
		}

<span class="fc" id="L625">		int iNumEstimationComponent = lsDate.size();</span>

<span class="fc bfc" id="L627" title="All 2 branches covered.">		if (0 == iNumEstimationComponent)</span>
<span class="fc" id="L628">			throw new java.lang.Exception</span>
				(&quot;MergedDiscountForwardCurve::estimateManifestMeasure =&gt; Estimation Components not available&quot;);

<span class="fc" id="L631">		int[] aiDate = new int[iNumEstimationComponent];</span>
<span class="fc" id="L632">		double[] adblQuote = new double[iNumEstimationComponent];</span>
<span class="fc" id="L633">		org.drip.spline.params.SegmentCustomBuilderControl[] aSBP = new</span>
			org.drip.spline.params.SegmentCustomBuilderControl[iNumEstimationComponent - 1];

<span class="pc bpc" id="L636" title="1 of 2 branches missed.">		if (1 == iNumEstimationComponent) return lsQuote.get (0);</span>

<span class="fc" id="L638">		org.drip.spline.params.SegmentCustomBuilderControl sbp = new</span>
			org.drip.spline.params.SegmentCustomBuilderControl
				(org.drip.spline.stretch.MultiSegmentSequenceBuilder.BASIS_SPLINE_POLYNOMIAL, new
					org.drip.spline.basis.PolynomialFunctionSetParams (4),
<span class="fc" id="L642">						org.drip.spline.params.SegmentInelasticDesignControl.Create (2, 2), null, null);</span>

<span class="fc bfc" id="L644" title="All 2 branches covered.">		for (int i = 0; i &lt; iNumEstimationComponent; ++i) {</span>
<span class="fc bfc" id="L645" title="All 2 branches covered.">			if (0 != i) aSBP[i - 1] = sbp;</span>

<span class="fc" id="L647">			aiDate[i] = lsDate.get (i);</span>

<span class="fc" id="L649">			adblQuote[i] = lsQuote.get (i);</span>
		}

<span class="fc" id="L652">		org.drip.spline.stretch.MultiSegmentSequence regime =</span>
			org.drip.spline.stretch.MultiSegmentSequenceBuilder.CreateCalibratedStretchEstimator
<span class="fc" id="L654">				(&quot;DISC_CURVE_REGIME&quot;, aiDate, adblQuote, aSBP, null,</span>
<span class="fc" id="L655">					org.drip.spline.stretch.BoundarySettings.NaturalStandard(),</span>
						org.drip.spline.stretch.MultiSegmentSequence.CALIBRATE);

<span class="pc bpc" id="L658" title="1 of 2 branches missed.">		if (null == regime)</span>
<span class="nc" id="L659">			throw new java.lang.Exception</span>
				(&quot;MergedDiscountForwardCurve::estimateManifestMeasure =&gt; Cannot create Spline Stretch&quot;);

<span class="fc" id="L662">		double dblRegimeLeftExtreme = regime.getLeftPredictorOrdinateEdge();</span>

<span class="fc bfc" id="L664" title="All 2 branches covered.">		if (iDate &lt;= dblRegimeLeftExtreme) return regime.responseValue (dblRegimeLeftExtreme);</span>

<span class="fc" id="L666">		double dblRegimeRightExtreme = regime.getRightPredictorOrdinateEdge();</span>

<span class="pc bpc" id="L668" title="1 of 2 branches missed.">		if (iDate &gt;= dblRegimeRightExtreme) return regime.responseValue (dblRegimeRightExtreme);</span>

<span class="fc" id="L670">		return regime.responseValue (iDate);</span>
	}

	/**
	 * Proxy the Manifest Measure Value using the Closest Node for the given Date
	 * 
	 * @param strManifestMeasure The Manifest Measure to be Proxied
	 * @param iDate Date
	 * 
	 * @return The Measure Value Proxy
	 * 
	 * @throws java.lang.Exception Thrown if the Manifest Measure Proxy cannot be computed
	 */

	public double proxyManifestMeasure (
		final java.lang.String strManifestMeasure,
		final int iDate)
		throws java.lang.Exception
	{
<span class="pc bpc" id="L689" title="2 of 4 branches missed.">		if (null == strManifestMeasure || strManifestMeasure.isEmpty())</span>
<span class="nc" id="L690">			throw new java.lang.Exception</span>
				(&quot;MergedDiscountForwardCurve::proxyManifestMeasure =&gt; Invalid input&quot;);

<span class="fc" id="L693">		org.drip.product.definition.CalibratableComponent[] aCalibComp = calibComp();</span>

<span class="pc bpc" id="L695" title="1 of 2 branches missed.">		if (null == aCalibComp)</span>
<span class="nc" id="L696">			throw new java.lang.Exception</span>
				(&quot;MergedDiscountForwardCurve::proxyManifestMeasure =&gt; Calib Components not available&quot;);

<span class="fc" id="L699">		int iNumComponent = aCalibComp.length;</span>

<span class="pc bpc" id="L701" title="1 of 2 branches missed.">		if (0 == iNumComponent)</span>
<span class="nc" id="L702">			throw new java.lang.Exception</span>
				(&quot;MergedDiscountForwardCurve::proxyManifestMeasure =&gt; Calib Components not available&quot;);

<span class="fc" id="L705">		java.util.List&lt;java.lang.Integer&gt; lsDate = new java.util.ArrayList&lt;java.lang.Integer&gt;();</span>

<span class="fc" id="L707">		java.util.List&lt;java.lang.Double&gt; lsQuote = new java.util.ArrayList&lt;java.lang.Double&gt;();</span>

<span class="fc bfc" id="L709" title="All 2 branches covered.">		for (int i = 0; i &lt; iNumComponent; ++i) {</span>
<span class="pc bpc" id="L710" title="1 of 2 branches missed.">			if (null == aCalibComp[i])</span>
<span class="nc" id="L711">				throw new java.lang.Exception</span>
					(&quot;MergedDiscountForwardCurve::proxyManifestMeasure =&gt; Cannot locate a component&quot;);

<span class="fc" id="L714">			org.drip.analytics.support.CaseInsensitiveTreeMap&lt;java.lang.Double&gt; mapManifestMeasure =</span>
<span class="fc" id="L715">				manifestMeasure (aCalibComp[i].primaryCode());</span>

<span class="fc bfc" id="L717" title="All 2 branches covered.">			if (mapManifestMeasure.containsKey (strManifestMeasure)) {</span>
<span class="fc" id="L718">				lsDate.add (aCalibComp[i].maturityDate().julian());</span>

<span class="fc" id="L720">				lsQuote.add (mapManifestMeasure.get (strManifestMeasure));</span>
			}
		}

<span class="fc" id="L724">		int iNumEstimationComponent = lsDate.size();</span>

<span class="pc bpc" id="L726" title="1 of 2 branches missed.">		if (0 == iNumEstimationComponent)</span>
<span class="nc" id="L727">			throw new java.lang.Exception</span>
				(&quot;MergedDiscountForwardCurve::proxyManifestMeasure =&gt; Estimation Components not available&quot;);

<span class="pc bpc" id="L730" title="1 of 2 branches missed.">		if (1 == iNumEstimationComponent) return lsQuote.get (0);</span>

<span class="fc" id="L732">		int iDatePrev = lsDate.get (0);</span>

<span class="fc bfc" id="L734" title="All 2 branches covered.">		if (iDate &lt;= iDatePrev) return lsQuote.get (0);</span>

<span class="pc bpc" id="L736" title="1 of 2 branches missed.">		for (int i = 1; i &lt; iNumEstimationComponent; ++i) {</span>
<span class="fc" id="L737">			int iDateCurr = lsDate.get (i);</span>

<span class="pc bpc" id="L739" title="1 of 4 branches missed.">			if (iDatePrev &lt;= iDate &amp;&amp; iDate &lt; iDateCurr)</span>
<span class="fc bfc" id="L740" title="All 2 branches covered.">				return iDate - iDatePrev &gt; iDateCurr - iDate ? lsQuote.get (i) : lsQuote.get (i - 1);</span>

<span class="fc" id="L742">			iDatePrev = iDateCurr;</span>
		}

<span class="nc" id="L745">		return lsQuote.get (iNumEstimationComponent - 1);</span>
	}

	@Override public boolean setCCIS (
		final org.drip.analytics.input.CurveConstructionInputSet ccis)
	{
<span class="pc bpc" id="L751" title="1 of 2 branches missed.">		if (null == ccis) return false;</span>

<span class="fc" id="L753">		_ccis = ccis;</span>
<span class="fc" id="L754">		return true;</span>
	}

	/**
	 * Retrieve the Forward Curve that might be implied by the Latent State of this Discount Curve Instance
	 * 	corresponding to the specified Floating Rate Index
	 * 
	 * @param iDate The Date
	 * @param fri The Floating Rate Index
	 * 
	 * @return The Forward Curve Implied by the Discount Curve Latent State
	 */

	public abstract org.drip.state.forward.ForwardRateEstimator forwardRateEstimator (
		final int iDate,
		final org.drip.state.identifier.ForwardLabel fri);

	/**
	 * Retrieve the Latent State Quantification Metric
	 * 
	 * @return The Latent State Quantification Metric
	 */

	public abstract java.lang.String latentStateQuantificationMetric();

	/**
	 * Retrieve the Manifest Measure Jacobian of the Discount Factor to the given date
	 * 
	 * @param iDate Date
	 * @param strManifestMeasure Manifest Measure
	 * 
	 * @return The Manifest Measure Jacobian of the Discount Factor to the given date
	 */

	public abstract org.drip.numerical.differentiation.WengertJacobian jackDDFDManifestMeasure (
		final int iDate,
		final java.lang.String strManifestMeasure);

	/**
	 * Retrieve the Manifest Measure Jacobian of the Discount Factor to the given date
	 * 
	 * @param dt Date
	 * @param strManifestMeasure Manifest Measure
	 * 
	 * @return The Manifest Measure Jacobian of the Discount Factor to the given date
	 */

	public org.drip.numerical.differentiation.WengertJacobian jackDDFDManifestMeasure (
		final org.drip.analytics.date.JulianDate dt,
		final java.lang.String strManifestMeasure)
	{
<span class="pc bpc" id="L805" title="1 of 2 branches missed.">		if (null == dt) return null;</span>

<span class="fc" id="L807">		return jackDDFDManifestMeasure (dt.julian(), strManifestMeasure);</span>
	}

	/**
	 * Retrieve the Manifest Measure Jacobian of the Discount Factor to the date implied by the given Tenor
	 * 
	 * @param strTenor Tenor
	 * @param strManifestMeasure Manifest Measure
	 * 
	 * @return The Manifest Measure Jacobian of the Discount Factor to the date implied by the given Tenor
	 */

	public org.drip.numerical.differentiation.WengertJacobian jackDDFDManifestMeasure (
		final java.lang.String strTenor,
		final java.lang.String strManifestMeasure)
	{
<span class="nc bnc" id="L823" title="All 4 branches missed.">		if (null == strTenor || strTenor.isEmpty()) return null;</span>

		try {
<span class="nc" id="L826">			return jackDDFDManifestMeasure (epoch().addTenor (strTenor), strManifestMeasure);</span>
<span class="nc" id="L827">		} catch (java.lang.Exception e) {</span>
<span class="nc" id="L828">			e.printStackTrace();</span>
		}

<span class="nc" id="L831">		return null;</span>
	}

	/**
	 * Calculate the Jacobian of PV at the given date to the Manifest Measure of each component in the
	 * 	calibration set to the DF
	 * 
	 * @param iDate Date for which the Jacobian is needed
	 * 
	 * @return The Jacobian
	 */

	public org.drip.numerical.differentiation.WengertJacobian compJackDPVDManifestMeasure (
		final int iDate)
	{
<span class="pc bpc" id="L846" title="1 of 2 branches missed.">		if (!org.drip.numerical.common.NumberUtil.IsValid (iDate)) return null;</span>

<span class="fc" id="L848">		org.drip.product.definition.CalibratableComponent[] aCalibComp = calibComp();</span>

<span class="pc bpc" id="L850" title="1 of 4 branches missed.">		if (null == aCalibComp || 0 == aCalibComp.length) return null;</span>

<span class="fc" id="L852">		int iNumParameters = 0;</span>
<span class="fc" id="L853">		int iNumComponents = aCalibComp.length;</span>
<span class="fc" id="L854">		org.drip.numerical.differentiation.WengertJacobian wjCompPVDF = null;</span>

<span class="fc" id="L856">		org.drip.param.valuation.ValuationParams valParams = org.drip.param.valuation.ValuationParams.Spot</span>
<span class="fc" id="L857">			(iDate);</span>

<span class="pc bpc" id="L859" title="1 of 2 branches missed.">		org.drip.param.market.CurveSurfaceQuoteContainer csqs =</span>
<span class="fc" id="L860">			org.drip.param.creator.MarketParamsBuilder.Create (this, null, null, null, null, null,</span>
<span class="fc" id="L861">				null, null == _ccis ? null : _ccis.fixing());</span>

<span class="fc bfc" id="L863" title="All 2 branches covered.">		for (int i = 0; i &lt; iNumComponents; ++i) {</span>
<span class="fc" id="L864">			org.drip.numerical.differentiation.WengertJacobian wjCompDDirtyPVDManifestMeasure =</span>
<span class="fc" id="L865">				aCalibComp[i].jackDDirtyPVDManifestMeasure (valParams, null, csqs, null);</span>

<span class="pc bpc" id="L867" title="1 of 2 branches missed.">			if (null == wjCompDDirtyPVDManifestMeasure) return null;</span>

<span class="fc" id="L869">			iNumParameters = wjCompDDirtyPVDManifestMeasure.numParameters();</span>

<span class="fc bfc" id="L871" title="All 2 branches covered.">			if (null == wjCompPVDF) {</span>
				try {
<span class="fc" id="L873">					wjCompPVDF = new org.drip.numerical.differentiation.WengertJacobian (iNumComponents,</span>
						iNumParameters);
<span class="nc" id="L875">				} catch (java.lang.Exception e) {</span>
<span class="nc" id="L876">					e.printStackTrace();</span>

<span class="nc" id="L878">					return null;</span>
<span class="fc" id="L879">				}</span>
			}

<span class="fc bfc" id="L882" title="All 2 branches covered.">			for (int k = 0; k &lt; iNumParameters; ++k) {</span>
<span class="pc bpc" id="L883" title="1 of 2 branches missed.">				if (!wjCompPVDF.accumulatePartialFirstDerivative (i, k,</span>
<span class="fc" id="L884">					wjCompDDirtyPVDManifestMeasure.firstDerivative (0, k)))</span>
<span class="nc" id="L885">					return null;</span>
			}
		}

<span class="fc" id="L889">		return wjCompPVDF;</span>
	}

	/**
	 * Calculate the Jacobian of PV at the given date to the Manifest Measure of each component in the
	 * 	calibration set to the DF
	 * 
	 * @param dt Date for which the Jacobian is needed
	 * 
	 * @return The Jacobian
	 */

	public org.drip.numerical.differentiation.WengertJacobian compJackDPVDManifestMeasure (
		final org.drip.analytics.date.JulianDate dt)
	{
<span class="pc bpc" id="L904" title="1 of 2 branches missed.">		return null == dt ? null : compJackDPVDManifestMeasure (dt.julian());</span>
	}

	/**
	 * Retrieve the Jacobian of the Forward Rate to the Manifest Measure between the given dates
	 * 
	 * @param iDate1 Date 1
	 * @param iDate2 Date 2
	 * @param strManifestMeasure Manifest Measure
	 * @param dblElapsedYear The Elapsed Year (in the appropriate Day Count) between dates 1 and 2
	 * 
	 * @return The Jacobian
	 */

	public org.drip.numerical.differentiation.WengertJacobian jackDForwardDManifestMeasure (
		final int iDate1,
		final int iDate2,
		final java.lang.String strManifestMeasure,
		final double dblElapsedYear)
	{
<span class="nc bnc" id="L924" title="All 2 branches missed.">		if (iDate1 == iDate2) return null;</span>

<span class="nc" id="L926">		org.drip.numerical.differentiation.WengertJacobian wjDDFDManifestMeasureDate1 = jackDDFDManifestMeasure</span>
<span class="nc" id="L927">			(iDate1, strManifestMeasure);</span>

<span class="nc bnc" id="L929" title="All 2 branches missed.">		if (null == wjDDFDManifestMeasureDate1) return null;</span>

<span class="nc" id="L931">		int iNumQuote = wjDDFDManifestMeasureDate1.numParameters();</span>

<span class="nc bnc" id="L933" title="All 2 branches missed.">		if (0 == iNumQuote) return null;</span>

<span class="nc" id="L935">		org.drip.numerical.differentiation.WengertJacobian wjDDFDManifestMeasureDate2 = jackDDFDManifestMeasure</span>
<span class="nc" id="L936">			(iDate2, strManifestMeasure);</span>

<span class="nc bnc" id="L938" title="All 4 branches missed.">		if (null == wjDDFDManifestMeasureDate2 || iNumQuote != wjDDFDManifestMeasureDate2.numParameters())</span>
<span class="nc" id="L939">			return null;</span>

<span class="nc" id="L941">		double dblDF1 = java.lang.Double.NaN;</span>
<span class="nc" id="L942">		double dblDF2 = java.lang.Double.NaN;</span>
<span class="nc" id="L943">		org.drip.numerical.differentiation.WengertJacobian wjDForwardDManifestMeasure = null;</span>

		try {
<span class="nc" id="L946">			dblDF1 = df (iDate1);</span>

<span class="nc" id="L948">			dblDF2 = df (iDate2);</span>

<span class="nc" id="L950">			wjDForwardDManifestMeasure = new org.drip.numerical.differentiation.WengertJacobian (1, iNumQuote);</span>
<span class="nc" id="L951">		} catch (java.lang.Exception e) {</span>
<span class="nc" id="L952">			e.printStackTrace();</span>

<span class="nc" id="L954">			return null;</span>
<span class="nc" id="L955">		}</span>

<span class="nc" id="L957">		double dblDForwardDManifestMeasure1iScale = 1. / dblDF2;</span>
<span class="nc" id="L958">		double dblDForwardDManifestMeasure2iScale = dblDF1 / (dblDF2 * dblDF2);</span>
<span class="nc" id="L959">		double dblInverseAnnualizedTenorLength = 1. / dblElapsedYear;</span>

<span class="nc bnc" id="L961" title="All 2 branches missed.">		for (int i = 0; i &lt; iNumQuote; ++i) {</span>
<span class="nc" id="L962">			double dblDForwardDQManifestMeasurei = ((wjDDFDManifestMeasureDate1.firstDerivative (0, i) *</span>
<span class="nc" id="L963">				dblDForwardDManifestMeasure1iScale) - (wjDDFDManifestMeasureDate2.firstDerivative (0, i) *</span>
					dblDForwardDManifestMeasure2iScale)) * dblInverseAnnualizedTenorLength;

<span class="nc bnc" id="L966" title="All 2 branches missed.">			if (!wjDForwardDManifestMeasure.accumulatePartialFirstDerivative (0, i,</span>
				dblDForwardDQManifestMeasurei))
<span class="nc" id="L968">				return null;</span>
		}

<span class="nc" id="L971">		return wjDForwardDManifestMeasure;</span>
	}

	/**
	 * Retrieve the Jacobian of the Forward Rate to the Manifest Measure between the given dates
	 * 
	 * @param dt1 Julian Date 1
	 * @param dt2 Julian Date 2
	 * @param strManifestMeasure Manifest Measure
	 * @param dblElapsedYear The Elapsed Year (in the appropriate Day Count) between dates 1 and 2
	 * 
	 * @return The Jacobian
	 */

	public org.drip.numerical.differentiation.WengertJacobian jackDForwardDManifestMeasure (
		final org.drip.analytics.date.JulianDate dt1,
		final org.drip.analytics.date.JulianDate dt2,
		final java.lang.String strManifestMeasure,
		final double dblElapsedYear)
	{
<span class="nc bnc" id="L991" title="All 4 branches missed.">		if (null == dt1 || null == dt2) return null;</span>

<span class="nc" id="L993">		return jackDForwardDManifestMeasure (dt1.julian(), dt2.julian(), strManifestMeasure, dblElapsedYear);</span>
	}

	/**
	 * Retrieve the Jacobian of the Forward Rate to the Manifest Measure at the given date
	 * 
	 * @param dt Given Julian Date
	 * @param strTenor Tenor
	 * @param strManifestMeasure Manifest Measure
	 * @param dblElapsedYear The Elapsed Year (in the appropriate Day Count) implied by the Tenor
	 * 
	 * @return The Jacobian
	 */

	public org.drip.numerical.differentiation.WengertJacobian jackDForwardDManifestMeasure (
		final org.drip.analytics.date.JulianDate dt,
		final java.lang.String strTenor,
		final java.lang.String strManifestMeasure,
		final double dblElapsedYear)
	{
<span class="nc bnc" id="L1013" title="All 6 branches missed.">		if (null == dt || null == strTenor || strTenor.isEmpty()) return null;</span>

<span class="nc" id="L1015">		return jackDForwardDManifestMeasure (dt.julian(), dt.addTenor (strTenor).julian(),</span>
			strManifestMeasure, dblElapsedYear);
	}

	/**
	 * Retrieve the Jacobian for the Zero Rate to the given date
	 * 
	 * @param iDate Date
	 * @param strManifestMeasure Manifest Measure
	 * 
	 * @return The Jacobian
	 */

	public org.drip.numerical.differentiation.WengertJacobian zeroRateJack (
		final int iDate,
		final java.lang.String strManifestMeasure)
	{
<span class="nc" id="L1032">		int iEpochDate = epoch().julian();</span>

<span class="nc" id="L1034">		return jackDForwardDManifestMeasure (iEpochDate, iDate, strManifestMeasure, 1. * (iDate - iEpochDate) /</span>
			365.25);
	}

	/**
	 * Retrieve the Jacobian for the Zero Rate to the given date
	 * 
	 * @param dt Julian Date
	 * @param strManifestMeasure Manifest Measure
	 * 
	 * @return The Jacobian
	 */

	public org.drip.numerical.differentiation.WengertJacobian zeroRateJack (
		final org.drip.analytics.date.JulianDate dt,
		final java.lang.String strManifestMeasure)
	{
<span class="nc bnc" id="L1051" title="All 2 branches missed.">		return null == dt? null : zeroRateJack (dt.julian(), strManifestMeasure);</span>
	}

	/**
	 * Convert the inferred Formulation Constraint into a &quot;Truthness&quot; Entity
	 * 
	 * @param strLatentStateQuantificationMetric Latent State Quantification Metric
	 * 
	 * @return Map of the Truthness Entities
	 */

	public java.util.Map&lt;java.lang.Integer, java.lang.Double&gt; canonicalTruthness (
		final java.lang.String strLatentStateQuantificationMetric)
	{
<span class="pc bpc" id="L1065" title="1 of 2 branches missed.">		if (null == strLatentStateQuantificationMetric ||</span>
			(!org.drip.analytics.definition.LatentStateStatic.DISCOUNT_QM_ZERO_RATE.equalsIgnoreCase
<span class="pc bpc" id="L1067" title="1 of 2 branches missed.">				(strLatentStateQuantificationMetric) &amp;&amp; !</span>
					org.drip.analytics.definition.LatentStateStatic.DISCOUNT_QM_DISCOUNT_FACTOR.equalsIgnoreCase
<span class="nc bnc" id="L1069" title="All 2 branches missed.">			(strLatentStateQuantificationMetric)))</span>
<span class="nc" id="L1070">			return null;</span>

<span class="fc" id="L1072">		org.drip.product.definition.CalibratableComponent[] aCC = calibComp();</span>

<span class="pc bpc" id="L1074" title="1 of 2 branches missed.">		if (null == aCC) return null;</span>

<span class="fc" id="L1076">		int iNumComp = aCC.length;</span>
<span class="fc" id="L1077">		boolean bFirstCashFlow = true;</span>

<span class="pc bpc" id="L1079" title="1 of 2 branches missed.">		if (0 == iNumComp) return null;</span>

<span class="fc" id="L1081">		java.util.Map&lt;java.lang.Integer, java.lang.Double&gt; mapCanonicalTruthness = new</span>
			java.util.TreeMap&lt;java.lang.Integer, java.lang.Double&gt;();

<span class="fc" id="L1084">		if (org.drip.analytics.definition.LatentStateStatic.DISCOUNT_QM_DISCOUNT_FACTOR.equalsIgnoreCase</span>
<span class="pc bpc" id="L1085" title="1 of 2 branches missed.">			(strLatentStateQuantificationMetric))</span>
<span class="nc" id="L1086">			mapCanonicalTruthness.put (_iEpochDate, 1.);</span>

<span class="fc bfc" id="L1088" title="All 2 branches covered.">		for (org.drip.product.definition.CalibratableComponent cc : aCC) {</span>
<span class="pc bpc" id="L1089" title="1 of 2 branches missed.">			if (null == cc) continue;</span>

<span class="fc" id="L1091">			java.util.List&lt;org.drip.analytics.cashflow.CompositePeriod&gt; lsCouponPeriod = cc.couponPeriods();</span>

<span class="pc bpc" id="L1093" title="2 of 4 branches missed.">			if (null == lsCouponPeriod || 0 == lsCouponPeriod.size()) continue;</span>

<span class="fc bfc" id="L1095" title="All 2 branches covered.">			for (org.drip.analytics.cashflow.CompositePeriod cpnPeriod : lsCouponPeriod) {</span>
<span class="pc bpc" id="L1096" title="1 of 2 branches missed.">				if (null == cpnPeriod) continue;</span>

<span class="fc" id="L1098">				int iPeriodPayDate = cpnPeriod.payDate();</span>

<span class="pc bpc" id="L1100" title="1 of 2 branches missed.">				if (iPeriodPayDate &gt;= _iEpochDate) {</span>
					try {
<span class="fc" id="L1102">						if (org.drip.analytics.definition.LatentStateStatic.DISCOUNT_QM_DISCOUNT_FACTOR.equalsIgnoreCase</span>
<span class="pc bpc" id="L1103" title="1 of 2 branches missed.">							(strLatentStateQuantificationMetric))</span>
<span class="nc" id="L1104">							mapCanonicalTruthness.put (iPeriodPayDate, df (iPeriodPayDate));</span>
<span class="fc" id="L1105">						else if (org.drip.analytics.definition.LatentStateStatic.DISCOUNT_QM_ZERO_RATE.equalsIgnoreCase</span>
<span class="pc bpc" id="L1106" title="1 of 2 branches missed.">							(strLatentStateQuantificationMetric)) {</span>
<span class="fc bfc" id="L1107" title="All 2 branches covered.">							if (bFirstCashFlow) {</span>
<span class="fc" id="L1108">								bFirstCashFlow = false;</span>

<span class="fc" id="L1110">								mapCanonicalTruthness.put (_iEpochDate, zero (iPeriodPayDate));</span>
							}

<span class="fc" id="L1113">							mapCanonicalTruthness.put (iPeriodPayDate, zero (iPeriodPayDate));</span>
						}
<span class="nc" id="L1115">					} catch (java.lang.Exception e) {</span>
<span class="nc" id="L1116">						e.printStackTrace();</span>

<span class="nc" id="L1118">						return null;</span>
<span class="fc" id="L1119">					}</span>
				}
<span class="fc" id="L1121">			}</span>
		}

<span class="fc" id="L1124">		return mapCanonicalTruthness;</span>
	}
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.7.9.201702052155</span></div></body></html>