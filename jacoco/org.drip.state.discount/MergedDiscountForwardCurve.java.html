<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>MergedDiscountForwardCurve.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">DROP</a> &gt; <a href="index.source.html" class="el_package">org.drip.state.discount</a> &gt; <span class="el_source">MergedDiscountForwardCurve.java</span></div><h1>MergedDiscountForwardCurve.java</h1><pre class="source lang-java linenums">
package org.drip.state.discount;

/*
 * -*- mode: java; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*-
 */

/*!
 * Copyright (C) 2019 Lakshmi Krishnamurthy
 * Copyright (C) 2018 Lakshmi Krishnamurthy
 * Copyright (C) 2017 Lakshmi Krishnamurthy
 * Copyright (C) 2016 Lakshmi Krishnamurthy
 * Copyright (C) 2015 Lakshmi Krishnamurthy
 * Copyright (C) 2014 Lakshmi Krishnamurthy
 * Copyright (C) 2013 Lakshmi Krishnamurthy
 * 
 *  This file is part of DROP, an open-source library targeting risk, transaction costs, exposure, margin
 *  	calculations, and portfolio construction within and across fixed income, credit, commodity, equity,
 *  	FX, and structured products.
 *  
 *  	https://lakshmidrip.github.io/DROP/
 *  
 *  DROP is composed of three main modules:
 *  
 *  - DROP Analytics Core - https://lakshmidrip.github.io/DROP-Analytics-Core/
 *  - DROP Portfolio Core - https://lakshmidrip.github.io/DROP-Portfolio-Core/
 *  - DROP Numerical Core - https://lakshmidrip.github.io/DROP-Numerical-Core/
 * 
 * 	DROP Analytics Core implements libraries for the following:
 * 	- Fixed Income Analytics
 * 	- Asset Backed Analytics
 * 	- XVA Analytics
 * 	- Exposure and Margin Analytics
 * 
 * 	DROP Portfolio Core implements libraries for the following:
 * 	- Asset Allocation Analytics
 * 	- Transaction Cost Analytics
 * 
 * 	DROP Numerical Core implements libraries for the following:
 * 	- Statistical Learning Library
 * 	- Numerical Optimizer Library
 * 	- Machine Learning Library
 * 	- Spline Builder Library
 * 
 * 	Documentation for DROP is Spread Over:
 * 
 * 	- Main                     =&gt; https://lakshmidrip.github.io/DROP/
 * 	- Wiki                     =&gt; https://github.com/lakshmiDRIP/DROP/wiki
 * 	- GitHub                   =&gt; https://github.com/lakshmiDRIP/DROP
 * 	- Javadoc                  =&gt; https://lakshmidrip.github.io/DROP/Javadoc/index.html
 * 	- Technical Specifications =&gt; https://github.com/lakshmiDRIP/DROP/tree/master/Docs/Internal
 * 	- Release Versions         =&gt; https://lakshmidrip.github.io/DROP/version.html
 * 	- Community Credits        =&gt; https://lakshmidrip.github.io/DROP/credits.html
 * 	- Issues Catalog           =&gt; https://github.com/lakshmiDRIP/DROP/issues
 * 	- JUnit                    =&gt; https://lakshmidrip.github.io/DROP/junit/index.html
 * 	- Jacoco                   =&gt; https://lakshmidrip.github.io/DROP/jacoco/index.html
 * 
 *  Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 *   	you may not use this file except in compliance with the License.
 *   
 *  You may obtain a copy of the License at
 *  	http://www.apache.org/licenses/LICENSE-2.0
 *  
 *  Unless required by applicable law or agreed to in writing, software
 *  	distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 *  	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  
 *  See the License for the specific language governing permissions and
 *  	limitations under the License.
 */

/**
 * &lt;i&gt;MergedDiscountForwardCurve&lt;/i&gt; is the Stub for the Merged Discount and Forward Curve Functionality. It
 * extends the both the Curve and the DiscountFactorEstimator instances by implementing their functions, and
 * exposing the following:
 *
 *  &lt;br&gt;&lt;br&gt;
 *  &lt;ul&gt;
 *  	&lt;li&gt;
 * 			Forward Rate to a specific date/tenor, and effective rate between a date interval
 *  	&lt;/li&gt;
 *  	&lt;li&gt;
 * 			Discount Factor to a specific date/tenor, and effective discount factor between a date interval
 *  	&lt;/li&gt;
 *  	&lt;li&gt;
 * 			Zero Rate to a specific date/tenor
 *  	&lt;/li&gt;
 *  	&lt;li&gt;
 *  		Value Jacobian for Forward rate, discount factor, and zero rate
 *  	&lt;/li&gt;
 *  	&lt;li&gt;
 *  		Cross Jacobian between each of Forward rate, discount factor, and zero rate
 *  	&lt;/li&gt;
 *  	&lt;li&gt;
 *  		Quote Jacobian to Forward rate, discount factor, and zero rate
 *  	&lt;/li&gt;
 *  	&lt;li&gt;
 *  		QM (DF/Zero/Forward) to Quote Jacobian
 *  	&lt;/li&gt;
 *  	&lt;li&gt;
 *  		Latent State Quantification Metric, and the canonical truthness transformations
 *  	&lt;/li&gt;
 *  	&lt;li&gt;
 *  		Implied/embedded ForwardRateEstimator
 *  	&lt;/li&gt;
 *  	&lt;li&gt;
 *  		Turns set/unset/adjust
 *  	&lt;/li&gt;
 *  &lt;/ul&gt;
 *
 *  &lt;br&gt;&lt;br&gt;
 *  &lt;ul&gt;
 *		&lt;li&gt;&lt;b&gt;Module &lt;/b&gt; = &lt;a href = &quot;https://github.com/lakshmiDRIP/DROP/tree/master/AnalyticsCore.md&quot;&gt;Analytics Core Module&lt;/a&gt;&lt;/li&gt;
 *		&lt;li&gt;&lt;b&gt;Library&lt;/b&gt; = &lt;a href = &quot;https://github.com/lakshmiDRIP/DROP/tree/master/FixedIncomeAnalyticsLibrary.md&quot;&gt;Fixed Income Analytics Library&lt;/a&gt;&lt;/li&gt;
 *		&lt;li&gt;&lt;b&gt;Project&lt;/b&gt; = &lt;a href = &quot;https://github.com/lakshmiDRIP/DROP/tree/master/src/main/java/org/drip/state&quot;&gt;State&lt;/a&gt;&lt;/li&gt;
 *		&lt;li&gt;&lt;b&gt;Package&lt;/b&gt; = &lt;a href = &quot;https://github.com/lakshmiDRIP/DROP/tree/master/src/main/java/org/drip/state/discount&quot;&gt;Discount&lt;/a&gt;&lt;/li&gt;
 *  &lt;/ul&gt;
 * &lt;br&gt;&lt;br&gt;
 *
 * @author Lakshmi Krishnamurthy
 */

public abstract class MergedDiscountForwardCurve extends org.drip.state.discount.DiscountCurve {
	private static final int NUM_DF_QUADRATURES = 5;

<span class="fc" id="L126">	protected java.lang.String _strCurrency = &quot;&quot;;</span>
<span class="fc" id="L127">	protected int _iEpochDate = java.lang.Integer.MIN_VALUE;</span>
<span class="fc" id="L128">	protected org.drip.state.discount.TurnListDiscountFactor _tldf = null;</span>
<span class="fc" id="L129">	protected org.drip.analytics.input.CurveConstructionInputSet _ccis = null;</span>

	protected MergedDiscountForwardCurve (
		final int iEpochDate,
		final java.lang.String strCurrency,
		final org.drip.state.discount.TurnListDiscountFactor tldf)
		throws java.lang.Exception
<span class="fc" id="L136">	{</span>
<span class="pc bpc" id="L137" title="2 of 4 branches missed.">		if (null == (_strCurrency = strCurrency) || _strCurrency.isEmpty() ||</span>
<span class="pc bpc" id="L138" title="1 of 2 branches missed.">			!org.drip.numerical.common.NumberUtil.IsValid (_iEpochDate = iEpochDate))</span>
<span class="nc" id="L139">			throw new java.lang.Exception (&quot;MergedDiscountForwardCurve ctr: Invalid Inputs&quot;);</span>

<span class="fc" id="L141">		_tldf = tldf;</span>
<span class="fc" id="L142">	}</span>

	@Override public org.drip.state.identifier.LatentStateLabel label()
	{
<span class="fc" id="L146">		return org.drip.state.identifier.FundingLabel.Standard (_strCurrency);</span>
	}

	@Override public java.lang.String currency()
	{
<span class="fc" id="L151">		return _strCurrency;</span>
	}

	@Override public org.drip.analytics.date.JulianDate epoch()
	{
		try {
<span class="fc" id="L157">			return new org.drip.analytics.date.JulianDate (_iEpochDate);</span>
<span class="nc" id="L158">		} catch (java.lang.Exception e) {</span>
<span class="nc" id="L159">			e.printStackTrace();</span>
		}

<span class="nc" id="L162">		return null;</span>
	}

	/**
	 * Set the Discount Curve Turns'
	 * 
	 * @param tldf Turn List Discount Factor
	 * 
	 * @return TRUE - Valid Turn List Discount Factor Set
	 */

	public boolean setTurns (
		final org.drip.state.discount.TurnListDiscountFactor tldf)
	{
<span class="pc bpc" id="L176" title="1 of 2 branches missed.">		return null != (_tldf = tldf);</span>
	}

	/**
	 * Apply the Turns' DF Adjustment
	 * 
	 * @param iStartDate Turn Start Date
	 * @param iFinishDate Turn Finish Date
	 * 
	 * @return Turns' DF Adjustment
	 * 
	 * @throws java.lang.Exception Thrown if the Inputs are invalid
	 */

	public double turnAdjust (
		final int iStartDate,
		final int iFinishDate)
		throws java.lang.Exception
	{
<span class="fc bfc" id="L195" title="All 2 branches covered.">		return null == _tldf ? 1. : _tldf.turnAdjust (iStartDate, iFinishDate);</span>
	}

	/**
	 * Apply the Turns' DF Adjustment
	 * 
	 * @param iFinishDate Turn Finish Date
	 * 
	 * @return Turns' DF Adjustment
	 * 
	 * @throws java.lang.Exception Thrown if the Inputs are invalid
	 */

	protected double turnAdjust (
		final int iFinishDate)
		throws java.lang.Exception
	{
<span class="nc" id="L212">		return turnAdjust (epoch().julian(), iFinishDate);</span>
	}

	/**
	 * Construct the Native Forward Curve for the given Tenor from the Discount Curve
	 * 
	 * @param strTenor The Tenor
	 * 
	 * @return The Tenor-Native Forward Curve
	 */

	public org.drip.state.forward.ForwardCurve nativeForwardCurve (
		final java.lang.String strTenor)
	{
<span class="pc bpc" id="L226" title="2 of 4 branches missed.">		if (null == strTenor || strTenor.isEmpty()) return null;</span>

		try {
<span class="fc" id="L229">			org.drip.state.forward.ForwardCurve fcNative = new org.drip.state.forward.ForwardCurve</span>
<span class="fc" id="L230">				(epoch().julian(), org.drip.state.identifier.ForwardLabel.Standard (_strCurrency + &quot;-&quot; +</span>
<span class="fc" id="L231">					strTenor)) {</span>
				@Override public double forward (
					final int iDate)
					throws java.lang.Exception
				{
<span class="fc" id="L236">					return forward (new org.drip.analytics.date.JulianDate (iDate));</span>
				}

				@Override public double forward (
					final org.drip.analytics.date.JulianDate dt)
					throws java.lang.Exception
				{
<span class="pc bpc" id="L243" title="1 of 2 branches missed.">					if (null == dt)</span>
<span class="nc" id="L244">						throw new java.lang.Exception</span>
							(&quot;MergedDiscountForwardCurve::nativeForwardCurve =&gt; Invalid Input&quot;);

<span class="fc" id="L247">					return libor (dt.subtractTenor (strTenor).julian(), strTenor);</span>
				}

				@Override public double forward (
					final java.lang.String strTenor)
					throws java.lang.Exception
				{
<span class="nc bnc" id="L254" title="All 4 branches missed.">					if (null == strTenor || strTenor.isEmpty())</span>
<span class="nc" id="L255">						throw new java.lang.Exception</span>
							(&quot;MergedDiscountForwardCurve::nativeForwardCurve =&gt; Invalid Input&quot;);

<span class="nc" id="L258">					return forward (epoch().addTenor (strTenor));</span>
				}

				@Override public org.drip.numerical.differentiation.WengertJacobian jackDForwardDManifestMeasure (
					final java.lang.String strManifestMeasure,
					final int iDate)
				{
<span class="nc" id="L265">					return null;</span>
				}
			};

<span class="fc" id="L269">			return fcNative;</span>
<span class="nc" id="L270">		} catch (java.lang.Exception e) {</span>
<span class="nc" id="L271">			e.printStackTrace();</span>
		}

<span class="nc" id="L274">		return null;</span>
	}

	@Override public double df (
		final org.drip.analytics.date.JulianDate dt)
		throws java.lang.Exception
	{
<span class="pc bpc" id="L281" title="1 of 2 branches missed.">		if (null == dt) throw new java.lang.Exception (&quot;MergedDiscountForwardCurve::df got null for date&quot;);</span>

<span class="fc" id="L283">		return df (dt.julian());</span>
	}

	@Override public double df (
		final java.lang.String strTenor)
		throws java.lang.Exception
	{
<span class="pc bpc" id="L290" title="2 of 4 branches missed.">		if (null == strTenor || strTenor.isEmpty())</span>
<span class="nc" id="L291">			throw new java.lang.Exception (&quot;MergedDiscountForwardCurve::df got bad tenor&quot;);</span>

<span class="fc" id="L293">		return df (epoch().addTenor (strTenor));</span>
	}

	@Override public double effectiveDF (
		final int iDate1,
		final int iDate2)
		throws java.lang.Exception
	{
<span class="fc bfc" id="L301" title="All 2 branches covered.">		if (iDate1 == iDate2) return df (iDate1);</span>

<span class="fc" id="L303">		int iNumQuadratures = 0;</span>
<span class="fc" id="L304">		double dblEffectiveDF = 0.;</span>
<span class="fc" id="L305">		int iQuadratureWidth = (iDate2 - iDate1) / NUM_DF_QUADRATURES;</span>

<span class="fc bfc" id="L307" title="All 2 branches covered.">		if (0 == iQuadratureWidth) iQuadratureWidth = 1;</span>

<span class="fc bfc" id="L309" title="All 2 branches covered.">		for (int iDate = iDate1; iDate &lt;= iDate2; iDate += iQuadratureWidth) {</span>
<span class="fc" id="L310">			++iNumQuadratures;</span>

<span class="fc" id="L312">			dblEffectiveDF += (df (iDate) + df (iDate + iQuadratureWidth));</span>
		}

<span class="fc" id="L315">		return dblEffectiveDF / (2. * iNumQuadratures);</span>
	}

	@Override public double effectiveDF (
		final org.drip.analytics.date.JulianDate dt1,
		final org.drip.analytics.date.JulianDate dt2)
		throws java.lang.Exception
	{
<span class="pc bpc" id="L323" title="2 of 4 branches missed.">		if (null == dt1 || null == dt2)</span>
<span class="nc" id="L324">			throw new java.lang.Exception (&quot;MergedDiscountForwardCurve::effectiveDF =&gt; Got null for date&quot;);</span>

<span class="fc" id="L326">		return effectiveDF (dt1.julian(), dt2.julian());</span>
	}

	@Override public double effectiveDF (
		final java.lang.String strTenor1,
		final java.lang.String strTenor2)
		throws java.lang.Exception
	{
<span class="pc bpc" id="L334" title="4 of 8 branches missed.">		if (null == strTenor1 || strTenor1.isEmpty() || null == strTenor2 || strTenor2.isEmpty())</span>
<span class="nc" id="L335">			throw new java.lang.Exception (&quot;MergedDiscountForwardCurve::effectiveDF =&gt; Got bad tenor&quot;);</span>

<span class="fc" id="L337">		org.drip.analytics.date.JulianDate dtStart = epoch();</span>

<span class="fc" id="L339">		return effectiveDF (dtStart.addTenor (strTenor1), dtStart.addTenor (strTenor2));</span>
	}

	/**
	 * Compute the Forward Rate between two Dates
	 * 
	 * @param iDate1 First Date
	 * @param iDate2 Second Date
	 * 
	 * @return The Forward Rate
	 * 
	 * @throws java.lang.Exception Thrown if the Forward Rate cannot be calculated
	 */

	public abstract double forward (
		final int iDate1,
		final int iDate2)
		throws java.lang.Exception;

	/**
	 * Compute the Forward Rate between two Tenors
	 * 
	 * @param strTenor1 Tenor Start
	 * @param strTenor2 Tenor End
	 * 
	 * @return The Forward Rate
	 * 
	 * @throws java.lang.Exception Thrown if the Forward Rate cannot be calculated
	 */

	public double forward (
		final java.lang.String strTenor1,
		final java.lang.String strTenor2)
		throws java.lang.Exception
	{
<span class="pc bpc" id="L374" title="4 of 8 branches missed.">		if (null == strTenor1 || strTenor1.isEmpty() || null == strTenor2 || strTenor2.isEmpty())</span>
<span class="nc" id="L375">			throw new java.lang.Exception (&quot;MergedDiscountForwardCurve::forward =&gt; Invalid Date&quot;);</span>

<span class="fc" id="L377">		org.drip.analytics.date.JulianDate dtStart = epoch();</span>

<span class="fc" id="L379">		return forward (dtStart.addTenor (strTenor1).julian(), dtStart.addTenor (strTenor2).julian());</span>
	}

	/**
	 * Calculate the implied rate to the given date
	 * 
	 * @param iDate Date
	 * 
	 * @return Implied rate
	 * 
	 * @throws java.lang.Exception Thrown if the discount factor cannot be calculated
	 */

	public abstract double zero (
		final int iDate)
		throws java.lang.Exception;

	/**
	 * Calculate the implied rate to the given tenor
	 * 
	 * @param strTenor Tenor
	 * 
	 * @return Implied rate
	 * 
	 * @throws java.lang.Exception Thrown if the discount factor cannot be calculated
	 */

	public double zero (
		final java.lang.String strTenor)
		throws java.lang.Exception
	{
<span class="pc bpc" id="L410" title="2 of 4 branches missed.">		if (null == strTenor || strTenor.isEmpty())</span>
<span class="nc" id="L411">			throw new java.lang.Exception (&quot;MergedDiscountForwardCurve::zero =&gt; Invalid date&quot;);</span>

<span class="fc" id="L413">		org.drip.analytics.date.JulianDate dtStart = epoch();</span>

<span class="fc" id="L415">		return forward (dtStart.julian(), dtStart.addTenor (strTenor).julian());</span>
	}

	/**
	 * Compute the LIBOR between 2 dates given the Day Count
	 * 
	 * @param iDate1 First Date
	 * @param iDate2 Second Date
	 * @param dblDCF Day Count Fraction
	 * 
	 * @return LIBOR
	 * 
	 * @throws java.lang.Exception Thrown if the discount factor cannot be calculated
	 */

	public double libor (
		final int iDate1,
		final int iDate2,
		final double dblDCF)
		throws java.lang.Exception
	{
<span class="pc bpc" id="L436" title="3 of 6 branches missed.">		if (iDate1 == iDate2 || !org.drip.numerical.common.NumberUtil.IsValid (dblDCF) || 0. == dblDCF)</span>
<span class="nc" id="L437">			throw new java.lang.Exception (&quot;MergedDiscountForwardCurve::libor =&gt; Invalid input dates&quot;);</span>

<span class="fc" id="L439">		return ((df (iDate1) / df (iDate2)) - 1.) / dblDCF;</span>
	}

	/**
	 * Compute the LIBOR between 2 dates
	 * 
	 * @param iDate1 First Date
	 * @param iDate2 Second Date
	 * 
	 * @return LIBOR
	 * 
	 * @throws java.lang.Exception Thrown if the discount factor cannot be calculated
	 */

	public double libor (
		final int iDate1,
		final int iDate2)
		throws java.lang.Exception
	{
<span class="pc bpc" id="L458" title="1 of 2 branches missed.">		if (iDate1 == iDate2)</span>
<span class="nc" id="L459">			throw new java.lang.Exception (&quot;MergedDiscountForwardCurve::libor =&gt; Invalid input dates&quot;);</span>

<span class="fc" id="L461">		return libor (iDate1, iDate2, org.drip.analytics.daycount.Convention.YearFraction (iDate1, iDate2,</span>
			&quot;Act/360&quot;, false, null, &quot;&quot;));
	}

	/**
	 * Calculate the LIBOR to the given tenor at the specified date
	 * 
	 * @param iStartDate Start Date
	 * @param strTenor Tenor
	 * 
	 * @return LIBOR
	 * 
	 * @throws java.lang.Exception Thrown if LIBOR cannot be calculated
	 */

	public double libor (
		final int iStartDate,
		final java.lang.String strTenor)
		throws java.lang.Exception
	{
<span class="pc bpc" id="L481" title="3 of 6 branches missed.">		if (!org.drip.numerical.common.NumberUtil.IsValid (iStartDate) || null == strTenor || strTenor.isEmpty())</span>
<span class="nc" id="L482">			throw new java.lang.Exception (&quot;MergedDiscountForwardCurve::libor =&gt; Invalid Inputs&quot;);</span>

<span class="fc" id="L484">		return libor (iStartDate, new org.drip.analytics.date.JulianDate (iStartDate).addTenor</span>
<span class="fc" id="L485">			(strTenor).julian());</span>
	}

	/**
	 * Calculate the LIBOR to the given tenor at the specified Julian Date
	 * 
	 * @param dt Julian Date
	 * @param strTenor Tenor
	 * 
	 * @return LIBOR
	 * 
	 * @throws java.lang.Exception Thrown if LIBOR cannot be calculated
	 */

	public double libor (
		final org.drip.analytics.date.JulianDate dt,
		final java.lang.String strTenor)
		throws java.lang.Exception
	{
<span class="pc bpc" id="L504" title="1 of 2 branches missed.">		if (null == dt)</span>
<span class="nc" id="L505">			throw new java.lang.Exception (&quot;MergedDiscountForwardCurve::libor =&gt; Invalid Inputs&quot;);</span>

<span class="fc" id="L507">		return libor (dt.julian(), strTenor);</span>
	}

	/**
	 * Calculate the DV01 of the Par Swap that Matures at the given date
	 * 
	 * @param iDate Date
	 * 
	 * @return DV01 of the Par Swap that Matures at the given date
	 * 
	 * @throws java.lang.Exception Thrown if DV01 cannot be calculated
	 */

	public double parSwapDV01 (
		final int iDate)
		throws java.lang.Exception
	{
<span class="fc" id="L524">		java.lang.String strCurrency = currency();</span>

<span class="fc" id="L526">		org.drip.analytics.date.JulianDate dtStart = epoch().addDays (2);</span>

<span class="fc" id="L528">		org.drip.param.period.UnitCouponAccrualSetting ucasFixed = new</span>
			org.drip.param.period.UnitCouponAccrualSetting (2, &quot;Act/360&quot;, false, &quot;Act/360&quot;, false,
				strCurrency, true,
					org.drip.analytics.support.CompositePeriodBuilder.ACCRUAL_COMPOUNDING_RULE_GEOMETRIC);

<span class="fc" id="L533">		org.drip.param.period.ComposableFixedUnitSetting cfusFixed = new</span>
			org.drip.param.period.ComposableFixedUnitSetting (&quot;6M&quot;,
				org.drip.analytics.support.CompositePeriodBuilder.EDGE_DATE_SEQUENCE_REGULAR, null, 0., 0.,
					strCurrency);

<span class="fc" id="L538">		org.drip.param.period.CompositePeriodSetting cpsFixed = new</span>
			org.drip.param.period.CompositePeriodSetting (2, &quot;6M&quot;, strCurrency, null, 1., null, null, null,
				null);

<span class="fc" id="L542">		java.util.List&lt;java.lang.Integer&gt; lsFixedStreamEdgeDate =</span>
<span class="fc" id="L543">			org.drip.analytics.support.CompositePeriodBuilder.BackwardEdgeDates (dtStart, new</span>
				org.drip.analytics.date.JulianDate (iDate), &quot;6M&quot;, null,
					org.drip.analytics.support.CompositePeriodBuilder.SHORT_STUB);

<span class="fc" id="L547">		org.drip.product.rates.Stream fixedStream = new org.drip.product.rates.Stream</span>
<span class="fc" id="L548">			(org.drip.analytics.support.CompositePeriodBuilder.FixedCompositeUnit (lsFixedStreamEdgeDate,</span>
				cpsFixed, ucasFixed, cfusFixed));

<span class="fc" id="L551">		org.drip.param.market.CurveSurfaceQuoteContainer csqs =</span>
<span class="fc" id="L552">			org.drip.param.creator.MarketParamsBuilder.Create (this, null, null, null, null, null, null,</span>
				null);

<span class="fc" id="L555">		java.util.Map&lt;java.lang.String, java.lang.Double&gt; mapFixStream = fixedStream.value</span>
<span class="fc" id="L556">			(org.drip.param.valuation.ValuationParams.Spot (dtStart, 0, &quot;&quot;,</span>
				org.drip.analytics.daycount.Convention.DATE_ROLL_ACTUAL), null, csqs, null);

<span class="fc" id="L559">		return mapFixStream.get (&quot;DV01&quot;);</span>
	}

	/**
	 * Estimate the manifest measure value for the given date
	 * 
	 * @param strManifestMeasure The Manifest Measure to be Estimated
	 * @param iDate Date
	 * 
	 * @return The estimated calibrated measure value
	 * 
	 * @throws java.lang.Exception Thrown if the estimated manifest measure cannot be computed
	 */

	public double estimateManifestMeasure (
		final java.lang.String strManifestMeasure,
		final int iDate)
		throws java.lang.Exception
	{
<span class="pc bpc" id="L578" title="2 of 4 branches missed.">		if (null == strManifestMeasure || strManifestMeasure.isEmpty())</span>
<span class="nc" id="L579">			throw new java.lang.Exception</span>
				(&quot;MergedDiscountForwardCurve::estimateManifestMeasure =&gt; Invalid input&quot;);

<span class="fc" id="L582">		org.drip.product.definition.CalibratableComponent[] aCalibComp = calibComp();</span>

<span class="pc bpc" id="L584" title="1 of 2 branches missed.">		if (null == aCalibComp)</span>
<span class="nc" id="L585">			throw new java.lang.Exception</span>
				(&quot;MergedDiscountForwardCurve::estimateManifestMeasure =&gt; Calib Components not available&quot;);

<span class="fc" id="L588">		int iNumComponent = aCalibComp.length;</span>

<span class="pc bpc" id="L590" title="1 of 2 branches missed.">		if (0 == iNumComponent)</span>
<span class="nc" id="L591">			throw new java.lang.Exception</span>
				(&quot;MergedDiscountForwardCurve::estimateManifestMeasure =&gt; Calib Components not available&quot;);

<span class="fc" id="L594">		java.util.List&lt;java.lang.Integer&gt; lsDate = new java.util.ArrayList&lt;java.lang.Integer&gt;();</span>

<span class="fc" id="L596">		java.util.List&lt;java.lang.Double&gt; lsQuote = new java.util.ArrayList&lt;java.lang.Double&gt;();</span>

<span class="fc bfc" id="L598" title="All 2 branches covered.">		for (int i = 0; i &lt; iNumComponent; ++i) {</span>
<span class="pc bpc" id="L599" title="1 of 2 branches missed.">			if (null == aCalibComp[i])</span>
<span class="nc" id="L600">				throw new java.lang.Exception</span>
					(&quot;MergedDiscountForwardCurve::estimateManifestMeasure =&gt; Cannot locate a component&quot;);

<span class="fc" id="L603">			org.drip.analytics.support.CaseInsensitiveTreeMap&lt;java.lang.Double&gt; mapManifestMeasure =</span>
<span class="fc" id="L604">				manifestMeasure (aCalibComp[i].primaryCode());</span>

<span class="fc bfc" id="L606" title="All 2 branches covered.">			if (mapManifestMeasure.containsKey (strManifestMeasure)) {</span>
<span class="fc" id="L607">				lsDate.add (aCalibComp[i].maturityDate().julian());</span>

<span class="fc" id="L609">				lsQuote.add (mapManifestMeasure.get (strManifestMeasure));</span>
			}
		}

<span class="fc" id="L613">		int iNumEstimationComponent = lsDate.size();</span>

<span class="fc bfc" id="L615" title="All 2 branches covered.">		if (0 == iNumEstimationComponent)</span>
<span class="fc" id="L616">			throw new java.lang.Exception</span>
				(&quot;MergedDiscountForwardCurve::estimateManifestMeasure =&gt; Estimation Components not available&quot;);

<span class="fc" id="L619">		int[] aiDate = new int[iNumEstimationComponent];</span>
<span class="fc" id="L620">		double[] adblQuote = new double[iNumEstimationComponent];</span>
<span class="fc" id="L621">		org.drip.spline.params.SegmentCustomBuilderControl[] aSBP = new</span>
			org.drip.spline.params.SegmentCustomBuilderControl[iNumEstimationComponent - 1];

<span class="pc bpc" id="L624" title="1 of 2 branches missed.">		if (1 == iNumEstimationComponent) return lsQuote.get (0);</span>

<span class="fc" id="L626">		org.drip.spline.params.SegmentCustomBuilderControl sbp = new</span>
			org.drip.spline.params.SegmentCustomBuilderControl
				(org.drip.spline.stretch.MultiSegmentSequenceBuilder.BASIS_SPLINE_POLYNOMIAL, new
					org.drip.spline.basis.PolynomialFunctionSetParams (4),
<span class="fc" id="L630">						org.drip.spline.params.SegmentInelasticDesignControl.Create (2, 2), null, null);</span>

<span class="fc bfc" id="L632" title="All 2 branches covered.">		for (int i = 0; i &lt; iNumEstimationComponent; ++i) {</span>
<span class="fc bfc" id="L633" title="All 2 branches covered.">			if (0 != i) aSBP[i - 1] = sbp;</span>

<span class="fc" id="L635">			aiDate[i] = lsDate.get (i);</span>

<span class="fc" id="L637">			adblQuote[i] = lsQuote.get (i);</span>
		}

<span class="fc" id="L640">		org.drip.spline.stretch.MultiSegmentSequence regime =</span>
			org.drip.spline.stretch.MultiSegmentSequenceBuilder.CreateCalibratedStretchEstimator
<span class="fc" id="L642">				(&quot;DISC_CURVE_REGIME&quot;, aiDate, adblQuote, aSBP, null,</span>
<span class="fc" id="L643">					org.drip.spline.stretch.BoundarySettings.NaturalStandard(),</span>
						org.drip.spline.stretch.MultiSegmentSequence.CALIBRATE);

<span class="pc bpc" id="L646" title="1 of 2 branches missed.">		if (null == regime)</span>
<span class="nc" id="L647">			throw new java.lang.Exception</span>
				(&quot;MergedDiscountForwardCurve::estimateManifestMeasure =&gt; Cannot create Spline Stretch&quot;);

<span class="fc" id="L650">		double dblRegimeLeftExtreme = regime.getLeftPredictorOrdinateEdge();</span>

<span class="fc bfc" id="L652" title="All 2 branches covered.">		if (iDate &lt;= dblRegimeLeftExtreme) return regime.responseValue (dblRegimeLeftExtreme);</span>

<span class="fc" id="L654">		double dblRegimeRightExtreme = regime.getRightPredictorOrdinateEdge();</span>

<span class="pc bpc" id="L656" title="1 of 2 branches missed.">		if (iDate &gt;= dblRegimeRightExtreme) return regime.responseValue (dblRegimeRightExtreme);</span>

<span class="fc" id="L658">		return regime.responseValue (iDate);</span>
	}

	/**
	 * Proxy the Manifest Measure Value using the Closest Node for the given Date
	 * 
	 * @param strManifestMeasure The Manifest Measure to be Proxied
	 * @param iDate Date
	 * 
	 * @return The Measure Value Proxy
	 * 
	 * @throws java.lang.Exception Thrown if the Manifest Measure Proxy cannot be computed
	 */

	public double proxyManifestMeasure (
		final java.lang.String strManifestMeasure,
		final int iDate)
		throws java.lang.Exception
	{
<span class="pc bpc" id="L677" title="2 of 4 branches missed.">		if (null == strManifestMeasure || strManifestMeasure.isEmpty())</span>
<span class="nc" id="L678">			throw new java.lang.Exception</span>
				(&quot;MergedDiscountForwardCurve::proxyManifestMeasure =&gt; Invalid input&quot;);

<span class="fc" id="L681">		org.drip.product.definition.CalibratableComponent[] aCalibComp = calibComp();</span>

<span class="pc bpc" id="L683" title="1 of 2 branches missed.">		if (null == aCalibComp)</span>
<span class="nc" id="L684">			throw new java.lang.Exception</span>
				(&quot;MergedDiscountForwardCurve::proxyManifestMeasure =&gt; Calib Components not available&quot;);

<span class="fc" id="L687">		int iNumComponent = aCalibComp.length;</span>

<span class="pc bpc" id="L689" title="1 of 2 branches missed.">		if (0 == iNumComponent)</span>
<span class="nc" id="L690">			throw new java.lang.Exception</span>
				(&quot;MergedDiscountForwardCurve::proxyManifestMeasure =&gt; Calib Components not available&quot;);

<span class="fc" id="L693">		java.util.List&lt;java.lang.Integer&gt; lsDate = new java.util.ArrayList&lt;java.lang.Integer&gt;();</span>

<span class="fc" id="L695">		java.util.List&lt;java.lang.Double&gt; lsQuote = new java.util.ArrayList&lt;java.lang.Double&gt;();</span>

<span class="fc bfc" id="L697" title="All 2 branches covered.">		for (int i = 0; i &lt; iNumComponent; ++i) {</span>
<span class="pc bpc" id="L698" title="1 of 2 branches missed.">			if (null == aCalibComp[i])</span>
<span class="nc" id="L699">				throw new java.lang.Exception</span>
					(&quot;MergedDiscountForwardCurve::proxyManifestMeasure =&gt; Cannot locate a component&quot;);

<span class="fc" id="L702">			org.drip.analytics.support.CaseInsensitiveTreeMap&lt;java.lang.Double&gt; mapManifestMeasure =</span>
<span class="fc" id="L703">				manifestMeasure (aCalibComp[i].primaryCode());</span>

<span class="fc bfc" id="L705" title="All 2 branches covered.">			if (mapManifestMeasure.containsKey (strManifestMeasure)) {</span>
<span class="fc" id="L706">				lsDate.add (aCalibComp[i].maturityDate().julian());</span>

<span class="fc" id="L708">				lsQuote.add (mapManifestMeasure.get (strManifestMeasure));</span>
			}
		}

<span class="fc" id="L712">		int iNumEstimationComponent = lsDate.size();</span>

<span class="pc bpc" id="L714" title="1 of 2 branches missed.">		if (0 == iNumEstimationComponent)</span>
<span class="nc" id="L715">			throw new java.lang.Exception</span>
				(&quot;MergedDiscountForwardCurve::proxyManifestMeasure =&gt; Estimation Components not available&quot;);

<span class="pc bpc" id="L718" title="1 of 2 branches missed.">		if (1 == iNumEstimationComponent) return lsQuote.get (0);</span>

<span class="fc" id="L720">		int iDatePrev = lsDate.get (0);</span>

<span class="fc bfc" id="L722" title="All 2 branches covered.">		if (iDate &lt;= iDatePrev) return lsQuote.get (0);</span>

<span class="pc bpc" id="L724" title="1 of 2 branches missed.">		for (int i = 1; i &lt; iNumEstimationComponent; ++i) {</span>
<span class="fc" id="L725">			int iDateCurr = lsDate.get (i);</span>

<span class="pc bpc" id="L727" title="1 of 4 branches missed.">			if (iDatePrev &lt;= iDate &amp;&amp; iDate &lt; iDateCurr)</span>
<span class="fc bfc" id="L728" title="All 2 branches covered.">				return iDate - iDatePrev &gt; iDateCurr - iDate ? lsQuote.get (i) : lsQuote.get (i - 1);</span>

<span class="fc" id="L730">			iDatePrev = iDateCurr;</span>
		}

<span class="nc" id="L733">		return lsQuote.get (iNumEstimationComponent - 1);</span>
	}

	@Override public boolean setCCIS (
		final org.drip.analytics.input.CurveConstructionInputSet ccis)
	{
<span class="pc bpc" id="L739" title="1 of 2 branches missed.">		if (null == ccis) return false;</span>

<span class="fc" id="L741">		_ccis = ccis;</span>
<span class="fc" id="L742">		return true;</span>
	}

	/**
	 * Retrieve the Forward Curve that might be implied by the Latent State of this Discount Curve Instance
	 * 	corresponding to the specified Floating Rate Index
	 * 
	 * @param iDate The Date
	 * @param fri The Floating Rate Index
	 * 
	 * @return The Forward Curve Implied by the Discount Curve Latent State
	 */

	public abstract org.drip.state.forward.ForwardRateEstimator forwardRateEstimator (
		final int iDate,
		final org.drip.state.identifier.ForwardLabel fri);

	/**
	 * Retrieve the Latent State Quantification Metric
	 * 
	 * @return The Latent State Quantification Metric
	 */

	public abstract java.lang.String latentStateQuantificationMetric();

	/**
	 * Retrieve the Manifest Measure Jacobian of the Discount Factor to the given date
	 * 
	 * @param iDate Date
	 * @param strManifestMeasure Manifest Measure
	 * 
	 * @return The Manifest Measure Jacobian of the Discount Factor to the given date
	 */

	public abstract org.drip.numerical.differentiation.WengertJacobian jackDDFDManifestMeasure (
		final int iDate,
		final java.lang.String strManifestMeasure);

	/**
	 * Retrieve the Manifest Measure Jacobian of the Discount Factor to the given date
	 * 
	 * @param dt Date
	 * @param strManifestMeasure Manifest Measure
	 * 
	 * @return The Manifest Measure Jacobian of the Discount Factor to the given date
	 */

	public org.drip.numerical.differentiation.WengertJacobian jackDDFDManifestMeasure (
		final org.drip.analytics.date.JulianDate dt,
		final java.lang.String strManifestMeasure)
	{
<span class="pc bpc" id="L793" title="1 of 2 branches missed.">		if (null == dt) return null;</span>

<span class="fc" id="L795">		return jackDDFDManifestMeasure (dt.julian(), strManifestMeasure);</span>
	}

	/**
	 * Retrieve the Manifest Measure Jacobian of the Discount Factor to the date implied by the given Tenor
	 * 
	 * @param strTenor Tenor
	 * @param strManifestMeasure Manifest Measure
	 * 
	 * @return The Manifest Measure Jacobian of the Discount Factor to the date implied by the given Tenor
	 */

	public org.drip.numerical.differentiation.WengertJacobian jackDDFDManifestMeasure (
		final java.lang.String strTenor,
		final java.lang.String strManifestMeasure)
	{
<span class="nc bnc" id="L811" title="All 4 branches missed.">		if (null == strTenor || strTenor.isEmpty()) return null;</span>

		try {
<span class="nc" id="L814">			return jackDDFDManifestMeasure (epoch().addTenor (strTenor), strManifestMeasure);</span>
<span class="nc" id="L815">		} catch (java.lang.Exception e) {</span>
<span class="nc" id="L816">			e.printStackTrace();</span>
		}

<span class="nc" id="L819">		return null;</span>
	}

	/**
	 * Calculate the Jacobian of PV at the given date to the Manifest Measure of each component in the
	 * 	calibration set to the DF
	 * 
	 * @param iDate Date for which the Jacobian is needed
	 * 
	 * @return The Jacobian
	 */

	public org.drip.numerical.differentiation.WengertJacobian compJackDPVDManifestMeasure (
		final int iDate)
	{
<span class="pc bpc" id="L834" title="1 of 2 branches missed.">		if (!org.drip.numerical.common.NumberUtil.IsValid (iDate)) return null;</span>

<span class="fc" id="L836">		org.drip.product.definition.CalibratableComponent[] aCalibComp = calibComp();</span>

<span class="pc bpc" id="L838" title="1 of 4 branches missed.">		if (null == aCalibComp || 0 == aCalibComp.length) return null;</span>

<span class="fc" id="L840">		int iNumParameters = 0;</span>
<span class="fc" id="L841">		int iNumComponents = aCalibComp.length;</span>
<span class="fc" id="L842">		org.drip.numerical.differentiation.WengertJacobian wjCompPVDF = null;</span>

<span class="fc" id="L844">		org.drip.param.valuation.ValuationParams valParams = org.drip.param.valuation.ValuationParams.Spot</span>
<span class="fc" id="L845">			(iDate);</span>

<span class="pc bpc" id="L847" title="1 of 2 branches missed.">		org.drip.param.market.CurveSurfaceQuoteContainer csqs =</span>
<span class="fc" id="L848">			org.drip.param.creator.MarketParamsBuilder.Create (this, null, null, null, null, null,</span>
<span class="fc" id="L849">				null, null == _ccis ? null : _ccis.fixing());</span>

<span class="fc bfc" id="L851" title="All 2 branches covered.">		for (int i = 0; i &lt; iNumComponents; ++i) {</span>
<span class="fc" id="L852">			org.drip.numerical.differentiation.WengertJacobian wjCompDDirtyPVDManifestMeasure =</span>
<span class="fc" id="L853">				aCalibComp[i].jackDDirtyPVDManifestMeasure (valParams, null, csqs, null);</span>

<span class="pc bpc" id="L855" title="1 of 2 branches missed.">			if (null == wjCompDDirtyPVDManifestMeasure) return null;</span>

<span class="fc" id="L857">			iNumParameters = wjCompDDirtyPVDManifestMeasure.numParameters();</span>

<span class="fc bfc" id="L859" title="All 2 branches covered.">			if (null == wjCompPVDF) {</span>
				try {
<span class="fc" id="L861">					wjCompPVDF = new org.drip.numerical.differentiation.WengertJacobian (iNumComponents,</span>
						iNumParameters);
<span class="nc" id="L863">				} catch (java.lang.Exception e) {</span>
<span class="nc" id="L864">					e.printStackTrace();</span>

<span class="nc" id="L866">					return null;</span>
<span class="fc" id="L867">				}</span>
			}

<span class="fc bfc" id="L870" title="All 2 branches covered.">			for (int k = 0; k &lt; iNumParameters; ++k) {</span>
<span class="pc bpc" id="L871" title="1 of 2 branches missed.">				if (!wjCompPVDF.accumulatePartialFirstDerivative (i, k,</span>
<span class="fc" id="L872">					wjCompDDirtyPVDManifestMeasure.firstDerivative (0, k)))</span>
<span class="nc" id="L873">					return null;</span>
			}
		}

<span class="fc" id="L877">		return wjCompPVDF;</span>
	}

	/**
	 * Calculate the Jacobian of PV at the given date to the Manifest Measure of each component in the
	 * 	calibration set to the DF
	 * 
	 * @param dt Date for which the Jacobian is needed
	 * 
	 * @return The Jacobian
	 */

	public org.drip.numerical.differentiation.WengertJacobian compJackDPVDManifestMeasure (
		final org.drip.analytics.date.JulianDate dt)
	{
<span class="pc bpc" id="L892" title="1 of 2 branches missed.">		return null == dt ? null : compJackDPVDManifestMeasure (dt.julian());</span>
	}

	/**
	 * Retrieve the Jacobian of the Forward Rate to the Manifest Measure between the given dates
	 * 
	 * @param iDate1 Date 1
	 * @param iDate2 Date 2
	 * @param strManifestMeasure Manifest Measure
	 * @param dblElapsedYear The Elapsed Year (in the appropriate Day Count) between dates 1 and 2
	 * 
	 * @return The Jacobian
	 */

	public org.drip.numerical.differentiation.WengertJacobian jackDForwardDManifestMeasure (
		final int iDate1,
		final int iDate2,
		final java.lang.String strManifestMeasure,
		final double dblElapsedYear)
	{
<span class="nc bnc" id="L912" title="All 2 branches missed.">		if (iDate1 == iDate2) return null;</span>

<span class="nc" id="L914">		org.drip.numerical.differentiation.WengertJacobian wjDDFDManifestMeasureDate1 = jackDDFDManifestMeasure</span>
<span class="nc" id="L915">			(iDate1, strManifestMeasure);</span>

<span class="nc bnc" id="L917" title="All 2 branches missed.">		if (null == wjDDFDManifestMeasureDate1) return null;</span>

<span class="nc" id="L919">		int iNumQuote = wjDDFDManifestMeasureDate1.numParameters();</span>

<span class="nc bnc" id="L921" title="All 2 branches missed.">		if (0 == iNumQuote) return null;</span>

<span class="nc" id="L923">		org.drip.numerical.differentiation.WengertJacobian wjDDFDManifestMeasureDate2 = jackDDFDManifestMeasure</span>
<span class="nc" id="L924">			(iDate2, strManifestMeasure);</span>

<span class="nc bnc" id="L926" title="All 4 branches missed.">		if (null == wjDDFDManifestMeasureDate2 || iNumQuote != wjDDFDManifestMeasureDate2.numParameters())</span>
<span class="nc" id="L927">			return null;</span>

<span class="nc" id="L929">		double dblDF1 = java.lang.Double.NaN;</span>
<span class="nc" id="L930">		double dblDF2 = java.lang.Double.NaN;</span>
<span class="nc" id="L931">		org.drip.numerical.differentiation.WengertJacobian wjDForwardDManifestMeasure = null;</span>

		try {
<span class="nc" id="L934">			dblDF1 = df (iDate1);</span>

<span class="nc" id="L936">			dblDF2 = df (iDate2);</span>

<span class="nc" id="L938">			wjDForwardDManifestMeasure = new org.drip.numerical.differentiation.WengertJacobian (1, iNumQuote);</span>
<span class="nc" id="L939">		} catch (java.lang.Exception e) {</span>
<span class="nc" id="L940">			e.printStackTrace();</span>

<span class="nc" id="L942">			return null;</span>
<span class="nc" id="L943">		}</span>

<span class="nc" id="L945">		double dblDForwardDManifestMeasure1iScale = 1. / dblDF2;</span>
<span class="nc" id="L946">		double dblDForwardDManifestMeasure2iScale = dblDF1 / (dblDF2 * dblDF2);</span>
<span class="nc" id="L947">		double dblInverseAnnualizedTenorLength = 1. / dblElapsedYear;</span>

<span class="nc bnc" id="L949" title="All 2 branches missed.">		for (int i = 0; i &lt; iNumQuote; ++i) {</span>
<span class="nc" id="L950">			double dblDForwardDQManifestMeasurei = ((wjDDFDManifestMeasureDate1.firstDerivative (0, i) *</span>
<span class="nc" id="L951">				dblDForwardDManifestMeasure1iScale) - (wjDDFDManifestMeasureDate2.firstDerivative (0, i) *</span>
					dblDForwardDManifestMeasure2iScale)) * dblInverseAnnualizedTenorLength;

<span class="nc bnc" id="L954" title="All 2 branches missed.">			if (!wjDForwardDManifestMeasure.accumulatePartialFirstDerivative (0, i,</span>
				dblDForwardDQManifestMeasurei))
<span class="nc" id="L956">				return null;</span>
		}

<span class="nc" id="L959">		return wjDForwardDManifestMeasure;</span>
	}

	/**
	 * Retrieve the Jacobian of the Forward Rate to the Manifest Measure between the given dates
	 * 
	 * @param dt1 Julian Date 1
	 * @param dt2 Julian Date 2
	 * @param strManifestMeasure Manifest Measure
	 * @param dblElapsedYear The Elapsed Year (in the appropriate Day Count) between dates 1 and 2
	 * 
	 * @return The Jacobian
	 */

	public org.drip.numerical.differentiation.WengertJacobian jackDForwardDManifestMeasure (
		final org.drip.analytics.date.JulianDate dt1,
		final org.drip.analytics.date.JulianDate dt2,
		final java.lang.String strManifestMeasure,
		final double dblElapsedYear)
	{
<span class="nc bnc" id="L979" title="All 4 branches missed.">		if (null == dt1 || null == dt2) return null;</span>

<span class="nc" id="L981">		return jackDForwardDManifestMeasure (dt1.julian(), dt2.julian(), strManifestMeasure, dblElapsedYear);</span>
	}

	/**
	 * Retrieve the Jacobian of the Forward Rate to the Manifest Measure at the given date
	 * 
	 * @param dt Given Julian Date
	 * @param strTenor Tenor
	 * @param strManifestMeasure Manifest Measure
	 * @param dblElapsedYear The Elapsed Year (in the appropriate Day Count) implied by the Tenor
	 * 
	 * @return The Jacobian
	 */

	public org.drip.numerical.differentiation.WengertJacobian jackDForwardDManifestMeasure (
		final org.drip.analytics.date.JulianDate dt,
		final java.lang.String strTenor,
		final java.lang.String strManifestMeasure,
		final double dblElapsedYear)
	{
<span class="nc bnc" id="L1001" title="All 6 branches missed.">		if (null == dt || null == strTenor || strTenor.isEmpty()) return null;</span>

<span class="nc" id="L1003">		return jackDForwardDManifestMeasure (dt.julian(), dt.addTenor (strTenor).julian(),</span>
			strManifestMeasure, dblElapsedYear);
	}

	/**
	 * Retrieve the Jacobian for the Zero Rate to the given date
	 * 
	 * @param iDate Date
	 * @param strManifestMeasure Manifest Measure
	 * 
	 * @return The Jacobian
	 */

	public org.drip.numerical.differentiation.WengertJacobian zeroRateJack (
		final int iDate,
		final java.lang.String strManifestMeasure)
	{
<span class="nc" id="L1020">		int iEpochDate = epoch().julian();</span>

<span class="nc" id="L1022">		return jackDForwardDManifestMeasure (iEpochDate, iDate, strManifestMeasure, 1. * (iDate - iEpochDate) /</span>
			365.25);
	}

	/**
	 * Retrieve the Jacobian for the Zero Rate to the given date
	 * 
	 * @param dt Julian Date
	 * @param strManifestMeasure Manifest Measure
	 * 
	 * @return The Jacobian
	 */

	public org.drip.numerical.differentiation.WengertJacobian zeroRateJack (
		final org.drip.analytics.date.JulianDate dt,
		final java.lang.String strManifestMeasure)
	{
<span class="nc bnc" id="L1039" title="All 2 branches missed.">		return null == dt? null : zeroRateJack (dt.julian(), strManifestMeasure);</span>
	}

	/**
	 * Convert the inferred Formulation Constraint into a &quot;Truthness&quot; Entity
	 * 
	 * @param strLatentStateQuantificationMetric Latent State Quantification Metric
	 * 
	 * @return Map of the Truthness Entities
	 */

	public java.util.Map&lt;java.lang.Integer, java.lang.Double&gt; canonicalTruthness (
		final java.lang.String strLatentStateQuantificationMetric)
	{
<span class="pc bpc" id="L1053" title="1 of 2 branches missed.">		if (null == strLatentStateQuantificationMetric ||</span>
			(!org.drip.analytics.definition.LatentStateStatic.DISCOUNT_QM_ZERO_RATE.equalsIgnoreCase
<span class="pc bpc" id="L1055" title="1 of 2 branches missed.">				(strLatentStateQuantificationMetric) &amp;&amp; !</span>
					org.drip.analytics.definition.LatentStateStatic.DISCOUNT_QM_DISCOUNT_FACTOR.equalsIgnoreCase
<span class="nc bnc" id="L1057" title="All 2 branches missed.">			(strLatentStateQuantificationMetric)))</span>
<span class="nc" id="L1058">			return null;</span>

<span class="fc" id="L1060">		org.drip.product.definition.CalibratableComponent[] aCC = calibComp();</span>

<span class="pc bpc" id="L1062" title="1 of 2 branches missed.">		if (null == aCC) return null;</span>

<span class="fc" id="L1064">		int iNumComp = aCC.length;</span>
<span class="fc" id="L1065">		boolean bFirstCashFlow = true;</span>

<span class="pc bpc" id="L1067" title="1 of 2 branches missed.">		if (0 == iNumComp) return null;</span>

<span class="fc" id="L1069">		java.util.Map&lt;java.lang.Integer, java.lang.Double&gt; mapCanonicalTruthness = new</span>
			java.util.TreeMap&lt;java.lang.Integer, java.lang.Double&gt;();

<span class="fc" id="L1072">		if (org.drip.analytics.definition.LatentStateStatic.DISCOUNT_QM_DISCOUNT_FACTOR.equalsIgnoreCase</span>
<span class="pc bpc" id="L1073" title="1 of 2 branches missed.">			(strLatentStateQuantificationMetric))</span>
<span class="nc" id="L1074">			mapCanonicalTruthness.put (_iEpochDate, 1.);</span>

<span class="fc bfc" id="L1076" title="All 2 branches covered.">		for (org.drip.product.definition.CalibratableComponent cc : aCC) {</span>
<span class="pc bpc" id="L1077" title="1 of 2 branches missed.">			if (null == cc) continue;</span>

<span class="fc" id="L1079">			java.util.List&lt;org.drip.analytics.cashflow.CompositePeriod&gt; lsCouponPeriod = cc.couponPeriods();</span>

<span class="pc bpc" id="L1081" title="2 of 4 branches missed.">			if (null == lsCouponPeriod || 0 == lsCouponPeriod.size()) continue;</span>

<span class="fc bfc" id="L1083" title="All 2 branches covered.">			for (org.drip.analytics.cashflow.CompositePeriod cpnPeriod : lsCouponPeriod) {</span>
<span class="pc bpc" id="L1084" title="1 of 2 branches missed.">				if (null == cpnPeriod) continue;</span>

<span class="fc" id="L1086">				int iPeriodPayDate = cpnPeriod.payDate();</span>

<span class="pc bpc" id="L1088" title="1 of 2 branches missed.">				if (iPeriodPayDate &gt;= _iEpochDate) {</span>
					try {
<span class="fc" id="L1090">						if (org.drip.analytics.definition.LatentStateStatic.DISCOUNT_QM_DISCOUNT_FACTOR.equalsIgnoreCase</span>
<span class="pc bpc" id="L1091" title="1 of 2 branches missed.">							(strLatentStateQuantificationMetric))</span>
<span class="nc" id="L1092">							mapCanonicalTruthness.put (iPeriodPayDate, df (iPeriodPayDate));</span>
<span class="fc" id="L1093">						else if (org.drip.analytics.definition.LatentStateStatic.DISCOUNT_QM_ZERO_RATE.equalsIgnoreCase</span>
<span class="pc bpc" id="L1094" title="1 of 2 branches missed.">							(strLatentStateQuantificationMetric)) {</span>
<span class="fc bfc" id="L1095" title="All 2 branches covered.">							if (bFirstCashFlow) {</span>
<span class="fc" id="L1096">								bFirstCashFlow = false;</span>

<span class="fc" id="L1098">								mapCanonicalTruthness.put (_iEpochDate, zero (iPeriodPayDate));</span>
							}

<span class="fc" id="L1101">							mapCanonicalTruthness.put (iPeriodPayDate, zero (iPeriodPayDate));</span>
						}
<span class="nc" id="L1103">					} catch (java.lang.Exception e) {</span>
<span class="nc" id="L1104">						e.printStackTrace();</span>

<span class="nc" id="L1106">						return null;</span>
<span class="fc" id="L1107">					}</span>
				}
<span class="fc" id="L1109">			}</span>
		}

<span class="fc" id="L1112">		return mapCanonicalTruthness;</span>
	}
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.7.9.201702052155</span></div></body></html>