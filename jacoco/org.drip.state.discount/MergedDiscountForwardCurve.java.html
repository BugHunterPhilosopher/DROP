<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>MergedDiscountForwardCurve.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">DROP</a> &gt; <a href="index.source.html" class="el_package">org.drip.state.discount</a> &gt; <span class="el_source">MergedDiscountForwardCurve.java</span></div><h1>MergedDiscountForwardCurve.java</h1><pre class="source lang-java linenums">
package org.drip.state.discount;

/*
 * -*- mode: java; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*-
 */

/*!
 * Copyright (C) 2019 Lakshmi Krishnamurthy
 * Copyright (C) 2018 Lakshmi Krishnamurthy
 * Copyright (C) 2017 Lakshmi Krishnamurthy
 * Copyright (C) 2016 Lakshmi Krishnamurthy
 * Copyright (C) 2015 Lakshmi Krishnamurthy
 * Copyright (C) 2014 Lakshmi Krishnamurthy
 * Copyright (C) 2013 Lakshmi Krishnamurthy
 * 
 *  This file is part of DROP, an open-source library targeting risk, transaction costs, exposure, margin
 *  	calculations, and portfolio construction within and across fixed income, credit, commodity, equity,
 *  	FX, and structured products.
 *  
 *  	https://lakshmidrip.github.io/DROP/
 *  
 *  DROP is composed of three main modules:
 *  
 *  - DROP Analytics Core - https://lakshmidrip.github.io/DROP-Analytics-Core/
 *  - DROP Portfolio Core - https://lakshmidrip.github.io/DROP-Portfolio-Core/
 *  - DROP Numerical Core - https://lakshmidrip.github.io/DROP-Numerical-Core/
 * 
 * 	DROP Analytics Core implements libraries for the following:
 * 	- Fixed Income Analytics
 * 	- Asset Backed Analytics
 * 	- XVA Analytics
 * 	- Exposure and Margin Analytics
 * 
 * 	DROP Portfolio Core implements libraries for the following:
 * 	- Asset Allocation Analytics
 * 	- Transaction Cost Analytics
 * 
 * 	DROP Numerical Core implements libraries for the following:
 * 	- Statistical Learning Library
 * 	- Numerical Optimizer Library
 * 	- Machine Learning Library
 * 	- Spline Builder Library
 * 
 * 	Documentation for DROP is Spread Over:
 * 
 * 	- Main                     =&gt; https://lakshmidrip.github.io/DROP/
 * 	- Wiki                     =&gt; https://github.com/lakshmiDRIP/DROP/wiki
 * 	- GitHub                   =&gt; https://github.com/lakshmiDRIP/DROP
 * 	- Javadoc                  =&gt; https://lakshmidrip.github.io/DROP/Javadoc/index.html
 * 	- Technical Specifications =&gt; https://github.com/lakshmiDRIP/DROP/tree/master/Docs/Internal
 * 	- Release Versions         =&gt; https://lakshmidrip.github.io/DROP/version.html
 * 	- Community Credits        =&gt; https://lakshmidrip.github.io/DROP/credits.html
 * 	- Issues Catalog           =&gt; https://github.com/lakshmiDRIP/DROP/issues
 * 	- JUnit                    =&gt; https://lakshmidrip.github.io/DROP/junit/index.html
 * 	- Jacoco                   =&gt; https://lakshmidrip.github.io/DROP/jacoco/index.html
 * 
 *  Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 *   	you may not use this file except in compliance with the License.
 *   
 *  You may obtain a copy of the License at
 *  	http://www.apache.org/licenses/LICENSE-2.0
 *  
 *  Unless required by applicable law or agreed to in writing, software
 *  	distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 *  	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  
 *  See the License for the specific language governing permissions and
 *  	limitations under the License.
 */

/**
 * &lt;i&gt;MergedDiscountForwardCurve&lt;/i&gt; is the Stub for the Merged Discount and Forward Curve Functionality. It
 * extends the both the Curve and the DiscountFactorEstimator instances by implementing their functions, and
 * exposing the following:
 *
 *  &lt;br&gt;&lt;br&gt;
 *  &lt;ul&gt;
 *  	&lt;li&gt;
 * 			Forward Rate to a specific date/tenor, and effective rate between a date interval
 *  	&lt;/li&gt;
 *  	&lt;li&gt;
 * 			Discount Factor to a specific date/tenor, and effective discount factor between a date interval
 *  	&lt;/li&gt;
 *  	&lt;li&gt;
 * 			Zero Rate to a specific date/tenor
 *  	&lt;/li&gt;
 *  	&lt;li&gt;
 *  		Value Jacobian for Forward rate, discount factor, and zero rate
 *  	&lt;/li&gt;
 *  	&lt;li&gt;
 *  		Cross Jacobian between each of Forward rate, discount factor, and zero rate
 *  	&lt;/li&gt;
 *  	&lt;li&gt;
 *  		Quote Jacobian to Forward rate, discount factor, and zero rate
 *  	&lt;/li&gt;
 *  	&lt;li&gt;
 *  		QM (DF/Zero/Forward) to Quote Jacobian
 *  	&lt;/li&gt;
 *  	&lt;li&gt;
 *  		Latent State Quantification Metric, and the canonical truthness transformations
 *  	&lt;/li&gt;
 *  	&lt;li&gt;
 *  		Implied/embedded ForwardRateEstimator
 *  	&lt;/li&gt;
 *  	&lt;li&gt;
 *  		Turns set/unset/adjust
 *  	&lt;/li&gt;
 *  &lt;/ul&gt;
 *
 *  &lt;br&gt;&lt;br&gt;
 *  &lt;ul&gt;
 *		&lt;li&gt;&lt;b&gt;Project&lt;/b&gt;       = &lt;a href = &quot;https://github.com/lakshmiDRIP/DROP/tree/master/src/main/java/org/drip/state&quot;&gt;State&lt;/a&gt;&lt;/li&gt;
 *		&lt;li&gt;&lt;b&gt;Package&lt;/b&gt;       = &lt;a href = &quot;https://github.com/lakshmiDRIP/DROP/tree/master/src/main/java/org/drip/state/discount&quot;&gt;Discount&lt;/a&gt;&lt;/li&gt;
 *		&lt;li&gt;&lt;b&gt;Specification&lt;/b&gt; = &lt;a href = &quot;https://github.com/lakshmiDRIP/DROP/tree/master/Docs/Internal/FixedIncome&quot;&gt;Fixed Income Analytics Library&lt;/a&gt;&lt;/li&gt;
 *  &lt;/ul&gt;
 * &lt;br&gt;&lt;br&gt;
 *
 * @author Lakshmi Krishnamurthy
 */

public abstract class MergedDiscountForwardCurve extends org.drip.state.discount.DiscountCurve {
	private static final int NUM_DF_QUADRATURES = 5;

<span class="fc" id="L125">	protected java.lang.String _strCurrency = &quot;&quot;;</span>
<span class="fc" id="L126">	protected int _iEpochDate = java.lang.Integer.MIN_VALUE;</span>
<span class="fc" id="L127">	protected org.drip.state.discount.TurnListDiscountFactor _tldf = null;</span>
<span class="fc" id="L128">	protected org.drip.analytics.input.CurveConstructionInputSet _ccis = null;</span>

	protected MergedDiscountForwardCurve (
		final int iEpochDate,
		final java.lang.String strCurrency,
		final org.drip.state.discount.TurnListDiscountFactor tldf)
		throws java.lang.Exception
<span class="fc" id="L135">	{</span>
<span class="pc bpc" id="L136" title="2 of 4 branches missed.">		if (null == (_strCurrency = strCurrency) || _strCurrency.isEmpty() ||</span>
<span class="pc bpc" id="L137" title="1 of 2 branches missed.">			!org.drip.quant.common.NumberUtil.IsValid (_iEpochDate = iEpochDate))</span>
<span class="nc" id="L138">			throw new java.lang.Exception (&quot;MergedDiscountForwardCurve ctr: Invalid Inputs&quot;);</span>

<span class="fc" id="L140">		_tldf = tldf;</span>
<span class="fc" id="L141">	}</span>

	@Override public org.drip.state.identifier.LatentStateLabel label()
	{
<span class="fc" id="L145">		return org.drip.state.identifier.FundingLabel.Standard (_strCurrency);</span>
	}

	@Override public java.lang.String currency()
	{
<span class="fc" id="L150">		return _strCurrency;</span>
	}

	@Override public org.drip.analytics.date.JulianDate epoch()
	{
		try {
<span class="fc" id="L156">			return new org.drip.analytics.date.JulianDate (_iEpochDate);</span>
<span class="nc" id="L157">		} catch (java.lang.Exception e) {</span>
<span class="nc" id="L158">			e.printStackTrace();</span>
		}

<span class="nc" id="L161">		return null;</span>
	}

	/**
	 * Set the Discount Curve Turns'
	 * 
	 * @param tldf Turn List Discount Factor
	 * 
	 * @return TRUE - Valid Turn List Discount Factor Set
	 */

	public boolean setTurns (
		final org.drip.state.discount.TurnListDiscountFactor tldf)
	{
<span class="pc bpc" id="L175" title="1 of 2 branches missed.">		return null != (_tldf = tldf);</span>
	}

	/**
	 * Apply the Turns' DF Adjustment
	 * 
	 * @param iStartDate Turn Start Date
	 * @param iFinishDate Turn Finish Date
	 * 
	 * @return Turns' DF Adjustment
	 * 
	 * @throws java.lang.Exception Thrown if the Inputs are invalid
	 */

	public double turnAdjust (
		final int iStartDate,
		final int iFinishDate)
		throws java.lang.Exception
	{
<span class="fc bfc" id="L194" title="All 2 branches covered.">		return null == _tldf ? 1. : _tldf.turnAdjust (iStartDate, iFinishDate);</span>
	}

	/**
	 * Apply the Turns' DF Adjustment
	 * 
	 * @param iFinishDate Turn Finish Date
	 * 
	 * @return Turns' DF Adjustment
	 * 
	 * @throws java.lang.Exception Thrown if the Inputs are invalid
	 */

	protected double turnAdjust (
		final int iFinishDate)
		throws java.lang.Exception
	{
<span class="nc" id="L211">		return turnAdjust (epoch().julian(), iFinishDate);</span>
	}

	/**
	 * Construct the Native Forward Curve for the given Tenor from the Discount Curve
	 * 
	 * @param strTenor The Tenor
	 * 
	 * @return The Tenor-Native Forward Curve
	 */

	public org.drip.state.forward.ForwardCurve nativeForwardCurve (
		final java.lang.String strTenor)
	{
<span class="pc bpc" id="L225" title="2 of 4 branches missed.">		if (null == strTenor || strTenor.isEmpty()) return null;</span>

		try {
<span class="fc" id="L228">			org.drip.state.forward.ForwardCurve fcNative = new org.drip.state.forward.ForwardCurve</span>
<span class="fc" id="L229">				(epoch().julian(), org.drip.state.identifier.ForwardLabel.Standard (_strCurrency + &quot;-&quot; +</span>
<span class="fc" id="L230">					strTenor)) {</span>
				@Override public double forward (
					final int iDate)
					throws java.lang.Exception
				{
<span class="fc" id="L235">					return forward (new org.drip.analytics.date.JulianDate (iDate));</span>
				}

				@Override public double forward (
					final org.drip.analytics.date.JulianDate dt)
					throws java.lang.Exception
				{
<span class="pc bpc" id="L242" title="1 of 2 branches missed.">					if (null == dt)</span>
<span class="nc" id="L243">						throw new java.lang.Exception</span>
							(&quot;MergedDiscountForwardCurve::nativeForwardCurve =&gt; Invalid Input&quot;);

<span class="fc" id="L246">					return libor (dt.subtractTenor (strTenor).julian(), strTenor);</span>
				}

				@Override public double forward (
					final java.lang.String strTenor)
					throws java.lang.Exception
				{
<span class="nc bnc" id="L253" title="All 4 branches missed.">					if (null == strTenor || strTenor.isEmpty())</span>
<span class="nc" id="L254">						throw new java.lang.Exception</span>
							(&quot;MergedDiscountForwardCurve::nativeForwardCurve =&gt; Invalid Input&quot;);

<span class="nc" id="L257">					return forward (epoch().addTenor (strTenor));</span>
				}

				@Override public org.drip.quant.calculus.WengertJacobian jackDForwardDManifestMeasure (
					final java.lang.String strManifestMeasure,
					final int iDate)
				{
<span class="nc" id="L264">					return null;</span>
				}
			};

<span class="fc" id="L268">			return fcNative;</span>
<span class="nc" id="L269">		} catch (java.lang.Exception e) {</span>
<span class="nc" id="L270">			e.printStackTrace();</span>
		}

<span class="nc" id="L273">		return null;</span>
	}

	@Override public double df (
		final org.drip.analytics.date.JulianDate dt)
		throws java.lang.Exception
	{
<span class="pc bpc" id="L280" title="1 of 2 branches missed.">		if (null == dt) throw new java.lang.Exception (&quot;MergedDiscountForwardCurve::df got null for date&quot;);</span>

<span class="fc" id="L282">		return df (dt.julian());</span>
	}

	@Override public double df (
		final java.lang.String strTenor)
		throws java.lang.Exception
	{
<span class="pc bpc" id="L289" title="2 of 4 branches missed.">		if (null == strTenor || strTenor.isEmpty())</span>
<span class="nc" id="L290">			throw new java.lang.Exception (&quot;MergedDiscountForwardCurve::df got bad tenor&quot;);</span>

<span class="fc" id="L292">		return df (epoch().addTenor (strTenor));</span>
	}

	@Override public double effectiveDF (
		final int iDate1,
		final int iDate2)
		throws java.lang.Exception
	{
<span class="fc bfc" id="L300" title="All 2 branches covered.">		if (iDate1 == iDate2) return df (iDate1);</span>

<span class="fc" id="L302">		int iNumQuadratures = 0;</span>
<span class="fc" id="L303">		double dblEffectiveDF = 0.;</span>
<span class="fc" id="L304">		int iQuadratureWidth = (iDate2 - iDate1) / NUM_DF_QUADRATURES;</span>

<span class="fc bfc" id="L306" title="All 2 branches covered.">		if (0 == iQuadratureWidth) iQuadratureWidth = 1;</span>

<span class="fc bfc" id="L308" title="All 2 branches covered.">		for (int iDate = iDate1; iDate &lt;= iDate2; iDate += iQuadratureWidth) {</span>
<span class="fc" id="L309">			++iNumQuadratures;</span>

<span class="fc" id="L311">			dblEffectiveDF += (df (iDate) + df (iDate + iQuadratureWidth));</span>
		}

<span class="fc" id="L314">		return dblEffectiveDF / (2. * iNumQuadratures);</span>
	}

	@Override public double effectiveDF (
		final org.drip.analytics.date.JulianDate dt1,
		final org.drip.analytics.date.JulianDate dt2)
		throws java.lang.Exception
	{
<span class="pc bpc" id="L322" title="2 of 4 branches missed.">		if (null == dt1 || null == dt2)</span>
<span class="nc" id="L323">			throw new java.lang.Exception (&quot;MergedDiscountForwardCurve::effectiveDF =&gt; Got null for date&quot;);</span>

<span class="fc" id="L325">		return effectiveDF (dt1.julian(), dt2.julian());</span>
	}

	@Override public double effectiveDF (
		final java.lang.String strTenor1,
		final java.lang.String strTenor2)
		throws java.lang.Exception
	{
<span class="pc bpc" id="L333" title="4 of 8 branches missed.">		if (null == strTenor1 || strTenor1.isEmpty() || null == strTenor2 || strTenor2.isEmpty())</span>
<span class="nc" id="L334">			throw new java.lang.Exception (&quot;MergedDiscountForwardCurve::effectiveDF =&gt; Got bad tenor&quot;);</span>

<span class="fc" id="L336">		org.drip.analytics.date.JulianDate dtStart = epoch();</span>

<span class="fc" id="L338">		return effectiveDF (dtStart.addTenor (strTenor1), dtStart.addTenor (strTenor2));</span>
	}

	/**
	 * Compute the Forward Rate between two Dates
	 * 
	 * @param iDate1 First Date
	 * @param iDate2 Second Date
	 * 
	 * @return The Forward Rate
	 * 
	 * @throws java.lang.Exception Thrown if the Forward Rate cannot be calculated
	 */

	public abstract double forward (
		final int iDate1,
		final int iDate2)
		throws java.lang.Exception;

	/**
	 * Compute the Forward Rate between two Tenors
	 * 
	 * @param strTenor1 Tenor Start
	 * @param strTenor2 Tenor End
	 * 
	 * @return The Forward Rate
	 * 
	 * @throws java.lang.Exception Thrown if the Forward Rate cannot be calculated
	 */

	public double forward (
		final java.lang.String strTenor1,
		final java.lang.String strTenor2)
		throws java.lang.Exception
	{
<span class="pc bpc" id="L373" title="4 of 8 branches missed.">		if (null == strTenor1 || strTenor1.isEmpty() || null == strTenor2 || strTenor2.isEmpty())</span>
<span class="nc" id="L374">			throw new java.lang.Exception (&quot;MergedDiscountForwardCurve::forward =&gt; Invalid Date&quot;);</span>

<span class="fc" id="L376">		org.drip.analytics.date.JulianDate dtStart = epoch();</span>

<span class="fc" id="L378">		return forward (dtStart.addTenor (strTenor1).julian(), dtStart.addTenor (strTenor2).julian());</span>
	}

	/**
	 * Calculate the implied rate to the given date
	 * 
	 * @param iDate Date
	 * 
	 * @return Implied rate
	 * 
	 * @throws java.lang.Exception Thrown if the discount factor cannot be calculated
	 */

	public abstract double zero (
		final int iDate)
		throws java.lang.Exception;

	/**
	 * Calculate the implied rate to the given tenor
	 * 
	 * @param strTenor Tenor
	 * 
	 * @return Implied rate
	 * 
	 * @throws java.lang.Exception Thrown if the discount factor cannot be calculated
	 */

	public double zero (
		final java.lang.String strTenor)
		throws java.lang.Exception
	{
<span class="pc bpc" id="L409" title="2 of 4 branches missed.">		if (null == strTenor || strTenor.isEmpty())</span>
<span class="nc" id="L410">			throw new java.lang.Exception (&quot;MergedDiscountForwardCurve::zero =&gt; Invalid date&quot;);</span>

<span class="fc" id="L412">		org.drip.analytics.date.JulianDate dtStart = epoch();</span>

<span class="fc" id="L414">		return forward (dtStart.julian(), dtStart.addTenor (strTenor).julian());</span>
	}

	/**
	 * Compute the LIBOR between 2 dates given the Day Count
	 * 
	 * @param iDate1 First Date
	 * @param iDate2 Second Date
	 * @param dblDCF Day Count Fraction
	 * 
	 * @return LIBOR
	 * 
	 * @throws java.lang.Exception Thrown if the discount factor cannot be calculated
	 */

	public double libor (
		final int iDate1,
		final int iDate2,
		final double dblDCF)
		throws java.lang.Exception
	{
<span class="pc bpc" id="L435" title="3 of 6 branches missed.">		if (iDate1 == iDate2 || !org.drip.quant.common.NumberUtil.IsValid (dblDCF) || 0. == dblDCF)</span>
<span class="nc" id="L436">			throw new java.lang.Exception (&quot;MergedDiscountForwardCurve::libor =&gt; Invalid input dates&quot;);</span>

<span class="fc" id="L438">		return ((df (iDate1) / df (iDate2)) - 1.) / dblDCF;</span>
	}

	/**
	 * Compute the LIBOR between 2 dates
	 * 
	 * @param iDate1 First Date
	 * @param iDate2 Second Date
	 * 
	 * @return LIBOR
	 * 
	 * @throws java.lang.Exception Thrown if the discount factor cannot be calculated
	 */

	public double libor (
		final int iDate1,
		final int iDate2)
		throws java.lang.Exception
	{
<span class="pc bpc" id="L457" title="1 of 2 branches missed.">		if (iDate1 == iDate2)</span>
<span class="nc" id="L458">			throw new java.lang.Exception (&quot;MergedDiscountForwardCurve::libor =&gt; Invalid input dates&quot;);</span>

<span class="fc" id="L460">		return libor (iDate1, iDate2, org.drip.analytics.daycount.Convention.YearFraction (iDate1, iDate2,</span>
			&quot;Act/360&quot;, false, null, &quot;&quot;));
	}

	/**
	 * Calculate the LIBOR to the given tenor at the specified date
	 * 
	 * @param iStartDate Start Date
	 * @param strTenor Tenor
	 * 
	 * @return LIBOR
	 * 
	 * @throws java.lang.Exception Thrown if LIBOR cannot be calculated
	 */

	public double libor (
		final int iStartDate,
		final java.lang.String strTenor)
		throws java.lang.Exception
	{
<span class="pc bpc" id="L480" title="3 of 6 branches missed.">		if (!org.drip.quant.common.NumberUtil.IsValid (iStartDate) || null == strTenor || strTenor.isEmpty())</span>
<span class="nc" id="L481">			throw new java.lang.Exception (&quot;MergedDiscountForwardCurve::libor =&gt; Invalid Inputs&quot;);</span>

<span class="fc" id="L483">		return libor (iStartDate, new org.drip.analytics.date.JulianDate (iStartDate).addTenor</span>
<span class="fc" id="L484">			(strTenor).julian());</span>
	}

	/**
	 * Calculate the LIBOR to the given tenor at the specified Julian Date
	 * 
	 * @param dt Julian Date
	 * @param strTenor Tenor
	 * 
	 * @return LIBOR
	 * 
	 * @throws java.lang.Exception Thrown if LIBOR cannot be calculated
	 */

	public double libor (
		final org.drip.analytics.date.JulianDate dt,
		final java.lang.String strTenor)
		throws java.lang.Exception
	{
<span class="pc bpc" id="L503" title="1 of 2 branches missed.">		if (null == dt)</span>
<span class="nc" id="L504">			throw new java.lang.Exception (&quot;MergedDiscountForwardCurve::libor =&gt; Invalid Inputs&quot;);</span>

<span class="fc" id="L506">		return libor (dt.julian(), strTenor);</span>
	}

	/**
	 * Calculate the DV01 of the Par Swap that Matures at the given date
	 * 
	 * @param iDate Date
	 * 
	 * @return DV01 of the Par Swap that Matures at the given date
	 * 
	 * @throws java.lang.Exception Thrown if DV01 cannot be calculated
	 */

	public double parSwapDV01 (
		final int iDate)
		throws java.lang.Exception
	{
<span class="fc" id="L523">		java.lang.String strCurrency = currency();</span>

<span class="fc" id="L525">		org.drip.analytics.date.JulianDate dtStart = epoch().addDays (2);</span>

<span class="fc" id="L527">		org.drip.param.period.UnitCouponAccrualSetting ucasFixed = new</span>
			org.drip.param.period.UnitCouponAccrualSetting (2, &quot;Act/360&quot;, false, &quot;Act/360&quot;, false,
				strCurrency, true,
					org.drip.analytics.support.CompositePeriodBuilder.ACCRUAL_COMPOUNDING_RULE_GEOMETRIC);

<span class="fc" id="L532">		org.drip.param.period.ComposableFixedUnitSetting cfusFixed = new</span>
			org.drip.param.period.ComposableFixedUnitSetting (&quot;6M&quot;,
				org.drip.analytics.support.CompositePeriodBuilder.EDGE_DATE_SEQUENCE_REGULAR, null, 0., 0.,
					strCurrency);

<span class="fc" id="L537">		org.drip.param.period.CompositePeriodSetting cpsFixed = new</span>
			org.drip.param.period.CompositePeriodSetting (2, &quot;6M&quot;, strCurrency, null, 1., null, null, null,
				null);

<span class="fc" id="L541">		java.util.List&lt;java.lang.Integer&gt; lsFixedStreamEdgeDate =</span>
<span class="fc" id="L542">			org.drip.analytics.support.CompositePeriodBuilder.BackwardEdgeDates (dtStart, new</span>
				org.drip.analytics.date.JulianDate (iDate), &quot;6M&quot;, null,
					org.drip.analytics.support.CompositePeriodBuilder.SHORT_STUB);

<span class="fc" id="L546">		org.drip.product.rates.Stream fixedStream = new org.drip.product.rates.Stream</span>
<span class="fc" id="L547">			(org.drip.analytics.support.CompositePeriodBuilder.FixedCompositeUnit (lsFixedStreamEdgeDate,</span>
				cpsFixed, ucasFixed, cfusFixed));

<span class="fc" id="L550">		org.drip.param.market.CurveSurfaceQuoteContainer csqs =</span>
<span class="fc" id="L551">			org.drip.param.creator.MarketParamsBuilder.Create (this, null, null, null, null, null, null,</span>
				null);

<span class="fc" id="L554">		java.util.Map&lt;java.lang.String, java.lang.Double&gt; mapFixStream = fixedStream.value</span>
<span class="fc" id="L555">			(org.drip.param.valuation.ValuationParams.Spot (dtStart, 0, &quot;&quot;,</span>
				org.drip.analytics.daycount.Convention.DATE_ROLL_ACTUAL), null, csqs, null);

<span class="fc" id="L558">		return mapFixStream.get (&quot;DV01&quot;);</span>
	}

	/**
	 * Estimate the manifest measure value for the given date
	 * 
	 * @param strManifestMeasure The Manifest Measure to be Estimated
	 * @param iDate Date
	 * 
	 * @return The estimated calibrated measure value
	 * 
	 * @throws java.lang.Exception Thrown if the estimated manifest measure cannot be computed
	 */

	public double estimateManifestMeasure (
		final java.lang.String strManifestMeasure,
		final int iDate)
		throws java.lang.Exception
	{
<span class="pc bpc" id="L577" title="2 of 4 branches missed.">		if (null == strManifestMeasure || strManifestMeasure.isEmpty())</span>
<span class="nc" id="L578">			throw new java.lang.Exception</span>
				(&quot;MergedDiscountForwardCurve::estimateManifestMeasure =&gt; Invalid input&quot;);

<span class="fc" id="L581">		org.drip.product.definition.CalibratableComponent[] aCalibComp = calibComp();</span>

<span class="pc bpc" id="L583" title="1 of 2 branches missed.">		if (null == aCalibComp)</span>
<span class="nc" id="L584">			throw new java.lang.Exception</span>
				(&quot;MergedDiscountForwardCurve::estimateManifestMeasure =&gt; Calib Components not available&quot;);

<span class="fc" id="L587">		int iNumComponent = aCalibComp.length;</span>

<span class="pc bpc" id="L589" title="1 of 2 branches missed.">		if (0 == iNumComponent)</span>
<span class="nc" id="L590">			throw new java.lang.Exception</span>
				(&quot;MergedDiscountForwardCurve::estimateManifestMeasure =&gt; Calib Components not available&quot;);

<span class="fc" id="L593">		java.util.List&lt;java.lang.Integer&gt; lsDate = new java.util.ArrayList&lt;java.lang.Integer&gt;();</span>

<span class="fc" id="L595">		java.util.List&lt;java.lang.Double&gt; lsQuote = new java.util.ArrayList&lt;java.lang.Double&gt;();</span>

<span class="fc bfc" id="L597" title="All 2 branches covered.">		for (int i = 0; i &lt; iNumComponent; ++i) {</span>
<span class="pc bpc" id="L598" title="1 of 2 branches missed.">			if (null == aCalibComp[i])</span>
<span class="nc" id="L599">				throw new java.lang.Exception</span>
					(&quot;MergedDiscountForwardCurve::estimateManifestMeasure =&gt; Cannot locate a component&quot;);

<span class="fc" id="L602">			org.drip.analytics.support.CaseInsensitiveTreeMap&lt;java.lang.Double&gt; mapManifestMeasure =</span>
<span class="fc" id="L603">				manifestMeasure (aCalibComp[i].primaryCode());</span>

<span class="fc bfc" id="L605" title="All 2 branches covered.">			if (mapManifestMeasure.containsKey (strManifestMeasure)) {</span>
<span class="fc" id="L606">				lsDate.add (aCalibComp[i].maturityDate().julian());</span>

<span class="fc" id="L608">				lsQuote.add (mapManifestMeasure.get (strManifestMeasure));</span>
			}
		}

<span class="fc" id="L612">		int iNumEstimationComponent = lsDate.size();</span>

<span class="fc bfc" id="L614" title="All 2 branches covered.">		if (0 == iNumEstimationComponent)</span>
<span class="fc" id="L615">			throw new java.lang.Exception</span>
				(&quot;MergedDiscountForwardCurve::estimateManifestMeasure =&gt; Estimation Components not available&quot;);

<span class="fc" id="L618">		int[] aiDate = new int[iNumEstimationComponent];</span>
<span class="fc" id="L619">		double[] adblQuote = new double[iNumEstimationComponent];</span>
<span class="fc" id="L620">		org.drip.spline.params.SegmentCustomBuilderControl[] aSBP = new</span>
			org.drip.spline.params.SegmentCustomBuilderControl[iNumEstimationComponent - 1];

<span class="pc bpc" id="L623" title="1 of 2 branches missed.">		if (1 == iNumEstimationComponent) return lsQuote.get (0);</span>

<span class="fc" id="L625">		org.drip.spline.params.SegmentCustomBuilderControl sbp = new</span>
			org.drip.spline.params.SegmentCustomBuilderControl
				(org.drip.spline.stretch.MultiSegmentSequenceBuilder.BASIS_SPLINE_POLYNOMIAL, new
					org.drip.spline.basis.PolynomialFunctionSetParams (4),
<span class="fc" id="L629">						org.drip.spline.params.SegmentInelasticDesignControl.Create (2, 2), null, null);</span>

<span class="fc bfc" id="L631" title="All 2 branches covered.">		for (int i = 0; i &lt; iNumEstimationComponent; ++i) {</span>
<span class="fc bfc" id="L632" title="All 2 branches covered.">			if (0 != i) aSBP[i - 1] = sbp;</span>

<span class="fc" id="L634">			aiDate[i] = lsDate.get (i);</span>

<span class="fc" id="L636">			adblQuote[i] = lsQuote.get (i);</span>
		}

<span class="fc" id="L639">		org.drip.spline.stretch.MultiSegmentSequence regime =</span>
			org.drip.spline.stretch.MultiSegmentSequenceBuilder.CreateCalibratedStretchEstimator
<span class="fc" id="L641">				(&quot;DISC_CURVE_REGIME&quot;, aiDate, adblQuote, aSBP, null,</span>
<span class="fc" id="L642">					org.drip.spline.stretch.BoundarySettings.NaturalStandard(),</span>
						org.drip.spline.stretch.MultiSegmentSequence.CALIBRATE);

<span class="pc bpc" id="L645" title="1 of 2 branches missed.">		if (null == regime)</span>
<span class="nc" id="L646">			throw new java.lang.Exception</span>
				(&quot;MergedDiscountForwardCurve::estimateManifestMeasure =&gt; Cannot create Spline Stretch&quot;);

<span class="fc" id="L649">		double dblRegimeLeftExtreme = regime.getLeftPredictorOrdinateEdge();</span>

<span class="fc bfc" id="L651" title="All 2 branches covered.">		if (iDate &lt;= dblRegimeLeftExtreme) return regime.responseValue (dblRegimeLeftExtreme);</span>

<span class="fc" id="L653">		double dblRegimeRightExtreme = regime.getRightPredictorOrdinateEdge();</span>

<span class="pc bpc" id="L655" title="1 of 2 branches missed.">		if (iDate &gt;= dblRegimeRightExtreme) return regime.responseValue (dblRegimeRightExtreme);</span>

<span class="fc" id="L657">		return regime.responseValue (iDate);</span>
	}

	/**
	 * Proxy the Manifest Measure Value using the Closest Node for the given Date
	 * 
	 * @param strManifestMeasure The Manifest Measure to be Proxied
	 * @param iDate Date
	 * 
	 * @return The Measure Value Proxy
	 * 
	 * @throws java.lang.Exception Thrown if the Manifest Measure Proxy cannot be computed
	 */

	public double proxyManifestMeasure (
		final java.lang.String strManifestMeasure,
		final int iDate)
		throws java.lang.Exception
	{
<span class="pc bpc" id="L676" title="2 of 4 branches missed.">		if (null == strManifestMeasure || strManifestMeasure.isEmpty())</span>
<span class="nc" id="L677">			throw new java.lang.Exception</span>
				(&quot;MergedDiscountForwardCurve::proxyManifestMeasure =&gt; Invalid input&quot;);

<span class="fc" id="L680">		org.drip.product.definition.CalibratableComponent[] aCalibComp = calibComp();</span>

<span class="pc bpc" id="L682" title="1 of 2 branches missed.">		if (null == aCalibComp)</span>
<span class="nc" id="L683">			throw new java.lang.Exception</span>
				(&quot;MergedDiscountForwardCurve::proxyManifestMeasure =&gt; Calib Components not available&quot;);

<span class="fc" id="L686">		int iNumComponent = aCalibComp.length;</span>

<span class="pc bpc" id="L688" title="1 of 2 branches missed.">		if (0 == iNumComponent)</span>
<span class="nc" id="L689">			throw new java.lang.Exception</span>
				(&quot;MergedDiscountForwardCurve::proxyManifestMeasure =&gt; Calib Components not available&quot;);

<span class="fc" id="L692">		java.util.List&lt;java.lang.Integer&gt; lsDate = new java.util.ArrayList&lt;java.lang.Integer&gt;();</span>

<span class="fc" id="L694">		java.util.List&lt;java.lang.Double&gt; lsQuote = new java.util.ArrayList&lt;java.lang.Double&gt;();</span>

<span class="fc bfc" id="L696" title="All 2 branches covered.">		for (int i = 0; i &lt; iNumComponent; ++i) {</span>
<span class="pc bpc" id="L697" title="1 of 2 branches missed.">			if (null == aCalibComp[i])</span>
<span class="nc" id="L698">				throw new java.lang.Exception</span>
					(&quot;MergedDiscountForwardCurve::proxyManifestMeasure =&gt; Cannot locate a component&quot;);

<span class="fc" id="L701">			org.drip.analytics.support.CaseInsensitiveTreeMap&lt;java.lang.Double&gt; mapManifestMeasure =</span>
<span class="fc" id="L702">				manifestMeasure (aCalibComp[i].primaryCode());</span>

<span class="fc bfc" id="L704" title="All 2 branches covered.">			if (mapManifestMeasure.containsKey (strManifestMeasure)) {</span>
<span class="fc" id="L705">				lsDate.add (aCalibComp[i].maturityDate().julian());</span>

<span class="fc" id="L707">				lsQuote.add (mapManifestMeasure.get (strManifestMeasure));</span>
			}
		}

<span class="fc" id="L711">		int iNumEstimationComponent = lsDate.size();</span>

<span class="pc bpc" id="L713" title="1 of 2 branches missed.">		if (0 == iNumEstimationComponent)</span>
<span class="nc" id="L714">			throw new java.lang.Exception</span>
				(&quot;MergedDiscountForwardCurve::proxyManifestMeasure =&gt; Estimation Components not available&quot;);

<span class="pc bpc" id="L717" title="1 of 2 branches missed.">		if (1 == iNumEstimationComponent) return lsQuote.get (0);</span>

<span class="fc" id="L719">		int iDatePrev = lsDate.get (0);</span>

<span class="fc bfc" id="L721" title="All 2 branches covered.">		if (iDate &lt;= iDatePrev) return lsQuote.get (0);</span>

<span class="pc bpc" id="L723" title="1 of 2 branches missed.">		for (int i = 1; i &lt; iNumEstimationComponent; ++i) {</span>
<span class="fc" id="L724">			int iDateCurr = lsDate.get (i);</span>

<span class="pc bpc" id="L726" title="1 of 4 branches missed.">			if (iDatePrev &lt;= iDate &amp;&amp; iDate &lt; iDateCurr)</span>
<span class="fc bfc" id="L727" title="All 2 branches covered.">				return iDate - iDatePrev &gt; iDateCurr - iDate ? lsQuote.get (i) : lsQuote.get (i - 1);</span>

<span class="fc" id="L729">			iDatePrev = iDateCurr;</span>
		}

<span class="nc" id="L732">		return lsQuote.get (iNumEstimationComponent - 1);</span>
	}

	@Override public boolean setCCIS (
		final org.drip.analytics.input.CurveConstructionInputSet ccis)
	{
<span class="pc bpc" id="L738" title="1 of 2 branches missed.">		if (null == ccis) return false;</span>

<span class="fc" id="L740">		_ccis = ccis;</span>
<span class="fc" id="L741">		return true;</span>
	}

	/**
	 * Retrieve the Forward Curve that might be implied by the Latent State of this Discount Curve Instance
	 * 	corresponding to the specified Floating Rate Index
	 * 
	 * @param iDate The Date
	 * @param fri The Floating Rate Index
	 * 
	 * @return The Forward Curve Implied by the Discount Curve Latent State
	 */

	public abstract org.drip.state.forward.ForwardRateEstimator forwardRateEstimator (
		final int iDate,
		final org.drip.state.identifier.ForwardLabel fri);

	/**
	 * Retrieve the Latent State Quantification Metric
	 * 
	 * @return The Latent State Quantification Metric
	 */

	public abstract java.lang.String latentStateQuantificationMetric();

	/**
	 * Retrieve the Manifest Measure Jacobian of the Discount Factor to the given date
	 * 
	 * @param iDate Date
	 * @param strManifestMeasure Manifest Measure
	 * 
	 * @return The Manifest Measure Jacobian of the Discount Factor to the given date
	 */

	public abstract org.drip.quant.calculus.WengertJacobian jackDDFDManifestMeasure (
		final int iDate,
		final java.lang.String strManifestMeasure);

	/**
	 * Retrieve the Manifest Measure Jacobian of the Discount Factor to the given date
	 * 
	 * @param dt Date
	 * @param strManifestMeasure Manifest Measure
	 * 
	 * @return The Manifest Measure Jacobian of the Discount Factor to the given date
	 */

	public org.drip.quant.calculus.WengertJacobian jackDDFDManifestMeasure (
		final org.drip.analytics.date.JulianDate dt,
		final java.lang.String strManifestMeasure)
	{
<span class="pc bpc" id="L792" title="1 of 2 branches missed.">		if (null == dt) return null;</span>

<span class="fc" id="L794">		return jackDDFDManifestMeasure (dt.julian(), strManifestMeasure);</span>
	}

	/**
	 * Retrieve the Manifest Measure Jacobian of the Discount Factor to the date implied by the given Tenor
	 * 
	 * @param strTenor Tenor
	 * @param strManifestMeasure Manifest Measure
	 * 
	 * @return The Manifest Measure Jacobian of the Discount Factor to the date implied by the given Tenor
	 */

	public org.drip.quant.calculus.WengertJacobian jackDDFDManifestMeasure (
		final java.lang.String strTenor,
		final java.lang.String strManifestMeasure)
	{
<span class="nc bnc" id="L810" title="All 4 branches missed.">		if (null == strTenor || strTenor.isEmpty()) return null;</span>

		try {
<span class="nc" id="L813">			return jackDDFDManifestMeasure (epoch().addTenor (strTenor), strManifestMeasure);</span>
<span class="nc" id="L814">		} catch (java.lang.Exception e) {</span>
<span class="nc" id="L815">			e.printStackTrace();</span>
		}

<span class="nc" id="L818">		return null;</span>
	}

	/**
	 * Calculate the Jacobian of PV at the given date to the Manifest Measure of each component in the
	 * 	calibration set to the DF
	 * 
	 * @param iDate Date for which the Jacobian is needed
	 * 
	 * @return The Jacobian
	 */

	public org.drip.quant.calculus.WengertJacobian compJackDPVDManifestMeasure (
		final int iDate)
	{
<span class="pc bpc" id="L833" title="1 of 2 branches missed.">		if (!org.drip.quant.common.NumberUtil.IsValid (iDate)) return null;</span>

<span class="fc" id="L835">		org.drip.product.definition.CalibratableComponent[] aCalibComp = calibComp();</span>

<span class="pc bpc" id="L837" title="1 of 4 branches missed.">		if (null == aCalibComp || 0 == aCalibComp.length) return null;</span>

<span class="fc" id="L839">		int iNumParameters = 0;</span>
<span class="fc" id="L840">		int iNumComponents = aCalibComp.length;</span>
<span class="fc" id="L841">		org.drip.quant.calculus.WengertJacobian wjCompPVDF = null;</span>

<span class="fc" id="L843">		org.drip.param.valuation.ValuationParams valParams = org.drip.param.valuation.ValuationParams.Spot</span>
<span class="fc" id="L844">			(iDate);</span>

<span class="pc bpc" id="L846" title="1 of 2 branches missed.">		org.drip.param.market.CurveSurfaceQuoteContainer csqs =</span>
<span class="fc" id="L847">			org.drip.param.creator.MarketParamsBuilder.Create (this, null, null, null, null, null,</span>
<span class="fc" id="L848">				null, null == _ccis ? null : _ccis.fixing());</span>

<span class="fc bfc" id="L850" title="All 2 branches covered.">		for (int i = 0; i &lt; iNumComponents; ++i) {</span>
<span class="fc" id="L851">			org.drip.quant.calculus.WengertJacobian wjCompDDirtyPVDManifestMeasure =</span>
<span class="fc" id="L852">				aCalibComp[i].jackDDirtyPVDManifestMeasure (valParams, null, csqs, null);</span>

<span class="pc bpc" id="L854" title="1 of 2 branches missed.">			if (null == wjCompDDirtyPVDManifestMeasure) return null;</span>

<span class="fc" id="L856">			iNumParameters = wjCompDDirtyPVDManifestMeasure.numParameters();</span>

<span class="fc bfc" id="L858" title="All 2 branches covered.">			if (null == wjCompPVDF) {</span>
				try {
<span class="fc" id="L860">					wjCompPVDF = new org.drip.quant.calculus.WengertJacobian (iNumComponents,</span>
						iNumParameters);
<span class="nc" id="L862">				} catch (java.lang.Exception e) {</span>
<span class="nc" id="L863">					e.printStackTrace();</span>

<span class="nc" id="L865">					return null;</span>
<span class="fc" id="L866">				}</span>
			}

<span class="fc bfc" id="L869" title="All 2 branches covered.">			for (int k = 0; k &lt; iNumParameters; ++k) {</span>
<span class="pc bpc" id="L870" title="1 of 2 branches missed.">				if (!wjCompPVDF.accumulatePartialFirstDerivative (i, k,</span>
<span class="fc" id="L871">					wjCompDDirtyPVDManifestMeasure.firstDerivative (0, k)))</span>
<span class="nc" id="L872">					return null;</span>
			}
		}

<span class="fc" id="L876">		return wjCompPVDF;</span>
	}

	/**
	 * Calculate the Jacobian of PV at the given date to the Manifest Measure of each component in the
	 * 	calibration set to the DF
	 * 
	 * @param dt Date for which the Jacobian is needed
	 * 
	 * @return The Jacobian
	 */

	public org.drip.quant.calculus.WengertJacobian compJackDPVDManifestMeasure (
		final org.drip.analytics.date.JulianDate dt)
	{
<span class="pc bpc" id="L891" title="1 of 2 branches missed.">		return null == dt ? null : compJackDPVDManifestMeasure (dt.julian());</span>
	}

	/**
	 * Retrieve the Jacobian of the Forward Rate to the Manifest Measure between the given dates
	 * 
	 * @param iDate1 Date 1
	 * @param iDate2 Date 2
	 * @param strManifestMeasure Manifest Measure
	 * @param dblElapsedYear The Elapsed Year (in the appropriate Day Count) between dates 1 and 2
	 * 
	 * @return The Jacobian
	 */

	public org.drip.quant.calculus.WengertJacobian jackDForwardDManifestMeasure (
		final int iDate1,
		final int iDate2,
		final java.lang.String strManifestMeasure,
		final double dblElapsedYear)
	{
<span class="nc bnc" id="L911" title="All 2 branches missed.">		if (iDate1 == iDate2) return null;</span>

<span class="nc" id="L913">		org.drip.quant.calculus.WengertJacobian wjDDFDManifestMeasureDate1 = jackDDFDManifestMeasure</span>
<span class="nc" id="L914">			(iDate1, strManifestMeasure);</span>

<span class="nc bnc" id="L916" title="All 2 branches missed.">		if (null == wjDDFDManifestMeasureDate1) return null;</span>

<span class="nc" id="L918">		int iNumQuote = wjDDFDManifestMeasureDate1.numParameters();</span>

<span class="nc bnc" id="L920" title="All 2 branches missed.">		if (0 == iNumQuote) return null;</span>

<span class="nc" id="L922">		org.drip.quant.calculus.WengertJacobian wjDDFDManifestMeasureDate2 = jackDDFDManifestMeasure</span>
<span class="nc" id="L923">			(iDate2, strManifestMeasure);</span>

<span class="nc bnc" id="L925" title="All 4 branches missed.">		if (null == wjDDFDManifestMeasureDate2 || iNumQuote != wjDDFDManifestMeasureDate2.numParameters())</span>
<span class="nc" id="L926">			return null;</span>

<span class="nc" id="L928">		double dblDF1 = java.lang.Double.NaN;</span>
<span class="nc" id="L929">		double dblDF2 = java.lang.Double.NaN;</span>
<span class="nc" id="L930">		org.drip.quant.calculus.WengertJacobian wjDForwardDManifestMeasure = null;</span>

		try {
<span class="nc" id="L933">			dblDF1 = df (iDate1);</span>

<span class="nc" id="L935">			dblDF2 = df (iDate2);</span>

<span class="nc" id="L937">			wjDForwardDManifestMeasure = new org.drip.quant.calculus.WengertJacobian (1, iNumQuote);</span>
<span class="nc" id="L938">		} catch (java.lang.Exception e) {</span>
<span class="nc" id="L939">			e.printStackTrace();</span>

<span class="nc" id="L941">			return null;</span>
<span class="nc" id="L942">		}</span>

<span class="nc" id="L944">		double dblDForwardDManifestMeasure1iScale = 1. / dblDF2;</span>
<span class="nc" id="L945">		double dblDForwardDManifestMeasure2iScale = dblDF1 / (dblDF2 * dblDF2);</span>
<span class="nc" id="L946">		double dblInverseAnnualizedTenorLength = 1. / dblElapsedYear;</span>

<span class="nc bnc" id="L948" title="All 2 branches missed.">		for (int i = 0; i &lt; iNumQuote; ++i) {</span>
<span class="nc" id="L949">			double dblDForwardDQManifestMeasurei = ((wjDDFDManifestMeasureDate1.firstDerivative (0, i) *</span>
<span class="nc" id="L950">				dblDForwardDManifestMeasure1iScale) - (wjDDFDManifestMeasureDate2.firstDerivative (0, i) *</span>
					dblDForwardDManifestMeasure2iScale)) * dblInverseAnnualizedTenorLength;

<span class="nc bnc" id="L953" title="All 2 branches missed.">			if (!wjDForwardDManifestMeasure.accumulatePartialFirstDerivative (0, i,</span>
				dblDForwardDQManifestMeasurei))
<span class="nc" id="L955">				return null;</span>
		}

<span class="nc" id="L958">		return wjDForwardDManifestMeasure;</span>
	}

	/**
	 * Retrieve the Jacobian of the Forward Rate to the Manifest Measure between the given dates
	 * 
	 * @param dt1 Julian Date 1
	 * @param dt2 Julian Date 2
	 * @param strManifestMeasure Manifest Measure
	 * @param dblElapsedYear The Elapsed Year (in the appropriate Day Count) between dates 1 and 2
	 * 
	 * @return The Jacobian
	 */

	public org.drip.quant.calculus.WengertJacobian jackDForwardDManifestMeasure (
		final org.drip.analytics.date.JulianDate dt1,
		final org.drip.analytics.date.JulianDate dt2,
		final java.lang.String strManifestMeasure,
		final double dblElapsedYear)
	{
<span class="nc bnc" id="L978" title="All 4 branches missed.">		if (null == dt1 || null == dt2) return null;</span>

<span class="nc" id="L980">		return jackDForwardDManifestMeasure (dt1.julian(), dt2.julian(), strManifestMeasure, dblElapsedYear);</span>
	}

	/**
	 * Retrieve the Jacobian of the Forward Rate to the Manifest Measure at the given date
	 * 
	 * @param dt Given Julian Date
	 * @param strTenor Tenor
	 * @param strManifestMeasure Manifest Measure
	 * @param dblElapsedYear The Elapsed Year (in the appropriate Day Count) implied by the Tenor
	 * 
	 * @return The Jacobian
	 */

	public org.drip.quant.calculus.WengertJacobian jackDForwardDManifestMeasure (
		final org.drip.analytics.date.JulianDate dt,
		final java.lang.String strTenor,
		final java.lang.String strManifestMeasure,
		final double dblElapsedYear)
	{
<span class="nc bnc" id="L1000" title="All 6 branches missed.">		if (null == dt || null == strTenor || strTenor.isEmpty()) return null;</span>

<span class="nc" id="L1002">		return jackDForwardDManifestMeasure (dt.julian(), dt.addTenor (strTenor).julian(),</span>
			strManifestMeasure, dblElapsedYear);
	}

	/**
	 * Retrieve the Jacobian for the Zero Rate to the given date
	 * 
	 * @param iDate Date
	 * @param strManifestMeasure Manifest Measure
	 * 
	 * @return The Jacobian
	 */

	public org.drip.quant.calculus.WengertJacobian zeroRateJack (
		final int iDate,
		final java.lang.String strManifestMeasure)
	{
<span class="nc" id="L1019">		int iEpochDate = epoch().julian();</span>

<span class="nc" id="L1021">		return jackDForwardDManifestMeasure (iEpochDate, iDate, strManifestMeasure, 1. * (iDate - iEpochDate) /</span>
			365.25);
	}

	/**
	 * Retrieve the Jacobian for the Zero Rate to the given date
	 * 
	 * @param dt Julian Date
	 * @param strManifestMeasure Manifest Measure
	 * 
	 * @return The Jacobian
	 */

	public org.drip.quant.calculus.WengertJacobian zeroRateJack (
		final org.drip.analytics.date.JulianDate dt,
		final java.lang.String strManifestMeasure)
	{
<span class="nc bnc" id="L1038" title="All 2 branches missed.">		return null == dt? null : zeroRateJack (dt.julian(), strManifestMeasure);</span>
	}

	/**
	 * Convert the inferred Formulation Constraint into a &quot;Truthness&quot; Entity
	 * 
	 * @param strLatentStateQuantificationMetric Latent State Quantification Metric
	 * 
	 * @return Map of the Truthness Entities
	 */

	public java.util.Map&lt;java.lang.Integer, java.lang.Double&gt; canonicalTruthness (
		final java.lang.String strLatentStateQuantificationMetric)
	{
<span class="pc bpc" id="L1052" title="1 of 2 branches missed.">		if (null == strLatentStateQuantificationMetric ||</span>
			(!org.drip.analytics.definition.LatentStateStatic.DISCOUNT_QM_ZERO_RATE.equalsIgnoreCase
<span class="pc bpc" id="L1054" title="1 of 2 branches missed.">				(strLatentStateQuantificationMetric) &amp;&amp; !</span>
					org.drip.analytics.definition.LatentStateStatic.DISCOUNT_QM_DISCOUNT_FACTOR.equalsIgnoreCase
<span class="nc bnc" id="L1056" title="All 2 branches missed.">			(strLatentStateQuantificationMetric)))</span>
<span class="nc" id="L1057">			return null;</span>

<span class="fc" id="L1059">		org.drip.product.definition.CalibratableComponent[] aCC = calibComp();</span>

<span class="pc bpc" id="L1061" title="1 of 2 branches missed.">		if (null == aCC) return null;</span>

<span class="fc" id="L1063">		int iNumComp = aCC.length;</span>
<span class="fc" id="L1064">		boolean bFirstCashFlow = true;</span>

<span class="pc bpc" id="L1066" title="1 of 2 branches missed.">		if (0 == iNumComp) return null;</span>

<span class="fc" id="L1068">		java.util.Map&lt;java.lang.Integer, java.lang.Double&gt; mapCanonicalTruthness = new</span>
			java.util.TreeMap&lt;java.lang.Integer, java.lang.Double&gt;();

<span class="fc" id="L1071">		if (org.drip.analytics.definition.LatentStateStatic.DISCOUNT_QM_DISCOUNT_FACTOR.equalsIgnoreCase</span>
<span class="pc bpc" id="L1072" title="1 of 2 branches missed.">			(strLatentStateQuantificationMetric))</span>
<span class="nc" id="L1073">			mapCanonicalTruthness.put (_iEpochDate, 1.);</span>

<span class="fc bfc" id="L1075" title="All 2 branches covered.">		for (org.drip.product.definition.CalibratableComponent cc : aCC) {</span>
<span class="pc bpc" id="L1076" title="1 of 2 branches missed.">			if (null == cc) continue;</span>

<span class="fc" id="L1078">			java.util.List&lt;org.drip.analytics.cashflow.CompositePeriod&gt; lsCouponPeriod = cc.couponPeriods();</span>

<span class="pc bpc" id="L1080" title="2 of 4 branches missed.">			if (null == lsCouponPeriod || 0 == lsCouponPeriod.size()) continue;</span>

<span class="fc bfc" id="L1082" title="All 2 branches covered.">			for (org.drip.analytics.cashflow.CompositePeriod cpnPeriod : lsCouponPeriod) {</span>
<span class="pc bpc" id="L1083" title="1 of 2 branches missed.">				if (null == cpnPeriod) continue;</span>

<span class="fc" id="L1085">				int iPeriodPayDate = cpnPeriod.payDate();</span>

<span class="pc bpc" id="L1087" title="1 of 2 branches missed.">				if (iPeriodPayDate &gt;= _iEpochDate) {</span>
					try {
<span class="fc" id="L1089">						if (org.drip.analytics.definition.LatentStateStatic.DISCOUNT_QM_DISCOUNT_FACTOR.equalsIgnoreCase</span>
<span class="pc bpc" id="L1090" title="1 of 2 branches missed.">							(strLatentStateQuantificationMetric))</span>
<span class="nc" id="L1091">							mapCanonicalTruthness.put (iPeriodPayDate, df (iPeriodPayDate));</span>
<span class="fc" id="L1092">						else if (org.drip.analytics.definition.LatentStateStatic.DISCOUNT_QM_ZERO_RATE.equalsIgnoreCase</span>
<span class="pc bpc" id="L1093" title="1 of 2 branches missed.">							(strLatentStateQuantificationMetric)) {</span>
<span class="fc bfc" id="L1094" title="All 2 branches covered.">							if (bFirstCashFlow) {</span>
<span class="fc" id="L1095">								bFirstCashFlow = false;</span>

<span class="fc" id="L1097">								mapCanonicalTruthness.put (_iEpochDate, zero (iPeriodPayDate));</span>
							}

<span class="fc" id="L1100">							mapCanonicalTruthness.put (iPeriodPayDate, zero (iPeriodPayDate));</span>
						}
<span class="nc" id="L1102">					} catch (java.lang.Exception e) {</span>
<span class="nc" id="L1103">						e.printStackTrace();</span>

<span class="nc" id="L1105">						return null;</span>
<span class="fc" id="L1106">					}</span>
				}
<span class="fc" id="L1108">			}</span>
		}

<span class="fc" id="L1111">		return mapCanonicalTruthness;</span>
	}
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.7.9.201702052155</span></div></body></html>