<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>Table4DetailedBlowout.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">DROP</a> &gt; <a href="index.source.html" class="el_package">org.drip.sample.helitterman</a> &gt; <span class="el_source">Table4DetailedBlowout.java</span></div><h1>Table4DetailedBlowout.java</h1><pre class="source lang-java linenums">
package org.drip.sample.helitterman;

import org.drip.numerical.common.FormatUtil;
import org.drip.numerical.linearalgebra.Matrix;
import org.drip.service.env.EnvManager;

/*
 * -*- mode: java; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*-
 */

/*!
 * Copyright (C) 2019 Lakshmi Krishnamurthy
 * Copyright (C) 2018 Lakshmi Krishnamurthy
 * Copyright (C) 2017 Lakshmi Krishnamurthy
 * Copyright (C) 2016 Lakshmi Krishnamurthy
 * 
 *  This file is part of DROP, an open-source library targeting risk, transaction costs, exposure, margin
 *  	calculations, valuation adjustment, and portfolio construction within and across fixed income,
 *  	credit, commodity, equity, FX, and structured products.
 *  
 *  	https://lakshmidrip.github.io/DROP/
 *  
 *  DROP is composed of three modules:
 *  
 *  - DROP Analytics Core - https://lakshmidrip.github.io/DROP-Analytics-Core/
 *  - DROP Portfolio Core - https://lakshmidrip.github.io/DROP-Portfolio-Core/
 *  - DROP Numerical Core - https://lakshmidrip.github.io/DROP-Numerical-Core/
 * 
 * 	DROP Analytics Core implements libraries for the following:
 * 	- Fixed Income Analytics
 * 	- Asset Backed Analytics
 * 	- XVA Analytics
 * 	- Exposure and Margin Analytics
 * 
 * 	DROP Portfolio Core implements libraries for the following:
 * 	- Asset Allocation Analytics
 * 	- Transaction Cost Analytics
 * 
 * 	DROP Numerical Core implements libraries for the following:
 * 	- Statistical Learning
 * 	- Numerical Optimizer
 * 	- Spline Builder
 * 	- Algorithm Support
 * 
 * 	Documentation for DROP is Spread Over:
 * 
 * 	- Main                     =&gt; https://lakshmidrip.github.io/DROP/
 * 	- Wiki                     =&gt; https://github.com/lakshmiDRIP/DROP/wiki
 * 	- GitHub                   =&gt; https://github.com/lakshmiDRIP/DROP
 * 	- Repo Layout Taxonomy     =&gt; https://github.com/lakshmiDRIP/DROP/blob/master/Taxonomy.md
 * 	- Javadoc                  =&gt; https://lakshmidrip.github.io/DROP/Javadoc/index.html
 * 	- Technical Specifications =&gt; https://github.com/lakshmiDRIP/DROP/tree/master/Docs/Internal
 * 	- Release Versions         =&gt; https://lakshmidrip.github.io/DROP/version.html
 * 	- Community Credits        =&gt; https://lakshmidrip.github.io/DROP/credits.html
 * 	- Issues Catalog           =&gt; https://github.com/lakshmiDRIP/DROP/issues
 * 	- JUnit                    =&gt; https://lakshmidrip.github.io/DROP/junit/index.html
 * 	- Jacoco                   =&gt; https://lakshmidrip.github.io/DROP/jacoco/index.html
 * 
 *  Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 *   	you may not use this file except in compliance with the License.
 *   
 *  You may obtain a copy of the License at
 *  	http://www.apache.org/licenses/LICENSE-2.0
 *  
 *  Unless required by applicable law or agreed to in writing, software
 *  	distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 *  	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  
 *  See the License for the specific language governing permissions and
 *  	limitations under the License.
 */

/**
 * &lt;i&gt;Table4DetailedBlowout&lt;/i&gt; replicates the detailed Steps involved in the Black-Litterman Model Process
 * as illustrated in Table #4 the Following Paper:
 *  
 * &lt;br&gt;&lt;br&gt;
 *  &lt;ul&gt;
 *  	&lt;li&gt;
 *  		He. G., and R. Litterman (1999): The Intuition behind the Black-Litterman Model Portfolios,
 *  			Goldman Sachs Asset Management
 *  	&lt;/li&gt;
 *  &lt;/ul&gt;
 *  
 * &lt;br&gt;&lt;br&gt;
 *  &lt;ul&gt;
 *		&lt;li&gt;&lt;b&gt;Module &lt;/b&gt; = &lt;a href = &quot;https://github.com/lakshmiDRIP/DROP/tree/master/PortfolioCore.md&quot;&gt;Portfolio Core Module&lt;/a&gt;&lt;/li&gt;
 *		&lt;li&gt;&lt;b&gt;Library&lt;/b&gt; = &lt;a href = &quot;https://github.com/lakshmiDRIP/DROP/tree/master/AssetAllocationAnalyticsLibrary.md&quot;&gt;Asset Allocation Analytics Library&lt;/a&gt;&lt;/li&gt;
 *		&lt;li&gt;&lt;b&gt;Project&lt;/b&gt; = &lt;a href = &quot;https://github.com/lakshmiDRIP/DROP/tree/master/src/main/java/org/drip/sample/README.md&quot;&gt;Sample&lt;/a&gt;&lt;/li&gt;
 *		&lt;li&gt;&lt;b&gt;Package&lt;/b&gt; = &lt;a href = &quot;https://github.com/lakshmiDRIP/DROP/tree/master/src/main/java/org/drip/sample/helitterman/README.md&quot;&gt;He and Litterman (1999) Reconcilers&lt;/a&gt;&lt;/li&gt;
 *  &lt;/ul&gt;
 * &lt;br&gt;&lt;br&gt;
 *
 * @author Lakshmi Krishnamurthy
 */

<span class="nc" id="L98">public class Table4DetailedBlowout</span>
{

	public static void main (
		final String[] argumentArray)
		throws Exception
	{
<span class="fc" id="L105">		EnvManager.InitEnv (&quot;&quot;);</span>

<span class="fc" id="L107">		String[] sovereignArray = new String[]</span>
		{
			&quot;AUS&quot;,
			&quot;CAD&quot;,
			&quot;FRA&quot;,
			&quot;GER&quot;,
			&quot;JPN&quot;,
			&quot;UK &quot;,
			&quot;USA&quot;
		};
<span class="fc" id="L117">		double[][] inputCorrelationMatrix = new double[][]</span>
		{
			{1.000, 0.488, 0.478, 0.515, 0.439, 0.512, 0.491},
			{0.488, 1.000, 0.664, 0.655, 0.310, 0.608, 0.779},
			{0.478, 0.664, 1.000, 0.861, 0.355, 0.783, 0.668},
			{0.515, 0.655, 0.861, 1.000, 0.354, 0.777, 0.653},
			{0.439, 0.310, 0.355, 0.354, 1.000, 0.405, 0.306},
			{0.512, 0.608, 0.783, 0.777, 0.405, 1.000, 0.652},
			{0.491, 0.779, 0.668, 0.653, 0.306, 0.652, 1.000}
		};
<span class="fc" id="L127">		double[] inputVolatilityArray = new double[]</span>
		{
			0.160,
			0.203,
			0.248,
			0.271,
			0.210,
			0.200,
			0.187
		};
<span class="fc" id="L137">		double[] inputWArray = new double[]</span>
		{
			0.016,
			0.022,
			0.052,
			0.055,
			0.116,
			0.124,
			0.615
		};
<span class="fc" id="L147">		double inputTAU = 0.05;</span>
<span class="fc" id="L148">		double inputDELTA = 2.5;</span>
<span class="fc" id="L149">		double[][] inputPMatrix = new double[][]</span>
		{
			{ 0.000,  0.000, -0.295,  1.000,  0.000, -0.705,  0.000}
		};
<span class="fc" id="L153">		double[][] inputOmegaMatrix = new double[][]</span>
		{
			{0.021}
		};
<span class="fc" id="L157">		double[] inputQArray = new double[]</span>
		{
			0.05
		};

<span class="fc" id="L162">		int sovereignCount = sovereignArray.length;</span>
<span class="fc" id="L163">		double[][] sigmaMatrix = new double[sovereignCount][sovereignCount];</span>

<span class="fc bfc" id="L165" title="All 2 branches covered.">		for (int sovereignIndexI = 0; sovereignIndexI &lt; sovereignCount; ++sovereignIndexI)</span>
		{
<span class="fc bfc" id="L167" title="All 2 branches covered.">			for (int sovereignIndexJ = 0; sovereignIndexJ &lt; sovereignCount; ++sovereignIndexJ)</span>
			{
<span class="fc" id="L169">				sigmaMatrix[sovereignIndexI][sovereignIndexJ] = inputVolatilityArray[sovereignIndexI] *</span>
					inputVolatilityArray[sovereignIndexJ] *
					inputCorrelationMatrix[sovereignIndexI][sovereignIndexJ];
			}
		}

<span class="fc" id="L175">		double[] piArray = Matrix.Product (</span>
			sigmaMatrix,
			inputWArray
		);

<span class="fc bfc" id="L180" title="All 2 branches covered.">		for (int sovereignIndex = 0; sovereignIndex &lt; sovereignCount; ++sovereignIndex)</span>
		{
<span class="fc" id="L182">			piArray[sovereignIndex] *= inputDELTA;</span>
		}

<span class="fc" id="L185">		System.out.println();</span>

<span class="fc bfc" id="L187" title="All 2 branches covered.">		for (int sovereignIndex = 0; sovereignIndex &lt; sovereignCount; ++sovereignIndex)</span>
		{
<span class="fc" id="L189">			System.out.println (</span>
				&quot;\t{PI}[&quot; + sovereignArray[sovereignIndex] + &quot;] =&gt;&quot; +
<span class="fc" id="L191">				FormatUtil.FormatDouble (piArray[sovereignIndex], 1, 1, 100.) + &quot;%&quot;</span>
			);
		}

<span class="fc" id="L195">		System.out.println();</span>

<span class="fc" id="L197">		double[] pDotPIArray = Matrix.Product (</span>
			inputPMatrix,
			piArray
		);

<span class="fc bfc" id="L202" title="All 2 branches covered.">		for (int pDotPIIndex = 0; pDotPIIndex &lt; pDotPIArray.length; ++pDotPIIndex)</span>
		{
<span class="fc" id="L204">			System.out.println (</span>
				&quot;\t{P.PI}[&quot; + pDotPIIndex + &quot;] =&gt;&quot; +
<span class="fc" id="L206">				FormatUtil.FormatDouble (pDotPIArray[pDotPIIndex], 1, 6, 1.)</span>
			);
		}

<span class="fc" id="L210">		System.out.println();</span>

<span class="fc" id="L212">		double[] qMinus_PdotPI_Array = new double[inputQArray.length];</span>

<span class="fc bfc" id="L214" title="All 2 branches covered.">		for (int qIndex = 0; qIndex &lt; inputQArray.length; ++qIndex)</span>
		{
<span class="fc" id="L216">			qMinus_PdotPI_Array[qIndex] = inputQArray[qIndex] - pDotPIArray[qIndex];</span>
		}

<span class="fc" id="L219">		for (int qMinus_PdotPI_ArrayIndex = 0;</span>
<span class="fc bfc" id="L220" title="All 2 branches covered.">			qMinus_PdotPI_ArrayIndex &lt; qMinus_PdotPI_Array.length;</span>
<span class="fc" id="L221">			++qMinus_PdotPI_ArrayIndex)</span>
		{
<span class="fc" id="L223">			System.out.println (</span>
				&quot;\t{Q-P.PI}[&quot; + qMinus_PdotPI_ArrayIndex + &quot;] =&gt;&quot; +
<span class="fc" id="L225">				FormatUtil.FormatDouble (qMinus_PdotPI_Array[qMinus_PdotPI_ArrayIndex], 1, 6, 1.)</span>
			);
		}

<span class="fc" id="L229">		System.out.println();</span>

<span class="fc" id="L231">		double[][] pTransposeMatrix = Matrix.Transpose (</span>
			inputPMatrix
		);

<span class="fc" id="L235">		double[][] sigmaDot_PTranspose_Matrix = Matrix.Product (</span>
			sigmaMatrix,
			pTransposeMatrix
		);

<span class="fc" id="L240">		for (int sigmaDot_PTranspose_MatrixRowIndex = 0;</span>
<span class="fc bfc" id="L241" title="All 2 branches covered.">			sigmaDot_PTranspose_MatrixRowIndex &lt; sigmaDot_PTranspose_Matrix.length;</span>
<span class="fc" id="L242">			++sigmaDot_PTranspose_MatrixRowIndex)</span>
		{
<span class="fc" id="L244">			for (int sigmaDot_PTranspose_MatrixColumnIndex = 0;</span>
<span class="fc bfc" id="L245" title="All 2 branches covered.">				sigmaDot_PTranspose_MatrixColumnIndex &lt; sigmaDot_PTranspose_Matrix[0].length;</span>
<span class="fc" id="L246">				++sigmaDot_PTranspose_MatrixColumnIndex)</span>
			{
<span class="fc" id="L248">				System.out.println (</span>
					&quot;\t{SIGMA.PTRANSPOSE}[&quot; + sigmaDot_PTranspose_MatrixRowIndex + &quot;][&quot; + sigmaDot_PTranspose_MatrixColumnIndex + &quot;] =&gt;&quot; +
<span class="fc" id="L250">					FormatUtil.FormatDouble (sigmaDot_PTranspose_Matrix[sigmaDot_PTranspose_MatrixRowIndex][sigmaDot_PTranspose_MatrixColumnIndex], 1, 6, 1.)</span>
				);
			}
		}

<span class="fc" id="L255">		System.out.println();</span>

<span class="fc" id="L257">		double[][] pDotSIGMAdot_PTranspose_Matrix = Matrix.Product (</span>
			inputPMatrix,
			sigmaDot_PTranspose_Matrix
		);

<span class="fc" id="L262">		for (int pDotSIGMAdot_PTranspose_MatrixRowIndex = 0;</span>
<span class="fc bfc" id="L263" title="All 2 branches covered.">			pDotSIGMAdot_PTranspose_MatrixRowIndex &lt; pDotSIGMAdot_PTranspose_Matrix.length;</span>
<span class="fc" id="L264">			++pDotSIGMAdot_PTranspose_MatrixRowIndex)</span>
		{
<span class="fc" id="L266">			for (int pDotSIGMAdot_PTranspose_MatrixColumnIndex = 0;</span>
<span class="fc bfc" id="L267" title="All 2 branches covered.">				pDotSIGMAdot_PTranspose_MatrixColumnIndex &lt; pDotSIGMAdot_PTranspose_Matrix[0].length;</span>
<span class="fc" id="L268">				++pDotSIGMAdot_PTranspose_MatrixColumnIndex)</span>
			{
<span class="fc" id="L270">				System.out.println (</span>
					&quot;\t{P.SIGMA.PTRANSPOSE}[&quot; + pDotSIGMAdot_PTranspose_MatrixRowIndex + &quot;][&quot; + pDotSIGMAdot_PTranspose_MatrixColumnIndex + &quot;] =&gt;&quot; +
<span class="fc" id="L272">					FormatUtil.FormatDouble (pDotSIGMAdot_PTranspose_Matrix[pDotSIGMAdot_PTranspose_MatrixRowIndex][pDotSIGMAdot_PTranspose_MatrixColumnIndex], 1, 6, 1.)</span>
				);
			}
		}

<span class="fc" id="L277">		System.out.println();</span>

<span class="fc" id="L279">		double[][] pDotSIGMAdot_PTranspose_PlusOMEGAMatrix =</span>
			new double[pDotSIGMAdot_PTranspose_Matrix.length][pDotSIGMAdot_PTranspose_Matrix[0].length];

<span class="fc" id="L282">		for (int pDotSIGMAdot_PTranspose_PlusOMEGAMatrixRowIndex = 0;</span>
<span class="fc bfc" id="L283" title="All 2 branches covered.">			pDotSIGMAdot_PTranspose_PlusOMEGAMatrixRowIndex &lt; pDotSIGMAdot_PTranspose_PlusOMEGAMatrix.length;</span>
<span class="fc" id="L284">			++pDotSIGMAdot_PTranspose_PlusOMEGAMatrixRowIndex)</span>
		{
<span class="fc" id="L286">			for (int pDotSIGMAdot_PTranspose_PlusOMEGAMatrixColumnIndex = 0;</span>
<span class="fc bfc" id="L287" title="All 2 branches covered.">				pDotSIGMAdot_PTranspose_PlusOMEGAMatrixColumnIndex &lt;</span>
					pDotSIGMAdot_PTranspose_PlusOMEGAMatrix[0].length;
<span class="fc" id="L289">				++pDotSIGMAdot_PTranspose_PlusOMEGAMatrixColumnIndex)</span>
			{
<span class="fc" id="L291">				pDotSIGMAdot_PTranspose_PlusOMEGAMatrix[pDotSIGMAdot_PTranspose_PlusOMEGAMatrixRowIndex][pDotSIGMAdot_PTranspose_PlusOMEGAMatrixColumnIndex] =</span>
					pDotSIGMAdot_PTranspose_Matrix[pDotSIGMAdot_PTranspose_PlusOMEGAMatrixRowIndex][pDotSIGMAdot_PTranspose_PlusOMEGAMatrixColumnIndex] +
					inputOmegaMatrix[pDotSIGMAdot_PTranspose_PlusOMEGAMatrixRowIndex][pDotSIGMAdot_PTranspose_PlusOMEGAMatrixColumnIndex];

<span class="fc" id="L295">				System.out.println (</span>
					&quot;\t{P.SIGMA.PTRANSPOSE+OMEGA}[&quot; + pDotSIGMAdot_PTranspose_PlusOMEGAMatrixRowIndex + &quot;][&quot; + pDotSIGMAdot_PTranspose_PlusOMEGAMatrixColumnIndex + &quot;] =&gt;&quot; +
<span class="fc" id="L297">					FormatUtil.FormatDouble (</span>
						pDotSIGMAdot_PTranspose_PlusOMEGAMatrix[pDotSIGMAdot_PTranspose_PlusOMEGAMatrixRowIndex][pDotSIGMAdot_PTranspose_PlusOMEGAMatrixColumnIndex],
						1, 6, 1.
					)
				);
			}
		}

<span class="fc" id="L305">		System.out.println();</span>

<span class="fc" id="L307">		double[][] $PDotSIGMAdot_PTranspose_PlusOMEGA$InverseMatrix = Matrix.InvertUsingGaussianElimination (</span>
			pDotSIGMAdot_PTranspose_PlusOMEGAMatrix
		);

<span class="fc" id="L311">		for (int $PDotSIGMAdot_PTranspose_PlusOMEGA$InverseMatrixRowIndex = 0;</span>
<span class="fc bfc" id="L312" title="All 2 branches covered.">			$PDotSIGMAdot_PTranspose_PlusOMEGA$InverseMatrixRowIndex &lt;</span>
				$PDotSIGMAdot_PTranspose_PlusOMEGA$InverseMatrix.length;
<span class="fc" id="L314">			++$PDotSIGMAdot_PTranspose_PlusOMEGA$InverseMatrixRowIndex)</span>
		{
<span class="fc" id="L316">			for (int $PDotSIGMAdot_PTranspose_PlusOMEGA$InverseMatrixColumnIndex = 0;</span>
<span class="fc bfc" id="L317" title="All 2 branches covered.">				$PDotSIGMAdot_PTranspose_PlusOMEGA$InverseMatrixColumnIndex &lt;</span>
					$PDotSIGMAdot_PTranspose_PlusOMEGA$InverseMatrix[0].length;
<span class="fc" id="L319">				++$PDotSIGMAdot_PTranspose_PlusOMEGA$InverseMatrixColumnIndex)</span>
			{
<span class="fc" id="L321">				System.out.println (</span>
					&quot;\t{P.SIGMA.PTRANSPOSE+OMEGA}^(-1)[&quot; + $PDotSIGMAdot_PTranspose_PlusOMEGA$InverseMatrixRowIndex + &quot;][&quot; + $PDotSIGMAdot_PTranspose_PlusOMEGA$InverseMatrixColumnIndex + &quot;] =&gt;&quot; +
<span class="fc" id="L323">					FormatUtil.FormatDouble ($PDotSIGMAdot_PTranspose_PlusOMEGA$InverseMatrix[$PDotSIGMAdot_PTranspose_PlusOMEGA$InverseMatrixRowIndex][$PDotSIGMAdot_PTranspose_PlusOMEGA$InverseMatrixColumnIndex], 1, 6, 1.)</span>
				);
			}
		}

<span class="fc" id="L328">		System.out.println();</span>

<span class="fc" id="L330">		double[] __$PDotSIGMADot_PTranspose_plusOMEGA$Inverse__Dot_QMinus__PDotPI__Array = Matrix.Product (</span>
			$PDotSIGMAdot_PTranspose_PlusOMEGA$InverseMatrix,
			qMinus_PdotPI_Array
		);

<span class="fc" id="L335">		for (int __$PDotSIGMADot_PTranspose_plusOMEGA$Inverse__Dot_QMinus__PDotPI__ArrayIndex = 0;</span>
<span class="fc bfc" id="L336" title="All 2 branches covered.">			__$PDotSIGMADot_PTranspose_plusOMEGA$Inverse__Dot_QMinus__PDotPI__ArrayIndex &lt;</span>
				__$PDotSIGMADot_PTranspose_plusOMEGA$Inverse__Dot_QMinus__PDotPI__Array.length;
<span class="fc" id="L338">			++__$PDotSIGMADot_PTranspose_plusOMEGA$Inverse__Dot_QMinus__PDotPI__ArrayIndex)</span>
		{
<span class="fc" id="L340">			System.out.println (</span>
				&quot;\t{P.SIGMA.PTRANSPOSE+OMEGA}^(-1).{Q-P.PI}[&quot; + __$PDotSIGMADot_PTranspose_plusOMEGA$Inverse__Dot_QMinus__PDotPI__ArrayIndex + &quot;] =&gt;&quot; +
<span class="fc" id="L342">				FormatUtil.FormatDouble (__$PDotSIGMADot_PTranspose_plusOMEGA$Inverse__Dot_QMinus__PDotPI__Array[__$PDotSIGMADot_PTranspose_plusOMEGA$Inverse__Dot_QMinus__PDotPI__ArrayIndex], 1, 6, 1.)</span>
			);
		}

<span class="fc" id="L346">		System.out.println();</span>

<span class="fc" id="L348">		double[] sigmaDot$PTranspose$__$PDotSIGMADot_PTranspose_PlusOmega$Inverse__Dot_QMinus__PDotPI__Array</span>
<span class="fc" id="L349">			= Matrix.Product (</span>
				sigmaDot_PTranspose_Matrix,
				__$PDotSIGMADot_PTranspose_plusOMEGA$Inverse__Dot_QMinus__PDotPI__Array
			);

<span class="fc" id="L354">		for (int sigmaDot$PTranspose$__$PDotSIGMADot_PTranspose_PlusOmega$Inverse__Dot_QMinus__PDotPI__ArrayIndex = 0;</span>
<span class="fc bfc" id="L355" title="All 2 branches covered.">			sigmaDot$PTranspose$__$PDotSIGMADot_PTranspose_PlusOmega$Inverse__Dot_QMinus__PDotPI__ArrayIndex &lt;</span>
				sigmaDot$PTranspose$__$PDotSIGMADot_PTranspose_PlusOmega$Inverse__Dot_QMinus__PDotPI__Array.length;
<span class="fc" id="L357">			++sigmaDot$PTranspose$__$PDotSIGMADot_PTranspose_PlusOmega$Inverse__Dot_QMinus__PDotPI__ArrayIndex)</span>
		{
<span class="fc" id="L359">			System.out.println (</span>
				&quot;\t{SIGMA.PTRANSPOSE}{P.SIGMA.PTRANSPOSE+OMEGA}^(-1).{Q-P.PI}[&quot; + sigmaDot$PTranspose$__$PDotSIGMADot_PTranspose_PlusOmega$Inverse__Dot_QMinus__PDotPI__ArrayIndex + &quot;] =&gt;&quot; +
<span class="fc" id="L361">				FormatUtil.FormatDouble (sigmaDot$PTranspose$__$PDotSIGMADot_PTranspose_PlusOmega$Inverse__Dot_QMinus__PDotPI__Array[sigmaDot$PTranspose$__$PDotSIGMADot_PTranspose_PlusOmega$Inverse__Dot_QMinus__PDotPI__ArrayIndex], 1, 6, 1.)</span>
			);
		}

<span class="fc" id="L365">		System.out.println();</span>

<span class="fc" id="L367">		double[] piHatArray = new double[piArray.length];</span>

<span class="fc bfc" id="L369" title="All 2 branches covered.">		for (int piHatArrayIndex = 0; piHatArrayIndex &lt; piHatArray.length; ++piHatArrayIndex)</span>
		{
<span class="fc" id="L371">			piHatArray[piHatArrayIndex] = piArray[piHatArrayIndex] +</span>
				sigmaDot$PTranspose$__$PDotSIGMADot_PTranspose_PlusOmega$Inverse__Dot_QMinus__PDotPI__Array[piHatArrayIndex];

<span class="fc" id="L374">			System.out.println (</span>
				&quot;\tPIHAT=PI+{SIGMA.PTRANSPOSE}{P.SIGMA.PTRANSPOSE+OMEGA}^(-1).{Q-P.PI}[&quot; + piHatArrayIndex + &quot;] =&gt;&quot; +
<span class="fc" id="L376">				FormatUtil.FormatDouble (piHatArray[piHatArrayIndex], 1, 1, 100.) + &quot;%&quot;</span>
			);
		}

<span class="fc" id="L380">		System.out.println();</span>

<span class="fc" id="L382">		double[][] pDotSigmaMatrix = Matrix.Product (</span>
			inputPMatrix,
			sigmaMatrix
		);

<span class="fc" id="L387">		for (int pDotSigmaMatrixRowIndex = 0;</span>
<span class="fc bfc" id="L388" title="All 2 branches covered.">			pDotSigmaMatrixRowIndex &lt; pDotSigmaMatrix.length;</span>
<span class="fc" id="L389">			++pDotSigmaMatrixRowIndex)</span>
		{
<span class="fc" id="L391">			for (int pDotSigmaMatrixColumnIndex = 0;</span>
<span class="fc bfc" id="L392" title="All 2 branches covered.">				pDotSigmaMatrixColumnIndex &lt; pDotSigmaMatrix[0].length;</span>
<span class="fc" id="L393">				++pDotSigmaMatrixColumnIndex)</span>
			{
<span class="fc" id="L395">				System.out.println (</span>
					&quot;\tP.SIGMA[&quot; + pDotSigmaMatrixRowIndex + &quot;][&quot; + pDotSigmaMatrixColumnIndex + &quot;] =&gt;&quot; +
<span class="fc" id="L397">					FormatUtil.FormatDouble (pDotSigmaMatrix[pDotSigmaMatrixRowIndex][pDotSigmaMatrixColumnIndex], 1, 6, 1.)</span>
				);
			}
		}

<span class="fc" id="L402">		System.out.println();</span>

<span class="fc" id="L404">		double[][] __$PDotSigmaDot_PTranspose_PlusOmega$Inverse__DotPDotSigmaMatrix = Matrix.Product (</span>
			$PDotSIGMAdot_PTranspose_PlusOMEGA$InverseMatrix,
			pDotSigmaMatrix
		);

<span class="fc" id="L409">		for (int __$PDotSigmaDot_PTranspose_PlusOmega$Inverse__DotPDotSigmaMatrixRowIndex = 0;</span>
<span class="fc bfc" id="L410" title="All 2 branches covered.">			__$PDotSigmaDot_PTranspose_PlusOmega$Inverse__DotPDotSigmaMatrixRowIndex &lt;</span>
				__$PDotSigmaDot_PTranspose_PlusOmega$Inverse__DotPDotSigmaMatrix.length;
<span class="fc" id="L412">			++__$PDotSigmaDot_PTranspose_PlusOmega$Inverse__DotPDotSigmaMatrixRowIndex)</span>
		{
<span class="fc" id="L414">			for (int __$PDotSigmaDot_PTranspose_PlusOmega$Inverse__DotPDotSigmaMatrixColumnIndex = 0;</span>
<span class="fc bfc" id="L415" title="All 2 branches covered.">				__$PDotSigmaDot_PTranspose_PlusOmega$Inverse__DotPDotSigmaMatrixColumnIndex &lt;</span>
					__$PDotSigmaDot_PTranspose_PlusOmega$Inverse__DotPDotSigmaMatrix[0].length;
<span class="fc" id="L417">				++__$PDotSigmaDot_PTranspose_PlusOmega$Inverse__DotPDotSigmaMatrixColumnIndex)</span>
			{
<span class="fc" id="L419">				System.out.println (</span>
					&quot;\t{P.SIGMA.PTRANSPOSE+OMEGA}^(-1).{P.SIGMA}[&quot; + __$PDotSigmaDot_PTranspose_PlusOmega$Inverse__DotPDotSigmaMatrixRowIndex + &quot;][&quot; + __$PDotSigmaDot_PTranspose_PlusOmega$Inverse__DotPDotSigmaMatrixColumnIndex + &quot;] =&gt;&quot; +
<span class="fc" id="L421">					FormatUtil.FormatDouble (__$PDotSigmaDot_PTranspose_PlusOmega$Inverse__DotPDotSigmaMatrix[__$PDotSigmaDot_PTranspose_PlusOmega$Inverse__DotPDotSigmaMatrixRowIndex][__$PDotSigmaDot_PTranspose_PlusOmega$Inverse__DotPDotSigmaMatrixColumnIndex], 1, 6, 1.)</span>
				);
			}
		}

<span class="fc" id="L426">		System.out.println();</span>

<span class="fc" id="L428">		double[][] sigmaDot_PTranspose_Dot__$PDotSigmaDot_PTranspose_PlusOmegaPDotSigmaMatrix =</span>
<span class="fc" id="L429">			Matrix.Product (</span>
				sigmaDot_PTranspose_Matrix,
				__$PDotSigmaDot_PTranspose_PlusOmega$Inverse__DotPDotSigmaMatrix
			);

<span class="fc" id="L434">		for (int sigmaDot_PTranspose_Dot__$PDotSigmaDot_PTranspose_PlusOmegaPDotSigmaMatrixRowIndex = 0;</span>
<span class="fc bfc" id="L435" title="All 2 branches covered.">			sigmaDot_PTranspose_Dot__$PDotSigmaDot_PTranspose_PlusOmegaPDotSigmaMatrixRowIndex &lt;</span>
				sigmaDot_PTranspose_Dot__$PDotSigmaDot_PTranspose_PlusOmegaPDotSigmaMatrix.length;
<span class="fc" id="L437">			++sigmaDot_PTranspose_Dot__$PDotSigmaDot_PTranspose_PlusOmegaPDotSigmaMatrixRowIndex)</span>
		{
<span class="fc" id="L439">			for (int sigmaDot_PTranspose_Dot__$PDotSigmaDot_PTranspose_PlusOmegaPDotSigmaMatrixColumnIndex = 0;</span>
<span class="fc bfc" id="L440" title="All 2 branches covered.">				sigmaDot_PTranspose_Dot__$PDotSigmaDot_PTranspose_PlusOmegaPDotSigmaMatrixColumnIndex &lt;</span>
					sigmaDot_PTranspose_Dot__$PDotSigmaDot_PTranspose_PlusOmegaPDotSigmaMatrix[0].length;
<span class="fc" id="L442">				++sigmaDot_PTranspose_Dot__$PDotSigmaDot_PTranspose_PlusOmegaPDotSigmaMatrixColumnIndex)</span>
			{
<span class="fc" id="L444">				System.out.println (</span>
					&quot;\t{SIGMA.PTRANSPOSE}.{P.SIGMA.PTRANSPOSE+OMEGA}^(-1).{P.SIGMA}[&quot; + sigmaDot_PTranspose_Dot__$PDotSigmaDot_PTranspose_PlusOmegaPDotSigmaMatrixRowIndex + &quot;][&quot; + sigmaDot_PTranspose_Dot__$PDotSigmaDot_PTranspose_PlusOmegaPDotSigmaMatrixColumnIndex + &quot;] =&gt;&quot; +
<span class="fc" id="L446">					FormatUtil.FormatDouble (</span>
						sigmaDot_PTranspose_Dot__$PDotSigmaDot_PTranspose_PlusOmegaPDotSigmaMatrix[sigmaDot_PTranspose_Dot__$PDotSigmaDot_PTranspose_PlusOmegaPDotSigmaMatrixRowIndex][sigmaDot_PTranspose_Dot__$PDotSigmaDot_PTranspose_PlusOmegaPDotSigmaMatrixColumnIndex],
						1, 6, 1.
					)
				);
			}
		}

<span class="fc" id="L454">		System.out.println();</span>

		double[][]
<span class="fc" id="L457">			sigmaMinusSigmaDot_PTranspose_Dot__$PDotSigmaDot_PTranspose_PlusOmega$Inverse__DotPDotSigmaMatrix</span>
				= new double[sovereignCount][sovereignCount];

<span class="fc" id="L460">		for (int sigmaMinusSigmaDot_PTranspose_Dot__$PDotSigmaDot_PTranspose_PlusOmega$Inverse__DotPDotSigmaMatrixRowIndex = 0;</span>
<span class="fc bfc" id="L461" title="All 2 branches covered.">			sigmaMinusSigmaDot_PTranspose_Dot__$PDotSigmaDot_PTranspose_PlusOmega$Inverse__DotPDotSigmaMatrixRowIndex &lt;</span>
				sigmaMinusSigmaDot_PTranspose_Dot__$PDotSigmaDot_PTranspose_PlusOmega$Inverse__DotPDotSigmaMatrix.length;
<span class="fc" id="L463">			++sigmaMinusSigmaDot_PTranspose_Dot__$PDotSigmaDot_PTranspose_PlusOmega$Inverse__DotPDotSigmaMatrixRowIndex)</span>
		{
<span class="fc" id="L465">			for (int sigmaMinusSigmaDot_PTranspose_Dot__$PDotSigmaDot_PTranspose_PlusOmega$Inverse__DotPDotSigmaMatrixColumnIndex = 0;</span>
<span class="fc bfc" id="L466" title="All 2 branches covered.">				sigmaMinusSigmaDot_PTranspose_Dot__$PDotSigmaDot_PTranspose_PlusOmega$Inverse__DotPDotSigmaMatrixColumnIndex &lt;</span>
					sigmaMinusSigmaDot_PTranspose_Dot__$PDotSigmaDot_PTranspose_PlusOmega$Inverse__DotPDotSigmaMatrix[0].length;
<span class="fc" id="L468">				++sigmaMinusSigmaDot_PTranspose_Dot__$PDotSigmaDot_PTranspose_PlusOmega$Inverse__DotPDotSigmaMatrixColumnIndex)</span>
			{
<span class="fc" id="L470">				sigmaMinusSigmaDot_PTranspose_Dot__$PDotSigmaDot_PTranspose_PlusOmega$Inverse__DotPDotSigmaMatrix[sigmaMinusSigmaDot_PTranspose_Dot__$PDotSigmaDot_PTranspose_PlusOmega$Inverse__DotPDotSigmaMatrixRowIndex][sigmaMinusSigmaDot_PTranspose_Dot__$PDotSigmaDot_PTranspose_PlusOmega$Inverse__DotPDotSigmaMatrixColumnIndex] =</span>
					sigmaMatrix[sigmaMinusSigmaDot_PTranspose_Dot__$PDotSigmaDot_PTranspose_PlusOmega$Inverse__DotPDotSigmaMatrixRowIndex][sigmaMinusSigmaDot_PTranspose_Dot__$PDotSigmaDot_PTranspose_PlusOmega$Inverse__DotPDotSigmaMatrixColumnIndex] -
					sigmaDot_PTranspose_Dot__$PDotSigmaDot_PTranspose_PlusOmegaPDotSigmaMatrix[sigmaMinusSigmaDot_PTranspose_Dot__$PDotSigmaDot_PTranspose_PlusOmega$Inverse__DotPDotSigmaMatrixRowIndex][sigmaMinusSigmaDot_PTranspose_Dot__$PDotSigmaDot_PTranspose_PlusOmega$Inverse__DotPDotSigmaMatrixColumnIndex];

<span class="fc" id="L474">				System.out.println (</span>
					&quot;\tSIGMA-{SIGMA.PTRANSPOSE}.{P.SIGMA.PTRANSPOSE+OMEGA}^(-1).{P.SIGMA}[&quot; + sigmaMinusSigmaDot_PTranspose_Dot__$PDotSigmaDot_PTranspose_PlusOmega$Inverse__DotPDotSigmaMatrixRowIndex + &quot;][&quot; + sigmaMinusSigmaDot_PTranspose_Dot__$PDotSigmaDot_PTranspose_PlusOmega$Inverse__DotPDotSigmaMatrixColumnIndex + &quot;] =&gt;&quot; +
<span class="fc" id="L476">					FormatUtil.FormatDouble (sigmaMinusSigmaDot_PTranspose_Dot__$PDotSigmaDot_PTranspose_PlusOmega$Inverse__DotPDotSigmaMatrix[sigmaMinusSigmaDot_PTranspose_Dot__$PDotSigmaDot_PTranspose_PlusOmega$Inverse__DotPDotSigmaMatrixRowIndex][sigmaMinusSigmaDot_PTranspose_Dot__$PDotSigmaDot_PTranspose_PlusOmega$Inverse__DotPDotSigmaMatrixColumnIndex], 1, 6, 1.)</span>
				);
			}
		}

<span class="fc" id="L481">		System.out.println();</span>

<span class="fc" id="L483">		double[][] tauDot$$SigmaMinusSigmaDot_PTranspose_Dot__$PDotSigmaDot_PTranspose_PlusOmega$Inverse__DotPDotSigma$$Matrix =</span>
			new double[sovereignCount][sovereignCount];

<span class="fc" id="L486">		for (int tauDot$$SigmaMinusSigmaDot_PTranspose_Dot__$PDotSigmaDot_PTranspose_PlusOmega$Inverse__DotPDotSigma$$MatrixRowIndex = 0;</span>
<span class="fc bfc" id="L487" title="All 2 branches covered.">			tauDot$$SigmaMinusSigmaDot_PTranspose_Dot__$PDotSigmaDot_PTranspose_PlusOmega$Inverse__DotPDotSigma$$MatrixRowIndex &lt;</span>
				tauDot$$SigmaMinusSigmaDot_PTranspose_Dot__$PDotSigmaDot_PTranspose_PlusOmega$Inverse__DotPDotSigma$$Matrix.length;
<span class="fc" id="L489">			++tauDot$$SigmaMinusSigmaDot_PTranspose_Dot__$PDotSigmaDot_PTranspose_PlusOmega$Inverse__DotPDotSigma$$MatrixRowIndex)</span>
		{
<span class="fc" id="L491">			for (int tauDot$$SigmaMinusSigmaDot_PTranspose_Dot__$PDotSigmaDot_PTranspose_PlusOmega$Inverse__DotPDotSigma$$MatrixColumnIndex = 0;</span>
<span class="fc bfc" id="L492" title="All 2 branches covered.">				tauDot$$SigmaMinusSigmaDot_PTranspose_Dot__$PDotSigmaDot_PTranspose_PlusOmega$Inverse__DotPDotSigma$$MatrixColumnIndex &lt;</span>
					tauDot$$SigmaMinusSigmaDot_PTranspose_Dot__$PDotSigmaDot_PTranspose_PlusOmega$Inverse__DotPDotSigma$$Matrix[0].length;
<span class="fc" id="L494">				++tauDot$$SigmaMinusSigmaDot_PTranspose_Dot__$PDotSigmaDot_PTranspose_PlusOmega$Inverse__DotPDotSigma$$MatrixColumnIndex)</span>
			{
<span class="fc" id="L496">				tauDot$$SigmaMinusSigmaDot_PTranspose_Dot__$PDotSigmaDot_PTranspose_PlusOmega$Inverse__DotPDotSigma$$Matrix[tauDot$$SigmaMinusSigmaDot_PTranspose_Dot__$PDotSigmaDot_PTranspose_PlusOmega$Inverse__DotPDotSigma$$MatrixRowIndex][tauDot$$SigmaMinusSigmaDot_PTranspose_Dot__$PDotSigmaDot_PTranspose_PlusOmega$Inverse__DotPDotSigma$$MatrixColumnIndex] =</span>
					inputTAU * sigmaMinusSigmaDot_PTranspose_Dot__$PDotSigmaDot_PTranspose_PlusOmega$Inverse__DotPDotSigmaMatrix[tauDot$$SigmaMinusSigmaDot_PTranspose_Dot__$PDotSigmaDot_PTranspose_PlusOmega$Inverse__DotPDotSigma$$MatrixRowIndex][tauDot$$SigmaMinusSigmaDot_PTranspose_Dot__$PDotSigmaDot_PTranspose_PlusOmega$Inverse__DotPDotSigma$$MatrixColumnIndex];

<span class="fc" id="L499">				System.out.println (</span>
					&quot;\tTAU.(SIGMA-{SIGMA.PTRANSPOSE}.{P.SIGMA.PTRANSPOSE+OMEGA}^(-1).{P.SIGMA})[&quot; + tauDot$$SigmaMinusSigmaDot_PTranspose_Dot__$PDotSigmaDot_PTranspose_PlusOmega$Inverse__DotPDotSigma$$MatrixRowIndex + &quot;][&quot; + tauDot$$SigmaMinusSigmaDot_PTranspose_Dot__$PDotSigmaDot_PTranspose_PlusOmega$Inverse__DotPDotSigma$$MatrixColumnIndex + &quot;] =&gt;&quot; +
<span class="fc" id="L501">					FormatUtil.FormatDouble (tauDot$$SigmaMinusSigmaDot_PTranspose_Dot__$PDotSigmaDot_PTranspose_PlusOmega$Inverse__DotPDotSigma$$Matrix[tauDot$$SigmaMinusSigmaDot_PTranspose_Dot__$PDotSigmaDot_PTranspose_PlusOmega$Inverse__DotPDotSigma$$MatrixRowIndex][tauDot$$SigmaMinusSigmaDot_PTranspose_Dot__$PDotSigmaDot_PTranspose_PlusOmega$Inverse__DotPDotSigma$$MatrixColumnIndex], 1, 6, 1.)</span>
				);
			}
		}

<span class="fc" id="L506">		System.out.println();</span>

<span class="fc" id="L508">		double[][] sigmaPlusTauDot$$SigmaMinusSigmaDot_PTranspose_Dot__$PDotSigmaDot_PTranspose_PlusOmega$Inverse__DotPDotSigma$$Matrix =</span>
			new double[sovereignCount][sovereignCount];

<span class="fc" id="L511">		for (int sigmaPlusTauDot$$SigmaMinusSigmaDot_PTranspose_Dot__$PDotSigmaDot_PTranspose_PlusOmega$Inverse__DotPDotSigma$$MatrixRowIndex = 0;</span>
<span class="fc bfc" id="L512" title="All 2 branches covered.">				sigmaPlusTauDot$$SigmaMinusSigmaDot_PTranspose_Dot__$PDotSigmaDot_PTranspose_PlusOmega$Inverse__DotPDotSigma$$MatrixRowIndex &lt;</span>
				sigmaPlusTauDot$$SigmaMinusSigmaDot_PTranspose_Dot__$PDotSigmaDot_PTranspose_PlusOmega$Inverse__DotPDotSigma$$Matrix.length;
<span class="fc" id="L514">			++sigmaPlusTauDot$$SigmaMinusSigmaDot_PTranspose_Dot__$PDotSigmaDot_PTranspose_PlusOmega$Inverse__DotPDotSigma$$MatrixRowIndex)</span>
		{
<span class="fc" id="L516">			for (int sigmaPlusTauDot$$SigmaMinusSigmaDot_PTranspose_Dot__$PDotSigmaDot_PTranspose_PlusOmega$Inverse__DotPDotSigma$$MatrixColumnIndex = 0;</span>
<span class="fc bfc" id="L517" title="All 2 branches covered.">				sigmaPlusTauDot$$SigmaMinusSigmaDot_PTranspose_Dot__$PDotSigmaDot_PTranspose_PlusOmega$Inverse__DotPDotSigma$$MatrixColumnIndex &lt;</span>
					sigmaPlusTauDot$$SigmaMinusSigmaDot_PTranspose_Dot__$PDotSigmaDot_PTranspose_PlusOmega$Inverse__DotPDotSigma$$Matrix[0].length;
<span class="fc" id="L519">				++sigmaPlusTauDot$$SigmaMinusSigmaDot_PTranspose_Dot__$PDotSigmaDot_PTranspose_PlusOmega$Inverse__DotPDotSigma$$MatrixColumnIndex)</span>
			{
<span class="fc" id="L521">				sigmaPlusTauDot$$SigmaMinusSigmaDot_PTranspose_Dot__$PDotSigmaDot_PTranspose_PlusOmega$Inverse__DotPDotSigma$$Matrix[sigmaPlusTauDot$$SigmaMinusSigmaDot_PTranspose_Dot__$PDotSigmaDot_PTranspose_PlusOmega$Inverse__DotPDotSigma$$MatrixRowIndex][sigmaPlusTauDot$$SigmaMinusSigmaDot_PTranspose_Dot__$PDotSigmaDot_PTranspose_PlusOmega$Inverse__DotPDotSigma$$MatrixColumnIndex] =</span>
					sigmaMatrix[sigmaPlusTauDot$$SigmaMinusSigmaDot_PTranspose_Dot__$PDotSigmaDot_PTranspose_PlusOmega$Inverse__DotPDotSigma$$MatrixRowIndex][sigmaPlusTauDot$$SigmaMinusSigmaDot_PTranspose_Dot__$PDotSigmaDot_PTranspose_PlusOmega$Inverse__DotPDotSigma$$MatrixColumnIndex] +
					tauDot$$SigmaMinusSigmaDot_PTranspose_Dot__$PDotSigmaDot_PTranspose_PlusOmega$Inverse__DotPDotSigma$$Matrix[sigmaPlusTauDot$$SigmaMinusSigmaDot_PTranspose_Dot__$PDotSigmaDot_PTranspose_PlusOmega$Inverse__DotPDotSigma$$MatrixRowIndex][sigmaPlusTauDot$$SigmaMinusSigmaDot_PTranspose_Dot__$PDotSigmaDot_PTranspose_PlusOmega$Inverse__DotPDotSigma$$MatrixColumnIndex];

<span class="fc" id="L525">				System.out.println (</span>
					&quot;\tSIGMA+TAU.(SIGMA-{SIGMA.PTRANSPOSE}.{P.SIGMA.PTRANSPOSE+OMEGA}^(-1).{P.SIGMA})[&quot; + sigmaPlusTauDot$$SigmaMinusSigmaDot_PTranspose_Dot__$PDotSigmaDot_PTranspose_PlusOmega$Inverse__DotPDotSigma$$MatrixRowIndex + &quot;][&quot; + sigmaPlusTauDot$$SigmaMinusSigmaDot_PTranspose_Dot__$PDotSigmaDot_PTranspose_PlusOmega$Inverse__DotPDotSigma$$MatrixColumnIndex + &quot;] =&gt;&quot; +
<span class="fc" id="L527">					FormatUtil.FormatDouble (sigmaPlusTauDot$$SigmaMinusSigmaDot_PTranspose_Dot__$PDotSigmaDot_PTranspose_PlusOmega$Inverse__DotPDotSigma$$Matrix[sigmaPlusTauDot$$SigmaMinusSigmaDot_PTranspose_Dot__$PDotSigmaDot_PTranspose_PlusOmega$Inverse__DotPDotSigma$$MatrixRowIndex][sigmaPlusTauDot$$SigmaMinusSigmaDot_PTranspose_Dot__$PDotSigmaDot_PTranspose_PlusOmega$Inverse__DotPDotSigma$$MatrixColumnIndex], 1, 6, 1.)</span>
				);
			}
		}

<span class="fc" id="L532">		System.out.println();</span>

<span class="fc" id="L534">		double[][] sigmaPInverseMatrix = Matrix.InvertUsingGaussianElimination (</span>
			sigmaPlusTauDot$$SigmaMinusSigmaDot_PTranspose_Dot__$PDotSigmaDot_PTranspose_PlusOmega$Inverse__DotPDotSigma$$Matrix
		);

<span class="fc" id="L538">		for (int sigmaPInverseMatrixRowIndex = 0;</span>
<span class="fc bfc" id="L539" title="All 2 branches covered.">			sigmaPInverseMatrixRowIndex&lt; sigmaPInverseMatrix.length;</span>
<span class="fc" id="L540">			++sigmaPInverseMatrixRowIndex)</span>
		{
<span class="fc" id="L542">			for (int sigmaPInverseMatrixColumnIndex = 0;</span>
<span class="fc bfc" id="L543" title="All 2 branches covered.">				sigmaPInverseMatrixColumnIndex &lt; sigmaPInverseMatrix[0].length;</span>
<span class="fc" id="L544">				++sigmaPInverseMatrixColumnIndex)</span>
			{
<span class="fc" id="L546">				System.out.println (</span>
					&quot;\t[SIGMA+TAU.(SIGMA-{SIGMA.PTRANSPOSE}.{P.SIGMA.PTRANSPOSE+OMEGA}^(-1).{P.SIGMA})]^(-1)[&quot; + sigmaPInverseMatrixRowIndex + &quot;][&quot; + sigmaPInverseMatrixColumnIndex + &quot;] =&gt;&quot; +
<span class="fc" id="L548">					FormatUtil.FormatDouble (sigmaPInverseMatrix[sigmaPInverseMatrixRowIndex][sigmaPInverseMatrixColumnIndex], 1, 6, 1.)</span>
				);
			}
		}

<span class="fc" id="L553">		System.out.println();</span>

<span class="fc" id="L555">		double[] sigmaPInverseDotPiHatArray = Matrix.Product (</span>
			sigmaPInverseMatrix,
			piHatArray
		);

<span class="fc" id="L560">		for (int sigmaPInverseDotPiHatArrayIndex = 0;</span>
<span class="fc bfc" id="L561" title="All 2 branches covered.">			sigmaPInverseDotPiHatArrayIndex &lt; sigmaPInverseDotPiHatArray.length;</span>
<span class="fc" id="L562">			++sigmaPInverseDotPiHatArrayIndex)</span>
		{
<span class="fc" id="L564">			sigmaPInverseDotPiHatArray[sigmaPInverseDotPiHatArrayIndex] /= inputDELTA;</span>

<span class="fc" id="L566">			System.out.println (</span>
				&quot;\t[SIGMA+TAU.(SIGMA-{SIGMA.PTRANSPOSE}.{P.SIGMA.PTRANSPOSE+OMEGA}^(-1).{P.SIGMA})]^(-1).PIHAT[&quot; + sigmaPInverseDotPiHatArrayIndex + &quot;] =&gt;&quot; +
<span class="fc" id="L568">				FormatUtil.FormatDouble (sigmaPInverseDotPiHatArray[sigmaPInverseDotPiHatArrayIndex], 1, 1, 100.) + &quot;%&quot;</span>
			);
		}

<span class="fc" id="L572">		System.out.println (&quot;\n\n\t|----------------||&quot;);</span>

<span class="fc" id="L574">		System.out.println (&quot;\t|  EQUILIBRIUM   ||&quot;);</span>

<span class="fc" id="L576">		System.out.println (&quot;\t|    RETURNS     ||&quot;);</span>

<span class="fc" id="L578">		System.out.println (&quot;\t|----------------||&quot;);</span>

<span class="fc bfc" id="L580" title="All 2 branches covered.">		for (int piArrayIndex = 0; piArrayIndex &lt; piArray.length; ++piArrayIndex)</span>
		{
<span class="fc" id="L582">			System.out.println (</span>
				&quot;\t| [&quot; + sovereignArray[piArrayIndex] + &quot;] =&gt;&quot; +
<span class="fc" id="L584">				FormatUtil.FormatDouble (piArray[piArrayIndex], 2, 1, 100.) + &quot;% ||&quot;</span>
			);
		}

<span class="fc" id="L588">		System.out.println (&quot;\n\n\t|----------------||&quot;);</span>

<span class="fc" id="L590">		System.out.println (&quot;\t| BLACK LITERMAN ||&quot;);</span>

<span class="fc" id="L592">		System.out.println (&quot;\t|    RETURNS     ||&quot;);</span>

<span class="fc" id="L594">		System.out.println (&quot;\t|----------------||&quot;);</span>

<span class="fc bfc" id="L596" title="All 2 branches covered.">		for (int piArrayIndex = 0; piArrayIndex &lt; piHatArray.length; ++piArrayIndex)</span>
		{
<span class="fc" id="L598">			System.out.println (</span>
				&quot;\t| [&quot; + sovereignArray[piArrayIndex] + &quot;] =&gt;&quot; +
<span class="fc" id="L600">				FormatUtil.FormatDouble (piHatArray[piArrayIndex], 2, 1, 100.) + &quot;% ||&quot;</span>
			);
		}

<span class="fc" id="L604">		System.out.println (&quot;\t|----------------||&quot;);</span>

<span class="fc" id="L606">		System.out.println (&quot;\t|----------------||&quot;);</span>

<span class="fc" id="L608">		System.out.println (&quot;\n\n\t|-----------------||&quot;);</span>

<span class="fc" id="L610">		System.out.println (&quot;\t|   EQUILIBRIUM   ||&quot;);</span>

<span class="fc" id="L612">		System.out.println (&quot;\t|   ALLOCATION    ||&quot;);</span>

<span class="fc" id="L614">		System.out.println (&quot;\t|-----------------||&quot;);</span>

<span class="fc bfc" id="L616" title="All 2 branches covered.">		for (int inputWArrayIndex = 0; inputWArrayIndex &lt; inputWArray.length; ++inputWArrayIndex)</span>
		{
<span class="fc" id="L618">			System.out.println (</span>
				&quot;\t| [&quot; + sovereignArray[inputWArrayIndex] + &quot;] =&gt; &quot; +
<span class="fc" id="L620">				FormatUtil.FormatDouble (inputWArray[inputWArrayIndex] / (1. + inputTAU), 2, 1, 100.) + &quot;% ||&quot;</span>
			);
		}

<span class="fc" id="L624">		System.out.println (&quot;\t|-----------------||&quot;);</span>

<span class="fc" id="L626">		System.out.println (&quot;\n\n\t|-----------------||&quot;);</span>

<span class="fc" id="L628">		System.out.println (&quot;\t| BLACK LITERMAN  ||&quot;);</span>

<span class="fc" id="L630">		System.out.println (&quot;\t|    ALLOCATION   ||&quot;);</span>

<span class="fc" id="L632">		System.out.println (&quot;\t|-----------------||&quot;);</span>

<span class="fc" id="L634">		for (int sigmaPInverseDotPiHatArrayIndex = 0;</span>
<span class="fc bfc" id="L635" title="All 2 branches covered.">			sigmaPInverseDotPiHatArrayIndex &lt; sigmaPInverseDotPiHatArray.length;</span>
<span class="fc" id="L636">			++sigmaPInverseDotPiHatArrayIndex)</span>
		{
<span class="fc" id="L638">			System.out.println (</span>
				&quot;\t| [&quot; + sovereignArray[sigmaPInverseDotPiHatArrayIndex] + &quot;] =&gt; &quot; +
<span class="fc" id="L640">				FormatUtil.FormatDouble (sigmaPInverseDotPiHatArray[sigmaPInverseDotPiHatArrayIndex], 2, 1, 100.) + &quot;% ||&quot;</span>
			);
		}

<span class="fc" id="L644">		System.out.println (&quot;\t|-----------------||&quot;);</span>

<span class="fc" id="L646">		System.out.println (&quot;\n\n\t|------------------||&quot;);</span>

<span class="fc" id="L648">		System.out.println (&quot;\t|  BLACK LITERMAN  ||&quot;);</span>

<span class="fc" id="L650">		System.out.println (&quot;\t| ALLOCATION SHIFT ||&quot;);</span>

<span class="fc" id="L652">		System.out.println (&quot;\t|------------------||&quot;);</span>

<span class="fc" id="L654">		for (int sigmaPInverseDotPiHatArrayIndex = 0;</span>
<span class="fc bfc" id="L655" title="All 2 branches covered.">			sigmaPInverseDotPiHatArrayIndex &lt; sigmaPInverseDotPiHatArray.length;</span>
<span class="fc" id="L656">			++sigmaPInverseDotPiHatArrayIndex)</span>
		{
<span class="fc" id="L658">			System.out.println (</span>
				&quot;\t| [&quot; + sovereignArray[sigmaPInverseDotPiHatArrayIndex] + &quot;] =&gt; &quot; +
<span class="fc" id="L660">				FormatUtil.FormatDouble (sigmaPInverseDotPiHatArray[sigmaPInverseDotPiHatArrayIndex] - (inputWArray[sigmaPInverseDotPiHatArrayIndex] / (1. + inputTAU)), 2, 1, 100.) + &quot;%  ||&quot;</span>
			);
		}

<span class="fc" id="L664">		System.out.println (&quot;\t|------------------||&quot;);</span>

<span class="fc" id="L666">		EnvManager.TerminateEnv();</span>
<span class="fc" id="L667">	}</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.7.9.201702052155</span></div></body></html>