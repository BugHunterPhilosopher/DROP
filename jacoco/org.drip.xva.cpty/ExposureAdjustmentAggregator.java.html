<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>ExposureAdjustmentAggregator.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">DROP</a> &gt; <a href="index.source.html" class="el_package">org.drip.xva.cpty</a> &gt; <span class="el_source">ExposureAdjustmentAggregator.java</span></div><h1>ExposureAdjustmentAggregator.java</h1><pre class="source lang-java linenums">
package org.drip.xva.cpty;

/*
 * -*- mode: java; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*-
 */

/*!
 * Copyright (C) 2018 Lakshmi Krishnamurthy
 * Copyright (C) 2017 Lakshmi Krishnamurthy
 * 
 *  This file is part of DRIP, a free-software/open-source library for buy/side financial/trading model
 *  	libraries targeting analysts and developers
 *  	https://lakshmidrip.github.io/DRIP/
 *  
 *  DRIP is composed of four main libraries:
 *  
 *  - DRIP Fixed Income - https://lakshmidrip.github.io/DRIP-Fixed-Income/
 *  - DRIP Asset Allocation - https://lakshmidrip.github.io/DRIP-Asset-Allocation/
 *  - DRIP Numerical Optimizer - https://lakshmidrip.github.io/DRIP-Numerical-Optimizer/
 *  - DRIP Statistical Learning - https://lakshmidrip.github.io/DRIP-Statistical-Learning/
 * 
 *  - DRIP Fixed Income: Library for Instrument/Trading Conventions, Treasury Futures/Options,
 *  	Funding/Forward/Overnight Curves, Multi-Curve Construction/Valuation, Collateral Valuation and XVA
 *  	Metric Generation, Calibration and Hedge Attributions, Statistical Curve Construction, Bond RV
 *  	Metrics, Stochastic Evolution and Option Pricing, Interest Rate Dynamics and Option Pricing, LMM
 *  	Extensions/Calibrations/Greeks, Algorithmic Differentiation, and Asset Backed Models and Analytics.
 * 
 *  - DRIP Asset Allocation: Library for model libraries for MPT framework, Black Litterman Strategy
 *  	Incorporator, Holdings Constraint, and Transaction Costs.
 * 
 *  - DRIP Numerical Optimizer: Library for Numerical Optimization and Spline Functionality.
 * 
 *  - DRIP Statistical Learning: Library for Statistical Evaluation and Machine Learning.
 * 
 *  Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 *   	you may not use this file except in compliance with the License.
 *   
 *  You may obtain a copy of the License at
 *  	http://www.apache.org/licenses/LICENSE-2.0
 *  
 *  Unless required by applicable law or agreed to in writing, software
 *  	distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 *  	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  
 *  See the License for the specific language governing permissions and
 *  	limitations under the License.
 */

/**
 * ExposureAdjustmentAggregator aggregates across Multiple Exposure/Adjustment Paths belonging to the Counter
 *  Party. The References are:
 *  
 *  - Burgard, C., and M. Kjaer (2014): PDE Representations of Derivatives with Bilateral Counter-party Risk
 *  	and Funding Costs, Journal of Credit Risk, 7 (3) 1-19.
 *  
 *  - Burgard, C., and M. Kjaer (2014): In the Balance, Risk, 24 (11) 72-75.
 *  
 *  - Gregory, J. (2009): Being Two-faced over Counter-party Credit Risk, Risk 20 (2) 86-90.
 *  
 *  - Li, B., and Y. Tang (2007): Quantitative Analysis, Derivatives Modeling, and Trading Strategies in the
 *  	Presence of Counter-party Credit Risk for the Fixed Income Market, World Scientific Publishing,
 *  	Singapore.
 * 
 *  - Piterbarg, V. (2010): Funding Beyond Discounting: Collateral Agreements and Derivatives Pricing, Risk
 *  	21 (2) 97-102.
 * 
 * @author Lakshmi Krishnamurthy
 */

public class ExposureAdjustmentAggregator
{
<span class="fc" id="L73">	private org.drip.xva.cpty.PathExposureAdjustment[] _pathExposureAdjustmentArray = null;</span>

	/**
	 * ExposureAdjustmentAggregator Constructor
	 * 
	 * @param pathExposureAdjustmentArray Array of the Counter Party Group Paths
	 * 
	 * @throws java.lang.Exception Thrown if the Inputs are Invalid
	 */

	public ExposureAdjustmentAggregator (
		final org.drip.xva.cpty.PathExposureAdjustment[] pathExposureAdjustmentArray)
		throws java.lang.Exception
<span class="fc" id="L86">	{</span>
<span class="pc bpc" id="L87" title="2 of 4 branches missed.">		if (null == (_pathExposureAdjustmentArray = pathExposureAdjustmentArray) ||</span>
			0 == _pathExposureAdjustmentArray.length)
		{
<span class="nc" id="L90">			throw new java.lang.Exception (&quot;ExposureAdjustmentAggregator Constructor =&gt; Invalid Inputs&quot;);</span>
		}
<span class="fc" id="L92">	}</span>

	/**
	 * Retrieve the Array of Counter Party Group Path Exposures
	 * 
	 * @return Array of Counter Party Group Path Exposures
	 */

	public org.drip.xva.cpty.PathExposureAdjustment[] counterPartyPathExposures()
	{
<span class="nc" id="L102">		return _pathExposureAdjustmentArray;</span>
	}

	/**
	 * Retrieve the Array of the Vertex Anchor Dates
	 * 
	 * @return The Array of the Vertex Anchor Dates
	 */

	public org.drip.analytics.date.JulianDate[] anchorDates()
	{
<span class="fc" id="L113">		return _pathExposureAdjustmentArray[0].anchorDates();</span>
	}

	/**
	 * Retrieve the Array of Collateralized Exposures
	 * 
	 * @return The Array of Collateralized Exposures
	 */

	public double[] collateralizedExposure()
	{
<span class="fc" id="L124">		int vertexCount = anchorDates().length;</span>

<span class="fc" id="L126">		int pathCount = _pathExposureAdjustmentArray.length;</span>
<span class="fc" id="L127">		double[] collateralizedExposure = new double[vertexCount];</span>

<span class="fc bfc" id="L129" title="All 2 branches covered.">		for (int vertexIndex = 0; vertexIndex &lt; vertexCount; ++vertexIndex)</span>
		{
<span class="fc" id="L131">			collateralizedExposure[vertexIndex] = 0.;</span>
		}

<span class="fc bfc" id="L134" title="All 2 branches covered.">		for (int pathIndex = 0; pathIndex &lt; pathCount; ++pathIndex)</span>
		{
<span class="fc" id="L136">			double[] pathCollateralizedExposure =</span>
<span class="fc" id="L137">				_pathExposureAdjustmentArray[pathIndex].collateralizedExposure();</span>

<span class="fc bfc" id="L139" title="All 2 branches covered.">			for (int vertexIndex = 0; vertexIndex &lt; vertexCount; ++vertexIndex)</span>
			{
<span class="fc" id="L141">				collateralizedExposure[vertexIndex] += pathCollateralizedExposure[vertexIndex];</span>
			}
		}

<span class="fc bfc" id="L145" title="All 2 branches covered.">		for (int vertexIndex = 0; vertexIndex &lt; vertexCount; ++vertexIndex)</span>
		{
<span class="fc" id="L147">			collateralizedExposure[vertexIndex] /= pathCount;</span>
		}

<span class="fc" id="L150">		return collateralizedExposure;</span>
	}

	/**
	 * Retrieve the Array of Collateralized Exposure PV's
	 * 
	 * @return The Array of Collateralized Exposure PV's
	 */

	public double[] collateralizedExposurePV()
	{
<span class="fc" id="L161">		int vertexCount = anchorDates().length;</span>

<span class="fc" id="L163">		int pathCount = _pathExposureAdjustmentArray.length;</span>
<span class="fc" id="L164">		double[] collateralizedExposurePV = new double[vertexCount];</span>

<span class="fc bfc" id="L166" title="All 2 branches covered.">		for (int vertexIndex = 0; vertexIndex &lt; vertexCount; ++vertexIndex)</span>
		{
<span class="fc" id="L168">			collateralizedExposurePV[vertexIndex] = 0.;</span>
		}

<span class="fc bfc" id="L171" title="All 2 branches covered.">		for (int pathIndex = 0; pathIndex &lt; pathCount; ++pathIndex)</span>
		{
<span class="fc" id="L173">			double[] pathCollateralizedExposurePV =</span>
<span class="fc" id="L174">				_pathExposureAdjustmentArray[pathIndex].collateralizedExposurePV();</span>

<span class="fc bfc" id="L176" title="All 2 branches covered.">			for (int vertexIndex = 0; vertexIndex &lt; vertexCount; ++vertexIndex)</span>
			{
<span class="fc" id="L178">				collateralizedExposurePV[vertexIndex] += pathCollateralizedExposurePV[vertexIndex];</span>
			}
		}

<span class="fc bfc" id="L182" title="All 2 branches covered.">		for (int vertexIndex = 0; vertexIndex &lt; vertexCount; ++vertexIndex)</span>
		{
<span class="fc" id="L184">			collateralizedExposurePV[vertexIndex] /= pathCount;</span>
		}

<span class="fc" id="L187">		return collateralizedExposurePV;</span>
	}

	/**
	 * Retrieve the Array of Uncollateralized Exposures
	 * 
	 * @return The Array of Uncollateralized Exposures
	 */

	public double[] uncollateralizedExposure()
	{
<span class="nc" id="L198">		int vertexCount = anchorDates().length;</span>

<span class="nc" id="L200">		int pathCount = _pathExposureAdjustmentArray.length;</span>
<span class="nc" id="L201">		double[] uncollateralizedExposure = new double[vertexCount];</span>

<span class="nc bnc" id="L203" title="All 2 branches missed.">		for (int vertexIndex = 0; vertexIndex &lt; vertexCount; ++vertexIndex)</span>
		{
<span class="nc" id="L205">			uncollateralizedExposure[vertexIndex] = 0.;</span>
		}

<span class="nc bnc" id="L208" title="All 2 branches missed.">		for (int pathIndex = 0; pathIndex &lt; pathCount; ++pathIndex)</span>
		{
<span class="nc" id="L210">			double[] pathUncollateralizedExposure =</span>
<span class="nc" id="L211">				_pathExposureAdjustmentArray[pathIndex].uncollateralizedExposure();</span>

<span class="nc bnc" id="L213" title="All 2 branches missed.">			for (int vertexIndex = 0; vertexIndex &lt; vertexCount; ++vertexIndex)</span>
			{
<span class="nc" id="L215">				uncollateralizedExposure[vertexIndex] += pathUncollateralizedExposure[vertexIndex];</span>
			}
		}

<span class="nc bnc" id="L219" title="All 2 branches missed.">		for (int vertexIndex = 0; vertexIndex &lt; vertexCount; ++vertexIndex)</span>
<span class="nc" id="L220">			uncollateralizedExposure[vertexIndex] /= pathCount;</span>

<span class="nc" id="L222">		return uncollateralizedExposure;</span>
	}

	/**
	 * Retrieve the Array of Uncollateralized Exposure PV's
	 * 
	 * @return The Array of Uncollateralized Exposure PV's
	 */

	public double[] uncollateralizedExposurePV()
	{
<span class="nc" id="L233">		int vertexCount = anchorDates().length;</span>

<span class="nc" id="L235">		int pathCount = _pathExposureAdjustmentArray.length;</span>
<span class="nc" id="L236">		double[] uncollateralizedExposurePV = new double[vertexCount];</span>

<span class="nc bnc" id="L238" title="All 2 branches missed.">		for (int vertexIndex = 0; vertexIndex &lt; vertexCount; ++vertexIndex)</span>
		{
<span class="nc" id="L240">			uncollateralizedExposurePV[vertexIndex] = 0.;</span>
		}

<span class="nc bnc" id="L243" title="All 2 branches missed.">		for (int pathIndex = 0; pathIndex &lt; pathCount; ++pathIndex)</span>
		{
<span class="nc" id="L245">			double[] pathUncollateralizedExposurePV =</span>
<span class="nc" id="L246">				_pathExposureAdjustmentArray[pathIndex].uncollateralizedExposurePV();</span>

<span class="nc bnc" id="L248" title="All 2 branches missed.">			for (int vertexIndex = 0; vertexIndex &lt; vertexCount; ++vertexIndex)</span>
			{
<span class="nc" id="L250">				uncollateralizedExposurePV[vertexIndex] +=</span>
					pathUncollateralizedExposurePV[vertexIndex];
			}
		}

<span class="nc bnc" id="L255" title="All 2 branches missed.">		for (int vertexIndex = 0; vertexIndex &lt; vertexCount; ++vertexIndex)</span>
		{
<span class="nc" id="L257">			uncollateralizedExposurePV[vertexIndex] /= pathCount;</span>
		}

<span class="nc" id="L260">		return uncollateralizedExposurePV;</span>
	}

	/**
	 * Retrieve the Array of Collateralized Positive Exposures
	 * 
	 * @return The Array of Collateralized Positive Exposures
	 */

	public double[] collateralizedPositiveExposure()
	{
<span class="fc" id="L271">		int vertexCount = anchorDates().length;</span>

<span class="fc" id="L273">		int pathCount = _pathExposureAdjustmentArray.length;</span>
<span class="fc" id="L274">		double[] collateralizedPositiveExposure = new double[vertexCount];</span>

<span class="fc bfc" id="L276" title="All 2 branches covered.">		for (int vertexIndex = 0; vertexIndex &lt; vertexCount; ++vertexIndex)</span>
		{
<span class="fc" id="L278">			collateralizedPositiveExposure[vertexIndex] = 0.;</span>
		}

<span class="fc bfc" id="L281" title="All 2 branches covered.">		for (int pathIndex = 0; pathIndex &lt; pathCount; ++pathIndex)</span>
		{
<span class="fc" id="L283">			double[] pathCollateralizedPositiveExposure =</span>
<span class="fc" id="L284">				_pathExposureAdjustmentArray[pathIndex].collateralizedPositiveExposure();</span>

<span class="fc bfc" id="L286" title="All 2 branches covered.">			for (int vertexIndex = 0; vertexIndex &lt; vertexCount; ++vertexIndex)</span>
			{
<span class="fc" id="L288">				collateralizedPositiveExposure[vertexIndex] +=</span>
					pathCollateralizedPositiveExposure[vertexIndex];
			}
		}

<span class="fc bfc" id="L293" title="All 2 branches covered.">		for (int vertexIndex = 0; vertexIndex &lt; vertexCount; ++vertexIndex)</span>
		{
<span class="fc" id="L295">			collateralizedPositiveExposure[vertexIndex] /= pathCount;</span>
		}

<span class="fc" id="L298">		return collateralizedPositiveExposure;</span>
	}

	/**
	 * Retrieve the Array of Collateralized Positive Exposure PV
	 * 
	 * @return The Array of Collateralized Positive Exposure PV
	 */

	public double[] collateralizedPositiveExposurePV()
	{
<span class="fc" id="L309">		int vertexCount = anchorDates().length;</span>

<span class="fc" id="L311">		int pathCount = _pathExposureAdjustmentArray.length;</span>
<span class="fc" id="L312">		double[] collateralizedPositiveExposurePV = new double[vertexCount];</span>

<span class="fc bfc" id="L314" title="All 2 branches covered.">		for (int vertexIndex = 0; vertexIndex &lt; vertexCount; ++vertexIndex)</span>
		{
<span class="fc" id="L316">			collateralizedPositiveExposurePV[vertexIndex] = 0.;</span>
		}

<span class="fc bfc" id="L319" title="All 2 branches covered.">		for (int pathIndex = 0; pathIndex &lt; pathCount; ++pathIndex)</span>
		{
<span class="fc" id="L321">			double[] pathCollateralizedPositiveExposurePV =</span>
<span class="fc" id="L322">				_pathExposureAdjustmentArray[pathIndex].collateralizedPositiveExposurePV();</span>

<span class="fc bfc" id="L324" title="All 2 branches covered.">			for (int vertexIndex = 0; vertexIndex &lt; vertexCount; ++vertexIndex)</span>
			{
<span class="fc" id="L326">				collateralizedPositiveExposurePV[vertexIndex] +=</span>
					pathCollateralizedPositiveExposurePV[vertexIndex];
			}
		}

<span class="fc bfc" id="L331" title="All 2 branches covered.">		for (int vertexIndex = 0; vertexIndex &lt; vertexCount; ++vertexIndex)</span>
		{
<span class="fc" id="L333">			collateralizedPositiveExposurePV[vertexIndex] /= pathCount;</span>
		}

<span class="fc" id="L336">		return collateralizedPositiveExposurePV;</span>
	}

	/**
	 * Retrieve the Array of Uncollateralized Positive Exposures
	 * 
	 * @return The Array of Uncollateralized Positive Exposures
	 */

	public double[] uncollateralizedPositiveExposure()
	{
<span class="nc" id="L347">		int vertexCount = anchorDates().length;</span>

<span class="nc" id="L349">		int pathCount = _pathExposureAdjustmentArray.length;</span>
<span class="nc" id="L350">		double[] uncollateralizedPositiveExposure = new double[vertexCount];</span>

<span class="nc bnc" id="L352" title="All 2 branches missed.">		for (int vertexIndex = 0; vertexIndex &lt; vertexCount; ++vertexIndex)</span>
		{
<span class="nc" id="L354">			uncollateralizedPositiveExposure[vertexIndex] = 0.;</span>
		}

<span class="nc bnc" id="L357" title="All 2 branches missed.">		for (int pathIndex = 0; pathIndex &lt; pathCount; ++pathIndex)</span>
		{
<span class="nc" id="L359">			double[] pathUncollateralizedPositiveExposure =</span>
<span class="nc" id="L360">				_pathExposureAdjustmentArray[pathIndex].uncollateralizedPositiveExposure();</span>

<span class="nc bnc" id="L362" title="All 2 branches missed.">			for (int vertexIndex = 0; vertexIndex &lt; vertexCount; ++vertexIndex)</span>
			{
<span class="nc" id="L364">				uncollateralizedPositiveExposure[vertexIndex] +=</span>
					pathUncollateralizedPositiveExposure[vertexIndex];
			}
		}

<span class="nc bnc" id="L369" title="All 2 branches missed.">		for (int vertexIndex = 0; vertexIndex &lt; vertexCount; ++vertexIndex)</span>
		{
<span class="nc" id="L371">			uncollateralizedPositiveExposure[vertexIndex] /= pathCount;</span>
		}

<span class="nc" id="L374">		return uncollateralizedPositiveExposure;</span>
	}

	/**
	 * Retrieve the Array of Uncollateralized Positive Exposure PV
	 * 
	 * @return The Array of Uncollateralized Positive Exposure PV
	 */

	public double[] uncollateralizedPositiveExposurePV()
	{
<span class="nc" id="L385">		int vertexCount = anchorDates().length;</span>

<span class="nc" id="L387">		int pathCount = _pathExposureAdjustmentArray.length;</span>
<span class="nc" id="L388">		double[] uncollateralizedPositiveExposurePV = new double[vertexCount];</span>

<span class="nc bnc" id="L390" title="All 2 branches missed.">		for (int vertexIndex = 0; vertexIndex &lt; vertexCount; ++vertexIndex)</span>
		{
<span class="nc" id="L392">			uncollateralizedPositiveExposurePV[vertexIndex] = 0.;</span>
		}

<span class="nc bnc" id="L395" title="All 2 branches missed.">		for (int pathIndex = 0; pathIndex &lt; pathCount; ++pathIndex)</span>
		{
<span class="nc" id="L397">			double[] pathUncollateralizedPositiveExposurePV =</span>
<span class="nc" id="L398">				_pathExposureAdjustmentArray[pathIndex].uncollateralizedPositiveExposurePV();</span>

<span class="nc bnc" id="L400" title="All 2 branches missed.">			for (int vertexIndex = 0; vertexIndex &lt; vertexCount; ++vertexIndex)</span>
			{
<span class="nc" id="L402">				uncollateralizedPositiveExposurePV[vertexIndex] +=</span>
					pathUncollateralizedPositiveExposurePV[vertexIndex];
			}
		}

<span class="nc bnc" id="L407" title="All 2 branches missed.">		for (int vertexIndex = 0; vertexIndex &lt; vertexCount; ++vertexIndex)</span>
		{
<span class="nc" id="L409">			uncollateralizedPositiveExposurePV[vertexIndex] /= pathCount;</span>
		}

<span class="nc" id="L412">		return uncollateralizedPositiveExposurePV;</span>
	}

	/**
	 * Retrieve the Array of Collateralized Negative Exposures
	 * 
	 * @return The Array of Collateralized Negative Exposures
	 */

	public double[] collateralizedNegativeExposure()
	{
<span class="fc" id="L423">		int vertexCount = anchorDates().length;</span>

<span class="fc" id="L425">		int pathCount = _pathExposureAdjustmentArray.length;</span>
<span class="fc" id="L426">		double[] collateralizedNegativeExposure = new double[vertexCount];</span>

<span class="fc bfc" id="L428" title="All 2 branches covered.">		for (int vertexIndex = 0; vertexIndex &lt; vertexCount; ++vertexIndex)</span>
		{
<span class="fc" id="L430">			collateralizedNegativeExposure[vertexIndex] = 0.;</span>
		}

<span class="fc bfc" id="L433" title="All 2 branches covered.">		for (int pathIndex = 0; pathIndex &lt; pathCount; ++pathIndex)</span>
		{
<span class="fc" id="L435">			double[] pathCollateralizedNegativeExposure =</span>
<span class="fc" id="L436">				_pathExposureAdjustmentArray[pathIndex].collateralizedNegativeExposure();</span>

<span class="fc bfc" id="L438" title="All 2 branches covered.">			for (int vertexIndex = 0; vertexIndex &lt; vertexCount; ++vertexIndex)</span>
			{
<span class="fc" id="L440">				collateralizedNegativeExposure[vertexIndex] +=</span>
					pathCollateralizedNegativeExposure[vertexIndex];
			}
		}

<span class="fc bfc" id="L445" title="All 2 branches covered.">		for (int vertexIndex = 0; vertexIndex &lt; vertexCount; ++vertexIndex)</span>
		{
<span class="fc" id="L447">			collateralizedNegativeExposure[vertexIndex] /= pathCount;</span>
		}

<span class="fc" id="L450">		return collateralizedNegativeExposure;</span>
	}

	/**
	 * Retrieve the Array of Collateralized Negative Exposure PV
	 * 
	 * @return The Array of Collateralized Negative Exposure PV
	 */

	public double[] collateralizedNegativeExposurePV()
	{
<span class="fc" id="L461">		int vertexCount = anchorDates().length;</span>

<span class="fc" id="L463">		int pathCount = _pathExposureAdjustmentArray.length;</span>
<span class="fc" id="L464">		double[] collateralizedNegativeExposurePV = new double[vertexCount];</span>

<span class="fc bfc" id="L466" title="All 2 branches covered.">		for (int vertexIndex = 0; vertexIndex &lt; vertexCount; ++vertexIndex)</span>
		{
<span class="fc" id="L468">			collateralizedNegativeExposurePV[vertexIndex] = 0.;</span>
		}

<span class="fc bfc" id="L471" title="All 2 branches covered.">		for (int pathIndex = 0; pathIndex &lt; pathCount; ++pathIndex)</span>
		{
<span class="fc" id="L473">			double[] pathCollateralizedNegativeExposurePV =</span>
<span class="fc" id="L474">				_pathExposureAdjustmentArray[pathIndex].collateralizedNegativeExposurePV();</span>

<span class="fc bfc" id="L476" title="All 2 branches covered.">			for (int vertexIndex = 0; vertexIndex &lt; vertexCount; ++vertexIndex)</span>
			{
<span class="fc" id="L478">				collateralizedNegativeExposurePV[vertexIndex] +=</span>
					pathCollateralizedNegativeExposurePV[vertexIndex];
			}
		}

<span class="fc bfc" id="L483" title="All 2 branches covered.">		for (int vertexIndex = 0; vertexIndex &lt; vertexCount; ++vertexIndex)</span>
		{
<span class="fc" id="L485">			collateralizedNegativeExposurePV[vertexIndex] /= pathCount;</span>
		}

<span class="fc" id="L488">		return collateralizedNegativeExposurePV;</span>
	}

	/**
	 * Retrieve the Array of Uncollateralized Negative Exposures
	 * 
	 * @return The Array of Uncollateralized Negative Exposures
	 */

	public double[] uncollateralizedNegativeExposure()
	{
<span class="nc" id="L499">		int vertexCount = anchorDates().length;</span>

<span class="nc" id="L501">		int pathCount = _pathExposureAdjustmentArray.length;</span>
<span class="nc" id="L502">		double[] uncollateralizedNegativeExposure = new double[vertexCount];</span>

<span class="nc bnc" id="L504" title="All 2 branches missed.">		for (int vertexIndex = 0; vertexIndex &lt; vertexCount; ++vertexIndex)</span>
		{
<span class="nc" id="L506">			uncollateralizedNegativeExposure[vertexIndex] = 0.;</span>
		}

<span class="nc bnc" id="L509" title="All 2 branches missed.">		for (int pathIndex = 0; pathIndex &lt; pathCount; ++pathIndex)</span>
		{
<span class="nc" id="L511">			double[] pathUncollateralizedNegativeExposure =</span>
<span class="nc" id="L512">				_pathExposureAdjustmentArray[pathIndex].uncollateralizedNegativeExposure();</span>

<span class="nc bnc" id="L514" title="All 2 branches missed.">			for (int vertexIndex = 0; vertexIndex &lt; vertexCount; ++vertexIndex)</span>
			{
<span class="nc" id="L516">				uncollateralizedNegativeExposure[vertexIndex] +=</span>
					pathUncollateralizedNegativeExposure[vertexIndex];
			}
		}

<span class="nc bnc" id="L521" title="All 2 branches missed.">		for (int vertexIndex = 0; vertexIndex &lt; vertexCount; ++vertexIndex)</span>
		{
<span class="nc" id="L523">			uncollateralizedNegativeExposure[vertexIndex] /= pathCount;</span>
		}

<span class="nc" id="L526">		return uncollateralizedNegativeExposure;</span>
	}

	/**
	 * Retrieve the Array of Uncollateralized Negative Exposure PV
	 * 
	 * @return The Array of Uncollateralized Negative Exposure PV
	 */

	public double[] uncollateralizedNegativeExposurePV()
	{
<span class="nc" id="L537">		int vertexCount = anchorDates().length;</span>

<span class="nc" id="L539">		int pathCount = _pathExposureAdjustmentArray.length;</span>
<span class="nc" id="L540">		double[] uncollateralizedNegativeExposurePV = new double[vertexCount];</span>

<span class="nc bnc" id="L542" title="All 2 branches missed.">		for (int vertexIndex = 0; vertexIndex &lt; vertexCount; ++vertexIndex)</span>
		{
<span class="nc" id="L544">			uncollateralizedNegativeExposurePV[vertexIndex] = 0.;</span>
		}

<span class="nc bnc" id="L547" title="All 2 branches missed.">		for (int pathIndex = 0; pathIndex &lt; pathCount; ++pathIndex)</span>
		{
<span class="nc" id="L549">			double[] pathUncollateralizedNegativeExposurePV =</span>
<span class="nc" id="L550">				_pathExposureAdjustmentArray[pathIndex].uncollateralizedNegativeExposurePV();</span>

<span class="nc bnc" id="L552" title="All 2 branches missed.">			for (int vertexIndex = 0; vertexIndex &lt; vertexCount; ++vertexIndex)</span>
			{
<span class="nc" id="L554">				uncollateralizedNegativeExposurePV[vertexIndex] +=</span>
					pathUncollateralizedNegativeExposurePV[vertexIndex];
			}
		}

<span class="nc bnc" id="L559" title="All 2 branches missed.">		for (int vertexIndex = 0; vertexIndex &lt; vertexCount; ++vertexIndex)</span>
		{
<span class="nc" id="L561">			uncollateralizedNegativeExposurePV[vertexIndex] /= pathCount;</span>
		}

<span class="nc" id="L564">		return uncollateralizedNegativeExposurePV;</span>
	}

	/**
	 * Retrieve the Array of Credit Exposures
	 * 
	 * @return The Array of Credit Exposures
	 */

	public double[] creditExposure()
	{
<span class="nc" id="L575">		int vertexCount = anchorDates().length;</span>

<span class="nc" id="L577">		double[] creditExposure = new double[vertexCount];</span>
<span class="nc" id="L578">		int pathCount = _pathExposureAdjustmentArray.length;</span>

<span class="nc bnc" id="L580" title="All 2 branches missed.">		for (int vertexIndex = 0; vertexIndex &lt; vertexCount; ++vertexIndex)</span>
		{
<span class="nc" id="L582">			creditExposure[vertexIndex] = 0.;</span>
		}

<span class="nc bnc" id="L585" title="All 2 branches missed.">		for (int pathIndex = 0; pathIndex &lt; pathCount; ++pathIndex)</span>
		{
<span class="nc" id="L587">			double[] pathCreditExposure = _pathExposureAdjustmentArray[pathIndex].creditExposure();</span>

<span class="nc bnc" id="L589" title="All 2 branches missed.">			for (int vertexIndex = 0; vertexIndex &lt; vertexCount; ++vertexIndex)</span>
			{
<span class="nc" id="L591">				creditExposure[vertexIndex] += pathCreditExposure[vertexIndex];</span>
			}
		}

<span class="nc bnc" id="L595" title="All 2 branches missed.">		for (int vertexIndex = 0; vertexIndex &lt; vertexCount; ++vertexIndex)</span>
		{
<span class="nc" id="L597">			creditExposure[vertexIndex] /= pathCount;</span>
		}

<span class="nc" id="L600">		return creditExposure;</span>
	}

	/**
	 * Retrieve the Array of Credit Exposure PV
	 * 
	 * @return The Array of Credit Exposure PV
	 */

	public double[] creditExposurePV()
	{
<span class="nc" id="L611">		int vertexCount = anchorDates().length;</span>

<span class="nc" id="L613">		int pathCount = _pathExposureAdjustmentArray.length;</span>
<span class="nc" id="L614">		double[] creditExposurePV = new double[vertexCount];</span>

<span class="nc bnc" id="L616" title="All 2 branches missed.">		for (int vertexIndex = 0; vertexIndex &lt; vertexCount; ++vertexIndex)</span>
		{
<span class="nc" id="L618">			creditExposurePV[vertexIndex] = 0.;</span>
		}

<span class="nc bnc" id="L621" title="All 2 branches missed.">		for (int pathIndex = 0; pathIndex &lt; pathCount; ++pathIndex)</span>
		{
<span class="nc" id="L623">			double[] pathCreditExposurePV = _pathExposureAdjustmentArray[pathIndex].creditExposurePV();</span>

<span class="nc bnc" id="L625" title="All 2 branches missed.">			for (int vertexIndex = 0; vertexIndex &lt; vertexCount; ++vertexIndex)</span>
			{
<span class="nc" id="L627">				creditExposurePV[vertexIndex] += pathCreditExposurePV[vertexIndex];</span>
			}
		}

<span class="nc bnc" id="L631" title="All 2 branches missed.">		for (int vertexIndex = 0; vertexIndex &lt; vertexCount; ++vertexIndex)</span>
		{
<span class="nc" id="L633">			creditExposurePV[vertexIndex] /= pathCount;</span>
		}

<span class="nc" id="L636">		return creditExposurePV;</span>
	}

	/**
	 * Retrieve the Array of Debt Exposures
	 * 
	 * @return The Array of Debt Exposures
	 */

	public double[] debtExposure()
	{
<span class="nc" id="L647">		int vertexCount = anchorDates().length;</span>

<span class="nc" id="L649">		double[] debtExposure = new double[vertexCount];</span>
<span class="nc" id="L650">		int pathCount = _pathExposureAdjustmentArray.length;</span>

<span class="nc bnc" id="L652" title="All 2 branches missed.">		for (int vertexIndex = 0; vertexIndex &lt; vertexCount; ++vertexIndex)</span>
		{
<span class="nc" id="L654">			debtExposure[vertexIndex] = 0.;</span>
		}

<span class="nc bnc" id="L657" title="All 2 branches missed.">		for (int pathIndex = 0; pathIndex &lt; pathCount; ++pathIndex)</span>
		{
<span class="nc" id="L659">			double[] pathDebtExposure = _pathExposureAdjustmentArray[pathIndex].debtExposure();</span>

<span class="nc bnc" id="L661" title="All 2 branches missed.">			for (int vertexIndex = 0; vertexIndex &lt; vertexCount; ++vertexIndex)</span>
			{
<span class="nc" id="L663">				debtExposure[vertexIndex] += pathDebtExposure[vertexIndex];</span>
			}
		}

<span class="nc bnc" id="L667" title="All 2 branches missed.">		for (int vertexIndex = 0; vertexIndex &lt; vertexCount; ++vertexIndex)</span>
		{
<span class="nc" id="L669">			debtExposure[vertexIndex] /= pathCount;</span>
		}

<span class="nc" id="L672">		return debtExposure;</span>
	}

	/**
	 * Retrieve the Array of Debt Exposure PV
	 * 
	 * @return The Array of Debt Exposure PV
	 */

	public double[] debtExposurePV()
	{
<span class="nc" id="L683">		int vertexCount = anchorDates().length;</span>

<span class="nc" id="L685">		int pathCount = _pathExposureAdjustmentArray.length;</span>
<span class="nc" id="L686">		double[] debtExposurePV = new double[vertexCount];</span>

<span class="nc bnc" id="L688" title="All 2 branches missed.">		for (int vertexIndex = 0; vertexIndex &lt; vertexCount; ++vertexIndex)</span>
		{
<span class="nc" id="L690">			debtExposurePV[vertexIndex] = 0.;</span>
		}

<span class="nc bnc" id="L693" title="All 2 branches missed.">		for (int pathIndex = 0; pathIndex &lt; pathCount; ++pathIndex)</span>
		{
<span class="nc" id="L695">			double[] pathDebtExposurePV = _pathExposureAdjustmentArray[pathIndex].debtExposurePV();</span>

<span class="nc bnc" id="L697" title="All 2 branches missed.">			for (int vertexIndex = 0; vertexIndex &lt; vertexCount; ++vertexIndex)</span>
			{
<span class="nc" id="L699">				debtExposurePV[vertexIndex] += pathDebtExposurePV[vertexIndex];</span>
			}
		}

<span class="nc bnc" id="L703" title="All 2 branches missed.">		for (int vertexIndex = 0; vertexIndex &lt; vertexCount; ++vertexIndex)</span>
		{
<span class="nc" id="L705">			debtExposurePV[vertexIndex] /= pathCount;</span>
		}

<span class="nc" id="L708">		return debtExposurePV;</span>
	}

	/**
	 * Retrieve the Array of Funding Exposures
	 * 
	 * @return The Array of Funding Exposures
	 */

	public double[] fundingExposure()
	{
<span class="nc" id="L719">		int vertexCount = anchorDates().length;</span>

<span class="nc" id="L721">		double[] fundingExposure = new double[vertexCount];</span>
<span class="nc" id="L722">		int pathCount = _pathExposureAdjustmentArray.length;</span>

<span class="nc bnc" id="L724" title="All 2 branches missed.">		for (int vertexIndex = 0; vertexIndex &lt; vertexCount; ++vertexIndex)</span>
		{
<span class="nc" id="L726">			fundingExposure[vertexIndex] = 0.;</span>
		}

<span class="nc bnc" id="L729" title="All 2 branches missed.">		for (int pathIndex = 0; pathIndex &lt; pathCount; ++pathIndex)</span>
		{
<span class="nc" id="L731">			double[] pathFundingExposure = _pathExposureAdjustmentArray[pathIndex].fundingExposure();</span>

<span class="nc bnc" id="L733" title="All 2 branches missed.">			for (int vertexIndex = 0; vertexIndex &lt; vertexCount; ++vertexIndex)</span>
			{
<span class="nc" id="L735">				fundingExposure[vertexIndex] += pathFundingExposure[vertexIndex];</span>
			}
		}

<span class="nc bnc" id="L739" title="All 2 branches missed.">		for (int vertexIndex = 0; vertexIndex &lt; vertexCount; ++vertexIndex)</span>
		{
<span class="nc" id="L741">			fundingExposure[vertexIndex] /= pathCount;</span>
		}

<span class="nc" id="L744">		return fundingExposure;</span>
	}

	/**
	 * Retrieve the Array of Funding Exposure PV
	 * 
	 * @return The Array of Funding Exposure PV
	 */

	public double[] fundingExposurePV()
	{
<span class="nc" id="L755">		int vertexCount = anchorDates().length;</span>

<span class="nc" id="L757">		int pathCount = _pathExposureAdjustmentArray.length;</span>
<span class="nc" id="L758">		double[] fundingExposurePV = new double[vertexCount];</span>

<span class="nc bnc" id="L760" title="All 2 branches missed.">		for (int vertexIndex = 0; vertexIndex &lt; vertexCount; ++vertexIndex)</span>
		{
<span class="nc" id="L762">			fundingExposurePV[vertexIndex] = 0.;</span>
		}

<span class="nc bnc" id="L765" title="All 2 branches missed.">		for (int pathIndex = 0; pathIndex &lt; pathCount; ++pathIndex)</span>
		{
<span class="nc" id="L767">			double[] pathFundingExposurePV = _pathExposureAdjustmentArray[pathIndex].fundingExposurePV();</span>

<span class="nc bnc" id="L769" title="All 2 branches missed.">			for (int vertexIndex = 0; vertexIndex &lt; vertexCount; ++vertexIndex)</span>
			{
<span class="nc" id="L771">				fundingExposurePV[vertexIndex] += pathFundingExposurePV[vertexIndex];</span>
			}
		}

<span class="nc bnc" id="L775" title="All 2 branches missed.">		for (int vertexIndex = 0; vertexIndex &lt; vertexCount; ++vertexIndex)</span>
		{
<span class="nc" id="L777">			fundingExposurePV[vertexIndex] /= pathCount;</span>
		}

<span class="nc" id="L780">		return fundingExposurePV;</span>
	}

	/**
	 * Retrieve the Expected Unilateral Collateral VA
	 * 
	 * @return The Expected Unilateral Collateral VA
	 */

	public org.drip.xva.basel.ValueAdjustment ucolva()
	{
<span class="nc" id="L791">		double ucolva = 0.;</span>
<span class="nc" id="L792">		int pathCount = _pathExposureAdjustmentArray.length;</span>

		try
		{
<span class="nc bnc" id="L796" title="All 2 branches missed.">			for (int pathIndex = 0; pathIndex &lt; pathCount; ++pathIndex)</span>
			{
<span class="nc" id="L798">				ucolva += _pathExposureAdjustmentArray[pathIndex].unilateralCollateralAdjustment();</span>
			}
		}
<span class="nc" id="L801">		catch (java.lang.Exception e)</span>
		{
<span class="nc" id="L803">			e.printStackTrace();</span>

<span class="nc" id="L805">			return null;</span>
<span class="nc" id="L806">		}</span>

<span class="nc" id="L808">		return org.drip.xva.basel.ValueAdjustment.COLVA (ucolva / pathCount);</span>
	}

	/**
	 * Retrieve the Expected Bilateral Collateral VA
	 * 
	 * @return The Expected Bilateral Collateral VA
	 */

	public org.drip.xva.basel.ValueAdjustment ftdcolva()
	{
<span class="nc" id="L819">		double ftdcolva = 0.;</span>
<span class="nc" id="L820">		int pathCount = _pathExposureAdjustmentArray.length;</span>

		try
		{
<span class="nc bnc" id="L824" title="All 2 branches missed.">			for (int pathIndex = 0; pathIndex &lt; pathCount; ++pathIndex)</span>
			{
<span class="nc" id="L826">				ftdcolva += _pathExposureAdjustmentArray[pathIndex].bilateralCollateralAdjustment();</span>
			}
		}
<span class="nc" id="L829">		catch (java.lang.Exception e)</span>
		{
<span class="nc" id="L831">			e.printStackTrace();</span>

<span class="nc" id="L833">			return null;</span>
<span class="nc" id="L834">		}</span>

<span class="nc" id="L836">		return org.drip.xva.basel.ValueAdjustment.COLVA (ftdcolva / pathCount);</span>
	}

	/**
	 * Retrieve the Expected Collateral VA
	 * 
	 * @return The Expected Collateral VA
	 */

	public org.drip.xva.basel.ValueAdjustment colva()
	{
<span class="fc" id="L847">		double colva = 0.;</span>
<span class="fc" id="L848">		int pathCount = _pathExposureAdjustmentArray.length;</span>

		try
		{
<span class="fc bfc" id="L852" title="All 2 branches covered.">			for (int pathIndex = 0; pathIndex &lt; pathCount; ++pathIndex)</span>
			{
<span class="fc" id="L854">				colva += _pathExposureAdjustmentArray[pathIndex].unilateralCollateralAdjustment();</span>
			}
		}
<span class="nc" id="L857">		catch (java.lang.Exception e)</span>
		{
<span class="nc" id="L859">			e.printStackTrace();</span>

<span class="nc" id="L861">			return null;</span>
<span class="fc" id="L862">		}</span>

<span class="fc" id="L864">		return org.drip.xva.basel.ValueAdjustment.COLVA (colva / pathCount);</span>
	}

	/**
	 * Retrieve the Expected Unilateral CVA
	 * 
	 * @return The Expected Unilateral CVA
	 */

	public org.drip.xva.basel.ValueAdjustment ucva()
	{
<span class="fc" id="L875">		double ucva = 0.;</span>
<span class="fc" id="L876">		int pathCount = _pathExposureAdjustmentArray.length;</span>

		try
		{
<span class="fc bfc" id="L880" title="All 2 branches covered.">			for (int pathIndex = 0; pathIndex &lt; pathCount; ++pathIndex)</span>
			{
<span class="fc" id="L882">				ucva += _pathExposureAdjustmentArray[pathIndex].unilateralCreditAdjustment();</span>
			}
		}
<span class="nc" id="L885">		catch (java.lang.Exception e)</span>
		{
<span class="nc" id="L887">			e.printStackTrace();</span>

<span class="nc" id="L889">			return null;</span>
<span class="fc" id="L890">		}</span>

<span class="fc" id="L892">		return org.drip.xva.basel.ValueAdjustment.UCVA (ucva / pathCount);</span>
	}

	/**
	 * Retrieve the Expected Bilateral/FTD CVA
	 * 
	 * @return The Expected Bilateral/FTD CVA
	 */

	public org.drip.xva.basel.ValueAdjustment ftdcva()
	{
<span class="fc" id="L903">		double ftdcva = 0.;</span>
<span class="fc" id="L904">		int pathCount = _pathExposureAdjustmentArray.length;</span>

		try
		{
<span class="fc bfc" id="L908" title="All 2 branches covered.">			for (int pathIndex = 0; pathIndex &lt; pathCount; ++pathIndex)</span>
			{
<span class="fc" id="L910">				ftdcva += _pathExposureAdjustmentArray[pathIndex].bilateralCreditAdjustment();</span>
			}
		}
<span class="nc" id="L913">		catch (java.lang.Exception e)</span>
		{
<span class="nc" id="L915">			e.printStackTrace();</span>

<span class="nc" id="L917">			return null;</span>
<span class="fc" id="L918">		}</span>

<span class="fc" id="L920">		return org.drip.xva.basel.ValueAdjustment.FTDCVA (ftdcva / pathCount);</span>
	}

	/**
	 * Retrieve the Expected CVA
	 * 
	 * @return The Expected CVA
	 */

	public org.drip.xva.basel.ValueAdjustment cva()
	{
<span class="fc" id="L931">		return ftdcva();</span>
	}

	/**
	 * Retrieve the Expected CVA Contra-Liability
	 * 
	 * @return The Expected CVA Contra-Liability
	 */

	public org.drip.xva.basel.ValueAdjustment cvacl()
	{
<span class="fc" id="L942">		double cvacl = 0.;</span>
<span class="fc" id="L943">		int pathCount = _pathExposureAdjustmentArray.length;</span>

		try
		{
<span class="fc bfc" id="L947" title="All 2 branches covered.">			for (int pathIndex = 0; pathIndex &lt; pathCount; ++pathIndex)</span>
			{
<span class="fc" id="L949">				cvacl += _pathExposureAdjustmentArray[pathIndex].contraLiabilityCreditAdjustment();</span>
			}
		}
<span class="nc" id="L952">		catch (java.lang.Exception e)</span>
		{
<span class="nc" id="L954">			e.printStackTrace();</span>

<span class="nc" id="L956">			return null;</span>
<span class="fc" id="L957">		}</span>

<span class="fc" id="L959">		return org.drip.xva.basel.ValueAdjustment.CVACL (cvacl / pathCount);</span>
	}

	/**
	 * Retrieve the Expected DVA
	 * 
	 * @return The Expected DVA
	 */

	public org.drip.xva.basel.ValueAdjustment dva()
	{
<span class="fc" id="L970">		double dva = 0.;</span>
<span class="fc" id="L971">		int pathCount = _pathExposureAdjustmentArray.length;</span>

<span class="fc bfc" id="L973" title="All 2 branches covered.">		for (int pathIndex = 0; pathIndex &lt; pathCount; ++pathIndex)</span>
		{
<span class="fc" id="L975">			dva += _pathExposureAdjustmentArray[pathIndex].debtAdjustment();</span>
		}

<span class="fc" id="L978">		return org.drip.xva.basel.ValueAdjustment.DVA (dva / pathCount);</span>
	}

	/**
	 * Retrieve the Expected FVA
	 * 
	 * @return The Expected FVA
	 */

	public org.drip.xva.basel.ValueAdjustment fva()
	{
<span class="fc" id="L989">		double fva = 0.;</span>
<span class="fc" id="L990">		int pathCount = _pathExposureAdjustmentArray.length;</span>

		try
		{
<span class="fc bfc" id="L994" title="All 2 branches covered.">			for (int pathIndex = 0; pathIndex &lt; pathCount; ++pathIndex)</span>
			{
<span class="fc" id="L996">				fva += _pathExposureAdjustmentArray[pathIndex].fundingValueAdjustment();</span>
			}
		}
<span class="nc" id="L999">		catch (java.lang.Exception e)</span>
		{
<span class="nc" id="L1001">			e.printStackTrace();</span>

<span class="nc" id="L1003">			return null;</span>
<span class="fc" id="L1004">		}</span>

<span class="fc" id="L1006">		return org.drip.xva.basel.ValueAdjustment.FVA (fva / pathCount);</span>
	}

	/**
	 * Retrieve the Expected FDA
	 * 
	 * @return The Expected FDA
	 */

	public org.drip.xva.basel.ValueAdjustment fda()
	{
<span class="fc" id="L1017">		double fda = 0.;</span>
<span class="fc" id="L1018">		int pathCount = _pathExposureAdjustmentArray.length;</span>

		try
		{
<span class="fc bfc" id="L1022" title="All 2 branches covered.">			for (int pathIndex = 0; pathIndex &lt; pathCount; ++pathIndex)</span>
			{
<span class="fc" id="L1024">				fda += _pathExposureAdjustmentArray[pathIndex].fundingDebtAdjustment();</span>
			}
		}
<span class="nc" id="L1027">		catch (java.lang.Exception e)</span>
		{
<span class="nc" id="L1029">			e.printStackTrace();</span>

<span class="nc" id="L1031">			return null;</span>
<span class="fc" id="L1032">		}</span>

<span class="fc" id="L1034">		return org.drip.xva.basel.ValueAdjustment.FDA (fda / pathCount);</span>
	}

	/**
	 * Retrieve the Expected FCA
	 * 
	 * @return The Expected FCA
	 */

	public org.drip.xva.basel.ValueAdjustment fca()
	{
<span class="fc" id="L1045">		double fca = 0.;</span>
<span class="fc" id="L1046">		int pathCount = _pathExposureAdjustmentArray.length;</span>

<span class="fc bfc" id="L1048" title="All 2 branches covered.">		for (int pathIndex = 0; pathIndex &lt; pathCount; ++pathIndex)</span>
		{
<span class="fc" id="L1050">			fca += _pathExposureAdjustmentArray[pathIndex].fundingCostAdjustment();</span>
		}

<span class="fc" id="L1053">		return org.drip.xva.basel.ValueAdjustment.HYBRID (fca / pathCount);</span>
	}

	/**
	 * Retrieve the Expected FBA
	 * 
	 * @return The Expected FBA
	 */

	public org.drip.xva.basel.ValueAdjustment fba()
	{
<span class="fc" id="L1064">		double fba = 0.;</span>
<span class="fc" id="L1065">		int pathCount = _pathExposureAdjustmentArray.length;</span>

<span class="fc bfc" id="L1067" title="All 2 branches covered.">		for (int pathIndex = 0; pathIndex &lt; pathCount; ++pathIndex)</span>
		{
<span class="fc" id="L1069">			fba += _pathExposureAdjustmentArray[pathIndex].fundingBenefitAdjustment();</span>
		}

<span class="fc" id="L1072">		return org.drip.xva.basel.ValueAdjustment.HYBRID (fba / pathCount);</span>
	}

	/**
	 * Retrieve the Expected SFVA
	 * 
	 * @return The Expected SFVA
	 */

	public org.drip.xva.basel.ValueAdjustment sfva()
	{
<span class="fc" id="L1083">		double sfva = 0.;</span>
<span class="fc" id="L1084">		int pathCount = _pathExposureAdjustmentArray.length;</span>

<span class="fc bfc" id="L1086" title="All 2 branches covered.">		for (int pathIndex = 0; pathIndex &lt; pathCount; ++pathIndex)</span>
		{
<span class="fc" id="L1088">			sfva += _pathExposureAdjustmentArray[pathIndex].symmetricFundingValueAdjustment();</span>
		}

<span class="fc" id="L1091">		return org.drip.xva.basel.ValueAdjustment.HYBRID (sfva / pathCount);</span>
	}

	/**
	 * Retrieve the Total VA
	 * 
	 * @return The Total VA
	 */

	public double total()
	{
<span class="fc" id="L1102">		return cva().amount() + dva().amount() + fva().amount() + colva().amount();</span>
	}

	/**
	 * Generate the &quot;Digest&quot; containing the &quot;Thin&quot; Path Statistics
	 * 
	 * @return The &quot;Digest&quot; containing the &quot;Thin&quot; Path Statistics
	 */

	public org.drip.xva.cpty.ExposureAdjustmentDigest digest()
	{
<span class="fc" id="L1113">		int vertexCount = anchorDates().length;</span>

<span class="fc" id="L1115">		int pathCount = _pathExposureAdjustmentArray.length;</span>
<span class="fc" id="L1116">		double[] pathCVA = new double[pathCount];</span>
<span class="fc" id="L1117">		double[] pathDVA = new double[pathCount];</span>
<span class="fc" id="L1118">		double[] pathFBA = new double[pathCount];</span>
<span class="fc" id="L1119">		double[] pathFCA = new double[pathCount];</span>
<span class="fc" id="L1120">		double[] pathFDA = new double[pathCount];</span>
<span class="fc" id="L1121">		double[] pathFVA = new double[pathCount];</span>
<span class="fc" id="L1122">		double[] pathUCVA = new double[pathCount];</span>
<span class="fc" id="L1123">		double[] pathSFVA = new double[pathCount];</span>
<span class="fc" id="L1124">		double[] pathCVACL = new double[pathCount];</span>
<span class="fc" id="L1125">		double[] pathFTDCVA = new double[pathCount];</span>
<span class="fc" id="L1126">		double[] pathCOLVA = new double[pathCount];</span>
<span class="fc" id="L1127">		double[] pathTotalVA = new double[pathCount];</span>
<span class="fc" id="L1128">		double[] pathFTDCOLVA = new double[pathCount];</span>
<span class="fc" id="L1129">		double[][] debtExposure = new double[vertexCount][pathCount];</span>
<span class="fc" id="L1130">		double[][] creditExposure = new double[vertexCount][pathCount];</span>
<span class="fc" id="L1131">		double[][] debtExposurePV = new double[vertexCount][pathCount];</span>
<span class="fc" id="L1132">		double[][] fundingExposure = new double[vertexCount][pathCount];</span>
<span class="fc" id="L1133">		double[][] creditExposurePV = new double[vertexCount][pathCount];</span>
<span class="fc" id="L1134">		double[][] fundingExposurePV = new double[vertexCount][pathCount];</span>
<span class="fc" id="L1135">		double[][] collateralizedExposure = new double[vertexCount][pathCount];</span>
<span class="fc" id="L1136">		double[][] uncollateralizedExposure = new double[vertexCount][pathCount];</span>
<span class="fc" id="L1137">		double[][] collateralizedExposurePV = new double[vertexCount][pathCount];</span>
<span class="fc" id="L1138">		double[][] uncollateralizedExposurePV = new double[vertexCount][pathCount];</span>
<span class="fc" id="L1139">		double[][] collateralizedPositiveExposure = new double[vertexCount][pathCount];</span>
<span class="fc" id="L1140">		double[][] collateralizedNegativeExposure = new double[vertexCount][pathCount];</span>
<span class="fc" id="L1141">		double[][] uncollateralizedPositiveExposure = new double[vertexCount][pathCount];</span>
<span class="fc" id="L1142">		double[][] uncollateralizedNegativeExposure = new double[vertexCount][pathCount];</span>
<span class="fc" id="L1143">		double[][] collateralizedPositiveExposurePV = new double[vertexCount][pathCount];</span>
<span class="fc" id="L1144">		double[][] collateralizedNegativeExposurePV = new double[vertexCount][pathCount];</span>
<span class="fc" id="L1145">		double[][] uncollateralizedPositiveExposurePV = new double[vertexCount][pathCount];</span>
<span class="fc" id="L1146">		double[][] uncollateralizedNegativeExposurePV = new double[vertexCount][pathCount];</span>

<span class="fc bfc" id="L1148" title="All 2 branches covered.">		for (int vertexIndex = 0; vertexIndex &lt; vertexCount; ++vertexIndex)</span>
		{
<span class="fc bfc" id="L1150" title="All 2 branches covered.">			for (int pathIndex = 0; pathIndex &lt; pathCount; ++pathIndex)</span>
			{
<span class="fc" id="L1152">				collateralizedExposure[vertexIndex][pathIndex] = 0.;</span>
<span class="fc" id="L1153">				uncollateralizedExposure[vertexIndex][pathIndex] = 0.;</span>
<span class="fc" id="L1154">				collateralizedExposurePV[vertexIndex][pathIndex] = 0.;</span>
<span class="fc" id="L1155">				uncollateralizedExposurePV[vertexIndex][pathIndex] = 0.;</span>
<span class="fc" id="L1156">				collateralizedPositiveExposure[vertexIndex][pathIndex] = 0.;</span>
<span class="fc" id="L1157">				collateralizedNegativeExposure[vertexIndex][pathIndex] = 0.;</span>
<span class="fc" id="L1158">				uncollateralizedPositiveExposure[vertexIndex][pathIndex] = 0.;</span>
<span class="fc" id="L1159">				uncollateralizedNegativeExposure[vertexIndex][pathIndex] = 0.;</span>
<span class="fc" id="L1160">				collateralizedPositiveExposurePV[vertexIndex][pathIndex] = 0.;</span>
<span class="fc" id="L1161">				collateralizedNegativeExposurePV[vertexIndex][pathIndex] = 0.;</span>
<span class="fc" id="L1162">				uncollateralizedPositiveExposurePV[vertexIndex][pathIndex] = 0.;</span>
<span class="fc" id="L1163">				uncollateralizedNegativeExposurePV[vertexIndex][pathIndex] = 0.;</span>
			}
		}

<span class="fc bfc" id="L1167" title="All 2 branches covered.">		for (int pathIndex = 0; pathIndex &lt; pathCount; ++pathIndex)</span>
		{
<span class="fc" id="L1169">			double[] pathCollateralizedExposure =</span>
<span class="fc" id="L1170">				_pathExposureAdjustmentArray[pathIndex].collateralizedExposure();</span>

<span class="fc" id="L1172">			double[] pathCollateralizedExposurePV =</span>
<span class="fc" id="L1173">				_pathExposureAdjustmentArray[pathIndex].collateralizedExposurePV();</span>

<span class="fc" id="L1175">			double[] pathCollateralizedPositiveExposure =</span>
<span class="fc" id="L1176">				_pathExposureAdjustmentArray[pathIndex].collateralizedPositiveExposure();</span>

<span class="fc" id="L1178">			double[] pathCollateralizedPositiveExposurePV =</span>
<span class="fc" id="L1179">				_pathExposureAdjustmentArray[pathIndex].collateralizedPositiveExposurePV();</span>

<span class="fc" id="L1181">			double[] pathCollateralizedNegativeExposure =</span>
<span class="fc" id="L1182">				_pathExposureAdjustmentArray[pathIndex].collateralizedNegativeExposure();</span>

<span class="fc" id="L1184">			double[] pathCollateralizedNegativeExposurePV =</span>
<span class="fc" id="L1185">				_pathExposureAdjustmentArray[pathIndex].collateralizedNegativeExposurePV();</span>

<span class="fc" id="L1187">			double[] pathUncollateralizedExposure =</span>
<span class="fc" id="L1188">				_pathExposureAdjustmentArray[pathIndex].uncollateralizedExposure();</span>

<span class="fc" id="L1190">			double[] pathUncollateralizedExposurePV =</span>
<span class="fc" id="L1191">				_pathExposureAdjustmentArray[pathIndex].uncollateralizedExposurePV();</span>

<span class="fc" id="L1193">			double[] pathUncollateralizedPositiveExposure =</span>
<span class="fc" id="L1194">				_pathExposureAdjustmentArray[pathIndex].uncollateralizedPositiveExposure();</span>

<span class="fc" id="L1196">			double[] pathUncollateralizedPositiveExposurePV =</span>
<span class="fc" id="L1197">				_pathExposureAdjustmentArray[pathIndex].uncollateralizedPositiveExposurePV();</span>

<span class="fc" id="L1199">			double[] pathUncollateralizedNegativeExposure =</span>
<span class="fc" id="L1200">				_pathExposureAdjustmentArray[pathIndex].uncollateralizedNegativeExposure();</span>

<span class="fc" id="L1202">			double[] pathUncollateralizedNegativeExposurePV =</span>
<span class="fc" id="L1203">				_pathExposureAdjustmentArray[pathIndex].uncollateralizedNegativeExposurePV();</span>

<span class="fc" id="L1205">			double[] pathCreditExposure = _pathExposureAdjustmentArray[pathIndex].creditExposure();</span>

<span class="fc" id="L1207">			double[] pathCreditExposurePV = _pathExposureAdjustmentArray[pathIndex].creditExposurePV();</span>

<span class="fc" id="L1209">			double[] pathDebtExposure = _pathExposureAdjustmentArray[pathIndex].debtExposure();</span>

<span class="fc" id="L1211">			double[] pathDebtExposurePV = _pathExposureAdjustmentArray[pathIndex].debtExposurePV();</span>

<span class="fc" id="L1213">			double[] pathFundingExposure = _pathExposureAdjustmentArray[pathIndex].fundingExposure();</span>

<span class="fc" id="L1215">			double[] pathFundingExposurePV = _pathExposureAdjustmentArray[pathIndex].fundingExposurePV();</span>

			try
			{
<span class="fc" id="L1219">				pathCVA[pathIndex] = _pathExposureAdjustmentArray[pathIndex].creditAdjustment();</span>

<span class="fc" id="L1221">				pathDVA[pathIndex] = _pathExposureAdjustmentArray[pathIndex].debtAdjustment();</span>

<span class="fc" id="L1223">				pathFCA[pathIndex] = _pathExposureAdjustmentArray[pathIndex].fundingCostAdjustment();</span>

<span class="fc" id="L1225">				pathFDA[pathIndex] = _pathExposureAdjustmentArray[pathIndex].fundingDebtAdjustment();</span>

<span class="fc" id="L1227">				pathFVA[pathIndex] = _pathExposureAdjustmentArray[pathIndex].fundingValueAdjustment();</span>

<span class="fc" id="L1229">				pathFBA[pathIndex] = _pathExposureAdjustmentArray[pathIndex].fundingBenefitAdjustment();</span>

<span class="fc" id="L1231">				pathUCVA[pathIndex] = _pathExposureAdjustmentArray[pathIndex].unilateralCreditAdjustment();</span>

<span class="fc" id="L1233">				pathSFVA[pathIndex] =</span>
<span class="fc" id="L1234">					_pathExposureAdjustmentArray[pathIndex].symmetricFundingValueAdjustment();</span>

<span class="fc" id="L1236">				pathCVACL[pathIndex] =</span>
<span class="fc" id="L1237">					_pathExposureAdjustmentArray[pathIndex].contraLiabilityCreditAdjustment();</span>

<span class="fc" id="L1239">				pathFTDCVA[pathIndex] = _pathExposureAdjustmentArray[pathIndex].bilateralCreditAdjustment();</span>

<span class="fc" id="L1241">				pathCOLVA[pathIndex] =</span>
<span class="fc" id="L1242">					_pathExposureAdjustmentArray[pathIndex].unilateralCollateralAdjustment();</span>

<span class="fc" id="L1244">				pathFTDCOLVA[pathIndex] =</span>
<span class="fc" id="L1245">					_pathExposureAdjustmentArray[pathIndex].bilateralCollateralAdjustment();</span>

<span class="fc" id="L1247">				pathTotalVA[pathIndex] = _pathExposureAdjustmentArray[pathIndex].totalAdjustment();</span>
			}
<span class="nc" id="L1249">			catch (java.lang.Exception e)</span>
			{
<span class="nc" id="L1251">				e.printStackTrace();</span>

<span class="nc" id="L1253">				return null;</span>
<span class="fc" id="L1254">			}</span>

<span class="fc bfc" id="L1256" title="All 2 branches covered.">			for (int vertexIndex = 0; vertexIndex &lt; vertexCount; ++vertexIndex)</span>
			{
<span class="fc" id="L1258">				collateralizedExposure[vertexIndex][pathIndex] =</span>
					pathCollateralizedExposure[vertexIndex];
<span class="fc" id="L1260">				collateralizedExposurePV[vertexIndex][pathIndex] =</span>
					pathCollateralizedExposurePV[vertexIndex];
<span class="fc" id="L1262">				collateralizedPositiveExposure[vertexIndex][pathIndex] =</span>
					pathCollateralizedPositiveExposure[vertexIndex];
<span class="fc" id="L1264">				collateralizedPositiveExposurePV[vertexIndex][pathIndex] =</span>
					pathCollateralizedPositiveExposurePV[vertexIndex];
<span class="fc" id="L1266">				collateralizedNegativeExposure[vertexIndex][pathIndex] =</span>
					pathCollateralizedNegativeExposure[vertexIndex];
<span class="fc" id="L1268">				collateralizedNegativeExposurePV[vertexIndex][pathIndex] =</span>
					pathCollateralizedNegativeExposurePV[vertexIndex];
<span class="fc" id="L1270">				uncollateralizedExposure[vertexIndex][pathIndex] =</span>
					pathUncollateralizedExposure[vertexIndex];
<span class="fc" id="L1272">				uncollateralizedExposurePV[vertexIndex][pathIndex] =</span>
					pathUncollateralizedExposurePV[vertexIndex];
<span class="fc" id="L1274">				uncollateralizedPositiveExposure[vertexIndex][pathIndex] =</span>
					pathUncollateralizedPositiveExposure[vertexIndex];
<span class="fc" id="L1276">				uncollateralizedPositiveExposurePV[vertexIndex][pathIndex] =</span>
					pathUncollateralizedPositiveExposurePV[vertexIndex];
<span class="fc" id="L1278">				uncollateralizedNegativeExposure[vertexIndex][pathIndex] =</span>
					pathUncollateralizedNegativeExposure[vertexIndex];
<span class="fc" id="L1280">				uncollateralizedNegativeExposurePV[vertexIndex][pathIndex] =</span>
					pathUncollateralizedNegativeExposurePV[vertexIndex];
<span class="fc" id="L1282">				creditExposure[vertexIndex][pathIndex] = pathCreditExposure[vertexIndex];</span>
<span class="fc" id="L1283">				creditExposurePV[vertexIndex][pathIndex] = pathCreditExposurePV[vertexIndex];</span>
<span class="fc" id="L1284">				debtExposure[vertexIndex][pathIndex] = pathDebtExposure[vertexIndex];</span>
<span class="fc" id="L1285">				debtExposurePV[vertexIndex][pathIndex] = pathDebtExposurePV[vertexIndex];</span>
<span class="fc" id="L1286">				fundingExposure[vertexIndex][pathIndex] = pathFundingExposure[vertexIndex];</span>
<span class="fc" id="L1287">				fundingExposurePV[vertexIndex][pathIndex] = pathFundingExposurePV[vertexIndex];</span>
			}
		}

		try
		{
<span class="fc" id="L1293">			return new org.drip.xva.cpty.ExposureAdjustmentDigest (</span>
				pathCOLVA,
				pathFTDCOLVA,
				pathUCVA,
				pathFTDCVA,
				pathCVA,
				pathCVACL,
				pathDVA,
				pathFVA,
				pathFDA,
				pathFCA,
				pathFBA,
				pathSFVA,
				pathTotalVA,
				collateralizedExposure,
				collateralizedExposurePV,
				collateralizedPositiveExposure,
				collateralizedPositiveExposurePV,
				collateralizedNegativeExposure,
				collateralizedNegativeExposurePV,
				uncollateralizedExposure,
				uncollateralizedExposurePV,
				uncollateralizedPositiveExposure,
				uncollateralizedPositiveExposurePV,
				uncollateralizedNegativeExposure,
				uncollateralizedNegativeExposurePV,
				creditExposure,
				creditExposurePV,
				debtExposure,
				debtExposurePV,
				fundingExposure,
				fundingExposurePV
			);
		}
<span class="nc" id="L1327">		catch (java.lang.Exception e)</span>
		{
<span class="nc" id="L1329">			e.printStackTrace();</span>
		}

<span class="nc" id="L1332">		return null;</span>
	}
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.7.9.201702052155</span></div></body></html>