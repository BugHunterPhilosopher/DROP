<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>LognormalLIBORCurveEvolver.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">DROP</a> &gt; <a href="index.source.html" class="el_package">org.drip.dynamics.lmm</a> &gt; <span class="el_source">LognormalLIBORCurveEvolver.java</span></div><h1>LognormalLIBORCurveEvolver.java</h1><pre class="source lang-java linenums">
package org.drip.dynamics.lmm;

/*
 * -*- mode: java; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*-
 */

/*!
 * Copyright (C) 2020 Lakshmi Krishnamurthy
 * Copyright (C) 2019 Lakshmi Krishnamurthy
 * Copyright (C) 2018 Lakshmi Krishnamurthy
 * Copyright (C) 2017 Lakshmi Krishnamurthy
 * Copyright (C) 2016 Lakshmi Krishnamurthy
 * Copyright (C) 2015 Lakshmi Krishnamurthy
 * 
 *  This file is part of DROP, an open-source library targeting analytics/risk, transaction cost analytics,
 *  	asset liability management analytics, capital, exposure, and margin analytics, valuation adjustment
 *  	analytics, and portfolio construction analytics within and across fixed income, credit, commodity,
 *  	equity, FX, and structured products. It also includes auxiliary libraries for algorithm support,
 *  	numerical analysis, numerical optimization, spline builder, model validation, statistical learning,
 *  	and computational support.
 *  
 *  	https://lakshmidrip.github.io/DROP/
 *  
 *  DROP is composed of three modules:
 *  
 *  - DROP Product Core - https://lakshmidrip.github.io/DROP-Product-Core/
 *  - DROP Portfolio Core - https://lakshmidrip.github.io/DROP-Portfolio-Core/
 *  - DROP Computational Core - https://lakshmidrip.github.io/DROP-Computational-Core/
 * 
 * 	DROP Product Core implements libraries for the following:
 * 	- Fixed Income Analytics
 * 	- Loan Analytics
 * 	- Transaction Cost Analytics
 * 
 * 	DROP Portfolio Core implements libraries for the following:
 * 	- Asset Allocation Analytics
 *  - Asset Liability Management Analytics
 * 	- Capital Estimation Analytics
 * 	- Exposure Analytics
 * 	- Margin Analytics
 * 	- XVA Analytics
 * 
 * 	DROP Computational Core implements libraries for the following:
 * 	- Algorithm Support
 * 	- Computation Support
 * 	- Function Analysis
 *  - Model Validation
 * 	- Numerical Analysis
 * 	- Numerical Optimizer
 * 	- Spline Builder
 *  - Statistical Learning
 * 
 * 	Documentation for DROP is Spread Over:
 * 
 * 	- Main                     =&gt; https://lakshmidrip.github.io/DROP/
 * 	- Wiki                     =&gt; https://github.com/lakshmiDRIP/DROP/wiki
 * 	- GitHub                   =&gt; https://github.com/lakshmiDRIP/DROP
 * 	- Repo Layout Taxonomy     =&gt; https://github.com/lakshmiDRIP/DROP/blob/master/Taxonomy.md
 * 	- Javadoc                  =&gt; https://lakshmidrip.github.io/DROP/Javadoc/index.html
 * 	- Technical Specifications =&gt; https://github.com/lakshmiDRIP/DROP/tree/master/Docs/Internal
 * 	- Release Versions         =&gt; https://lakshmidrip.github.io/DROP/version.html
 * 	- Community Credits        =&gt; https://lakshmidrip.github.io/DROP/credits.html
 * 	- Issues Catalog           =&gt; https://github.com/lakshmiDRIP/DROP/issues
 * 	- JUnit                    =&gt; https://lakshmidrip.github.io/DROP/junit/index.html
 * 	- Jacoco                   =&gt; https://lakshmidrip.github.io/DROP/jacoco/index.html
 * 
 *  Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 *   	you may not use this file except in compliance with the License.
 *   
 *  You may obtain a copy of the License at
 *  	http://www.apache.org/licenses/LICENSE-2.0
 *  
 *  Unless required by applicable law or agreed to in writing, software
 *  	distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 *  	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  
 *  See the License for the specific language governing permissions and
 *  	limitations under the License.
 */

/**
 * &lt;i&gt;LognormalLIBORCurveEvolver&lt;/i&gt; sets up and implements the Multi-Factor No-arbitrage Dynamics of the
 * full Curve Rates State Quantifiers traced from the Evolution of the LIBOR Forward Rate as formulated in:
 *
 *	&lt;br&gt;&lt;br&gt;
 *  &lt;ul&gt;
 *  	&lt;li&gt;
 *  		Goldys, B., M. Musiela, and D. Sondermann (1994): &lt;i&gt;Log-normality of Rates and Term Structure
 *  			Models&lt;/i&gt; &lt;b&gt;The University of New South Wales&lt;/b&gt;
 *  	&lt;/li&gt;
 *  	&lt;li&gt;
 *  		Musiela, M. (1994): &lt;i&gt;Nominal Annual Rates and Log-normal Volatility Structure&lt;/i&gt; &lt;b&gt;The
 *  			University of New South Wales&lt;/b&gt;
 *  	&lt;/li&gt;
 *  	&lt;li&gt;
 * 			Brace, A., D. Gatarek, and M. Musiela (1997): The Market Model of Interest Rate Dynamics
 * 				&lt;i&gt;Mathematical Finance&lt;/i&gt; &lt;b&gt;7 (2)&lt;/b&gt; 127-155
 *  	&lt;/li&gt;
 *  &lt;/ul&gt;
 *
 *	&lt;br&gt;&lt;br&gt;
 *  &lt;ul&gt;
 *		&lt;li&gt;&lt;b&gt;Module &lt;/b&gt; = &lt;a href = &quot;https://github.com/lakshmiDRIP/DROP/tree/master/ProductCore.md&quot;&gt;Product Core Module&lt;/a&gt;&lt;/li&gt;
 *		&lt;li&gt;&lt;b&gt;Library&lt;/b&gt; = &lt;a href = &quot;https://github.com/lakshmiDRIP/DROP/tree/master/FixedIncomeAnalyticsLibrary.md&quot;&gt;Fixed Income Analytics&lt;/a&gt;&lt;/li&gt;
 *		&lt;li&gt;&lt;b&gt;Project&lt;/b&gt; = &lt;a href = &quot;https://github.com/lakshmiDRIP/DROP/tree/master/src/main/java/org/drip/dynamics/README.md&quot;&gt;HJM, Hull White, LMM, and SABR Dynamic Evolution Models&lt;/a&gt;&lt;/li&gt;
 *		&lt;li&gt;&lt;b&gt;Package&lt;/b&gt; = &lt;a href = &quot;https://github.com/lakshmiDRIP/DROP/tree/master/src/main/java/org/drip/dynamics/lmm/README.md&quot;&gt;LMM Based Latent State Evolution&lt;/a&gt;&lt;/li&gt;
 *  &lt;/ul&gt;
 *
 * @author Lakshmi Krishnamurthy
 */

public class LognormalLIBORCurveEvolver implements org.drip.dynamics.evolution.CurveStateEvolver {
<span class="fc" id="L114">	private int _iNumForwardTenor = -1;</span>
<span class="fc" id="L115">	private org.drip.state.identifier.ForwardLabel _lslForward = null;</span>
<span class="fc" id="L116">	private org.drip.state.identifier.FundingLabel _lslFunding = null;</span>
<span class="fc" id="L117">	private org.drip.spline.params.SegmentCustomBuilderControl[] _aSCBCLIBOR = null;</span>
<span class="fc" id="L118">	private org.drip.spline.params.SegmentCustomBuilderControl[] _aSCBCDiscountFactor = null;</span>
<span class="fc" id="L119">	private org.drip.spline.params.SegmentCustomBuilderControl[] _aSCBCLIBORIncrement = null;</span>
<span class="fc" id="L120">	private org.drip.spline.params.SegmentCustomBuilderControl[] _aSCBCSpotRateIncrement = null;</span>
<span class="fc" id="L121">	private org.drip.spline.params.SegmentCustomBuilderControl[] _aSCBCDiscountFactorIncrement = null;</span>
<span class="fc" id="L122">	private org.drip.spline.params.SegmentCustomBuilderControl[] _aSCBCContinuousForwardIncrement = null;</span>
<span class="fc" id="L123">	private org.drip.spline.params.SegmentCustomBuilderControl[] _aSCBCInstantaneousNominalForward = null;</span>
<span class="fc" id="L124">	private org.drip.spline.params.SegmentCustomBuilderControl[] _aSCBCInstantaneousEffectiveForward = null;</span>

	/**
	 * Create a LognormalLIBORCurveEvolver Instance
	 * 
	 * @param lslFunding The Funding Latent State Label
	 * @param lslForward The Forward Latent State Label
	 * @param iNumForwardTenor Number of Forward Tenors to Build the Span
	 * @param scbc The Common Span Segment Custom Builder Control Instance
	 * 
	 * @return The LognormalLIBORCurveEvolver Instance
	 */

	public static final LognormalLIBORCurveEvolver Create (
		final org.drip.state.identifier.FundingLabel lslFunding,
		final org.drip.state.identifier.ForwardLabel lslForward,
		final int iNumForwardTenor,
		final org.drip.spline.params.SegmentCustomBuilderControl scbc)
	{
		try {
<span class="fc" id="L144">			return new LognormalLIBORCurveEvolver (lslFunding, lslForward, iNumForwardTenor, scbc, scbc,</span>
				scbc, scbc, scbc, scbc, scbc, scbc);
<span class="nc" id="L146">		} catch (java.lang.Exception e) {</span>
<span class="nc" id="L147">			e.printStackTrace();</span>
		}

<span class="nc" id="L150">		return null;</span>
	}

	private double forwardDerivative (
		final org.drip.state.forward.ForwardCurve fc,
		final int iTargetPointDate)
		throws java.lang.Exception
	{
<span class="fc" id="L158">		org.drip.function.definition.R1ToR1 freR1ToR1 = new org.drip.function.definition.R1ToR1 (null) {</span>
			@Override public double evaluate (
				final double dblDate)
				throws java.lang.Exception
			{
<span class="fc" id="L163">				return fc.forward ((int) dblDate);</span>
			}
		};

<span class="fc" id="L167">		return freR1ToR1.derivative (iTargetPointDate, 1);</span>
	}

	private double continuousForwardRateIncrement (
		final int iViewDate,
		final double dblAnnualizedIncrement,
		final double dblAnnualizedIncrementSQRT,
		final org.drip.state.forward.ForwardCurve fc,
		final double[] adblMultivariateRandom,
		final org.drip.dynamics.lmm.LognormalLIBORVolatility llv)
		throws java.lang.Exception
	{
<span class="fc" id="L179">		final int iNumFactor = adblMultivariateRandom.length;</span>

<span class="fc" id="L181">		org.drip.function.definition.R1ToR1 continuousForwardRateR1ToR1 = new</span>
<span class="fc" id="L182">			org.drip.function.definition.R1ToR1 (null) {</span>
			@Override public double evaluate (
				final double dblDate)
				throws java.lang.Exception
			{
<span class="fc" id="L187">				double dblForwardPointVolatilityModulus = 0.;</span>
<span class="fc" id="L188">				double dblPointVolatilityMultifactorRandom = 0.;</span>

<span class="fc" id="L190">				double[] adblContinuousForwardVolatility = llv.continuousForwardVolatility ((int) dblDate,</span>
					fc);

<span class="pc bpc" id="L193" title="1 of 2 branches missed.">				if (null != adblContinuousForwardVolatility) {</span>
<span class="fc bfc" id="L194" title="All 2 branches covered.">					for (int i = 0; i &lt; iNumFactor; ++i) {</span>
<span class="fc" id="L195">						dblForwardPointVolatilityModulus += adblContinuousForwardVolatility[i] *</span>
							adblContinuousForwardVolatility[i];
<span class="fc" id="L197">						dblPointVolatilityMultifactorRandom += adblContinuousForwardVolatility[i] *</span>
							adblMultivariateRandom[i];
					}
				}

<span class="fc" id="L202">				return (fc.forward ((int) dblDate) + 0.5 * dblForwardPointVolatilityModulus) *</span>
					dblAnnualizedIncrement + dblPointVolatilityMultifactorRandom *
						dblAnnualizedIncrementSQRT;
			}
		};

<span class="fc" id="L208">		return continuousForwardRateR1ToR1.derivative (iViewDate, 1);</span>
	}

	private double spotRateIncrement (
		final int iViewDate,
		final double dblAnnualizedIncrement,
		final double dblAnnualizedIncrementSQRT,
		final org.drip.state.discount.MergedDiscountForwardCurve dc,
		final double[] adblMultivariateRandom,
		final org.drip.dynamics.lmm.LognormalLIBORVolatility llv)
		throws java.lang.Exception
	{
<span class="fc" id="L220">		final int iNumFactor = adblMultivariateRandom.length;</span>

<span class="fc" id="L222">		org.drip.function.definition.R1ToR1 spotRateR1ToR1 = new org.drip.function.definition.R1ToR1 (null) {</span>
			@Override public double evaluate (
				final double dblDate)
				throws java.lang.Exception
			{
<span class="fc" id="L227">				int iDate = (int) dblDate;</span>
<span class="fc" id="L228">				double dblPointVolatilityMultifactorRandom = 0.;</span>

<span class="fc" id="L230">				double[] adblContinuousForwardVolatility = llv.continuousForwardVolatility (iDate, dc);</span>

<span class="pc bpc" id="L232" title="1 of 2 branches missed.">				if (null != adblContinuousForwardVolatility) {</span>
<span class="fc bfc" id="L233" title="All 2 branches covered.">					for (int i = 0; i &lt; iNumFactor; ++i)</span>
<span class="fc" id="L234">						dblPointVolatilityMultifactorRandom += adblContinuousForwardVolatility[i] *</span>
							adblMultivariateRandom[i];
				}

<span class="fc" id="L238">				return dc.forward (iDate, iDate + 1) * dblAnnualizedIncrement +</span>
					dblPointVolatilityMultifactorRandom * dblAnnualizedIncrementSQRT;
			}
		};

<span class="fc" id="L243">		return spotRateR1ToR1.derivative (iViewDate, 1);</span>
	}

	private org.drip.dynamics.lmm.BGMForwardTenorSnap timeSnap (
		final int iSpotDate,
		final int iTargetPointDate,
		final double dblAnnualizedIncrement,
		final double dblAnnualizedIncrementSQRT,
		final java.lang.String strForwardTenor,
		final org.drip.state.forward.ForwardCurve fc,
		final org.drip.state.discount.MergedDiscountForwardCurve dc,
		final org.drip.dynamics.lmm.LognormalLIBORVolatility llv)
	{
<span class="fc" id="L256">		double[] adblLognormalFactorPointVolatility = llv.factorPointVolatility (iSpotDate,</span>
			iTargetPointDate);

<span class="fc" id="L259">		double[] adblContinuousForwardVolatility = llv.continuousForwardVolatility (iTargetPointDate, fc);</span>

<span class="fc" id="L261">		double[] adblMultivariateRandom = llv.msg().random();</span>

<span class="fc" id="L263">		double dblCrossVolatilityDotProduct = 0.;</span>
<span class="fc" id="L264">		double dblLognormalPointVolatilityModulus = 0.;</span>
<span class="fc" id="L265">		double dblLIBORVolatilityMultiFactorRandom = 0.;</span>
<span class="fc" id="L266">		double dblContinuousForwardVolatilityModulus = 0.;</span>
<span class="fc" id="L267">		double dblForwardVolatilityMultiFactorRandom = 0.;</span>
<span class="fc" id="L268">		int iNumFactor = adblLognormalFactorPointVolatility.length;</span>

<span class="fc bfc" id="L270" title="All 2 branches covered.">		for (int i = 0; i &lt; iNumFactor; ++i) {</span>
<span class="fc" id="L271">			dblLognormalPointVolatilityModulus += adblLognormalFactorPointVolatility[i] *</span>
				adblLognormalFactorPointVolatility[i];
<span class="fc" id="L273">			dblCrossVolatilityDotProduct += adblLognormalFactorPointVolatility[i] *</span>
				adblContinuousForwardVolatility[i];
<span class="fc" id="L275">			dblLIBORVolatilityMultiFactorRandom += adblLognormalFactorPointVolatility[i] *</span>
				adblMultivariateRandom[i] * dblAnnualizedIncrementSQRT;
<span class="fc" id="L277">			dblContinuousForwardVolatilityModulus += adblContinuousForwardVolatility[i] *</span>
				adblContinuousForwardVolatility[i];
<span class="fc" id="L279">			dblForwardVolatilityMultiFactorRandom += adblContinuousForwardVolatility[i] *</span>
				adblMultivariateRandom[i] * dblAnnualizedIncrementSQRT;
		}

		try {
<span class="fc" id="L284">			double dblLIBOR = fc.forward (iTargetPointDate);</span>

<span class="fc" id="L286">			double dblDiscountFactor = dc.df (iTargetPointDate);</span>

<span class="fc" id="L288">			double dblSpotRate = dc.forward (iSpotDate, iSpotDate + 1);</span>

<span class="fc" id="L290">			double dblContinuousForwardRate = fc.forward (iTargetPointDate);</span>

<span class="fc" id="L292">			double dblDCF = org.drip.analytics.support.Helper.TenorToYearFraction (strForwardTenor);</span>

<span class="fc" id="L294">			double dblLIBORDCF = dblDCF * dblLIBOR;</span>

<span class="fc" id="L296">			double dblLIBORIncrement = dblAnnualizedIncrement * (forwardDerivative (fc, iTargetPointDate) +</span>
				dblLIBOR * dblCrossVolatilityDotProduct + (dblLognormalPointVolatilityModulus * dblLIBOR *
					dblLIBORDCF / (1. + dblLIBORDCF))) + dblLIBOR * dblLIBORVolatilityMultiFactorRandom;

<span class="fc" id="L300">			double dblDiscountFactorIncrement = dblDiscountFactor * (dblSpotRate - dblContinuousForwardRate)</span>
				* dblAnnualizedIncrement - dblForwardVolatilityMultiFactorRandom;

<span class="fc" id="L303">			double dblContinuousForwardRateIncrement = continuousForwardRateIncrement (iTargetPointDate,</span>
				dblAnnualizedIncrement, dblAnnualizedIncrementSQRT, fc, adblMultivariateRandom, llv);

<span class="fc" id="L306">			double dblSpotRateIncrement = spotRateIncrement (iTargetPointDate, dblAnnualizedIncrement,</span>
				dblAnnualizedIncrementSQRT, dc, adblMultivariateRandom, llv);

<span class="fc" id="L309">			double dblContinuousForwardRateEvolved = dblContinuousForwardRate +</span>
				dblContinuousForwardRateIncrement;

<span class="fc" id="L312">			return new org.drip.dynamics.lmm.BGMForwardTenorSnap (iTargetPointDate, dblLIBOR +</span>
				dblLIBORIncrement, dblLIBORIncrement, dblDiscountFactor + dblDiscountFactorIncrement,
					dblDiscountFactorIncrement, dblContinuousForwardRateIncrement, dblSpotRateIncrement,
<span class="fc" id="L315">						java.lang.Math.exp (dblContinuousForwardRateEvolved) - 1., (java.lang.Math.exp</span>
<span class="fc" id="L316">							(dblDCF * dblContinuousForwardRateEvolved) - 1.) / dblDCF, java.lang.Math.sqrt</span>
<span class="fc" id="L317">								(dblLognormalPointVolatilityModulus), java.lang.Math.sqrt</span>
<span class="fc" id="L318">									(dblContinuousForwardVolatilityModulus));</span>
<span class="nc" id="L319">		} catch (java.lang.Exception e) {</span>
<span class="nc" id="L320">			e.printStackTrace();</span>
		}

<span class="nc" id="L323">		return null;</span>
	}

	private org.drip.dynamics.lmm.PathwiseQMRealization simulateLIBOR (
		final int iEvolutionDate,
		final int iViewDate,
		final double dblAnnualizedIncrement,
		final double dblAnnualizedIncrementSQRT,
		final org.drip.state.forward.ForwardCurve fc,
		final java.lang.String strForwardTenor,
		final double dblForwardDCF,
		final org.drip.dynamics.lmm.LognormalLIBORVolatility llv)
	{
<span class="nc" id="L336">		int[] aiTenorDate = new int[_iNumForwardTenor + 1];</span>
<span class="nc" id="L337">		double[] adblLIBOR = new double[_iNumForwardTenor + 1];</span>

<span class="nc" id="L339">		double[] adblMultivariateRandom = llv.msg().random();</span>

<span class="nc" id="L341">		org.drip.analytics.date.JulianDate dtTargetPoint = new org.drip.analytics.date.JulianDate</span>
			(iViewDate);

		try {
<span class="nc bnc" id="L345" title="All 2 branches missed.">			for (int i = 0; i &lt;= _iNumForwardTenor; ++i) {</span>
<span class="nc" id="L346">				int iTargetPointDate = dtTargetPoint.julian();</span>

<span class="nc" id="L348">				double[] adblLognormalFactorPointVolatility = llv.factorPointVolatility (iEvolutionDate,</span>
					iTargetPointDate);

<span class="nc" id="L351">				double[] adblContinuousForwardVolatility = llv.continuousForwardVolatility (iTargetPointDate,</span>
					fc);

<span class="nc" id="L354">				double dblLIBOR = fc.forward (iTargetPointDate);</span>

<span class="nc" id="L356">				aiTenorDate[i] = iTargetPointDate;</span>
<span class="nc" id="L357">				double dblCrossVolatilityDotProduct = 0.;</span>
<span class="nc" id="L358">				double dblLIBORDCF = dblForwardDCF * dblLIBOR;</span>
<span class="nc" id="L359">				double dblLognormalPointVolatilityModulus = 0.;</span>
<span class="nc" id="L360">				double dblLIBORVolatilityMultiFactorRandom = 0.;</span>
<span class="nc" id="L361">				int iNumFactor = adblLognormalFactorPointVolatility.length;</span>

<span class="nc bnc" id="L363" title="All 2 branches missed.">				for (int j = 0; j &lt; iNumFactor; ++j) {</span>
<span class="nc" id="L364">					dblLognormalPointVolatilityModulus += adblLognormalFactorPointVolatility[j] *</span>
						adblLognormalFactorPointVolatility[j];
<span class="nc" id="L366">					dblCrossVolatilityDotProduct += adblLognormalFactorPointVolatility[j] *</span>
						adblContinuousForwardVolatility[j];
<span class="nc" id="L368">					dblLIBORVolatilityMultiFactorRandom += adblLognormalFactorPointVolatility[j] *</span>
						adblMultivariateRandom[j] * dblAnnualizedIncrementSQRT;
				}

<span class="nc" id="L372">				adblLIBOR[i] = dblLIBOR + dblAnnualizedIncrement * (forwardDerivative (fc, iTargetPointDate)</span>
					+ dblLIBOR * dblCrossVolatilityDotProduct + (dblLognormalPointVolatilityModulus *
						dblLIBOR * dblLIBORDCF / (1. + dblLIBORDCF))) + dblLIBOR *
							dblLIBORVolatilityMultiFactorRandom;

<span class="nc" id="L377">				dtTargetPoint = dtTargetPoint.addTenor (strForwardTenor);</span>
			}

<span class="nc" id="L380">			return new org.drip.dynamics.lmm.PathwiseQMRealization (aiTenorDate, adblLIBOR);</span>
<span class="nc" id="L381">		} catch (java.lang.Exception e) {</span>
<span class="nc" id="L382">			e.printStackTrace();</span>
		}

<span class="nc" id="L385">		return null;</span>
	}

	/**
	 * LognormalLIBORCurveEvolver Constructor
	 * 
	 * @param lslFunding The Funding Latent State Label
	 * @param lslForward The Forward Latent State Label
	 * @param iNumForwardTenor Number of Forward Tenors to Build the Span
	 * @param scbcLIBOR LIBOR Span Segment Custom Builder Control Instance
	 * @param scbcDiscountFactor Discount Factor Span Segment Custom Builder Control Instance
	 * @param scbcLIBORIncrement LIBOR Increment Span Segment Custom Builder Control Instance
	 * @param scbcDiscountFactorIncrement Discount Factor Increment Span Segment Custom Builder Control
	 * 		Instance
	 * @param scbcContinuousForwardIncrement Instantaneous Continuously Compounded Forward Rate Increment
	 *  	Span Segment Custom Builder Control Instance
	 * @param scbcSpotRateIncrement Spot Rate Increment Span Segment Custom Builder Control Instance
	 * @param scbcInstantaneousEffectiveForward Instantaneous Effective Annual Forward Rate Span Segment
	 * 		Custom Builder Control Instance
	 * @param scbcInstantaneousNominalForward Instantaneous Nominal Annual Forward Rate Span Segment Custom
	 * 		Builder Control Instance
	 * 
	 * @throws java.lang.Exception Thrown if Inputs are Invalid
	 */

	public LognormalLIBORCurveEvolver (
		final org.drip.state.identifier.FundingLabel lslFunding,
		final org.drip.state.identifier.ForwardLabel lslForward,
		final int iNumForwardTenor,
		final org.drip.spline.params.SegmentCustomBuilderControl scbcLIBOR,
		final org.drip.spline.params.SegmentCustomBuilderControl scbcDiscountFactor,
		final org.drip.spline.params.SegmentCustomBuilderControl scbcLIBORIncrement,
		final org.drip.spline.params.SegmentCustomBuilderControl scbcDiscountFactorIncrement,
		final org.drip.spline.params.SegmentCustomBuilderControl scbcContinuousForwardIncrement,
		final org.drip.spline.params.SegmentCustomBuilderControl scbcSpotRateIncrement,
		final org.drip.spline.params.SegmentCustomBuilderControl scbcInstantaneousEffectiveForward,
		final org.drip.spline.params.SegmentCustomBuilderControl scbcInstantaneousNominalForward)
		throws java.lang.Exception
<span class="fc" id="L423">	{</span>
<span class="pc bpc" id="L424" title="10 of 20 branches missed.">		if (null == (_lslFunding = lslFunding) || null == (_lslForward = lslForward) || 1 &gt;=</span>
			(_iNumForwardTenor = iNumForwardTenor) || null == scbcLIBOR || null == scbcLIBORIncrement || null
				== scbcDiscountFactor || null == scbcDiscountFactorIncrement || null ==
					scbcContinuousForwardIncrement || null == scbcSpotRateIncrement || null ==
						scbcInstantaneousEffectiveForward)
<span class="nc" id="L429">			throw new java.lang.Exception (&quot;LognormalLIBORCurveEvolver ctr: Invalid Inputs&quot;);</span>

<span class="fc" id="L431">		_aSCBCLIBOR = new org.drip.spline.params.SegmentCustomBuilderControl[iNumForwardTenor];</span>
<span class="fc" id="L432">		_aSCBCDiscountFactor = new org.drip.spline.params.SegmentCustomBuilderControl[iNumForwardTenor];</span>
<span class="fc" id="L433">		_aSCBCLIBORIncrement = new org.drip.spline.params.SegmentCustomBuilderControl[iNumForwardTenor];</span>
<span class="fc" id="L434">		_aSCBCDiscountFactorIncrement = new</span>
			org.drip.spline.params.SegmentCustomBuilderControl[iNumForwardTenor];
<span class="fc" id="L436">		_aSCBCContinuousForwardIncrement = new</span>
			org.drip.spline.params.SegmentCustomBuilderControl[iNumForwardTenor];
<span class="fc" id="L438">		_aSCBCSpotRateIncrement = new org.drip.spline.params.SegmentCustomBuilderControl[iNumForwardTenor];</span>
<span class="fc" id="L439">		_aSCBCInstantaneousNominalForward = new</span>
			org.drip.spline.params.SegmentCustomBuilderControl[iNumForwardTenor];
<span class="fc" id="L441">		_aSCBCInstantaneousEffectiveForward = new</span>
			org.drip.spline.params.SegmentCustomBuilderControl[iNumForwardTenor];

<span class="fc bfc" id="L444" title="All 2 branches covered.">		for (int i = 0; i &lt; iNumForwardTenor; ++i) {</span>
<span class="fc" id="L445">			_aSCBCLIBOR[i] = scbcLIBOR;</span>
<span class="fc" id="L446">			_aSCBCDiscountFactor[i] = scbcDiscountFactor;</span>
<span class="fc" id="L447">			_aSCBCLIBORIncrement[i] = scbcLIBORIncrement;</span>
<span class="fc" id="L448">			_aSCBCDiscountFactorIncrement[i] = scbcDiscountFactorIncrement;</span>
<span class="fc" id="L449">			_aSCBCContinuousForwardIncrement[i] = scbcContinuousForwardIncrement;</span>
<span class="fc" id="L450">			_aSCBCSpotRateIncrement[i] = scbcSpotRateIncrement;</span>
<span class="fc" id="L451">			_aSCBCInstantaneousEffectiveForward[i] = scbcInstantaneousEffectiveForward;</span>
<span class="fc" id="L452">			_aSCBCInstantaneousNominalForward[i] = scbcInstantaneousNominalForward;</span>
		}
<span class="fc" id="L454">	}</span>

	/**
	 * Retrieve the Funding Label
	 * 
	 * @return The Funding Label
	 */

	public org.drip.state.identifier.FundingLabel fundingLabel()
	{
<span class="nc" id="L464">		return _lslFunding;</span>
	}

	/**
	 * Retrieve the Forward Label
	 * 
	 * @return The Forward Label
	 */

	public org.drip.state.identifier.ForwardLabel forwardLabel()
	{
<span class="nc" id="L475">		return _lslForward;</span>
	}

	/**
	 * Retrieve the Number of Forward Tenors comprising the Span Tenor
	 * 
	 * @return Number of Forward Tenors comprising the Span Tenor
	 */

	public int spanTenor()
	{
<span class="nc" id="L486">		return _iNumForwardTenor;</span>
	}

	/**
	 * Retrieve the LIBOR Curve Segment Custom Builder Control Instance
	 * 
	 * @return The LIBOR Curve Segment Custom Builder Control Instance
	 */

	public org.drip.spline.params.SegmentCustomBuilderControl scbcLIBOR()
	{
<span class="nc" id="L497">		return _aSCBCLIBOR[0];</span>
	}

	/**
	 * Retrieve the Discount Factor Segment Custom Builder Control Instance
	 * 
	 * @return The Discount Factor Segment Custom Builder Control Instance
	 */

	public org.drip.spline.params.SegmentCustomBuilderControl scbcDiscountFactor()
	{
<span class="nc" id="L508">		return _aSCBCDiscountFactor[0];</span>
	}

	/**
	 * Retrieve the LIBOR Increment Segment Custom Builder Control Instance
	 * 
	 * @return The LIBOR Increment Segment Custom Builder Control Instance
	 */

	public org.drip.spline.params.SegmentCustomBuilderControl scbcLIBORIncrement()
	{
<span class="nc" id="L519">		return _aSCBCLIBORIncrement[0];</span>
	}

	/**
	 * Retrieve the Discount Factor Increment Segment Custom Builder Control Instance
	 * 
	 * @return The Discount Factor Increment Segment Custom Builder Control Instance
	 */

	public org.drip.spline.params.SegmentCustomBuilderControl scbcDiscountFactorIncrement()
	{
<span class="nc" id="L530">		return _aSCBCDiscountFactorIncrement[0];</span>
	}

	/**
	 * Retrieve the Instantaneous Continuously Compounded Forward Rate Increment Segment Custom Builder
	 *  Control Instance
	 * 
	 * @return The Instantaneous Continuously Compounded Forward Rate Increment Segment Custom Builder
	 *  Control Instance
	 */

	public org.drip.spline.params.SegmentCustomBuilderControl scbcContinuousForwardIncrement()
	{
<span class="nc" id="L543">		return _aSCBCContinuousForwardIncrement[0];</span>
	}

	/**
	 * Retrieve the Spot Rate Increment Segment Custom Builder Control Instance
	 * 
	 * @return The Spot Rate Increment Segment Custom Builder Control Instance
	 */

	public org.drip.spline.params.SegmentCustomBuilderControl scbcSpotRateIncrement()
	{
<span class="nc" id="L554">		return _aSCBCSpotRateIncrement[0];</span>
	}

	/**
	 * Retrieve the Instantaneous Effective Annual Forward Rate Increment Segment Custom Builder Control
	 *  Instance
	 * 
	 * @return The Instantaneous Effective Annual Forward Rate Increment Segment Custom Builder Control
	 *  Instance
	 */

	public org.drip.spline.params.SegmentCustomBuilderControl scbcInstantaneousEffectiveForward()
	{
<span class="nc" id="L567">		return _aSCBCInstantaneousEffectiveForward[0];</span>
	}

	/**
	 * Retrieve the Instantaneous Nominal Annual Forward Rate Increment Segment Custom Builder Control
	 *  Instance
	 * 
	 * @return The Instantaneous Nominal Annual Forward Rate Increment Segment Custom Builder Control
	 *  Instance
	 */

	public org.drip.spline.params.SegmentCustomBuilderControl scbcInstantaneousNominalForward()
	{
<span class="nc" id="L580">		return _aSCBCInstantaneousNominalForward[0];</span>
	}

	@Override public org.drip.dynamics.lmm.BGMCurveUpdate evolve (
		final int iSpotDate,
		final int iViewDate,
		final int iSpotTimeIncrement,
		final org.drip.dynamics.evolution.LSQMCurveUpdate lsqmPrev)
	{
<span class="pc bpc" id="L589" title="3 of 6 branches missed.">		if (iSpotDate &gt; iViewDate || null == lsqmPrev || !(lsqmPrev instanceof</span>
			org.drip.dynamics.lmm.BGMCurveUpdate))
<span class="nc" id="L591">			return null;</span>

<span class="fc" id="L593">		org.drip.dynamics.lmm.BGMCurveUpdate bgmPrev = (org.drip.dynamics.lmm.BGMCurveUpdate) lsqmPrev;</span>
<span class="fc" id="L594">		org.drip.dynamics.lmm.BGMForwardTenorSnap[] aBGMTS = new</span>
			org.drip.dynamics.lmm.BGMForwardTenorSnap[_iNumForwardTenor + 1];
<span class="fc" id="L596">		double dblAnnualizedIncrement = 1. * iSpotTimeIncrement / 365.25;</span>

<span class="fc" id="L598">		double dblAnnualizedIncrementSQRT = java.lang.Math.sqrt (dblAnnualizedIncrement);</span>

<span class="fc" id="L600">		org.drip.state.forward.ForwardCurve fc = bgmPrev.forwardCurve();</span>

<span class="fc" id="L602">		org.drip.state.discount.MergedDiscountForwardCurve dc = bgmPrev.discountCurve();</span>

<span class="fc" id="L604">		org.drip.dynamics.lmm.LognormalLIBORVolatility llv = bgmPrev.lognormalLIBORVolatility();</span>

<span class="fc" id="L606">		java.lang.String strForwardTenor = _lslForward.tenor();</span>

<span class="fc" id="L608">		org.drip.analytics.date.JulianDate dtTargetPoint = new org.drip.analytics.date.JulianDate</span>
			(iViewDate);

		try {
<span class="fc bfc" id="L612" title="All 2 branches covered.">			for (int i = 0; i &lt;= _iNumForwardTenor; ++i) {</span>
<span class="pc bpc" id="L613" title="1 of 2 branches missed.">				if (null == (aBGMTS[i] = timeSnap (iSpotDate, dtTargetPoint.julian(), iSpotTimeIncrement,</span>
					dblAnnualizedIncrementSQRT, strForwardTenor, fc, dc, llv)) || null == (dtTargetPoint =
<span class="pc bpc" id="L615" title="1 of 2 branches missed.">						dtTargetPoint.addTenor (strForwardTenor)))</span>
<span class="nc" id="L616">					return null;</span>
			}

<span class="fc" id="L619">			org.drip.dynamics.lmm.BGMTenorNodeSequence btns = new org.drip.dynamics.lmm.BGMTenorNodeSequence</span>
				(aBGMTS);

			org.drip.spline.stretch.BoundarySettings bs =
<span class="fc" id="L623">				org.drip.spline.stretch.BoundarySettings.NaturalStandard();</span>

<span class="fc" id="L625">			java.lang.String strForwardLabelName = _lslForward.fullyQualifiedName();</span>

<span class="fc" id="L627">			java.lang.String strFundingLabelName = _lslFunding.fullyQualifiedName();</span>

<span class="fc" id="L629">			int[] aiTenorDate = btns.dates();</span>

<span class="fc" id="L631">			org.drip.state.curve.BasisSplineForwardRate fcLIBOR = new</span>
				org.drip.state.curve.BasisSplineForwardRate (_lslForward, new
					org.drip.spline.grid.OverlappingStretchSpan
						(org.drip.spline.stretch.MultiSegmentSequenceBuilder.CreateCalibratedStretchEstimator
<span class="fc" id="L635">							(strForwardLabelName + &quot;_QM_LIBOR&quot;, aiTenorDate, btns.liborRates(), _aSCBCLIBOR,</span>
								null, bs, org.drip.spline.stretch.MultiSegmentSequence.CALIBRATE)));

<span class="fc" id="L638">			org.drip.state.curve.DiscountFactorDiscountCurve dcDiscountFactor = new</span>
<span class="fc" id="L639">				org.drip.state.curve.DiscountFactorDiscountCurve (_lslForward.currency(), new</span>
					org.drip.spline.grid.OverlappingStretchSpan
						(org.drip.spline.stretch.MultiSegmentSequenceBuilder.CreateCalibratedStretchEstimator
<span class="fc" id="L642">							(strFundingLabelName + &quot;_QM_DISCOUNTFACTOR&quot;, aiTenorDate, btns.discountFactors(),</span>
								_aSCBCDiscountFactor, null, bs,
									org.drip.spline.stretch.MultiSegmentSequence.CALIBRATE)));

<span class="fc" id="L646">			org.drip.spline.stretch.MultiSegmentSequence mssDiscountFactorIncrement =</span>
				org.drip.spline.stretch.MultiSegmentSequenceBuilder.CreateCalibratedStretchEstimator
<span class="fc" id="L648">					(strFundingLabelName + &quot;_INCREMENT&quot;, aiTenorDate, btns.discountFactorIncrements(),</span>
						_aSCBCDiscountFactorIncrement, null, bs,
							org.drip.spline.stretch.MultiSegmentSequence.CALIBRATE);

<span class="fc" id="L652">			org.drip.spline.stretch.MultiSegmentSequence mssContinuousForwardRateIncrement =</span>
				org.drip.spline.stretch.MultiSegmentSequenceBuilder.CreateCalibratedStretchEstimator
<span class="fc" id="L654">					(strForwardLabelName + &quot;_CONT_FWD_INCREMENT&quot;, aiTenorDate,</span>
<span class="fc" id="L655">						btns.continuousForwardRateIncrements(), _aSCBCContinuousForwardIncrement, null, bs,</span>
							org.drip.spline.stretch.MultiSegmentSequence.CALIBRATE);

<span class="fc" id="L658">			org.drip.spline.stretch.MultiSegmentSequence mssSpotRateIncrement =</span>
				org.drip.spline.stretch.MultiSegmentSequenceBuilder.CreateCalibratedStretchEstimator
<span class="fc" id="L660">					(strForwardLabelName + &quot;_SPOT_RATE_INCREMENT&quot;, aiTenorDate, btns.spotRateIncrements(),</span>
						_aSCBCSpotRateIncrement, null, bs,
							org.drip.spline.stretch.MultiSegmentSequence.CALIBRATE);

<span class="fc" id="L664">			org.drip.spline.stretch.MultiSegmentSequence mssInstantaneousEffectiveForwardRate =</span>
				org.drip.spline.stretch.MultiSegmentSequenceBuilder.CreateCalibratedStretchEstimator
<span class="fc" id="L666">					(strForwardLabelName + &quot;_EFFECTIVE_ANNUAL_FORWARD&quot;, aiTenorDate,</span>
<span class="fc" id="L667">						btns.instantaneousEffectiveForwardRates(), _aSCBCInstantaneousEffectiveForward, null,</span>
							bs, org.drip.spline.stretch.MultiSegmentSequence.CALIBRATE);

<span class="fc" id="L670">			org.drip.spline.stretch.MultiSegmentSequence mssInstantaneousNominalForwardRate =</span>
				org.drip.spline.stretch.MultiSegmentSequenceBuilder.CreateCalibratedStretchEstimator
<span class="fc" id="L672">					(strForwardLabelName + &quot;_NOMINAL_ANNUAL_FORWARD&quot;, aiTenorDate,</span>
<span class="fc" id="L673">						btns.instantaneousNominalForwardRates(), _aSCBCInstantaneousNominalForward, null, bs,</span>
							org.drip.spline.stretch.MultiSegmentSequence.CALIBRATE);

<span class="fc" id="L676">			return org.drip.dynamics.lmm.BGMCurveUpdate.Create (_lslFunding, _lslForward, iSpotDate,</span>
				iSpotDate + iSpotTimeIncrement, fcLIBOR, new org.drip.spline.grid.OverlappingStretchSpan
					(org.drip.spline.stretch.MultiSegmentSequenceBuilder.CreateCalibratedStretchEstimator
<span class="fc" id="L679">						(strForwardLabelName + &quot;_INCREMENT&quot;, aiTenorDate, btns.liborRateIncrements(),</span>
							_aSCBCLIBORIncrement, null, bs,
								org.drip.spline.stretch.MultiSegmentSequence.CALIBRATE)), dcDiscountFactor,
									new org.drip.spline.grid.OverlappingStretchSpan
										(mssDiscountFactorIncrement), new
											org.drip.spline.grid.OverlappingStretchSpan
												(mssContinuousForwardRateIncrement), new
													org.drip.spline.grid.OverlappingStretchSpan
														(mssSpotRateIncrement), new
															org.drip.spline.grid.OverlappingStretchSpan
																(mssInstantaneousEffectiveForwardRate), new
																	org.drip.spline.grid.OverlappingStretchSpan
<span class="fc" id="L691">				(mssInstantaneousNominalForwardRate), bgmPrev.lognormalLIBORVolatility());</span>
<span class="nc" id="L692">		} catch (java.lang.Exception e) {</span>
<span class="nc" id="L693">			e.printStackTrace();</span>
		}

<span class="nc" id="L696">		return null;</span>
	}

	@Override public double[][] simulatePrincipalMetric (
		final int iEvolutionStartDate,
		final int iEvolutionFinishDate,
		final int iEvolutionIncrement,
		final int iViewDate,
		final org.drip.dynamics.evolution.LSQMCurveUpdate lsqmStart,
		final int iNumSimulation)
	{
<span class="nc bnc" id="L707" title="All 14 branches missed.">		if (iEvolutionStartDate &gt; iViewDate || iEvolutionFinishDate &lt;= iEvolutionStartDate ||</span>
			iEvolutionFinishDate &gt; iViewDate || iEvolutionIncrement &lt;= 0. || null == lsqmStart || !(lsqmStart
				instanceof org.drip.dynamics.lmm.BGMCurveUpdate) || 1 &gt;= iNumSimulation)
<span class="nc" id="L710">			return null;</span>

<span class="nc" id="L712">		org.drip.dynamics.lmm.BGMCurveUpdate bgmMetrics = (org.drip.dynamics.lmm.BGMCurveUpdate) lsqmStart;</span>

<span class="nc" id="L714">		org.drip.dynamics.lmm.LognormalLIBORVolatility llv = bgmMetrics.lognormalLIBORVolatility();</span>

<span class="nc" id="L716">		java.lang.String strForwardLabel = _lslForward.fullyQualifiedName() + &quot;_QM_LIBOR&quot;;</span>

<span class="nc" id="L718">		org.drip.state.forward.ForwardCurve fc = bgmMetrics.forwardCurve();</span>

<span class="nc" id="L720">		java.lang.String strForwardTenor = _lslForward.tenor();</span>

<span class="nc" id="L722">		int iNumTimeStep = ((iEvolutionFinishDate - iEvolutionStartDate) / iEvolutionIncrement) + 1;</span>
<span class="nc" id="L723">		double[][] aadblTenorLIBOR = new double[iNumTimeStep][_iNumForwardTenor + 1];</span>
<span class="nc" id="L724">		double dblAnnualizedIncrement = 1. * iEvolutionIncrement / 365.25;</span>
<span class="nc" id="L725">		double dblForwardDCF = java.lang.Double.NaN;</span>

<span class="nc" id="L727">		double dblAnnualizedIncrementSQRT = java.lang.Math.sqrt (dblAnnualizedIncrement);</span>

		org.drip.spline.stretch.BoundarySettings bs =
<span class="nc" id="L730">			org.drip.spline.stretch.BoundarySettings.NaturalStandard();</span>

		try {
<span class="nc" id="L733">			dblForwardDCF = org.drip.analytics.support.Helper.TenorToYearFraction (strForwardTenor);</span>
<span class="nc" id="L734">		} catch (java.lang.Exception e) {</span>
<span class="nc" id="L735">			e.printStackTrace();</span>

<span class="nc" id="L737">			return null;</span>
<span class="nc" id="L738">		}</span>

<span class="nc bnc" id="L740" title="All 2 branches missed.">		for (int i = 0 ; i &lt; iNumTimeStep; ++i) {</span>
<span class="nc bnc" id="L741" title="All 2 branches missed.">			for (int j = 0 ; j &lt;= _iNumForwardTenor; ++j)</span>
<span class="nc" id="L742">				aadblTenorLIBOR[i][j] = 0.;</span>
		}

<span class="nc bnc" id="L745" title="All 2 branches missed.">		for (int iSimulationIndex = 0; iSimulationIndex &lt; iNumSimulation; ++iSimulationIndex) {</span>
<span class="nc" id="L746">			int iEvolutionTimeIndex = 0;</span>
<span class="nc" id="L747">			org.drip.state.forward.ForwardCurve fcLIBOR = fc;</span>

<span class="nc bnc" id="L749" title="All 2 branches missed.">			for (int iEvolutionDate = iEvolutionStartDate; iEvolutionDate &lt;= iEvolutionFinishDate;</span>
<span class="nc" id="L750">				iEvolutionDate += iEvolutionIncrement) {</span>
<span class="nc" id="L751">				org.drip.dynamics.lmm.PathwiseQMRealization pqmr = simulateLIBOR (iEvolutionDate, iViewDate,</span>
					dblAnnualizedIncrement, dblAnnualizedIncrementSQRT, fcLIBOR, strForwardTenor,
						dblForwardDCF, llv);

<span class="nc bnc" id="L755" title="All 2 branches missed.">				if (null == pqmr) return null;</span>

<span class="nc" id="L757">				double[] adblSimulatedLIBOR = pqmr.realizedQM();</span>

				try {
<span class="nc" id="L760">					fcLIBOR = new org.drip.state.curve.BasisSplineForwardRate (_lslForward, new</span>
						org.drip.spline.grid.OverlappingStretchSpan
							(org.drip.spline.stretch.MultiSegmentSequenceBuilder.CreateCalibratedStretchEstimator
<span class="nc" id="L763">						(strForwardLabel + &quot;_QM_LIBOR&quot;, pqmr.targetDate(), adblSimulatedLIBOR, _aSCBCLIBOR,</span>
							null, bs, org.drip.spline.stretch.MultiSegmentSequence.CALIBRATE)));
<span class="nc" id="L765">				} catch (java.lang.Exception e) {</span>
<span class="nc" id="L766">					e.printStackTrace();</span>

<span class="nc" id="L768">					return null;</span>
<span class="nc" id="L769">				}</span>

<span class="nc bnc" id="L771" title="All 2 branches missed.">				for (int j = 0 ; j &lt;= _iNumForwardTenor; ++j)</span>
<span class="nc" id="L772">					aadblTenorLIBOR[iEvolutionTimeIndex][j] += adblSimulatedLIBOR[j];</span>

<span class="nc" id="L774">				iEvolutionTimeIndex++;</span>
			}
		}

<span class="nc bnc" id="L778" title="All 2 branches missed.">		for (int i = 0 ; i &lt; iNumTimeStep; ++i) {</span>
<span class="nc bnc" id="L779" title="All 2 branches missed.">			for (int j = 0 ; j &lt;= _iNumForwardTenor; ++j)</span>
<span class="nc" id="L780">				aadblTenorLIBOR[i][j] /= iNumSimulation;</span>
		}

<span class="nc" id="L783">		return aadblTenorLIBOR;</span>
	}

	/**
	 * Construct an Array of Forward Curves that Result from the Simulation
	 * 
	 * @param iEvolutionStartDate The Start Date of the Simulation
	 * @param iEvolutionFinishDate The Finish Date of the Simulation
	 * @param iEvolutionIncrement The Simulation Evolution Increment
	 * @param iViewDate The Forward View Date
	 * @param lsqmStart The Initial/Starting LSQM State
	 * @param iNumSimulation Number of Simulations
	 * 
	 * @return The Array of Forward Curves that Result from the Simulation
	 */

	public org.drip.state.forward.ForwardCurve[] simulateTerminalLatentState (
		final int iEvolutionStartDate,
		final int iEvolutionFinishDate,
		final int iEvolutionIncrement,
		final int iViewDate,
		final org.drip.dynamics.evolution.LSQMCurveUpdate lsqmStart,
		final int iNumSimulation)
	{
<span class="nc bnc" id="L807" title="All 14 branches missed.">		if (iEvolutionStartDate &gt; iViewDate || iEvolutionFinishDate &lt;= iEvolutionStartDate ||</span>
			iEvolutionFinishDate &gt; iViewDate || iEvolutionIncrement &lt;= 0. || null == lsqmStart || !(lsqmStart
				instanceof org.drip.dynamics.lmm.BGMCurveUpdate) || 1 &gt;= iNumSimulation)
<span class="nc" id="L810">			return null;</span>

<span class="nc" id="L812">		org.drip.dynamics.lmm.BGMCurveUpdate bgmMetrics = (org.drip.dynamics.lmm.BGMCurveUpdate) lsqmStart;</span>

<span class="nc" id="L814">		org.drip.dynamics.lmm.LognormalLIBORVolatility llv = bgmMetrics.lognormalLIBORVolatility();</span>

<span class="nc" id="L816">		java.lang.String strForwardLabel = _lslForward.fullyQualifiedName() + &quot;_QM_LIBOR&quot;;</span>

<span class="nc" id="L818">		org.drip.state.forward.ForwardCurve fc = bgmMetrics.forwardCurve();</span>

<span class="nc" id="L820">		java.lang.String strForwardTenor = _lslForward.tenor();</span>

<span class="nc" id="L822">		org.drip.state.forward.ForwardCurve[] aFCLIBOR = new</span>
			org.drip.state.forward.ForwardCurve[iNumSimulation];
<span class="nc" id="L824">		double dblAnnualizedIncrement = 1. * iEvolutionIncrement / 365.25;</span>
<span class="nc" id="L825">		double dblForwardDCF = java.lang.Double.NaN;</span>

<span class="nc" id="L827">		double dblAnnualizedIncrementSQRT = java.lang.Math.sqrt (dblAnnualizedIncrement);</span>

		org.drip.spline.stretch.BoundarySettings bs =
<span class="nc" id="L830">			org.drip.spline.stretch.BoundarySettings.NaturalStandard();</span>

		try {
<span class="nc" id="L833">			dblForwardDCF = org.drip.analytics.support.Helper.TenorToYearFraction (strForwardTenor);</span>
<span class="nc" id="L834">		} catch (java.lang.Exception e) {</span>
<span class="nc" id="L835">			e.printStackTrace();</span>

<span class="nc" id="L837">			return null;</span>
<span class="nc" id="L838">		}</span>

<span class="nc bnc" id="L840" title="All 2 branches missed.">		for (int iSimulationIndex = 0; iSimulationIndex &lt; iNumSimulation; ++iSimulationIndex) {</span>
<span class="nc" id="L841">			System.out.println (&quot;\t\tSimulation #&quot; + (iSimulationIndex + 1));</span>

<span class="nc" id="L843">			org.drip.state.forward.ForwardCurve fcLIBOR = fc;</span>

<span class="nc bnc" id="L845" title="All 2 branches missed.">			for (int iEvolutionDate = iEvolutionStartDate; iEvolutionDate &lt;= iEvolutionFinishDate;</span>
<span class="nc" id="L846">				iEvolutionDate += iEvolutionIncrement) {</span>
<span class="nc" id="L847">				org.drip.dynamics.lmm.PathwiseQMRealization pqmr = simulateLIBOR (iEvolutionDate, iViewDate,</span>
					dblAnnualizedIncrement, dblAnnualizedIncrementSQRT, fcLIBOR, strForwardTenor,
						dblForwardDCF, llv);

<span class="nc bnc" id="L851" title="All 2 branches missed.">				if (null == pqmr) return null;</span>

				try {
<span class="nc" id="L854">					fcLIBOR = new org.drip.state.curve.BasisSplineForwardRate (_lslForward, new</span>
						org.drip.spline.grid.OverlappingStretchSpan
							(org.drip.spline.stretch.MultiSegmentSequenceBuilder.CreateCalibratedStretchEstimator
<span class="nc" id="L857">						(strForwardLabel + &quot;_QM_LIBOR&quot;, pqmr.targetDate(), pqmr.realizedQM(), _aSCBCLIBOR,</span>
							null, bs, org.drip.spline.stretch.MultiSegmentSequence.CALIBRATE)));
<span class="nc" id="L859">				} catch (java.lang.Exception e) {</span>
<span class="nc" id="L860">					e.printStackTrace();</span>

<span class="nc" id="L862">					return null;</span>
<span class="nc" id="L863">				}</span>
			}

<span class="nc" id="L866">			aFCLIBOR[iSimulationIndex] = fcLIBOR;</span>
		}

<span class="nc" id="L869">		return aFCLIBOR;</span>
	}
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.7.9.201702052155</span></div></body></html>