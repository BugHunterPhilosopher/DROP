<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>ExposureAdjustmentAggregator.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">DROP</a> &gt; <a href="index.source.html" class="el_package">org.drip.xva.gross</a> &gt; <span class="el_source">ExposureAdjustmentAggregator.java</span></div><h1>ExposureAdjustmentAggregator.java</h1><pre class="source lang-java linenums">
package org.drip.xva.gross;

/*
 * -*- mode: java; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*-
 */

/*!
 * Copyright (C) 2019 Lakshmi Krishnamurthy
 * Copyright (C) 2018 Lakshmi Krishnamurthy
 * Copyright (C) 2017 Lakshmi Krishnamurthy
 * 
 *  This file is part of DROP, an open-source library targeting risk, transaction costs, exposure, margin
 *  	calculations, and portfolio construction within and across fixed income, credit, commodity, equity,
 *  	FX, and structured products.
 *  
 *  	https://lakshmidrip.github.io/DROP/
 *  
 *  DROP is composed of three main modules:
 *  
 *  - DROP Analytics Core - https://lakshmidrip.github.io/DROP-Analytics-Core/
 *  - DROP Portfolio Core - https://lakshmidrip.github.io/DROP-Portfolio-Core/
 *  - DROP Numerical Core - https://lakshmidrip.github.io/DROP-Numerical-Core/
 * 
 * 	DROP Analytics Core implements libraries for the following:
 * 	- Fixed Income Analytics
 * 	- Asset Backed Analytics
 * 	- XVA Analytics
 * 	- Exposure and Margin Analytics
 * 
 * 	DROP Portfolio Core implements libraries for the following:
 * 	- Asset Allocation Analytics
 * 	- Transaction Cost Analytics
 * 
 * 	DROP Numerical Core implements libraries for the following:
 * 	- Statistical Learning Library
 * 	- Numerical Optimizer Library
 * 	- Machine Learning Library
 * 	- Spline Builder Library
 * 
 * 	Documentation for DROP is Spread Over:
 * 
 * 	- Main                     =&gt; https://lakshmidrip.github.io/DROP/
 * 	- Wiki                     =&gt; https://github.com/lakshmiDRIP/DROP/wiki
 * 	- GitHub                   =&gt; https://github.com/lakshmiDRIP/DROP
 * 	- Javadoc                  =&gt; https://lakshmidrip.github.io/DROP/Javadoc/index.html
 * 	- Technical Specifications =&gt; https://github.com/lakshmiDRIP/DROP/tree/master/Docs/Internal
 * 	- Release Versions         =&gt; https://lakshmidrip.github.io/DROP/version.html
 * 	- Community Credits        =&gt; https://lakshmidrip.github.io/DROP/credits.html
 * 	- Issues Catalog           =&gt; https://github.com/lakshmiDRIP/DROP/issues
 * 	- JUnit                    =&gt; https://lakshmidrip.github.io/DROP/junit/index.html
 * 	- Jacoco                   =&gt; https://lakshmidrip.github.io/DROP/jacoco/index.html
 * 
 *  Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 *   	you may not use this file except in compliance with the License.
 *   
 *  You may obtain a copy of the License at
 *  	http://www.apache.org/licenses/LICENSE-2.0
 *  
 *  Unless required by applicable law or agreed to in writing, software
 *  	distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 *  	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  
 *  See the License for the specific language governing permissions and
 *  	limitations under the License.
 */

/**
 * &lt;i&gt;ExposureAdjustmentAggregator&lt;/i&gt; aggregates across Multiple Exposure/Adjustment Paths belonging to the
 * Counter Party. The References are:
 *
 *  &lt;br&gt;&lt;br&gt;
 *  &lt;ul&gt;
 *  	&lt;li&gt;
 *  		Burgard, C., and M. Kjaer (2014): PDE Representations of Derivatives with Bilateral Counter-party
 *  			Risk and Funding Costs &lt;i&gt;Journal of Credit Risk&lt;/i&gt; &lt;b&gt;7 (3)&lt;/b&gt; 1-19
 *  	&lt;/li&gt;
 *  	&lt;li&gt;
 *  		Burgard, C., and M. Kjaer (2014): In the Balance &lt;i&gt;Risk&lt;/i&gt; &lt;b&gt;24 (11)&lt;/b&gt; 72-75
 *  	&lt;/li&gt;
 *  	&lt;li&gt;
 *  		Gregory, J. (2009): Being Two-faced over Counter-party Credit Risk &lt;i&gt;Risk&lt;/i&gt; &lt;b&gt;20 (2)&lt;/b&gt;
 *  			86-90
 *  	&lt;/li&gt;
 *  	&lt;li&gt;
 *  		Li, B., and Y. Tang (2007): &lt;i&gt;Quantitative Analysis, Derivatives Modeling, and Trading
 *  			Strategies in the Presence of Counter-party Credit Risk for the Fixed Income Market&lt;/i&gt;
 *  			&lt;b&gt;World Scientific Publishing&lt;/b&gt; Singapore
 *  	&lt;/li&gt;
 *  	&lt;li&gt;
 *  		Piterbarg, V. (2010): Funding Beyond Discounting: Collateral Agreements and Derivatives Pricing
 *  			&lt;i&gt;Risk&lt;/i&gt; &lt;b&gt;21 (2)&lt;/b&gt; 97-102
 *  	&lt;/li&gt;
 *  &lt;/ul&gt;
 *
 *  &lt;br&gt;&lt;br&gt;
 *  &lt;ul&gt;
 *		&lt;li&gt;&lt;b&gt;Project&lt;/b&gt;       = &lt;a href = &quot;https://github.com/lakshmiDRIP/DROP/tree/master/src/main/java/org/drip/xva&quot;&gt;XVA&lt;/a&gt;&lt;/li&gt;
 *		&lt;li&gt;&lt;b&gt;Package&lt;/b&gt;       = &lt;a href = &quot;https://github.com/lakshmiDRIP/DROP/tree/master/src/main/java/org/drip/xva/gross&quot;&gt;Gross&lt;/a&gt;&lt;/li&gt;
 *		&lt;li&gt;&lt;b&gt;Specification&lt;/b&gt; = &lt;a href = &quot;https://github.com/lakshmiDRIP/DROP/tree/master/Docs/Internal/XVA&quot;&gt;XVA Analytics Library&lt;/a&gt;&lt;/li&gt;
 *  &lt;/ul&gt;
 * &lt;br&gt;&lt;br&gt;
 * 
 * @author Lakshmi Krishnamurthy
 */

public class ExposureAdjustmentAggregator
{
<span class="fc" id="L109">	private org.drip.xva.gross.PathExposureAdjustment[] _pathExposureAdjustmentArray = null;</span>

	/**
	 * ExposureAdjustmentAggregator Constructor
	 * 
	 * @param pathExposureAdjustmentArray Array of the Counter Party Group Paths
	 * 
	 * @throws java.lang.Exception Thrown if the Inputs are Invalid
	 */

	public ExposureAdjustmentAggregator (
		final org.drip.xva.gross.PathExposureAdjustment[] pathExposureAdjustmentArray)
		throws java.lang.Exception
<span class="fc" id="L122">	{</span>
<span class="pc bpc" id="L123" title="2 of 4 branches missed.">		if (null == (_pathExposureAdjustmentArray = pathExposureAdjustmentArray) ||</span>
			0 == _pathExposureAdjustmentArray.length)
		{
<span class="nc" id="L126">			throw new java.lang.Exception (&quot;ExposureAdjustmentAggregator Constructor =&gt; Invalid Inputs&quot;);</span>
		}
<span class="fc" id="L128">	}</span>

	/**
	 * Retrieve the Array of Group Path Exposure Adjustments
	 * 
	 * @return Array of Group Path Exposure Adjustments
	 */

	public org.drip.xva.gross.PathExposureAdjustment[] pathExposureAdjustmentArray()
	{
<span class="nc" id="L138">		return _pathExposureAdjustmentArray;</span>
	}

	/**
	 * Retrieve the Array of the Vertex Anchor Dates
	 * 
	 * @return The Array of the Vertex Anchor Dates
	 */

	public org.drip.analytics.date.JulianDate[] vertexDates()
	{
<span class="fc" id="L149">		return _pathExposureAdjustmentArray[0].vertexDates();</span>
	}

	/**
	 * Retrieve the Array of Collateralized Exposures
	 * 
	 * @return The Array of Collateralized Exposures
	 */

	public double[] collateralizedExposure()
	{
<span class="fc" id="L160">		int vertexCount = vertexDates().length;</span>

<span class="fc" id="L162">		int pathCount = _pathExposureAdjustmentArray.length;</span>
<span class="fc" id="L163">		double[] collateralizedExposure = new double[vertexCount];</span>

<span class="fc bfc" id="L165" title="All 2 branches covered.">		for (int vertexIndex = 0; vertexIndex &lt; vertexCount; ++vertexIndex)</span>
		{
<span class="fc" id="L167">			collateralizedExposure[vertexIndex] = 0.;</span>
		}

<span class="fc bfc" id="L170" title="All 2 branches covered.">		for (int pathIndex = 0; pathIndex &lt; pathCount; ++pathIndex)</span>
		{
<span class="fc" id="L172">			double[] pathCollateralizedExposure =</span>
<span class="fc" id="L173">				_pathExposureAdjustmentArray[pathIndex].vertexCollateralizedExposure();</span>

<span class="fc bfc" id="L175" title="All 2 branches covered.">			for (int vertexIndex = 0; vertexIndex &lt; vertexCount; ++vertexIndex)</span>
			{
<span class="fc" id="L177">				collateralizedExposure[vertexIndex] += pathCollateralizedExposure[vertexIndex];</span>
			}
		}

<span class="fc bfc" id="L181" title="All 2 branches covered.">		for (int vertexIndex = 0; vertexIndex &lt; vertexCount; ++vertexIndex)</span>
		{
<span class="fc" id="L183">			collateralizedExposure[vertexIndex] /= pathCount;</span>
		}

<span class="fc" id="L186">		return collateralizedExposure;</span>
	}

	/**
	 * Retrieve the Array of Collateralized Exposure PV's
	 * 
	 * @return The Array of Collateralized Exposure PV's
	 */

	public double[] collateralizedExposurePV()
	{
<span class="fc" id="L197">		int vertexCount = vertexDates().length;</span>

<span class="fc" id="L199">		int pathCount = _pathExposureAdjustmentArray.length;</span>
<span class="fc" id="L200">		double[] collateralizedExposurePV = new double[vertexCount];</span>

<span class="fc bfc" id="L202" title="All 2 branches covered.">		for (int vertexIndex = 0; vertexIndex &lt; vertexCount; ++vertexIndex)</span>
		{
<span class="fc" id="L204">			collateralizedExposurePV[vertexIndex] = 0.;</span>
		}

<span class="fc bfc" id="L207" title="All 2 branches covered.">		for (int pathIndex = 0; pathIndex &lt; pathCount; ++pathIndex)</span>
		{
<span class="fc" id="L209">			double[] pathCollateralizedExposurePV =</span>
<span class="fc" id="L210">				_pathExposureAdjustmentArray[pathIndex].vertexCollateralizedExposurePV();</span>

<span class="fc bfc" id="L212" title="All 2 branches covered.">			for (int vertexIndex = 0; vertexIndex &lt; vertexCount; ++vertexIndex)</span>
			{
<span class="fc" id="L214">				collateralizedExposurePV[vertexIndex] += pathCollateralizedExposurePV[vertexIndex];</span>
			}
		}

<span class="fc bfc" id="L218" title="All 2 branches covered.">		for (int vertexIndex = 0; vertexIndex &lt; vertexCount; ++vertexIndex)</span>
		{
<span class="fc" id="L220">			collateralizedExposurePV[vertexIndex] /= pathCount;</span>
		}

<span class="fc" id="L223">		return collateralizedExposurePV;</span>
	}

	/**
	 * Retrieve the Array of Uncollateralized Exposures
	 * 
	 * @return The Array of Uncollateralized Exposures
	 */

	public double[] uncollateralizedExposure()
	{
<span class="nc" id="L234">		int vertexCount = vertexDates().length;</span>

<span class="nc" id="L236">		int pathCount = _pathExposureAdjustmentArray.length;</span>
<span class="nc" id="L237">		double[] uncollateralizedExposure = new double[vertexCount];</span>

<span class="nc bnc" id="L239" title="All 2 branches missed.">		for (int vertexIndex = 0; vertexIndex &lt; vertexCount; ++vertexIndex)</span>
		{
<span class="nc" id="L241">			uncollateralizedExposure[vertexIndex] = 0.;</span>
		}

<span class="nc bnc" id="L244" title="All 2 branches missed.">		for (int pathIndex = 0; pathIndex &lt; pathCount; ++pathIndex)</span>
		{
<span class="nc" id="L246">			double[] pathUncollateralizedExposure =</span>
<span class="nc" id="L247">				_pathExposureAdjustmentArray[pathIndex].vertexUncollateralizedExposure();</span>

<span class="nc bnc" id="L249" title="All 2 branches missed.">			for (int vertexIndex = 0; vertexIndex &lt; vertexCount; ++vertexIndex)</span>
			{
<span class="nc" id="L251">				uncollateralizedExposure[vertexIndex] += pathUncollateralizedExposure[vertexIndex];</span>
			}
		}

<span class="nc bnc" id="L255" title="All 2 branches missed.">		for (int vertexIndex = 0; vertexIndex &lt; vertexCount; ++vertexIndex)</span>
<span class="nc" id="L256">			uncollateralizedExposure[vertexIndex] /= pathCount;</span>

<span class="nc" id="L258">		return uncollateralizedExposure;</span>
	}

	/**
	 * Retrieve the Array of Uncollateralized Exposure PV's
	 * 
	 * @return The Array of Uncollateralized Exposure PV's
	 */

	public double[] uncollateralizedExposurePV()
	{
<span class="nc" id="L269">		int vertexCount = vertexDates().length;</span>

<span class="nc" id="L271">		int pathCount = _pathExposureAdjustmentArray.length;</span>
<span class="nc" id="L272">		double[] uncollateralizedExposurePV = new double[vertexCount];</span>

<span class="nc bnc" id="L274" title="All 2 branches missed.">		for (int vertexIndex = 0; vertexIndex &lt; vertexCount; ++vertexIndex)</span>
		{
<span class="nc" id="L276">			uncollateralizedExposurePV[vertexIndex] = 0.;</span>
		}

<span class="nc bnc" id="L279" title="All 2 branches missed.">		for (int pathIndex = 0; pathIndex &lt; pathCount; ++pathIndex)</span>
		{
<span class="nc" id="L281">			double[] pathUncollateralizedExposurePV =</span>
<span class="nc" id="L282">				_pathExposureAdjustmentArray[pathIndex].vertexUncollateralizedExposurePV();</span>

<span class="nc bnc" id="L284" title="All 2 branches missed.">			for (int vertexIndex = 0; vertexIndex &lt; vertexCount; ++vertexIndex)</span>
			{
<span class="nc" id="L286">				uncollateralizedExposurePV[vertexIndex] +=</span>
					pathUncollateralizedExposurePV[vertexIndex];
			}
		}

<span class="nc bnc" id="L291" title="All 2 branches missed.">		for (int vertexIndex = 0; vertexIndex &lt; vertexCount; ++vertexIndex)</span>
		{
<span class="nc" id="L293">			uncollateralizedExposurePV[vertexIndex] /= pathCount;</span>
		}

<span class="nc" id="L296">		return uncollateralizedExposurePV;</span>
	}

	/**
	 * Retrieve the Array of Collateralized Positive Exposures
	 * 
	 * @return The Array of Collateralized Positive Exposures
	 */

	public double[] collateralizedPositiveExposure()
	{
<span class="fc" id="L307">		int vertexCount = vertexDates().length;</span>

<span class="fc" id="L309">		int pathCount = _pathExposureAdjustmentArray.length;</span>
<span class="fc" id="L310">		double[] collateralizedPositiveExposure = new double[vertexCount];</span>

<span class="fc bfc" id="L312" title="All 2 branches covered.">		for (int vertexIndex = 0; vertexIndex &lt; vertexCount; ++vertexIndex)</span>
		{
<span class="fc" id="L314">			collateralizedPositiveExposure[vertexIndex] = 0.;</span>
		}

<span class="fc bfc" id="L317" title="All 2 branches covered.">		for (int pathIndex = 0; pathIndex &lt; pathCount; ++pathIndex)</span>
		{
<span class="fc" id="L319">			double[] pathCollateralizedPositiveExposure =</span>
<span class="fc" id="L320">				_pathExposureAdjustmentArray[pathIndex].vertexCollateralizedPositiveExposure();</span>

<span class="fc bfc" id="L322" title="All 2 branches covered.">			for (int vertexIndex = 0; vertexIndex &lt; vertexCount; ++vertexIndex)</span>
			{
<span class="fc" id="L324">				collateralizedPositiveExposure[vertexIndex] +=</span>
					pathCollateralizedPositiveExposure[vertexIndex];
			}
		}

<span class="fc bfc" id="L329" title="All 2 branches covered.">		for (int vertexIndex = 0; vertexIndex &lt; vertexCount; ++vertexIndex)</span>
		{
<span class="fc" id="L331">			collateralizedPositiveExposure[vertexIndex] /= pathCount;</span>
		}

<span class="fc" id="L334">		return collateralizedPositiveExposure;</span>
	}

	/**
	 * Retrieve the Array of Collateralized Positive Exposure PV
	 * 
	 * @return The Array of Collateralized Positive Exposure PV
	 */

	public double[] collateralizedPositiveExposurePV()
	{
<span class="fc" id="L345">		int vertexCount = vertexDates().length;</span>

<span class="fc" id="L347">		int pathCount = _pathExposureAdjustmentArray.length;</span>
<span class="fc" id="L348">		double[] collateralizedPositiveExposurePV = new double[vertexCount];</span>

<span class="fc bfc" id="L350" title="All 2 branches covered.">		for (int vertexIndex = 0; vertexIndex &lt; vertexCount; ++vertexIndex)</span>
		{
<span class="fc" id="L352">			collateralizedPositiveExposurePV[vertexIndex] = 0.;</span>
		}

<span class="fc bfc" id="L355" title="All 2 branches covered.">		for (int pathIndex = 0; pathIndex &lt; pathCount; ++pathIndex)</span>
		{
<span class="fc" id="L357">			double[] pathCollateralizedPositiveExposurePV =</span>
<span class="fc" id="L358">				_pathExposureAdjustmentArray[pathIndex].vertexCollateralizedPositiveExposurePV();</span>

<span class="fc bfc" id="L360" title="All 2 branches covered.">			for (int vertexIndex = 0; vertexIndex &lt; vertexCount; ++vertexIndex)</span>
			{
<span class="fc" id="L362">				collateralizedPositiveExposurePV[vertexIndex] +=</span>
					pathCollateralizedPositiveExposurePV[vertexIndex];
			}
		}

<span class="fc bfc" id="L367" title="All 2 branches covered.">		for (int vertexIndex = 0; vertexIndex &lt; vertexCount; ++vertexIndex)</span>
		{
<span class="fc" id="L369">			collateralizedPositiveExposurePV[vertexIndex] /= pathCount;</span>
		}

<span class="fc" id="L372">		return collateralizedPositiveExposurePV;</span>
	}

	/**
	 * Retrieve the Array of Uncollateralized Positive Exposures
	 * 
	 * @return The Array of Uncollateralized Positive Exposures
	 */

	public double[] uncollateralizedPositiveExposure()
	{
<span class="nc" id="L383">		int vertexCount = vertexDates().length;</span>

<span class="nc" id="L385">		int pathCount = _pathExposureAdjustmentArray.length;</span>
<span class="nc" id="L386">		double[] uncollateralizedPositiveExposure = new double[vertexCount];</span>

<span class="nc bnc" id="L388" title="All 2 branches missed.">		for (int vertexIndex = 0; vertexIndex &lt; vertexCount; ++vertexIndex)</span>
		{
<span class="nc" id="L390">			uncollateralizedPositiveExposure[vertexIndex] = 0.;</span>
		}

<span class="nc bnc" id="L393" title="All 2 branches missed.">		for (int pathIndex = 0; pathIndex &lt; pathCount; ++pathIndex)</span>
		{
<span class="nc" id="L395">			double[] pathUncollateralizedPositiveExposure =</span>
<span class="nc" id="L396">				_pathExposureAdjustmentArray[pathIndex].vertexUncollateralizedPositiveExposure();</span>

<span class="nc bnc" id="L398" title="All 2 branches missed.">			for (int vertexIndex = 0; vertexIndex &lt; vertexCount; ++vertexIndex)</span>
			{
<span class="nc" id="L400">				uncollateralizedPositiveExposure[vertexIndex] +=</span>
					pathUncollateralizedPositiveExposure[vertexIndex];
			}
		}

<span class="nc bnc" id="L405" title="All 2 branches missed.">		for (int vertexIndex = 0; vertexIndex &lt; vertexCount; ++vertexIndex)</span>
		{
<span class="nc" id="L407">			uncollateralizedPositiveExposure[vertexIndex] /= pathCount;</span>
		}

<span class="nc" id="L410">		return uncollateralizedPositiveExposure;</span>
	}

	/**
	 * Retrieve the Array of Uncollateralized Positive Exposure PV
	 * 
	 * @return The Array of Uncollateralized Positive Exposure PV
	 */

	public double[] uncollateralizedPositiveExposurePV()
	{
<span class="nc" id="L421">		int vertexCount = vertexDates().length;</span>

<span class="nc" id="L423">		int pathCount = _pathExposureAdjustmentArray.length;</span>
<span class="nc" id="L424">		double[] uncollateralizedPositiveExposurePV = new double[vertexCount];</span>

<span class="nc bnc" id="L426" title="All 2 branches missed.">		for (int vertexIndex = 0; vertexIndex &lt; vertexCount; ++vertexIndex)</span>
		{
<span class="nc" id="L428">			uncollateralizedPositiveExposurePV[vertexIndex] = 0.;</span>
		}

<span class="nc bnc" id="L431" title="All 2 branches missed.">		for (int pathIndex = 0; pathIndex &lt; pathCount; ++pathIndex)</span>
		{
<span class="nc" id="L433">			double[] pathUncollateralizedPositiveExposurePV =</span>
<span class="nc" id="L434">				_pathExposureAdjustmentArray[pathIndex].vertexUncollateralizedPositiveExposurePV();</span>

<span class="nc bnc" id="L436" title="All 2 branches missed.">			for (int vertexIndex = 0; vertexIndex &lt; vertexCount; ++vertexIndex)</span>
			{
<span class="nc" id="L438">				uncollateralizedPositiveExposurePV[vertexIndex] +=</span>
					pathUncollateralizedPositiveExposurePV[vertexIndex];
			}
		}

<span class="nc bnc" id="L443" title="All 2 branches missed.">		for (int vertexIndex = 0; vertexIndex &lt; vertexCount; ++vertexIndex)</span>
		{
<span class="nc" id="L445">			uncollateralizedPositiveExposurePV[vertexIndex] /= pathCount;</span>
		}

<span class="nc" id="L448">		return uncollateralizedPositiveExposurePV;</span>
	}

	/**
	 * Retrieve the Array of Collateralized Negative Exposures
	 * 
	 * @return The Array of Collateralized Negative Exposures
	 */

	public double[] collateralizedNegativeExposure()
	{
<span class="fc" id="L459">		int vertexCount = vertexDates().length;</span>

<span class="fc" id="L461">		int pathCount = _pathExposureAdjustmentArray.length;</span>
<span class="fc" id="L462">		double[] collateralizedNegativeExposure = new double[vertexCount];</span>

<span class="fc bfc" id="L464" title="All 2 branches covered.">		for (int vertexIndex = 0; vertexIndex &lt; vertexCount; ++vertexIndex)</span>
		{
<span class="fc" id="L466">			collateralizedNegativeExposure[vertexIndex] = 0.;</span>
		}

<span class="fc bfc" id="L469" title="All 2 branches covered.">		for (int pathIndex = 0; pathIndex &lt; pathCount; ++pathIndex)</span>
		{
<span class="fc" id="L471">			double[] pathCollateralizedNegativeExposure =</span>
<span class="fc" id="L472">				_pathExposureAdjustmentArray[pathIndex].vertexCollateralizedNegativeExposure();</span>

<span class="fc bfc" id="L474" title="All 2 branches covered.">			for (int vertexIndex = 0; vertexIndex &lt; vertexCount; ++vertexIndex)</span>
			{
<span class="fc" id="L476">				collateralizedNegativeExposure[vertexIndex] +=</span>
					pathCollateralizedNegativeExposure[vertexIndex];
			}
		}

<span class="fc bfc" id="L481" title="All 2 branches covered.">		for (int vertexIndex = 0; vertexIndex &lt; vertexCount; ++vertexIndex)</span>
		{
<span class="fc" id="L483">			collateralizedNegativeExposure[vertexIndex] /= pathCount;</span>
		}

<span class="fc" id="L486">		return collateralizedNegativeExposure;</span>
	}

	/**
	 * Retrieve the Array of Collateralized Negative Exposure PV
	 * 
	 * @return The Array of Collateralized Negative Exposure PV
	 */

	public double[] collateralizedNegativeExposurePV()
	{
<span class="fc" id="L497">		int vertexCount = vertexDates().length;</span>

<span class="fc" id="L499">		int pathCount = _pathExposureAdjustmentArray.length;</span>
<span class="fc" id="L500">		double[] collateralizedNegativeExposurePV = new double[vertexCount];</span>

<span class="fc bfc" id="L502" title="All 2 branches covered.">		for (int vertexIndex = 0; vertexIndex &lt; vertexCount; ++vertexIndex)</span>
		{
<span class="fc" id="L504">			collateralizedNegativeExposurePV[vertexIndex] = 0.;</span>
		}

<span class="fc bfc" id="L507" title="All 2 branches covered.">		for (int pathIndex = 0; pathIndex &lt; pathCount; ++pathIndex)</span>
		{
<span class="fc" id="L509">			double[] pathCollateralizedNegativeExposurePV =</span>
<span class="fc" id="L510">				_pathExposureAdjustmentArray[pathIndex].vertexCollateralizedNegativeExposurePV();</span>

<span class="fc bfc" id="L512" title="All 2 branches covered.">			for (int vertexIndex = 0; vertexIndex &lt; vertexCount; ++vertexIndex)</span>
			{
<span class="fc" id="L514">				collateralizedNegativeExposurePV[vertexIndex] +=</span>
					pathCollateralizedNegativeExposurePV[vertexIndex];
			}
		}

<span class="fc bfc" id="L519" title="All 2 branches covered.">		for (int vertexIndex = 0; vertexIndex &lt; vertexCount; ++vertexIndex)</span>
		{
<span class="fc" id="L521">			collateralizedNegativeExposurePV[vertexIndex] /= pathCount;</span>
		}

<span class="fc" id="L524">		return collateralizedNegativeExposurePV;</span>
	}

	/**
	 * Retrieve the Array of Uncollateralized Negative Exposures
	 * 
	 * @return The Array of Uncollateralized Negative Exposures
	 */

	public double[] uncollateralizedNegativeExposure()
	{
<span class="nc" id="L535">		int vertexCount = vertexDates().length;</span>

<span class="nc" id="L537">		int pathCount = _pathExposureAdjustmentArray.length;</span>
<span class="nc" id="L538">		double[] uncollateralizedNegativeExposure = new double[vertexCount];</span>

<span class="nc bnc" id="L540" title="All 2 branches missed.">		for (int vertexIndex = 0; vertexIndex &lt; vertexCount; ++vertexIndex)</span>
		{
<span class="nc" id="L542">			uncollateralizedNegativeExposure[vertexIndex] = 0.;</span>
		}

<span class="nc bnc" id="L545" title="All 2 branches missed.">		for (int pathIndex = 0; pathIndex &lt; pathCount; ++pathIndex)</span>
		{
<span class="nc" id="L547">			double[] pathUncollateralizedNegativeExposure =</span>
<span class="nc" id="L548">				_pathExposureAdjustmentArray[pathIndex].vertexUncollateralizedNegativeExposure();</span>

<span class="nc bnc" id="L550" title="All 2 branches missed.">			for (int vertexIndex = 0; vertexIndex &lt; vertexCount; ++vertexIndex)</span>
			{
<span class="nc" id="L552">				uncollateralizedNegativeExposure[vertexIndex] +=</span>
					pathUncollateralizedNegativeExposure[vertexIndex];
			}
		}

<span class="nc bnc" id="L557" title="All 2 branches missed.">		for (int vertexIndex = 0; vertexIndex &lt; vertexCount; ++vertexIndex)</span>
		{
<span class="nc" id="L559">			uncollateralizedNegativeExposure[vertexIndex] /= pathCount;</span>
		}

<span class="nc" id="L562">		return uncollateralizedNegativeExposure;</span>
	}

	/**
	 * Retrieve the Array of Uncollateralized Negative Exposure PV
	 * 
	 * @return The Array of Uncollateralized Negative Exposure PV
	 */

	public double[] uncollateralizedNegativeExposurePV()
	{
<span class="nc" id="L573">		int vertexCount = vertexDates().length;</span>

<span class="nc" id="L575">		int pathCount = _pathExposureAdjustmentArray.length;</span>
<span class="nc" id="L576">		double[] uncollateralizedNegativeExposurePV = new double[vertexCount];</span>

<span class="nc bnc" id="L578" title="All 2 branches missed.">		for (int vertexIndex = 0; vertexIndex &lt; vertexCount; ++vertexIndex)</span>
		{
<span class="nc" id="L580">			uncollateralizedNegativeExposurePV[vertexIndex] = 0.;</span>
		}

<span class="nc bnc" id="L583" title="All 2 branches missed.">		for (int pathIndex = 0; pathIndex &lt; pathCount; ++pathIndex)</span>
		{
<span class="nc" id="L585">			double[] pathUncollateralizedNegativeExposurePV =</span>
<span class="nc" id="L586">				_pathExposureAdjustmentArray[pathIndex].vertexUncollateralizedNegativeExposurePV();</span>

<span class="nc bnc" id="L588" title="All 2 branches missed.">			for (int vertexIndex = 0; vertexIndex &lt; vertexCount; ++vertexIndex)</span>
			{
<span class="nc" id="L590">				uncollateralizedNegativeExposurePV[vertexIndex] +=</span>
					pathUncollateralizedNegativeExposurePV[vertexIndex];
			}
		}

<span class="nc bnc" id="L595" title="All 2 branches missed.">		for (int vertexIndex = 0; vertexIndex &lt; vertexCount; ++vertexIndex)</span>
		{
<span class="nc" id="L597">			uncollateralizedNegativeExposurePV[vertexIndex] /= pathCount;</span>
		}

<span class="nc" id="L600">		return uncollateralizedNegativeExposurePV;</span>
	}

	/**
	 * Retrieve the Array of Funding Exposures
	 * 
	 * @return The Array of Funding Exposures
	 */

	public double[] fundingExposure()
	{
<span class="nc" id="L611">		int vertexCount = vertexDates().length;</span>

<span class="nc" id="L613">		double[] fundingExposure = new double[vertexCount];</span>
<span class="nc" id="L614">		int pathCount = _pathExposureAdjustmentArray.length;</span>

<span class="nc bnc" id="L616" title="All 2 branches missed.">		for (int vertexIndex = 0; vertexIndex &lt; vertexCount; ++vertexIndex)</span>
		{
<span class="nc" id="L618">			fundingExposure[vertexIndex] = 0.;</span>
		}

<span class="nc bnc" id="L621" title="All 2 branches missed.">		for (int pathIndex = 0; pathIndex &lt; pathCount; ++pathIndex)</span>
		{
<span class="nc" id="L623">			double[] pathFundingExposure = _pathExposureAdjustmentArray[pathIndex].vertexFundingExposure();</span>

<span class="nc bnc" id="L625" title="All 2 branches missed.">			for (int vertexIndex = 0; vertexIndex &lt; vertexCount; ++vertexIndex)</span>
			{
<span class="nc" id="L627">				fundingExposure[vertexIndex] += pathFundingExposure[vertexIndex];</span>
			}
		}

<span class="nc bnc" id="L631" title="All 2 branches missed.">		for (int vertexIndex = 0; vertexIndex &lt; vertexCount; ++vertexIndex)</span>
		{
<span class="nc" id="L633">			fundingExposure[vertexIndex] /= pathCount;</span>
		}

<span class="nc" id="L636">		return fundingExposure;</span>
	}

	/**
	 * Retrieve the Array of Funding Exposure PV
	 * 
	 * @return The Array of Funding Exposure PV
	 */

	public double[] fundingExposurePV()
	{
<span class="nc" id="L647">		int vertexCount = vertexDates().length;</span>

<span class="nc" id="L649">		int pathCount = _pathExposureAdjustmentArray.length;</span>
<span class="nc" id="L650">		double[] fundingExposurePV = new double[vertexCount];</span>

<span class="nc bnc" id="L652" title="All 2 branches missed.">		for (int vertexIndex = 0; vertexIndex &lt; vertexCount; ++vertexIndex)</span>
		{
<span class="nc" id="L654">			fundingExposurePV[vertexIndex] = 0.;</span>
		}

<span class="nc bnc" id="L657" title="All 2 branches missed.">		for (int pathIndex = 0; pathIndex &lt; pathCount; ++pathIndex)</span>
		{
<span class="nc" id="L659">			double[] pathFundingExposurePV =</span>
<span class="nc" id="L660">				_pathExposureAdjustmentArray[pathIndex].vertexFundingExposurePV();</span>

<span class="nc bnc" id="L662" title="All 2 branches missed.">			for (int vertexIndex = 0; vertexIndex &lt; vertexCount; ++vertexIndex)</span>
			{
<span class="nc" id="L664">				fundingExposurePV[vertexIndex] += pathFundingExposurePV[vertexIndex];</span>
			}
		}

<span class="nc bnc" id="L668" title="All 2 branches missed.">		for (int vertexIndex = 0; vertexIndex &lt; vertexCount; ++vertexIndex)</span>
		{
<span class="nc" id="L670">			fundingExposurePV[vertexIndex] /= pathCount;</span>
		}

<span class="nc" id="L673">		return fundingExposurePV;</span>
	}

	/**
	 * Retrieve the Expected Bilateral Collateral VA
	 * 
	 * @return The Expected Bilateral Collateral VA
	 */

	public org.drip.xva.basel.ValueAdjustment ftdcolva()
	{
<span class="nc" id="L684">		double ftdcolva = 0.;</span>
<span class="nc" id="L685">		int pathCount = _pathExposureAdjustmentArray.length;</span>

		try
		{
<span class="nc bnc" id="L689" title="All 2 branches missed.">			for (int pathIndex = 0; pathIndex &lt; pathCount; ++pathIndex)</span>
			{
<span class="nc" id="L691">				ftdcolva += _pathExposureAdjustmentArray[pathIndex].bilateralCollateralAdjustment();</span>
			}
		}
<span class="nc" id="L694">		catch (java.lang.Exception e)</span>
		{
<span class="nc" id="L696">			e.printStackTrace();</span>

<span class="nc" id="L698">			return null;</span>
<span class="nc" id="L699">		}</span>

<span class="nc" id="L701">		return org.drip.xva.basel.ValueAdjustment.COLVA (ftdcolva / pathCount);</span>
	}

	/**
	 * Retrieve the Expected Collateral VA
	 * 
	 * @return The Expected Collateral VA
	 */

	public org.drip.xva.basel.ValueAdjustment colva()
	{
<span class="fc" id="L712">		double colva = 0.;</span>
<span class="fc" id="L713">		int pathCount = _pathExposureAdjustmentArray.length;</span>

		try
		{
<span class="fc bfc" id="L717" title="All 2 branches covered.">			for (int pathIndex = 0; pathIndex &lt; pathCount; ++pathIndex)</span>
			{
<span class="fc" id="L719">				colva += _pathExposureAdjustmentArray[pathIndex].bilateralCollateralAdjustment();</span>
			}
		}
<span class="nc" id="L722">		catch (java.lang.Exception e)</span>
		{
<span class="nc" id="L724">			e.printStackTrace();</span>

<span class="nc" id="L726">			return null;</span>
<span class="fc" id="L727">		}</span>

<span class="fc" id="L729">		return org.drip.xva.basel.ValueAdjustment.COLVA (colva / pathCount);</span>
	}

	/**
	 * Retrieve the Expected Unilateral CVA
	 * 
	 * @return The Expected Unilateral CVA
	 */

	public org.drip.xva.basel.ValueAdjustment ucva()
	{
<span class="fc" id="L740">		double ucva = 0.;</span>
<span class="fc" id="L741">		int pathCount = _pathExposureAdjustmentArray.length;</span>

		try
		{
<span class="fc bfc" id="L745" title="All 2 branches covered.">			for (int pathIndex = 0; pathIndex &lt; pathCount; ++pathIndex)</span>
			{
<span class="fc" id="L747">				ucva += _pathExposureAdjustmentArray[pathIndex].unilateralCreditAdjustment();</span>
			}
		}
<span class="nc" id="L750">		catch (java.lang.Exception e)</span>
		{
<span class="nc" id="L752">			e.printStackTrace();</span>

<span class="nc" id="L754">			return null;</span>
<span class="fc" id="L755">		}</span>

<span class="fc" id="L757">		return org.drip.xva.basel.ValueAdjustment.UCVA (ucva / pathCount);</span>
	}

	/**
	 * Retrieve the Expected Bilateral/FTD CVA
	 * 
	 * @return The Expected Bilateral/FTD CVA
	 */

	public org.drip.xva.basel.ValueAdjustment ftdcva()
	{
<span class="fc" id="L768">		double ftdcva = 0.;</span>
<span class="fc" id="L769">		int pathCount = _pathExposureAdjustmentArray.length;</span>

		try
		{
<span class="fc bfc" id="L773" title="All 2 branches covered.">			for (int pathIndex = 0; pathIndex &lt; pathCount; ++pathIndex)</span>
			{
<span class="fc" id="L775">				ftdcva += _pathExposureAdjustmentArray[pathIndex].bilateralCreditAdjustment();</span>
			}
		}
<span class="nc" id="L778">		catch (java.lang.Exception e)</span>
		{
<span class="nc" id="L780">			e.printStackTrace();</span>

<span class="nc" id="L782">			return null;</span>
<span class="fc" id="L783">		}</span>

<span class="fc" id="L785">		return org.drip.xva.basel.ValueAdjustment.FTDCVA (ftdcva / pathCount);</span>
	}

	/**
	 * Retrieve the Expected CVA
	 * 
	 * @return The Expected CVA
	 */

	public org.drip.xva.basel.ValueAdjustment cva()
	{
<span class="fc" id="L796">		return ftdcva();</span>
	}

	/**
	 * Retrieve the Expected CVA Contra-Liability
	 * 
	 * @return The Expected CVA Contra-Liability
	 */

	public org.drip.xva.basel.ValueAdjustment cvacl()
	{
<span class="fc" id="L807">		double cvacl = 0.;</span>
<span class="fc" id="L808">		int pathCount = _pathExposureAdjustmentArray.length;</span>

		try
		{
<span class="fc bfc" id="L812" title="All 2 branches covered.">			for (int pathIndex = 0; pathIndex &lt; pathCount; ++pathIndex)</span>
			{
<span class="fc" id="L814">				cvacl += _pathExposureAdjustmentArray[pathIndex].contraLiabilityCreditAdjustment();</span>
			}
		}
<span class="nc" id="L817">		catch (java.lang.Exception e)</span>
		{
<span class="nc" id="L819">			e.printStackTrace();</span>

<span class="nc" id="L821">			return null;</span>
<span class="fc" id="L822">		}</span>

<span class="fc" id="L824">		return org.drip.xva.basel.ValueAdjustment.CVACL (cvacl / pathCount);</span>
	}

	/**
	 * Retrieve the Expected Unilateral DVA
	 * 
	 * @return The Expected Unilateral DVA
	 */

	public org.drip.xva.basel.ValueAdjustment udva()
	{
<span class="nc" id="L835">		double udva = 0.;</span>
<span class="nc" id="L836">		int pathCount = _pathExposureAdjustmentArray.length;</span>

		try {
<span class="nc bnc" id="L839" title="All 2 branches missed.">			for (int pathIndex = 0; pathIndex &lt; pathCount; ++pathIndex)</span>
			{
<span class="nc" id="L841">				udva += _pathExposureAdjustmentArray[pathIndex].unilateralDebtAdjustment();</span>
			}
		}
<span class="nc" id="L844">		catch (java.lang.Exception e)</span>
		{
<span class="nc" id="L846">			e.printStackTrace();</span>

<span class="nc" id="L848">			return null;</span>
<span class="nc" id="L849">		}</span>

<span class="nc" id="L851">		return org.drip.xva.basel.ValueAdjustment.DVA (udva / pathCount);</span>
	}

	/**
	 * Retrieve the Expected Bilateral DVA
	 * 
	 * @return The Expected Bilateral DVA
	 */

	public org.drip.xva.basel.ValueAdjustment ftddva()
	{
<span class="nc" id="L862">		double ftddva = 0.;</span>
<span class="nc" id="L863">		int pathCount = _pathExposureAdjustmentArray.length;</span>

		try {
<span class="nc bnc" id="L866" title="All 2 branches missed.">			for (int pathIndex = 0; pathIndex &lt; pathCount; ++pathIndex)</span>
			{
<span class="nc" id="L868">				ftddva += _pathExposureAdjustmentArray[pathIndex].bilateralDebtAdjustment();</span>
			}
		}
<span class="nc" id="L871">		catch (java.lang.Exception e)</span>
		{
<span class="nc" id="L873">			e.printStackTrace();</span>

<span class="nc" id="L875">			return null;</span>
<span class="nc" id="L876">		}</span>

<span class="nc" id="L878">		return org.drip.xva.basel.ValueAdjustment.DVA (ftddva / pathCount);</span>
	}

	/**
	 * Retrieve the Expected DVA
	 * 
	 * @return The Expected DVA
	 */

	public org.drip.xva.basel.ValueAdjustment dva()
	{
<span class="fc" id="L889">		double dva = 0.;</span>
<span class="fc" id="L890">		int pathCount = _pathExposureAdjustmentArray.length;</span>

		try {
<span class="fc bfc" id="L893" title="All 2 branches covered.">			for (int pathIndex = 0; pathIndex &lt; pathCount; ++pathIndex)</span>
			{
<span class="fc" id="L895">				dva += _pathExposureAdjustmentArray[pathIndex].debtAdjustment();</span>
			}
		}
<span class="nc" id="L898">		catch (java.lang.Exception e)</span>
		{
<span class="nc" id="L900">			e.printStackTrace();</span>

<span class="nc" id="L902">			return null;</span>
<span class="fc" id="L903">		}</span>

<span class="fc" id="L905">		return org.drip.xva.basel.ValueAdjustment.DVA (dva / pathCount);</span>
	}

	/**
	 * Retrieve the Expected FVA
	 * 
	 * @return The Expected FVA
	 */

	public org.drip.xva.basel.ValueAdjustment fva()
	{
<span class="fc" id="L916">		double fva = 0.;</span>
<span class="fc" id="L917">		int pathCount = _pathExposureAdjustmentArray.length;</span>

		try
		{
<span class="fc bfc" id="L921" title="All 2 branches covered.">			for (int pathIndex = 0; pathIndex &lt; pathCount; ++pathIndex)</span>
			{
<span class="fc" id="L923">				fva += _pathExposureAdjustmentArray[pathIndex].fundingValueAdjustment();</span>
			}
		}
<span class="nc" id="L926">		catch (java.lang.Exception e)</span>
		{
<span class="nc" id="L928">			e.printStackTrace();</span>

<span class="nc" id="L930">			return null;</span>
<span class="fc" id="L931">		}</span>

<span class="fc" id="L933">		return org.drip.xva.basel.ValueAdjustment.FVA (fva / pathCount);</span>
	}

	/**
	 * Retrieve the Expected FDA
	 * 
	 * @return The Expected FDA
	 */

	public org.drip.xva.basel.ValueAdjustment fda()
	{
<span class="fc" id="L944">		double fda = 0.;</span>
<span class="fc" id="L945">		int pathCount = _pathExposureAdjustmentArray.length;</span>

		try
		{
<span class="fc bfc" id="L949" title="All 2 branches covered.">			for (int pathIndex = 0; pathIndex &lt; pathCount; ++pathIndex)</span>
			{
<span class="fc" id="L951">				fda += _pathExposureAdjustmentArray[pathIndex].fundingDebtAdjustment();</span>
			}
		}
<span class="nc" id="L954">		catch (java.lang.Exception e)</span>
		{
<span class="nc" id="L956">			e.printStackTrace();</span>

<span class="nc" id="L958">			return null;</span>
<span class="fc" id="L959">		}</span>

<span class="fc" id="L961">		return org.drip.xva.basel.ValueAdjustment.FDA (fda / pathCount);</span>
	}

	/**
	 * Retrieve the Expected DVA2
	 * 
	 * @return The Expected DVA2
	 */

	public org.drip.xva.basel.ValueAdjustment dva2()
	{
<span class="nc" id="L972">		return fda();</span>
	}

	/**
	 * Retrieve the Expected FCA
	 * 
	 * @return The Expected FCA
	 */

	public org.drip.xva.basel.ValueAdjustment fca()
	{
<span class="fc" id="L983">		double fca = 0.;</span>
<span class="fc" id="L984">		int pathCount = _pathExposureAdjustmentArray.length;</span>

<span class="fc bfc" id="L986" title="All 2 branches covered.">		for (int pathIndex = 0; pathIndex &lt; pathCount; ++pathIndex)</span>
		{
<span class="fc" id="L988">			fca += _pathExposureAdjustmentArray[pathIndex].fundingCostAdjustment();</span>
		}

<span class="fc" id="L991">		return org.drip.xva.basel.ValueAdjustment.HYBRID (fca / pathCount);</span>
	}

	/**
	 * Retrieve the Expected FBA
	 * 
	 * @return The Expected FBA
	 */

	public org.drip.xva.basel.ValueAdjustment fba()
	{
<span class="fc" id="L1002">		double fba = 0.;</span>
<span class="fc" id="L1003">		int pathCount = _pathExposureAdjustmentArray.length;</span>

<span class="fc bfc" id="L1005" title="All 2 branches covered.">		for (int pathIndex = 0; pathIndex &lt; pathCount; ++pathIndex)</span>
		{
<span class="fc" id="L1007">			fba += _pathExposureAdjustmentArray[pathIndex].fundingBenefitAdjustment();</span>
		}

<span class="fc" id="L1010">		return org.drip.xva.basel.ValueAdjustment.HYBRID (fba / pathCount);</span>
	}

	/**
	 * Retrieve the Expected SFVA
	 * 
	 * @return The Expected SFVA
	 */

	public org.drip.xva.basel.ValueAdjustment sfva()
	{
<span class="fc" id="L1021">		double sfva = 0.;</span>
<span class="fc" id="L1022">		int pathCount = _pathExposureAdjustmentArray.length;</span>

<span class="fc bfc" id="L1024" title="All 2 branches covered.">		for (int pathIndex = 0; pathIndex &lt; pathCount; ++pathIndex)</span>
		{
<span class="fc" id="L1026">			sfva += _pathExposureAdjustmentArray[pathIndex].symmetricFundingValueAdjustment();</span>
		}

<span class="fc" id="L1029">		return org.drip.xva.basel.ValueAdjustment.HYBRID (sfva / pathCount);</span>
	}

	/**
	 * Retrieve the Total VA
	 * 
	 * @return The Total VA
	 */

	public double total()
	{
<span class="fc" id="L1040">		return cva().amount() + dva().amount() + fva().amount() + colva().amount();</span>
	}

	/**
	 * Generate the &quot;Digest&quot; containing the &quot;Thin&quot; Path Statistics
	 * 
	 * @return The &quot;Digest&quot; containing the &quot;Thin&quot; Path Statistics
	 */

	public org.drip.xva.gross.ExposureAdjustmentDigest digest()
	{
<span class="fc" id="L1051">		int vertexCount = vertexDates().length;</span>

<span class="fc" id="L1053">		int pathCount = _pathExposureAdjustmentArray.length;</span>
<span class="fc" id="L1054">		double[] pathCVA = new double[pathCount];</span>
<span class="fc" id="L1055">		double[] pathDVA = new double[pathCount];</span>
<span class="fc" id="L1056">		double[] pathFBA = new double[pathCount];</span>
<span class="fc" id="L1057">		double[] pathFCA = new double[pathCount];</span>
<span class="fc" id="L1058">		double[] pathFDA = new double[pathCount];</span>
<span class="fc" id="L1059">		double[] pathFVA = new double[pathCount];</span>
<span class="fc" id="L1060">		double[] pathUCVA = new double[pathCount];</span>
<span class="fc" id="L1061">		double[] pathSFVA = new double[pathCount];</span>
<span class="fc" id="L1062">		double[] pathCVACL = new double[pathCount];</span>
<span class="fc" id="L1063">		double[] pathFTDCVA = new double[pathCount];</span>
<span class="fc" id="L1064">		double[] pathCOLVA = new double[pathCount];</span>
<span class="fc" id="L1065">		double[] pathTotalVA = new double[pathCount];</span>
<span class="fc" id="L1066">		double[] pathFTDCOLVA = new double[pathCount];</span>
<span class="fc" id="L1067">		double[][] fundingExposure = new double[vertexCount][pathCount];</span>
<span class="fc" id="L1068">		double[][] fundingExposurePV = new double[vertexCount][pathCount];</span>
<span class="fc" id="L1069">		double[][] collateralizedExposure = new double[vertexCount][pathCount];</span>
<span class="fc" id="L1070">		double[][] uncollateralizedExposure = new double[vertexCount][pathCount];</span>
<span class="fc" id="L1071">		double[][] collateralizedExposurePV = new double[vertexCount][pathCount];</span>
<span class="fc" id="L1072">		double[][] uncollateralizedExposurePV = new double[vertexCount][pathCount];</span>
<span class="fc" id="L1073">		double[][] collateralizedPositiveExposure = new double[vertexCount][pathCount];</span>
<span class="fc" id="L1074">		double[][] collateralizedNegativeExposure = new double[vertexCount][pathCount];</span>
<span class="fc" id="L1075">		double[][] uncollateralizedPositiveExposure = new double[vertexCount][pathCount];</span>
<span class="fc" id="L1076">		double[][] uncollateralizedNegativeExposure = new double[vertexCount][pathCount];</span>
<span class="fc" id="L1077">		double[][] collateralizedPositiveExposurePV = new double[vertexCount][pathCount];</span>
<span class="fc" id="L1078">		double[][] collateralizedNegativeExposurePV = new double[vertexCount][pathCount];</span>
<span class="fc" id="L1079">		double[][] uncollateralizedPositiveExposurePV = new double[vertexCount][pathCount];</span>
<span class="fc" id="L1080">		double[][] uncollateralizedNegativeExposurePV = new double[vertexCount][pathCount];</span>

<span class="fc bfc" id="L1082" title="All 2 branches covered.">		for (int vertexIndex = 0; vertexIndex &lt; vertexCount; ++vertexIndex)</span>
		{
<span class="fc bfc" id="L1084" title="All 2 branches covered.">			for (int pathIndex = 0; pathIndex &lt; pathCount; ++pathIndex)</span>
			{
<span class="fc" id="L1086">				collateralizedExposure[vertexIndex][pathIndex] = 0.;</span>
<span class="fc" id="L1087">				uncollateralizedExposure[vertexIndex][pathIndex] = 0.;</span>
<span class="fc" id="L1088">				collateralizedExposurePV[vertexIndex][pathIndex] = 0.;</span>
<span class="fc" id="L1089">				uncollateralizedExposurePV[vertexIndex][pathIndex] = 0.;</span>
<span class="fc" id="L1090">				collateralizedPositiveExposure[vertexIndex][pathIndex] = 0.;</span>
<span class="fc" id="L1091">				collateralizedNegativeExposure[vertexIndex][pathIndex] = 0.;</span>
<span class="fc" id="L1092">				uncollateralizedPositiveExposure[vertexIndex][pathIndex] = 0.;</span>
<span class="fc" id="L1093">				uncollateralizedNegativeExposure[vertexIndex][pathIndex] = 0.;</span>
<span class="fc" id="L1094">				collateralizedPositiveExposurePV[vertexIndex][pathIndex] = 0.;</span>
<span class="fc" id="L1095">				collateralizedNegativeExposurePV[vertexIndex][pathIndex] = 0.;</span>
<span class="fc" id="L1096">				uncollateralizedPositiveExposurePV[vertexIndex][pathIndex] = 0.;</span>
<span class="fc" id="L1097">				uncollateralizedNegativeExposurePV[vertexIndex][pathIndex] = 0.;</span>
			}
		}

<span class="fc bfc" id="L1101" title="All 2 branches covered.">		for (int pathIndex = 0; pathIndex &lt; pathCount; ++pathIndex)</span>
		{
<span class="fc" id="L1103">			double[] pathCollateralizedExposure =</span>
<span class="fc" id="L1104">				_pathExposureAdjustmentArray[pathIndex].vertexCollateralizedExposure();</span>

<span class="fc" id="L1106">			double[] pathCollateralizedExposurePV =</span>
<span class="fc" id="L1107">				_pathExposureAdjustmentArray[pathIndex].vertexCollateralizedExposurePV();</span>

<span class="fc" id="L1109">			double[] pathCollateralizedPositiveExposure =</span>
<span class="fc" id="L1110">				_pathExposureAdjustmentArray[pathIndex].vertexCollateralizedPositiveExposure();</span>

<span class="fc" id="L1112">			double[] pathCollateralizedPositiveExposurePV =</span>
<span class="fc" id="L1113">				_pathExposureAdjustmentArray[pathIndex].vertexCollateralizedPositiveExposurePV();</span>

<span class="fc" id="L1115">			double[] pathCollateralizedNegativeExposure =</span>
<span class="fc" id="L1116">				_pathExposureAdjustmentArray[pathIndex].vertexCollateralizedNegativeExposure();</span>

<span class="fc" id="L1118">			double[] pathCollateralizedNegativeExposurePV =</span>
<span class="fc" id="L1119">				_pathExposureAdjustmentArray[pathIndex].vertexCollateralizedNegativeExposurePV();</span>

<span class="fc" id="L1121">			double[] pathUncollateralizedExposure =</span>
<span class="fc" id="L1122">				_pathExposureAdjustmentArray[pathIndex].vertexUncollateralizedExposure();</span>

<span class="fc" id="L1124">			double[] pathUncollateralizedExposurePV =</span>
<span class="fc" id="L1125">				_pathExposureAdjustmentArray[pathIndex].vertexUncollateralizedExposurePV();</span>

<span class="fc" id="L1127">			double[] pathUncollateralizedPositiveExposure =</span>
<span class="fc" id="L1128">				_pathExposureAdjustmentArray[pathIndex].vertexUncollateralizedPositiveExposure();</span>

<span class="fc" id="L1130">			double[] pathUncollateralizedPositiveExposurePV =</span>
<span class="fc" id="L1131">				_pathExposureAdjustmentArray[pathIndex].vertexUncollateralizedPositiveExposurePV();</span>

<span class="fc" id="L1133">			double[] pathUncollateralizedNegativeExposure =</span>
<span class="fc" id="L1134">				_pathExposureAdjustmentArray[pathIndex].vertexUncollateralizedNegativeExposure();</span>

<span class="fc" id="L1136">			double[] pathUncollateralizedNegativeExposurePV =</span>
<span class="fc" id="L1137">				_pathExposureAdjustmentArray[pathIndex].vertexUncollateralizedNegativeExposurePV();</span>

<span class="fc" id="L1139">			double[] pathFundingExposure = _pathExposureAdjustmentArray[pathIndex].vertexFundingExposure();</span>

<span class="fc" id="L1141">			double[] pathFundingExposurePV =</span>
<span class="fc" id="L1142">				_pathExposureAdjustmentArray[pathIndex].vertexFundingExposurePV();</span>

			try
			{
<span class="fc" id="L1146">				pathCVA[pathIndex] = _pathExposureAdjustmentArray[pathIndex].creditAdjustment();</span>

<span class="fc" id="L1148">				pathDVA[pathIndex] = _pathExposureAdjustmentArray[pathIndex].debtAdjustment();</span>

<span class="fc" id="L1150">				pathFCA[pathIndex] = _pathExposureAdjustmentArray[pathIndex].fundingCostAdjustment();</span>

<span class="fc" id="L1152">				pathFDA[pathIndex] = _pathExposureAdjustmentArray[pathIndex].fundingDebtAdjustment();</span>

<span class="fc" id="L1154">				pathFVA[pathIndex] = _pathExposureAdjustmentArray[pathIndex].fundingValueAdjustment();</span>

<span class="fc" id="L1156">				pathFBA[pathIndex] = _pathExposureAdjustmentArray[pathIndex].fundingBenefitAdjustment();</span>

<span class="fc" id="L1158">				pathUCVA[pathIndex] = _pathExposureAdjustmentArray[pathIndex].unilateralCreditAdjustment();</span>

<span class="fc" id="L1160">				pathSFVA[pathIndex] =</span>
<span class="fc" id="L1161">					_pathExposureAdjustmentArray[pathIndex].symmetricFundingValueAdjustment();</span>

<span class="fc" id="L1163">				pathCVACL[pathIndex] =</span>
<span class="fc" id="L1164">					_pathExposureAdjustmentArray[pathIndex].contraLiabilityCreditAdjustment();</span>

<span class="fc" id="L1166">				pathFTDCVA[pathIndex] = _pathExposureAdjustmentArray[pathIndex].bilateralCreditAdjustment();</span>

<span class="fc" id="L1168">				pathCOLVA[pathIndex] =</span>
<span class="fc" id="L1169">					_pathExposureAdjustmentArray[pathIndex].bilateralCollateralAdjustment();</span>

<span class="fc" id="L1171">				pathFTDCOLVA[pathIndex] =</span>
<span class="fc" id="L1172">					_pathExposureAdjustmentArray[pathIndex].bilateralCollateralAdjustment();</span>

<span class="fc" id="L1174">				pathTotalVA[pathIndex] = _pathExposureAdjustmentArray[pathIndex].totalAdjustment();</span>
			}
<span class="nc" id="L1176">			catch (java.lang.Exception e)</span>
			{
<span class="nc" id="L1178">				e.printStackTrace();</span>

<span class="nc" id="L1180">				return null;</span>
<span class="fc" id="L1181">			}</span>

<span class="fc bfc" id="L1183" title="All 2 branches covered.">			for (int vertexIndex = 0; vertexIndex &lt; vertexCount; ++vertexIndex)</span>
			{
<span class="fc" id="L1185">				collateralizedExposure[vertexIndex][pathIndex] =</span>
					pathCollateralizedExposure[vertexIndex];
<span class="fc" id="L1187">				collateralizedExposurePV[vertexIndex][pathIndex] =</span>
					pathCollateralizedExposurePV[vertexIndex];
<span class="fc" id="L1189">				collateralizedPositiveExposure[vertexIndex][pathIndex] =</span>
					pathCollateralizedPositiveExposure[vertexIndex];
<span class="fc" id="L1191">				collateralizedPositiveExposurePV[vertexIndex][pathIndex] =</span>
					pathCollateralizedPositiveExposurePV[vertexIndex];
<span class="fc" id="L1193">				collateralizedNegativeExposure[vertexIndex][pathIndex] =</span>
					pathCollateralizedNegativeExposure[vertexIndex];
<span class="fc" id="L1195">				collateralizedNegativeExposurePV[vertexIndex][pathIndex] =</span>
					pathCollateralizedNegativeExposurePV[vertexIndex];
<span class="fc" id="L1197">				uncollateralizedExposure[vertexIndex][pathIndex] =</span>
					pathUncollateralizedExposure[vertexIndex];
<span class="fc" id="L1199">				uncollateralizedExposurePV[vertexIndex][pathIndex] =</span>
					pathUncollateralizedExposurePV[vertexIndex];
<span class="fc" id="L1201">				uncollateralizedPositiveExposure[vertexIndex][pathIndex] =</span>
					pathUncollateralizedPositiveExposure[vertexIndex];
<span class="fc" id="L1203">				uncollateralizedPositiveExposurePV[vertexIndex][pathIndex] =</span>
					pathUncollateralizedPositiveExposurePV[vertexIndex];
<span class="fc" id="L1205">				uncollateralizedNegativeExposure[vertexIndex][pathIndex] =</span>
					pathUncollateralizedNegativeExposure[vertexIndex];
<span class="fc" id="L1207">				uncollateralizedNegativeExposurePV[vertexIndex][pathIndex] =</span>
					pathUncollateralizedNegativeExposurePV[vertexIndex];
<span class="fc" id="L1209">				fundingExposure[vertexIndex][pathIndex] = pathFundingExposure[vertexIndex];</span>
<span class="fc" id="L1210">				fundingExposurePV[vertexIndex][pathIndex] = pathFundingExposurePV[vertexIndex];</span>
			}
		}

		try
		{
<span class="fc" id="L1216">			return new org.drip.xva.gross.ExposureAdjustmentDigest (</span>
				pathCOLVA,
				pathFTDCOLVA,
				pathUCVA,
				pathFTDCVA,
				pathCVA,
				pathCVACL,
				pathDVA,
				pathFVA,
				pathFDA,
				pathFCA,
				pathFBA,
				pathSFVA,
				pathTotalVA,
				collateralizedExposure,
				collateralizedExposurePV,
				collateralizedPositiveExposure,
				collateralizedPositiveExposurePV,
				collateralizedNegativeExposure,
				collateralizedNegativeExposurePV,
				uncollateralizedExposure,
				uncollateralizedExposurePV,
				uncollateralizedPositiveExposure,
				uncollateralizedPositiveExposurePV,
				uncollateralizedNegativeExposure,
				uncollateralizedNegativeExposurePV,
				fundingExposure,
				fundingExposurePV
			);
		}
<span class="nc" id="L1246">		catch (java.lang.Exception e)</span>
		{
<span class="nc" id="L1248">			e.printStackTrace();</span>
		}

<span class="nc" id="L1251">		return null;</span>
	}

	/**
	 * Generate the Basel Exposure Digest
	 * 
	 * @param standardizedExposureGeneratorScheme The Standardized Basel Exposure Generation Scheme
	 * 
	 * @return The Basel Exposure Digest
	 */

	public org.drip.xva.gross.BaselExposureDigest baselExposureDigest (
		final org.drip.xva.settings.StandardizedExposureGeneratorScheme standardizedExposureGeneratorScheme)
	{
<span class="nc bnc" id="L1265" title="All 2 branches missed.">		if (null == standardizedExposureGeneratorScheme)</span>
		{
<span class="nc" id="L1267">			return null;</span>
		}

<span class="nc" id="L1270">		org.drip.analytics.date.JulianDate[] vertexJulianDateArray = vertexDates();</span>

<span class="nc" id="L1272">		int vertexCount = vertexJulianDateArray.length;</span>
<span class="nc" id="L1273">		int[] vertexDateArray = new int[vertexCount];</span>
<span class="nc" id="L1274">		int pathCount = _pathExposureAdjustmentArray.length;</span>
<span class="nc" id="L1275">		double[] collateralizedPositiveExposure = new double[vertexCount];</span>
<span class="nc" id="L1276">		double[] effectiveCollateralizedPositiveExposure = new double[vertexCount];</span>
<span class="nc" id="L1277">		org.drip.spline.params.SegmentCustomBuilderControl[] collateralizedExposureSegmentBuilderControlArray</span>
			= new org.drip.spline.params.SegmentCustomBuilderControl[vertexCount - 1];
		org.drip.spline.params.SegmentCustomBuilderControl[]
<span class="nc" id="L1280">			collateralizedPositiveExposureSegmentBuilderControlArray = new</span>
				org.drip.spline.params.SegmentCustomBuilderControl[vertexCount - 1];

<span class="nc" id="L1283">		org.drip.spline.params.SegmentCustomBuilderControl collateralizedExposureSegmentBuilderControl =</span>
<span class="nc" id="L1284">			standardizedExposureGeneratorScheme.collateralizedExposureSegmentBuilderControl();</span>

		org.drip.spline.params.SegmentCustomBuilderControl
<span class="nc" id="L1287">			collateralizedPositiveExposureSegmentBuilderControl =</span>
<span class="nc" id="L1288">				standardizedExposureGeneratorScheme.collateralizedPositiveExposureSegmentBuilderControl();</span>

<span class="nc bnc" id="L1290" title="All 2 branches missed.">		for (int i = 0; i &lt; vertexCount - 1; ++i)</span>
		{
<span class="nc" id="L1292">			collateralizedExposureSegmentBuilderControlArray[i] =</span>
				collateralizedExposureSegmentBuilderControl;
<span class="nc" id="L1294">			collateralizedPositiveExposureSegmentBuilderControlArray[i] =</span>
				collateralizedPositiveExposureSegmentBuilderControl;
		}

<span class="nc bnc" id="L1298" title="All 2 branches missed.">		for (int vertexIndex = 0; vertexIndex &lt; vertexCount; ++vertexIndex)</span>
		{
<span class="nc" id="L1300">			collateralizedPositiveExposure[vertexIndex] = 0.;</span>

<span class="nc" id="L1302">			vertexDateArray[vertexIndex] = vertexJulianDateArray[vertexIndex].julian();</span>
		}

<span class="nc bnc" id="L1305" title="All 2 branches missed.">		for (int pathIndex = 0; pathIndex &lt; pathCount; ++pathIndex)</span>
		{
<span class="nc" id="L1307">			double[] pathCollateralizedPositiveExposure =</span>
<span class="nc" id="L1308">				_pathExposureAdjustmentArray[pathIndex].vertexCollateralizedPositiveExposure();</span>

<span class="nc bnc" id="L1310" title="All 2 branches missed.">			for (int vertexIndex = 0; vertexIndex &lt; vertexCount; ++vertexIndex)</span>
			{
<span class="nc" id="L1312">				collateralizedPositiveExposure[vertexIndex] +=</span>
					pathCollateralizedPositiveExposure[vertexIndex];
			}
		}

<span class="nc bnc" id="L1317" title="All 2 branches missed.">		for (int vertexIndex = 0; vertexIndex &lt; vertexCount; ++vertexIndex)</span>
		{
<span class="nc" id="L1319">			collateralizedPositiveExposure[vertexIndex] /= pathCount;</span>

<span class="nc bnc" id="L1321" title="All 2 branches missed.">			if (0 == vertexIndex)</span>
			{
<span class="nc" id="L1323">				effectiveCollateralizedPositiveExposure[0] = collateralizedPositiveExposure[0];</span>
			}
			else
			{
<span class="nc bnc" id="L1327" title="All 2 branches missed.">				effectiveCollateralizedPositiveExposure[vertexIndex] =</span>
					collateralizedPositiveExposure[vertexIndex] &gt;
					effectiveCollateralizedPositiveExposure[vertexIndex - 1] ?
					collateralizedPositiveExposure[vertexIndex] :
					effectiveCollateralizedPositiveExposure[vertexIndex - 1];
			}
		}

		try
		{
<span class="nc" id="L1337">			org.drip.spline.stretch.MultiSegmentSequence multiSegmentSequenceCollateralizedPositiveExposure =</span>
<span class="nc" id="L1338">				org.drip.spline.stretch.MultiSegmentSequenceBuilder.CreateCalibratedStretchEstimator (</span>
					&quot;CollateralizedPositiveExposure&quot;,
					vertexDateArray,
					collateralizedPositiveExposure,
					collateralizedExposureSegmentBuilderControlArray,
					null,
<span class="nc" id="L1344">					org.drip.spline.stretch.BoundarySettings.NaturalStandard(),</span>
					org.drip.spline.stretch.MultiSegmentSequence.CALIBRATE
				);

			org.drip.spline.stretch.MultiSegmentSequence
<span class="nc" id="L1349">				multiSegmentSequenceEffectiveCollateralizedPositiveExposure =</span>
<span class="nc" id="L1350">					org.drip.spline.stretch.MultiSegmentSequenceBuilder.CreateCalibratedStretchEstimator (</span>
						&quot;EffectiveCollateralizedPositiveExposure&quot;,
						vertexDateArray,
						effectiveCollateralizedPositiveExposure,
						collateralizedPositiveExposureSegmentBuilderControlArray,
						null,
<span class="nc" id="L1356">						org.drip.spline.stretch.BoundarySettings.NaturalStandard(),</span>
						org.drip.spline.stretch.MultiSegmentSequence.CALIBRATE
					);

<span class="nc bnc" id="L1360" title="All 4 branches missed.">			if (null == multiSegmentSequenceCollateralizedPositiveExposure ||</span>
				null == multiSegmentSequenceEffectiveCollateralizedPositiveExposure)
			{
<span class="nc" id="L1363">				return null;</span>
			}

<span class="nc" id="L1366">			int exposureGeneratorTimeIntegrand = standardizedExposureGeneratorScheme.timeIntegrand();</span>

<span class="nc" id="L1368">			int integrandFinishDate = vertexDateArray[0] + exposureGeneratorTimeIntegrand;</span>

<span class="nc" id="L1370">			double effectiveExpectedPositiveExposure =</span>
<span class="nc" id="L1371">				multiSegmentSequenceEffectiveCollateralizedPositiveExposure.toAU().integrate (</span>
					vertexDateArray[0],
					integrandFinishDate
				) / exposureGeneratorTimeIntegrand;

<span class="nc" id="L1376">			return new BaselExposureDigest (</span>
				collateralizedPositiveExposure[0],
<span class="nc" id="L1378">				multiSegmentSequenceCollateralizedPositiveExposure.toAU().integrate (</span>
					vertexDateArray[0],
					integrandFinishDate
				) / exposureGeneratorTimeIntegrand,
				effectiveCollateralizedPositiveExposure[vertexCount - 1],
				effectiveExpectedPositiveExposure,
<span class="nc" id="L1384">				effectiveExpectedPositiveExposure * standardizedExposureGeneratorScheme.eadMultiplier()</span>
			);
		}
<span class="nc" id="L1387">		catch (java.lang.Exception e)</span>
		{
<span class="nc" id="L1389">			e.printStackTrace();</span>
		}

<span class="nc" id="L1392">		return null;</span>
	}
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.7.9.201702052155</span></div></body></html>