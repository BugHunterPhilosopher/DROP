<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>ExposureAdjustmentAggregator.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">DROP</a> &gt; <a href="index.source.html" class="el_package">org.drip.xva.gross</a> &gt; <span class="el_source">ExposureAdjustmentAggregator.java</span></div><h1>ExposureAdjustmentAggregator.java</h1><pre class="source lang-java linenums">
package org.drip.xva.gross;

/*
 * -*- mode: java; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*-
 */

/*!
 * Copyright (C) 2019 Lakshmi Krishnamurthy
 * Copyright (C) 2018 Lakshmi Krishnamurthy
 * Copyright (C) 2017 Lakshmi Krishnamurthy
 * 
 *  This file is part of DROP, an open-source library targeting risk, transaction costs, exposure, margin
 *  	calculations, and portfolio construction within and across fixed income, credit, commodity, equity,
 *  	FX, and structured products.
 *  
 *  	https://lakshmidrip.github.io/DROP/
 *  
 *  DROP is composed of three main modules:
 *  
 *  - DROP Analytics Core - https://lakshmidrip.github.io/DROP-Analytics-Core/
 *  - DROP Portfolio Core - https://lakshmidrip.github.io/DROP-Portfolio-Core/
 *  - DROP Numerical Core - https://lakshmidrip.github.io/DROP-Numerical-Core/
 * 
 * 	DROP Analytics Core implements libraries for the following:
 * 	- Fixed Income Analytics
 * 	- Asset Backed Analytics
 * 	- XVA Analytics
 * 	- Exposure and Margin Analytics
 * 
 * 	DROP Portfolio Core implements libraries for the following:
 * 	- Asset Allocation Analytics
 * 	- Transaction Cost Analytics
 * 
 * 	DROP Numerical Core implements libraries for the following:
 * 	- Statistical Learning Library
 * 	- Numerical Optimizer Library
 * 	- Machine Learning Library
 * 	- Spline Builder Library
 * 
 * 	Documentation for DROP is Spread Over:
 * 
 * 	- Main                     =&gt; https://lakshmidrip.github.io/DROP/
 * 	- Wiki                     =&gt; https://github.com/lakshmiDRIP/DROP/wiki
 * 	- GitHub                   =&gt; https://github.com/lakshmiDRIP/DROP
 * 	- Javadoc                  =&gt; https://lakshmidrip.github.io/DROP/Javadoc/index.html
 * 	- Technical Specifications =&gt; https://github.com/lakshmiDRIP/DROP/tree/master/Docs/Internal
 * 	- Release Versions         =&gt; https://lakshmidrip.github.io/DROP/version.html
 * 	- Community Credits        =&gt; https://lakshmidrip.github.io/DROP/credits.html
 * 	- Issues Catalog           =&gt; https://github.com/lakshmiDRIP/DROP/issues
 * 	- JUnit                    =&gt; https://lakshmidrip.github.io/DROP/junit/index.html
 * 	- Jacoco                   =&gt; https://lakshmidrip.github.io/DROP/jacoco/index.html
 * 
 *  Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 *   	you may not use this file except in compliance with the License.
 *   
 *  You may obtain a copy of the License at
 *  	http://www.apache.org/licenses/LICENSE-2.0
 *  
 *  Unless required by applicable law or agreed to in writing, software
 *  	distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 *  	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  
 *  See the License for the specific language governing permissions and
 *  	limitations under the License.
 */

/**
 * &lt;i&gt;ExposureAdjustmentAggregator&lt;/i&gt; aggregates across Multiple Exposure/Adjustment Paths belonging to the
 * Counter Party. The References are:
 *
 *  &lt;br&gt;&lt;br&gt;
 *  &lt;ul&gt;
 *  	&lt;li&gt;
 *  		Burgard, C., and M. Kjaer (2014): PDE Representations of Derivatives with Bilateral Counter-party
 *  			Risk and Funding Costs &lt;i&gt;Journal of Credit Risk&lt;/i&gt; &lt;b&gt;7 (3)&lt;/b&gt; 1-19
 *  	&lt;/li&gt;
 *  	&lt;li&gt;
 *  		Burgard, C., and M. Kjaer (2014): In the Balance &lt;i&gt;Risk&lt;/i&gt; &lt;b&gt;24 (11)&lt;/b&gt; 72-75
 *  	&lt;/li&gt;
 *  	&lt;li&gt;
 *  		Gregory, J. (2009): Being Two-faced over Counter-party Credit Risk &lt;i&gt;Risk&lt;/i&gt; &lt;b&gt;20 (2)&lt;/b&gt;
 *  			86-90
 *  	&lt;/li&gt;
 *  	&lt;li&gt;
 *  		Li, B., and Y. Tang (2007): &lt;i&gt;Quantitative Analysis, Derivatives Modeling, and Trading
 *  			Strategies in the Presence of Counter-party Credit Risk for the Fixed Income Market&lt;/i&gt;
 *  			&lt;b&gt;World Scientific Publishing&lt;/b&gt; Singapore
 *  	&lt;/li&gt;
 *  	&lt;li&gt;
 *  		Piterbarg, V. (2010): Funding Beyond Discounting: Collateral Agreements and Derivatives Pricing
 *  			&lt;i&gt;Risk&lt;/i&gt; &lt;b&gt;21 (2)&lt;/b&gt; 97-102
 *  	&lt;/li&gt;
 *  &lt;/ul&gt;
 *
 *  &lt;br&gt;&lt;br&gt;
 *  &lt;ul&gt;
 *		&lt;li&gt;&lt;b&gt;Module &lt;/b&gt; = &lt;a href = &quot;https://github.com/lakshmiDRIP/DROP/tree/master/AnalyticsCore.md&quot;&gt;Analytics Core Module&lt;/a&gt;&lt;/li&gt;
 *		&lt;li&gt;&lt;b&gt;Library&lt;/b&gt; = &lt;a href = &quot;https://github.com/lakshmiDRIP/DROP/tree/master/XVAAnalyticsLibrary.md&quot;&gt;XVA Analytics Library&lt;/a&gt;&lt;/li&gt;
 *		&lt;li&gt;&lt;b&gt;Project&lt;/b&gt; = &lt;a href = &quot;https://github.com/lakshmiDRIP/DROP/tree/master/src/main/java/org/drip/xva&quot;&gt;XVA&lt;/a&gt;&lt;/li&gt;
 *		&lt;li&gt;&lt;b&gt;Package&lt;/b&gt; = &lt;a href = &quot;https://github.com/lakshmiDRIP/DROP/tree/master/src/main/java/org/drip/xva/gross&quot;&gt;Gross&lt;/a&gt;&lt;/li&gt;
 *  &lt;/ul&gt;
 * &lt;br&gt;&lt;br&gt;
 * 
 * @author Lakshmi Krishnamurthy
 */

public class ExposureAdjustmentAggregator
{
<span class="fc" id="L110">	private org.drip.xva.gross.PathExposureAdjustment[] _pathExposureAdjustmentArray = null;</span>

	/**
	 * ExposureAdjustmentAggregator Constructor
	 * 
	 * @param pathExposureAdjustmentArray Array of the Counter Party Group Paths
	 * 
	 * @throws java.lang.Exception Thrown if the Inputs are Invalid
	 */

	public ExposureAdjustmentAggregator (
		final org.drip.xva.gross.PathExposureAdjustment[] pathExposureAdjustmentArray)
		throws java.lang.Exception
<span class="fc" id="L123">	{</span>
<span class="pc bpc" id="L124" title="2 of 4 branches missed.">		if (null == (_pathExposureAdjustmentArray = pathExposureAdjustmentArray) ||</span>
			0 == _pathExposureAdjustmentArray.length)
		{
<span class="nc" id="L127">			throw new java.lang.Exception (&quot;ExposureAdjustmentAggregator Constructor =&gt; Invalid Inputs&quot;);</span>
		}
<span class="fc" id="L129">	}</span>

	/**
	 * Retrieve the Array of Group Path Exposure Adjustments
	 * 
	 * @return Array of Group Path Exposure Adjustments
	 */

	public org.drip.xva.gross.PathExposureAdjustment[] pathExposureAdjustmentArray()
	{
<span class="nc" id="L139">		return _pathExposureAdjustmentArray;</span>
	}

	/**
	 * Retrieve the Array of the Vertex Anchor Dates
	 * 
	 * @return The Array of the Vertex Anchor Dates
	 */

	public org.drip.analytics.date.JulianDate[] vertexDates()
	{
<span class="fc" id="L150">		return _pathExposureAdjustmentArray[0].vertexDates();</span>
	}

	/**
	 * Retrieve the Array of Collateralized Exposures
	 * 
	 * @return The Array of Collateralized Exposures
	 */

	public double[] collateralizedExposure()
	{
<span class="fc" id="L161">		int vertexCount = vertexDates().length;</span>

<span class="fc" id="L163">		int pathCount = _pathExposureAdjustmentArray.length;</span>
<span class="fc" id="L164">		double[] collateralizedExposure = new double[vertexCount];</span>

<span class="fc bfc" id="L166" title="All 2 branches covered.">		for (int vertexIndex = 0; vertexIndex &lt; vertexCount; ++vertexIndex)</span>
		{
<span class="fc" id="L168">			collateralizedExposure[vertexIndex] = 0.;</span>
		}

<span class="fc bfc" id="L171" title="All 2 branches covered.">		for (int pathIndex = 0; pathIndex &lt; pathCount; ++pathIndex)</span>
		{
<span class="fc" id="L173">			double[] pathCollateralizedExposure =</span>
<span class="fc" id="L174">				_pathExposureAdjustmentArray[pathIndex].vertexCollateralizedExposure();</span>

<span class="fc bfc" id="L176" title="All 2 branches covered.">			for (int vertexIndex = 0; vertexIndex &lt; vertexCount; ++vertexIndex)</span>
			{
<span class="fc" id="L178">				collateralizedExposure[vertexIndex] += pathCollateralizedExposure[vertexIndex];</span>
			}
		}

<span class="fc bfc" id="L182" title="All 2 branches covered.">		for (int vertexIndex = 0; vertexIndex &lt; vertexCount; ++vertexIndex)</span>
		{
<span class="fc" id="L184">			collateralizedExposure[vertexIndex] /= pathCount;</span>
		}

<span class="fc" id="L187">		return collateralizedExposure;</span>
	}

	/**
	 * Retrieve the Array of Collateralized Exposure PV's
	 * 
	 * @return The Array of Collateralized Exposure PV's
	 */

	public double[] collateralizedExposurePV()
	{
<span class="fc" id="L198">		int vertexCount = vertexDates().length;</span>

<span class="fc" id="L200">		int pathCount = _pathExposureAdjustmentArray.length;</span>
<span class="fc" id="L201">		double[] collateralizedExposurePV = new double[vertexCount];</span>

<span class="fc bfc" id="L203" title="All 2 branches covered.">		for (int vertexIndex = 0; vertexIndex &lt; vertexCount; ++vertexIndex)</span>
		{
<span class="fc" id="L205">			collateralizedExposurePV[vertexIndex] = 0.;</span>
		}

<span class="fc bfc" id="L208" title="All 2 branches covered.">		for (int pathIndex = 0; pathIndex &lt; pathCount; ++pathIndex)</span>
		{
<span class="fc" id="L210">			double[] pathCollateralizedExposurePV =</span>
<span class="fc" id="L211">				_pathExposureAdjustmentArray[pathIndex].vertexCollateralizedExposurePV();</span>

<span class="fc bfc" id="L213" title="All 2 branches covered.">			for (int vertexIndex = 0; vertexIndex &lt; vertexCount; ++vertexIndex)</span>
			{
<span class="fc" id="L215">				collateralizedExposurePV[vertexIndex] += pathCollateralizedExposurePV[vertexIndex];</span>
			}
		}

<span class="fc bfc" id="L219" title="All 2 branches covered.">		for (int vertexIndex = 0; vertexIndex &lt; vertexCount; ++vertexIndex)</span>
		{
<span class="fc" id="L221">			collateralizedExposurePV[vertexIndex] /= pathCount;</span>
		}

<span class="fc" id="L224">		return collateralizedExposurePV;</span>
	}

	/**
	 * Retrieve the Array of Uncollateralized Exposures
	 * 
	 * @return The Array of Uncollateralized Exposures
	 */

	public double[] uncollateralizedExposure()
	{
<span class="nc" id="L235">		int vertexCount = vertexDates().length;</span>

<span class="nc" id="L237">		int pathCount = _pathExposureAdjustmentArray.length;</span>
<span class="nc" id="L238">		double[] uncollateralizedExposure = new double[vertexCount];</span>

<span class="nc bnc" id="L240" title="All 2 branches missed.">		for (int vertexIndex = 0; vertexIndex &lt; vertexCount; ++vertexIndex)</span>
		{
<span class="nc" id="L242">			uncollateralizedExposure[vertexIndex] = 0.;</span>
		}

<span class="nc bnc" id="L245" title="All 2 branches missed.">		for (int pathIndex = 0; pathIndex &lt; pathCount; ++pathIndex)</span>
		{
<span class="nc" id="L247">			double[] pathUncollateralizedExposure =</span>
<span class="nc" id="L248">				_pathExposureAdjustmentArray[pathIndex].vertexUncollateralizedExposure();</span>

<span class="nc bnc" id="L250" title="All 2 branches missed.">			for (int vertexIndex = 0; vertexIndex &lt; vertexCount; ++vertexIndex)</span>
			{
<span class="nc" id="L252">				uncollateralizedExposure[vertexIndex] += pathUncollateralizedExposure[vertexIndex];</span>
			}
		}

<span class="nc bnc" id="L256" title="All 2 branches missed.">		for (int vertexIndex = 0; vertexIndex &lt; vertexCount; ++vertexIndex)</span>
<span class="nc" id="L257">			uncollateralizedExposure[vertexIndex] /= pathCount;</span>

<span class="nc" id="L259">		return uncollateralizedExposure;</span>
	}

	/**
	 * Retrieve the Array of Uncollateralized Exposure PV's
	 * 
	 * @return The Array of Uncollateralized Exposure PV's
	 */

	public double[] uncollateralizedExposurePV()
	{
<span class="nc" id="L270">		int vertexCount = vertexDates().length;</span>

<span class="nc" id="L272">		int pathCount = _pathExposureAdjustmentArray.length;</span>
<span class="nc" id="L273">		double[] uncollateralizedExposurePV = new double[vertexCount];</span>

<span class="nc bnc" id="L275" title="All 2 branches missed.">		for (int vertexIndex = 0; vertexIndex &lt; vertexCount; ++vertexIndex)</span>
		{
<span class="nc" id="L277">			uncollateralizedExposurePV[vertexIndex] = 0.;</span>
		}

<span class="nc bnc" id="L280" title="All 2 branches missed.">		for (int pathIndex = 0; pathIndex &lt; pathCount; ++pathIndex)</span>
		{
<span class="nc" id="L282">			double[] pathUncollateralizedExposurePV =</span>
<span class="nc" id="L283">				_pathExposureAdjustmentArray[pathIndex].vertexUncollateralizedExposurePV();</span>

<span class="nc bnc" id="L285" title="All 2 branches missed.">			for (int vertexIndex = 0; vertexIndex &lt; vertexCount; ++vertexIndex)</span>
			{
<span class="nc" id="L287">				uncollateralizedExposurePV[vertexIndex] +=</span>
					pathUncollateralizedExposurePV[vertexIndex];
			}
		}

<span class="nc bnc" id="L292" title="All 2 branches missed.">		for (int vertexIndex = 0; vertexIndex &lt; vertexCount; ++vertexIndex)</span>
		{
<span class="nc" id="L294">			uncollateralizedExposurePV[vertexIndex] /= pathCount;</span>
		}

<span class="nc" id="L297">		return uncollateralizedExposurePV;</span>
	}

	/**
	 * Retrieve the Array of Collateralized Positive Exposures
	 * 
	 * @return The Array of Collateralized Positive Exposures
	 */

	public double[] collateralizedPositiveExposure()
	{
<span class="fc" id="L308">		int vertexCount = vertexDates().length;</span>

<span class="fc" id="L310">		int pathCount = _pathExposureAdjustmentArray.length;</span>
<span class="fc" id="L311">		double[] collateralizedPositiveExposure = new double[vertexCount];</span>

<span class="fc bfc" id="L313" title="All 2 branches covered.">		for (int vertexIndex = 0; vertexIndex &lt; vertexCount; ++vertexIndex)</span>
		{
<span class="fc" id="L315">			collateralizedPositiveExposure[vertexIndex] = 0.;</span>
		}

<span class="fc bfc" id="L318" title="All 2 branches covered.">		for (int pathIndex = 0; pathIndex &lt; pathCount; ++pathIndex)</span>
		{
<span class="fc" id="L320">			double[] pathCollateralizedPositiveExposure =</span>
<span class="fc" id="L321">				_pathExposureAdjustmentArray[pathIndex].vertexCollateralizedPositiveExposure();</span>

<span class="fc bfc" id="L323" title="All 2 branches covered.">			for (int vertexIndex = 0; vertexIndex &lt; vertexCount; ++vertexIndex)</span>
			{
<span class="fc" id="L325">				collateralizedPositiveExposure[vertexIndex] +=</span>
					pathCollateralizedPositiveExposure[vertexIndex];
			}
		}

<span class="fc bfc" id="L330" title="All 2 branches covered.">		for (int vertexIndex = 0; vertexIndex &lt; vertexCount; ++vertexIndex)</span>
		{
<span class="fc" id="L332">			collateralizedPositiveExposure[vertexIndex] /= pathCount;</span>
		}

<span class="fc" id="L335">		return collateralizedPositiveExposure;</span>
	}

	/**
	 * Retrieve the Array of Collateralized Positive Exposure PV
	 * 
	 * @return The Array of Collateralized Positive Exposure PV
	 */

	public double[] collateralizedPositiveExposurePV()
	{
<span class="fc" id="L346">		int vertexCount = vertexDates().length;</span>

<span class="fc" id="L348">		int pathCount = _pathExposureAdjustmentArray.length;</span>
<span class="fc" id="L349">		double[] collateralizedPositiveExposurePV = new double[vertexCount];</span>

<span class="fc bfc" id="L351" title="All 2 branches covered.">		for (int vertexIndex = 0; vertexIndex &lt; vertexCount; ++vertexIndex)</span>
		{
<span class="fc" id="L353">			collateralizedPositiveExposurePV[vertexIndex] = 0.;</span>
		}

<span class="fc bfc" id="L356" title="All 2 branches covered.">		for (int pathIndex = 0; pathIndex &lt; pathCount; ++pathIndex)</span>
		{
<span class="fc" id="L358">			double[] pathCollateralizedPositiveExposurePV =</span>
<span class="fc" id="L359">				_pathExposureAdjustmentArray[pathIndex].vertexCollateralizedPositiveExposurePV();</span>

<span class="fc bfc" id="L361" title="All 2 branches covered.">			for (int vertexIndex = 0; vertexIndex &lt; vertexCount; ++vertexIndex)</span>
			{
<span class="fc" id="L363">				collateralizedPositiveExposurePV[vertexIndex] +=</span>
					pathCollateralizedPositiveExposurePV[vertexIndex];
			}
		}

<span class="fc bfc" id="L368" title="All 2 branches covered.">		for (int vertexIndex = 0; vertexIndex &lt; vertexCount; ++vertexIndex)</span>
		{
<span class="fc" id="L370">			collateralizedPositiveExposurePV[vertexIndex] /= pathCount;</span>
		}

<span class="fc" id="L373">		return collateralizedPositiveExposurePV;</span>
	}

	/**
	 * Retrieve the Array of Uncollateralized Positive Exposures
	 * 
	 * @return The Array of Uncollateralized Positive Exposures
	 */

	public double[] uncollateralizedPositiveExposure()
	{
<span class="nc" id="L384">		int vertexCount = vertexDates().length;</span>

<span class="nc" id="L386">		int pathCount = _pathExposureAdjustmentArray.length;</span>
<span class="nc" id="L387">		double[] uncollateralizedPositiveExposure = new double[vertexCount];</span>

<span class="nc bnc" id="L389" title="All 2 branches missed.">		for (int vertexIndex = 0; vertexIndex &lt; vertexCount; ++vertexIndex)</span>
		{
<span class="nc" id="L391">			uncollateralizedPositiveExposure[vertexIndex] = 0.;</span>
		}

<span class="nc bnc" id="L394" title="All 2 branches missed.">		for (int pathIndex = 0; pathIndex &lt; pathCount; ++pathIndex)</span>
		{
<span class="nc" id="L396">			double[] pathUncollateralizedPositiveExposure =</span>
<span class="nc" id="L397">				_pathExposureAdjustmentArray[pathIndex].vertexUncollateralizedPositiveExposure();</span>

<span class="nc bnc" id="L399" title="All 2 branches missed.">			for (int vertexIndex = 0; vertexIndex &lt; vertexCount; ++vertexIndex)</span>
			{
<span class="nc" id="L401">				uncollateralizedPositiveExposure[vertexIndex] +=</span>
					pathUncollateralizedPositiveExposure[vertexIndex];
			}
		}

<span class="nc bnc" id="L406" title="All 2 branches missed.">		for (int vertexIndex = 0; vertexIndex &lt; vertexCount; ++vertexIndex)</span>
		{
<span class="nc" id="L408">			uncollateralizedPositiveExposure[vertexIndex] /= pathCount;</span>
		}

<span class="nc" id="L411">		return uncollateralizedPositiveExposure;</span>
	}

	/**
	 * Retrieve the Array of Uncollateralized Positive Exposure PV
	 * 
	 * @return The Array of Uncollateralized Positive Exposure PV
	 */

	public double[] uncollateralizedPositiveExposurePV()
	{
<span class="nc" id="L422">		int vertexCount = vertexDates().length;</span>

<span class="nc" id="L424">		int pathCount = _pathExposureAdjustmentArray.length;</span>
<span class="nc" id="L425">		double[] uncollateralizedPositiveExposurePV = new double[vertexCount];</span>

<span class="nc bnc" id="L427" title="All 2 branches missed.">		for (int vertexIndex = 0; vertexIndex &lt; vertexCount; ++vertexIndex)</span>
		{
<span class="nc" id="L429">			uncollateralizedPositiveExposurePV[vertexIndex] = 0.;</span>
		}

<span class="nc bnc" id="L432" title="All 2 branches missed.">		for (int pathIndex = 0; pathIndex &lt; pathCount; ++pathIndex)</span>
		{
<span class="nc" id="L434">			double[] pathUncollateralizedPositiveExposurePV =</span>
<span class="nc" id="L435">				_pathExposureAdjustmentArray[pathIndex].vertexUncollateralizedPositiveExposurePV();</span>

<span class="nc bnc" id="L437" title="All 2 branches missed.">			for (int vertexIndex = 0; vertexIndex &lt; vertexCount; ++vertexIndex)</span>
			{
<span class="nc" id="L439">				uncollateralizedPositiveExposurePV[vertexIndex] +=</span>
					pathUncollateralizedPositiveExposurePV[vertexIndex];
			}
		}

<span class="nc bnc" id="L444" title="All 2 branches missed.">		for (int vertexIndex = 0; vertexIndex &lt; vertexCount; ++vertexIndex)</span>
		{
<span class="nc" id="L446">			uncollateralizedPositiveExposurePV[vertexIndex] /= pathCount;</span>
		}

<span class="nc" id="L449">		return uncollateralizedPositiveExposurePV;</span>
	}

	/**
	 * Retrieve the Array of Collateralized Negative Exposures
	 * 
	 * @return The Array of Collateralized Negative Exposures
	 */

	public double[] collateralizedNegativeExposure()
	{
<span class="fc" id="L460">		int vertexCount = vertexDates().length;</span>

<span class="fc" id="L462">		int pathCount = _pathExposureAdjustmentArray.length;</span>
<span class="fc" id="L463">		double[] collateralizedNegativeExposure = new double[vertexCount];</span>

<span class="fc bfc" id="L465" title="All 2 branches covered.">		for (int vertexIndex = 0; vertexIndex &lt; vertexCount; ++vertexIndex)</span>
		{
<span class="fc" id="L467">			collateralizedNegativeExposure[vertexIndex] = 0.;</span>
		}

<span class="fc bfc" id="L470" title="All 2 branches covered.">		for (int pathIndex = 0; pathIndex &lt; pathCount; ++pathIndex)</span>
		{
<span class="fc" id="L472">			double[] pathCollateralizedNegativeExposure =</span>
<span class="fc" id="L473">				_pathExposureAdjustmentArray[pathIndex].vertexCollateralizedNegativeExposure();</span>

<span class="fc bfc" id="L475" title="All 2 branches covered.">			for (int vertexIndex = 0; vertexIndex &lt; vertexCount; ++vertexIndex)</span>
			{
<span class="fc" id="L477">				collateralizedNegativeExposure[vertexIndex] +=</span>
					pathCollateralizedNegativeExposure[vertexIndex];
			}
		}

<span class="fc bfc" id="L482" title="All 2 branches covered.">		for (int vertexIndex = 0; vertexIndex &lt; vertexCount; ++vertexIndex)</span>
		{
<span class="fc" id="L484">			collateralizedNegativeExposure[vertexIndex] /= pathCount;</span>
		}

<span class="fc" id="L487">		return collateralizedNegativeExposure;</span>
	}

	/**
	 * Retrieve the Array of Collateralized Negative Exposure PV
	 * 
	 * @return The Array of Collateralized Negative Exposure PV
	 */

	public double[] collateralizedNegativeExposurePV()
	{
<span class="fc" id="L498">		int vertexCount = vertexDates().length;</span>

<span class="fc" id="L500">		int pathCount = _pathExposureAdjustmentArray.length;</span>
<span class="fc" id="L501">		double[] collateralizedNegativeExposurePV = new double[vertexCount];</span>

<span class="fc bfc" id="L503" title="All 2 branches covered.">		for (int vertexIndex = 0; vertexIndex &lt; vertexCount; ++vertexIndex)</span>
		{
<span class="fc" id="L505">			collateralizedNegativeExposurePV[vertexIndex] = 0.;</span>
		}

<span class="fc bfc" id="L508" title="All 2 branches covered.">		for (int pathIndex = 0; pathIndex &lt; pathCount; ++pathIndex)</span>
		{
<span class="fc" id="L510">			double[] pathCollateralizedNegativeExposurePV =</span>
<span class="fc" id="L511">				_pathExposureAdjustmentArray[pathIndex].vertexCollateralizedNegativeExposurePV();</span>

<span class="fc bfc" id="L513" title="All 2 branches covered.">			for (int vertexIndex = 0; vertexIndex &lt; vertexCount; ++vertexIndex)</span>
			{
<span class="fc" id="L515">				collateralizedNegativeExposurePV[vertexIndex] +=</span>
					pathCollateralizedNegativeExposurePV[vertexIndex];
			}
		}

<span class="fc bfc" id="L520" title="All 2 branches covered.">		for (int vertexIndex = 0; vertexIndex &lt; vertexCount; ++vertexIndex)</span>
		{
<span class="fc" id="L522">			collateralizedNegativeExposurePV[vertexIndex] /= pathCount;</span>
		}

<span class="fc" id="L525">		return collateralizedNegativeExposurePV;</span>
	}

	/**
	 * Retrieve the Array of Uncollateralized Negative Exposures
	 * 
	 * @return The Array of Uncollateralized Negative Exposures
	 */

	public double[] uncollateralizedNegativeExposure()
	{
<span class="nc" id="L536">		int vertexCount = vertexDates().length;</span>

<span class="nc" id="L538">		int pathCount = _pathExposureAdjustmentArray.length;</span>
<span class="nc" id="L539">		double[] uncollateralizedNegativeExposure = new double[vertexCount];</span>

<span class="nc bnc" id="L541" title="All 2 branches missed.">		for (int vertexIndex = 0; vertexIndex &lt; vertexCount; ++vertexIndex)</span>
		{
<span class="nc" id="L543">			uncollateralizedNegativeExposure[vertexIndex] = 0.;</span>
		}

<span class="nc bnc" id="L546" title="All 2 branches missed.">		for (int pathIndex = 0; pathIndex &lt; pathCount; ++pathIndex)</span>
		{
<span class="nc" id="L548">			double[] pathUncollateralizedNegativeExposure =</span>
<span class="nc" id="L549">				_pathExposureAdjustmentArray[pathIndex].vertexUncollateralizedNegativeExposure();</span>

<span class="nc bnc" id="L551" title="All 2 branches missed.">			for (int vertexIndex = 0; vertexIndex &lt; vertexCount; ++vertexIndex)</span>
			{
<span class="nc" id="L553">				uncollateralizedNegativeExposure[vertexIndex] +=</span>
					pathUncollateralizedNegativeExposure[vertexIndex];
			}
		}

<span class="nc bnc" id="L558" title="All 2 branches missed.">		for (int vertexIndex = 0; vertexIndex &lt; vertexCount; ++vertexIndex)</span>
		{
<span class="nc" id="L560">			uncollateralizedNegativeExposure[vertexIndex] /= pathCount;</span>
		}

<span class="nc" id="L563">		return uncollateralizedNegativeExposure;</span>
	}

	/**
	 * Retrieve the Array of Uncollateralized Negative Exposure PV
	 * 
	 * @return The Array of Uncollateralized Negative Exposure PV
	 */

	public double[] uncollateralizedNegativeExposurePV()
	{
<span class="nc" id="L574">		int vertexCount = vertexDates().length;</span>

<span class="nc" id="L576">		int pathCount = _pathExposureAdjustmentArray.length;</span>
<span class="nc" id="L577">		double[] uncollateralizedNegativeExposurePV = new double[vertexCount];</span>

<span class="nc bnc" id="L579" title="All 2 branches missed.">		for (int vertexIndex = 0; vertexIndex &lt; vertexCount; ++vertexIndex)</span>
		{
<span class="nc" id="L581">			uncollateralizedNegativeExposurePV[vertexIndex] = 0.;</span>
		}

<span class="nc bnc" id="L584" title="All 2 branches missed.">		for (int pathIndex = 0; pathIndex &lt; pathCount; ++pathIndex)</span>
		{
<span class="nc" id="L586">			double[] pathUncollateralizedNegativeExposurePV =</span>
<span class="nc" id="L587">				_pathExposureAdjustmentArray[pathIndex].vertexUncollateralizedNegativeExposurePV();</span>

<span class="nc bnc" id="L589" title="All 2 branches missed.">			for (int vertexIndex = 0; vertexIndex &lt; vertexCount; ++vertexIndex)</span>
			{
<span class="nc" id="L591">				uncollateralizedNegativeExposurePV[vertexIndex] +=</span>
					pathUncollateralizedNegativeExposurePV[vertexIndex];
			}
		}

<span class="nc bnc" id="L596" title="All 2 branches missed.">		for (int vertexIndex = 0; vertexIndex &lt; vertexCount; ++vertexIndex)</span>
		{
<span class="nc" id="L598">			uncollateralizedNegativeExposurePV[vertexIndex] /= pathCount;</span>
		}

<span class="nc" id="L601">		return uncollateralizedNegativeExposurePV;</span>
	}

	/**
	 * Retrieve the Array of Funding Exposures
	 * 
	 * @return The Array of Funding Exposures
	 */

	public double[] fundingExposure()
	{
<span class="nc" id="L612">		int vertexCount = vertexDates().length;</span>

<span class="nc" id="L614">		double[] fundingExposure = new double[vertexCount];</span>
<span class="nc" id="L615">		int pathCount = _pathExposureAdjustmentArray.length;</span>

<span class="nc bnc" id="L617" title="All 2 branches missed.">		for (int vertexIndex = 0; vertexIndex &lt; vertexCount; ++vertexIndex)</span>
		{
<span class="nc" id="L619">			fundingExposure[vertexIndex] = 0.;</span>
		}

<span class="nc bnc" id="L622" title="All 2 branches missed.">		for (int pathIndex = 0; pathIndex &lt; pathCount; ++pathIndex)</span>
		{
<span class="nc" id="L624">			double[] pathFundingExposure = _pathExposureAdjustmentArray[pathIndex].vertexFundingExposure();</span>

<span class="nc bnc" id="L626" title="All 2 branches missed.">			for (int vertexIndex = 0; vertexIndex &lt; vertexCount; ++vertexIndex)</span>
			{
<span class="nc" id="L628">				fundingExposure[vertexIndex] += pathFundingExposure[vertexIndex];</span>
			}
		}

<span class="nc bnc" id="L632" title="All 2 branches missed.">		for (int vertexIndex = 0; vertexIndex &lt; vertexCount; ++vertexIndex)</span>
		{
<span class="nc" id="L634">			fundingExposure[vertexIndex] /= pathCount;</span>
		}

<span class="nc" id="L637">		return fundingExposure;</span>
	}

	/**
	 * Retrieve the Array of Funding Exposure PV
	 * 
	 * @return The Array of Funding Exposure PV
	 */

	public double[] fundingExposurePV()
	{
<span class="nc" id="L648">		int vertexCount = vertexDates().length;</span>

<span class="nc" id="L650">		int pathCount = _pathExposureAdjustmentArray.length;</span>
<span class="nc" id="L651">		double[] fundingExposurePV = new double[vertexCount];</span>

<span class="nc bnc" id="L653" title="All 2 branches missed.">		for (int vertexIndex = 0; vertexIndex &lt; vertexCount; ++vertexIndex)</span>
		{
<span class="nc" id="L655">			fundingExposurePV[vertexIndex] = 0.;</span>
		}

<span class="nc bnc" id="L658" title="All 2 branches missed.">		for (int pathIndex = 0; pathIndex &lt; pathCount; ++pathIndex)</span>
		{
<span class="nc" id="L660">			double[] pathFundingExposurePV =</span>
<span class="nc" id="L661">				_pathExposureAdjustmentArray[pathIndex].vertexFundingExposurePV();</span>

<span class="nc bnc" id="L663" title="All 2 branches missed.">			for (int vertexIndex = 0; vertexIndex &lt; vertexCount; ++vertexIndex)</span>
			{
<span class="nc" id="L665">				fundingExposurePV[vertexIndex] += pathFundingExposurePV[vertexIndex];</span>
			}
		}

<span class="nc bnc" id="L669" title="All 2 branches missed.">		for (int vertexIndex = 0; vertexIndex &lt; vertexCount; ++vertexIndex)</span>
		{
<span class="nc" id="L671">			fundingExposurePV[vertexIndex] /= pathCount;</span>
		}

<span class="nc" id="L674">		return fundingExposurePV;</span>
	}

	/**
	 * Retrieve the Expected Bilateral Collateral VA
	 * 
	 * @return The Expected Bilateral Collateral VA
	 */

	public org.drip.xva.basel.ValueAdjustment ftdcolva()
	{
<span class="nc" id="L685">		double ftdcolva = 0.;</span>
<span class="nc" id="L686">		int pathCount = _pathExposureAdjustmentArray.length;</span>

		try
		{
<span class="nc bnc" id="L690" title="All 2 branches missed.">			for (int pathIndex = 0; pathIndex &lt; pathCount; ++pathIndex)</span>
			{
<span class="nc" id="L692">				ftdcolva += _pathExposureAdjustmentArray[pathIndex].bilateralCollateralAdjustment();</span>
			}
		}
<span class="nc" id="L695">		catch (java.lang.Exception e)</span>
		{
<span class="nc" id="L697">			e.printStackTrace();</span>

<span class="nc" id="L699">			return null;</span>
<span class="nc" id="L700">		}</span>

<span class="nc" id="L702">		return org.drip.xva.basel.ValueAdjustment.COLVA (ftdcolva / pathCount);</span>
	}

	/**
	 * Retrieve the Expected Collateral VA
	 * 
	 * @return The Expected Collateral VA
	 */

	public org.drip.xva.basel.ValueAdjustment colva()
	{
<span class="fc" id="L713">		double colva = 0.;</span>
<span class="fc" id="L714">		int pathCount = _pathExposureAdjustmentArray.length;</span>

		try
		{
<span class="fc bfc" id="L718" title="All 2 branches covered.">			for (int pathIndex = 0; pathIndex &lt; pathCount; ++pathIndex)</span>
			{
<span class="fc" id="L720">				colva += _pathExposureAdjustmentArray[pathIndex].bilateralCollateralAdjustment();</span>
			}
		}
<span class="nc" id="L723">		catch (java.lang.Exception e)</span>
		{
<span class="nc" id="L725">			e.printStackTrace();</span>

<span class="nc" id="L727">			return null;</span>
<span class="fc" id="L728">		}</span>

<span class="fc" id="L730">		return org.drip.xva.basel.ValueAdjustment.COLVA (colva / pathCount);</span>
	}

	/**
	 * Retrieve the Expected Unilateral CVA
	 * 
	 * @return The Expected Unilateral CVA
	 */

	public org.drip.xva.basel.ValueAdjustment ucva()
	{
<span class="fc" id="L741">		double ucva = 0.;</span>
<span class="fc" id="L742">		int pathCount = _pathExposureAdjustmentArray.length;</span>

		try
		{
<span class="fc bfc" id="L746" title="All 2 branches covered.">			for (int pathIndex = 0; pathIndex &lt; pathCount; ++pathIndex)</span>
			{
<span class="fc" id="L748">				ucva += _pathExposureAdjustmentArray[pathIndex].unilateralCreditAdjustment();</span>
			}
		}
<span class="nc" id="L751">		catch (java.lang.Exception e)</span>
		{
<span class="nc" id="L753">			e.printStackTrace();</span>

<span class="nc" id="L755">			return null;</span>
<span class="fc" id="L756">		}</span>

<span class="fc" id="L758">		return org.drip.xva.basel.ValueAdjustment.UCVA (ucva / pathCount);</span>
	}

	/**
	 * Retrieve the Expected Bilateral/FTD CVA
	 * 
	 * @return The Expected Bilateral/FTD CVA
	 */

	public org.drip.xva.basel.ValueAdjustment ftdcva()
	{
<span class="fc" id="L769">		double ftdcva = 0.;</span>
<span class="fc" id="L770">		int pathCount = _pathExposureAdjustmentArray.length;</span>

		try
		{
<span class="fc bfc" id="L774" title="All 2 branches covered.">			for (int pathIndex = 0; pathIndex &lt; pathCount; ++pathIndex)</span>
			{
<span class="fc" id="L776">				ftdcva += _pathExposureAdjustmentArray[pathIndex].bilateralCreditAdjustment();</span>
			}
		}
<span class="nc" id="L779">		catch (java.lang.Exception e)</span>
		{
<span class="nc" id="L781">			e.printStackTrace();</span>

<span class="nc" id="L783">			return null;</span>
<span class="fc" id="L784">		}</span>

<span class="fc" id="L786">		return org.drip.xva.basel.ValueAdjustment.FTDCVA (ftdcva / pathCount);</span>
	}

	/**
	 * Retrieve the Expected CVA
	 * 
	 * @return The Expected CVA
	 */

	public org.drip.xva.basel.ValueAdjustment cva()
	{
<span class="fc" id="L797">		return ftdcva();</span>
	}

	/**
	 * Retrieve the Expected CVA Contra-Liability
	 * 
	 * @return The Expected CVA Contra-Liability
	 */

	public org.drip.xva.basel.ValueAdjustment cvacl()
	{
<span class="fc" id="L808">		double cvacl = 0.;</span>
<span class="fc" id="L809">		int pathCount = _pathExposureAdjustmentArray.length;</span>

		try
		{
<span class="fc bfc" id="L813" title="All 2 branches covered.">			for (int pathIndex = 0; pathIndex &lt; pathCount; ++pathIndex)</span>
			{
<span class="fc" id="L815">				cvacl += _pathExposureAdjustmentArray[pathIndex].contraLiabilityCreditAdjustment();</span>
			}
		}
<span class="nc" id="L818">		catch (java.lang.Exception e)</span>
		{
<span class="nc" id="L820">			e.printStackTrace();</span>

<span class="nc" id="L822">			return null;</span>
<span class="fc" id="L823">		}</span>

<span class="fc" id="L825">		return org.drip.xva.basel.ValueAdjustment.CVACL (cvacl / pathCount);</span>
	}

	/**
	 * Retrieve the Expected Unilateral DVA
	 * 
	 * @return The Expected Unilateral DVA
	 */

	public org.drip.xva.basel.ValueAdjustment udva()
	{
<span class="nc" id="L836">		double udva = 0.;</span>
<span class="nc" id="L837">		int pathCount = _pathExposureAdjustmentArray.length;</span>

		try {
<span class="nc bnc" id="L840" title="All 2 branches missed.">			for (int pathIndex = 0; pathIndex &lt; pathCount; ++pathIndex)</span>
			{
<span class="nc" id="L842">				udva += _pathExposureAdjustmentArray[pathIndex].unilateralDebtAdjustment();</span>
			}
		}
<span class="nc" id="L845">		catch (java.lang.Exception e)</span>
		{
<span class="nc" id="L847">			e.printStackTrace();</span>

<span class="nc" id="L849">			return null;</span>
<span class="nc" id="L850">		}</span>

<span class="nc" id="L852">		return org.drip.xva.basel.ValueAdjustment.DVA (udva / pathCount);</span>
	}

	/**
	 * Retrieve the Expected Bilateral DVA
	 * 
	 * @return The Expected Bilateral DVA
	 */

	public org.drip.xva.basel.ValueAdjustment ftddva()
	{
<span class="nc" id="L863">		double ftddva = 0.;</span>
<span class="nc" id="L864">		int pathCount = _pathExposureAdjustmentArray.length;</span>

		try {
<span class="nc bnc" id="L867" title="All 2 branches missed.">			for (int pathIndex = 0; pathIndex &lt; pathCount; ++pathIndex)</span>
			{
<span class="nc" id="L869">				ftddva += _pathExposureAdjustmentArray[pathIndex].bilateralDebtAdjustment();</span>
			}
		}
<span class="nc" id="L872">		catch (java.lang.Exception e)</span>
		{
<span class="nc" id="L874">			e.printStackTrace();</span>

<span class="nc" id="L876">			return null;</span>
<span class="nc" id="L877">		}</span>

<span class="nc" id="L879">		return org.drip.xva.basel.ValueAdjustment.DVA (ftddva / pathCount);</span>
	}

	/**
	 * Retrieve the Expected DVA
	 * 
	 * @return The Expected DVA
	 */

	public org.drip.xva.basel.ValueAdjustment dva()
	{
<span class="fc" id="L890">		double dva = 0.;</span>
<span class="fc" id="L891">		int pathCount = _pathExposureAdjustmentArray.length;</span>

		try {
<span class="fc bfc" id="L894" title="All 2 branches covered.">			for (int pathIndex = 0; pathIndex &lt; pathCount; ++pathIndex)</span>
			{
<span class="fc" id="L896">				dva += _pathExposureAdjustmentArray[pathIndex].debtAdjustment();</span>
			}
		}
<span class="nc" id="L899">		catch (java.lang.Exception e)</span>
		{
<span class="nc" id="L901">			e.printStackTrace();</span>

<span class="nc" id="L903">			return null;</span>
<span class="fc" id="L904">		}</span>

<span class="fc" id="L906">		return org.drip.xva.basel.ValueAdjustment.DVA (dva / pathCount);</span>
	}

	/**
	 * Retrieve the Expected FVA
	 * 
	 * @return The Expected FVA
	 */

	public org.drip.xva.basel.ValueAdjustment fva()
	{
<span class="fc" id="L917">		double fva = 0.;</span>
<span class="fc" id="L918">		int pathCount = _pathExposureAdjustmentArray.length;</span>

		try
		{
<span class="fc bfc" id="L922" title="All 2 branches covered.">			for (int pathIndex = 0; pathIndex &lt; pathCount; ++pathIndex)</span>
			{
<span class="fc" id="L924">				fva += _pathExposureAdjustmentArray[pathIndex].fundingValueAdjustment();</span>
			}
		}
<span class="nc" id="L927">		catch (java.lang.Exception e)</span>
		{
<span class="nc" id="L929">			e.printStackTrace();</span>

<span class="nc" id="L931">			return null;</span>
<span class="fc" id="L932">		}</span>

<span class="fc" id="L934">		return org.drip.xva.basel.ValueAdjustment.FVA (fva / pathCount);</span>
	}

	/**
	 * Retrieve the Expected FDA
	 * 
	 * @return The Expected FDA
	 */

	public org.drip.xva.basel.ValueAdjustment fda()
	{
<span class="fc" id="L945">		double fda = 0.;</span>
<span class="fc" id="L946">		int pathCount = _pathExposureAdjustmentArray.length;</span>

		try
		{
<span class="fc bfc" id="L950" title="All 2 branches covered.">			for (int pathIndex = 0; pathIndex &lt; pathCount; ++pathIndex)</span>
			{
<span class="fc" id="L952">				fda += _pathExposureAdjustmentArray[pathIndex].fundingDebtAdjustment();</span>
			}
		}
<span class="nc" id="L955">		catch (java.lang.Exception e)</span>
		{
<span class="nc" id="L957">			e.printStackTrace();</span>

<span class="nc" id="L959">			return null;</span>
<span class="fc" id="L960">		}</span>

<span class="fc" id="L962">		return org.drip.xva.basel.ValueAdjustment.FDA (fda / pathCount);</span>
	}

	/**
	 * Retrieve the Expected DVA2
	 * 
	 * @return The Expected DVA2
	 */

	public org.drip.xva.basel.ValueAdjustment dva2()
	{
<span class="nc" id="L973">		return fda();</span>
	}

	/**
	 * Retrieve the Expected FCA
	 * 
	 * @return The Expected FCA
	 */

	public org.drip.xva.basel.ValueAdjustment fca()
	{
<span class="fc" id="L984">		double fca = 0.;</span>
<span class="fc" id="L985">		int pathCount = _pathExposureAdjustmentArray.length;</span>

<span class="fc bfc" id="L987" title="All 2 branches covered.">		for (int pathIndex = 0; pathIndex &lt; pathCount; ++pathIndex)</span>
		{
<span class="fc" id="L989">			fca += _pathExposureAdjustmentArray[pathIndex].fundingCostAdjustment();</span>
		}

<span class="fc" id="L992">		return org.drip.xva.basel.ValueAdjustment.HYBRID (fca / pathCount);</span>
	}

	/**
	 * Retrieve the Expected FBA
	 * 
	 * @return The Expected FBA
	 */

	public org.drip.xva.basel.ValueAdjustment fba()
	{
<span class="fc" id="L1003">		double fba = 0.;</span>
<span class="fc" id="L1004">		int pathCount = _pathExposureAdjustmentArray.length;</span>

<span class="fc bfc" id="L1006" title="All 2 branches covered.">		for (int pathIndex = 0; pathIndex &lt; pathCount; ++pathIndex)</span>
		{
<span class="fc" id="L1008">			fba += _pathExposureAdjustmentArray[pathIndex].fundingBenefitAdjustment();</span>
		}

<span class="fc" id="L1011">		return org.drip.xva.basel.ValueAdjustment.HYBRID (fba / pathCount);</span>
	}

	/**
	 * Retrieve the Expected SFVA
	 * 
	 * @return The Expected SFVA
	 */

	public org.drip.xva.basel.ValueAdjustment sfva()
	{
<span class="fc" id="L1022">		double sfva = 0.;</span>
<span class="fc" id="L1023">		int pathCount = _pathExposureAdjustmentArray.length;</span>

<span class="fc bfc" id="L1025" title="All 2 branches covered.">		for (int pathIndex = 0; pathIndex &lt; pathCount; ++pathIndex)</span>
		{
<span class="fc" id="L1027">			sfva += _pathExposureAdjustmentArray[pathIndex].symmetricFundingValueAdjustment();</span>
		}

<span class="fc" id="L1030">		return org.drip.xva.basel.ValueAdjustment.HYBRID (sfva / pathCount);</span>
	}

	/**
	 * Retrieve the Total VA
	 * 
	 * @return The Total VA
	 */

	public double total()
	{
<span class="fc" id="L1041">		return cva().amount() + dva().amount() + fva().amount() + colva().amount();</span>
	}

	/**
	 * Generate the &quot;Digest&quot; containing the &quot;Thin&quot; Path Statistics
	 * 
	 * @return The &quot;Digest&quot; containing the &quot;Thin&quot; Path Statistics
	 */

	public org.drip.xva.gross.ExposureAdjustmentDigest digest()
	{
<span class="fc" id="L1052">		int vertexCount = vertexDates().length;</span>

<span class="fc" id="L1054">		int pathCount = _pathExposureAdjustmentArray.length;</span>
<span class="fc" id="L1055">		double[] pathCVA = new double[pathCount];</span>
<span class="fc" id="L1056">		double[] pathDVA = new double[pathCount];</span>
<span class="fc" id="L1057">		double[] pathFBA = new double[pathCount];</span>
<span class="fc" id="L1058">		double[] pathFCA = new double[pathCount];</span>
<span class="fc" id="L1059">		double[] pathFDA = new double[pathCount];</span>
<span class="fc" id="L1060">		double[] pathFVA = new double[pathCount];</span>
<span class="fc" id="L1061">		double[] pathUCVA = new double[pathCount];</span>
<span class="fc" id="L1062">		double[] pathSFVA = new double[pathCount];</span>
<span class="fc" id="L1063">		double[] pathCVACL = new double[pathCount];</span>
<span class="fc" id="L1064">		double[] pathFTDCVA = new double[pathCount];</span>
<span class="fc" id="L1065">		double[] pathCOLVA = new double[pathCount];</span>
<span class="fc" id="L1066">		double[] pathTotalVA = new double[pathCount];</span>
<span class="fc" id="L1067">		double[] pathFTDCOLVA = new double[pathCount];</span>
<span class="fc" id="L1068">		double[][] fundingExposure = new double[vertexCount][pathCount];</span>
<span class="fc" id="L1069">		double[][] fundingExposurePV = new double[vertexCount][pathCount];</span>
<span class="fc" id="L1070">		double[][] collateralizedExposure = new double[vertexCount][pathCount];</span>
<span class="fc" id="L1071">		double[][] uncollateralizedExposure = new double[vertexCount][pathCount];</span>
<span class="fc" id="L1072">		double[][] collateralizedExposurePV = new double[vertexCount][pathCount];</span>
<span class="fc" id="L1073">		double[][] uncollateralizedExposurePV = new double[vertexCount][pathCount];</span>
<span class="fc" id="L1074">		double[][] collateralizedPositiveExposure = new double[vertexCount][pathCount];</span>
<span class="fc" id="L1075">		double[][] collateralizedNegativeExposure = new double[vertexCount][pathCount];</span>
<span class="fc" id="L1076">		double[][] uncollateralizedPositiveExposure = new double[vertexCount][pathCount];</span>
<span class="fc" id="L1077">		double[][] uncollateralizedNegativeExposure = new double[vertexCount][pathCount];</span>
<span class="fc" id="L1078">		double[][] collateralizedPositiveExposurePV = new double[vertexCount][pathCount];</span>
<span class="fc" id="L1079">		double[][] collateralizedNegativeExposurePV = new double[vertexCount][pathCount];</span>
<span class="fc" id="L1080">		double[][] uncollateralizedPositiveExposurePV = new double[vertexCount][pathCount];</span>
<span class="fc" id="L1081">		double[][] uncollateralizedNegativeExposurePV = new double[vertexCount][pathCount];</span>

<span class="fc bfc" id="L1083" title="All 2 branches covered.">		for (int vertexIndex = 0; vertexIndex &lt; vertexCount; ++vertexIndex)</span>
		{
<span class="fc bfc" id="L1085" title="All 2 branches covered.">			for (int pathIndex = 0; pathIndex &lt; pathCount; ++pathIndex)</span>
			{
<span class="fc" id="L1087">				collateralizedExposure[vertexIndex][pathIndex] = 0.;</span>
<span class="fc" id="L1088">				uncollateralizedExposure[vertexIndex][pathIndex] = 0.;</span>
<span class="fc" id="L1089">				collateralizedExposurePV[vertexIndex][pathIndex] = 0.;</span>
<span class="fc" id="L1090">				uncollateralizedExposurePV[vertexIndex][pathIndex] = 0.;</span>
<span class="fc" id="L1091">				collateralizedPositiveExposure[vertexIndex][pathIndex] = 0.;</span>
<span class="fc" id="L1092">				collateralizedNegativeExposure[vertexIndex][pathIndex] = 0.;</span>
<span class="fc" id="L1093">				uncollateralizedPositiveExposure[vertexIndex][pathIndex] = 0.;</span>
<span class="fc" id="L1094">				uncollateralizedNegativeExposure[vertexIndex][pathIndex] = 0.;</span>
<span class="fc" id="L1095">				collateralizedPositiveExposurePV[vertexIndex][pathIndex] = 0.;</span>
<span class="fc" id="L1096">				collateralizedNegativeExposurePV[vertexIndex][pathIndex] = 0.;</span>
<span class="fc" id="L1097">				uncollateralizedPositiveExposurePV[vertexIndex][pathIndex] = 0.;</span>
<span class="fc" id="L1098">				uncollateralizedNegativeExposurePV[vertexIndex][pathIndex] = 0.;</span>
			}
		}

<span class="fc bfc" id="L1102" title="All 2 branches covered.">		for (int pathIndex = 0; pathIndex &lt; pathCount; ++pathIndex)</span>
		{
<span class="fc" id="L1104">			double[] pathCollateralizedExposure =</span>
<span class="fc" id="L1105">				_pathExposureAdjustmentArray[pathIndex].vertexCollateralizedExposure();</span>

<span class="fc" id="L1107">			double[] pathCollateralizedExposurePV =</span>
<span class="fc" id="L1108">				_pathExposureAdjustmentArray[pathIndex].vertexCollateralizedExposurePV();</span>

<span class="fc" id="L1110">			double[] pathCollateralizedPositiveExposure =</span>
<span class="fc" id="L1111">				_pathExposureAdjustmentArray[pathIndex].vertexCollateralizedPositiveExposure();</span>

<span class="fc" id="L1113">			double[] pathCollateralizedPositiveExposurePV =</span>
<span class="fc" id="L1114">				_pathExposureAdjustmentArray[pathIndex].vertexCollateralizedPositiveExposurePV();</span>

<span class="fc" id="L1116">			double[] pathCollateralizedNegativeExposure =</span>
<span class="fc" id="L1117">				_pathExposureAdjustmentArray[pathIndex].vertexCollateralizedNegativeExposure();</span>

<span class="fc" id="L1119">			double[] pathCollateralizedNegativeExposurePV =</span>
<span class="fc" id="L1120">				_pathExposureAdjustmentArray[pathIndex].vertexCollateralizedNegativeExposurePV();</span>

<span class="fc" id="L1122">			double[] pathUncollateralizedExposure =</span>
<span class="fc" id="L1123">				_pathExposureAdjustmentArray[pathIndex].vertexUncollateralizedExposure();</span>

<span class="fc" id="L1125">			double[] pathUncollateralizedExposurePV =</span>
<span class="fc" id="L1126">				_pathExposureAdjustmentArray[pathIndex].vertexUncollateralizedExposurePV();</span>

<span class="fc" id="L1128">			double[] pathUncollateralizedPositiveExposure =</span>
<span class="fc" id="L1129">				_pathExposureAdjustmentArray[pathIndex].vertexUncollateralizedPositiveExposure();</span>

<span class="fc" id="L1131">			double[] pathUncollateralizedPositiveExposurePV =</span>
<span class="fc" id="L1132">				_pathExposureAdjustmentArray[pathIndex].vertexUncollateralizedPositiveExposurePV();</span>

<span class="fc" id="L1134">			double[] pathUncollateralizedNegativeExposure =</span>
<span class="fc" id="L1135">				_pathExposureAdjustmentArray[pathIndex].vertexUncollateralizedNegativeExposure();</span>

<span class="fc" id="L1137">			double[] pathUncollateralizedNegativeExposurePV =</span>
<span class="fc" id="L1138">				_pathExposureAdjustmentArray[pathIndex].vertexUncollateralizedNegativeExposurePV();</span>

<span class="fc" id="L1140">			double[] pathFundingExposure = _pathExposureAdjustmentArray[pathIndex].vertexFundingExposure();</span>

<span class="fc" id="L1142">			double[] pathFundingExposurePV =</span>
<span class="fc" id="L1143">				_pathExposureAdjustmentArray[pathIndex].vertexFundingExposurePV();</span>

			try
			{
<span class="fc" id="L1147">				pathCVA[pathIndex] = _pathExposureAdjustmentArray[pathIndex].creditAdjustment();</span>

<span class="fc" id="L1149">				pathDVA[pathIndex] = _pathExposureAdjustmentArray[pathIndex].debtAdjustment();</span>

<span class="fc" id="L1151">				pathFCA[pathIndex] = _pathExposureAdjustmentArray[pathIndex].fundingCostAdjustment();</span>

<span class="fc" id="L1153">				pathFDA[pathIndex] = _pathExposureAdjustmentArray[pathIndex].fundingDebtAdjustment();</span>

<span class="fc" id="L1155">				pathFVA[pathIndex] = _pathExposureAdjustmentArray[pathIndex].fundingValueAdjustment();</span>

<span class="fc" id="L1157">				pathFBA[pathIndex] = _pathExposureAdjustmentArray[pathIndex].fundingBenefitAdjustment();</span>

<span class="fc" id="L1159">				pathUCVA[pathIndex] = _pathExposureAdjustmentArray[pathIndex].unilateralCreditAdjustment();</span>

<span class="fc" id="L1161">				pathSFVA[pathIndex] =</span>
<span class="fc" id="L1162">					_pathExposureAdjustmentArray[pathIndex].symmetricFundingValueAdjustment();</span>

<span class="fc" id="L1164">				pathCVACL[pathIndex] =</span>
<span class="fc" id="L1165">					_pathExposureAdjustmentArray[pathIndex].contraLiabilityCreditAdjustment();</span>

<span class="fc" id="L1167">				pathFTDCVA[pathIndex] = _pathExposureAdjustmentArray[pathIndex].bilateralCreditAdjustment();</span>

<span class="fc" id="L1169">				pathCOLVA[pathIndex] =</span>
<span class="fc" id="L1170">					_pathExposureAdjustmentArray[pathIndex].bilateralCollateralAdjustment();</span>

<span class="fc" id="L1172">				pathFTDCOLVA[pathIndex] =</span>
<span class="fc" id="L1173">					_pathExposureAdjustmentArray[pathIndex].bilateralCollateralAdjustment();</span>

<span class="fc" id="L1175">				pathTotalVA[pathIndex] = _pathExposureAdjustmentArray[pathIndex].totalAdjustment();</span>
			}
<span class="nc" id="L1177">			catch (java.lang.Exception e)</span>
			{
<span class="nc" id="L1179">				e.printStackTrace();</span>

<span class="nc" id="L1181">				return null;</span>
<span class="fc" id="L1182">			}</span>

<span class="fc bfc" id="L1184" title="All 2 branches covered.">			for (int vertexIndex = 0; vertexIndex &lt; vertexCount; ++vertexIndex)</span>
			{
<span class="fc" id="L1186">				collateralizedExposure[vertexIndex][pathIndex] =</span>
					pathCollateralizedExposure[vertexIndex];
<span class="fc" id="L1188">				collateralizedExposurePV[vertexIndex][pathIndex] =</span>
					pathCollateralizedExposurePV[vertexIndex];
<span class="fc" id="L1190">				collateralizedPositiveExposure[vertexIndex][pathIndex] =</span>
					pathCollateralizedPositiveExposure[vertexIndex];
<span class="fc" id="L1192">				collateralizedPositiveExposurePV[vertexIndex][pathIndex] =</span>
					pathCollateralizedPositiveExposurePV[vertexIndex];
<span class="fc" id="L1194">				collateralizedNegativeExposure[vertexIndex][pathIndex] =</span>
					pathCollateralizedNegativeExposure[vertexIndex];
<span class="fc" id="L1196">				collateralizedNegativeExposurePV[vertexIndex][pathIndex] =</span>
					pathCollateralizedNegativeExposurePV[vertexIndex];
<span class="fc" id="L1198">				uncollateralizedExposure[vertexIndex][pathIndex] =</span>
					pathUncollateralizedExposure[vertexIndex];
<span class="fc" id="L1200">				uncollateralizedExposurePV[vertexIndex][pathIndex] =</span>
					pathUncollateralizedExposurePV[vertexIndex];
<span class="fc" id="L1202">				uncollateralizedPositiveExposure[vertexIndex][pathIndex] =</span>
					pathUncollateralizedPositiveExposure[vertexIndex];
<span class="fc" id="L1204">				uncollateralizedPositiveExposurePV[vertexIndex][pathIndex] =</span>
					pathUncollateralizedPositiveExposurePV[vertexIndex];
<span class="fc" id="L1206">				uncollateralizedNegativeExposure[vertexIndex][pathIndex] =</span>
					pathUncollateralizedNegativeExposure[vertexIndex];
<span class="fc" id="L1208">				uncollateralizedNegativeExposurePV[vertexIndex][pathIndex] =</span>
					pathUncollateralizedNegativeExposurePV[vertexIndex];
<span class="fc" id="L1210">				fundingExposure[vertexIndex][pathIndex] = pathFundingExposure[vertexIndex];</span>
<span class="fc" id="L1211">				fundingExposurePV[vertexIndex][pathIndex] = pathFundingExposurePV[vertexIndex];</span>
			}
		}

		try
		{
<span class="fc" id="L1217">			return new org.drip.xva.gross.ExposureAdjustmentDigest (</span>
				pathCOLVA,
				pathFTDCOLVA,
				pathUCVA,
				pathFTDCVA,
				pathCVA,
				pathCVACL,
				pathDVA,
				pathFVA,
				pathFDA,
				pathFCA,
				pathFBA,
				pathSFVA,
				pathTotalVA,
				collateralizedExposure,
				collateralizedExposurePV,
				collateralizedPositiveExposure,
				collateralizedPositiveExposurePV,
				collateralizedNegativeExposure,
				collateralizedNegativeExposurePV,
				uncollateralizedExposure,
				uncollateralizedExposurePV,
				uncollateralizedPositiveExposure,
				uncollateralizedPositiveExposurePV,
				uncollateralizedNegativeExposure,
				uncollateralizedNegativeExposurePV,
				fundingExposure,
				fundingExposurePV
			);
		}
<span class="nc" id="L1247">		catch (java.lang.Exception e)</span>
		{
<span class="nc" id="L1249">			e.printStackTrace();</span>
		}

<span class="nc" id="L1252">		return null;</span>
	}

	/**
	 * Generate the Basel Exposure Digest
	 * 
	 * @param standardizedExposureGeneratorScheme The Standardized Basel Exposure Generation Scheme
	 * 
	 * @return The Basel Exposure Digest
	 */

	public org.drip.xva.gross.BaselExposureDigest baselExposureDigest (
		final org.drip.xva.settings.StandardizedExposureGeneratorScheme standardizedExposureGeneratorScheme)
	{
<span class="nc bnc" id="L1266" title="All 2 branches missed.">		if (null == standardizedExposureGeneratorScheme)</span>
		{
<span class="nc" id="L1268">			return null;</span>
		}

<span class="nc" id="L1271">		org.drip.analytics.date.JulianDate[] vertexJulianDateArray = vertexDates();</span>

<span class="nc" id="L1273">		int vertexCount = vertexJulianDateArray.length;</span>
<span class="nc" id="L1274">		int[] vertexDateArray = new int[vertexCount];</span>
<span class="nc" id="L1275">		int pathCount = _pathExposureAdjustmentArray.length;</span>
<span class="nc" id="L1276">		double[] collateralizedPositiveExposure = new double[vertexCount];</span>
<span class="nc" id="L1277">		double[] effectiveCollateralizedPositiveExposure = new double[vertexCount];</span>
<span class="nc" id="L1278">		org.drip.spline.params.SegmentCustomBuilderControl[] collateralizedExposureSegmentBuilderControlArray</span>
			= new org.drip.spline.params.SegmentCustomBuilderControl[vertexCount - 1];
		org.drip.spline.params.SegmentCustomBuilderControl[]
<span class="nc" id="L1281">			collateralizedPositiveExposureSegmentBuilderControlArray = new</span>
				org.drip.spline.params.SegmentCustomBuilderControl[vertexCount - 1];

<span class="nc" id="L1284">		org.drip.spline.params.SegmentCustomBuilderControl collateralizedExposureSegmentBuilderControl =</span>
<span class="nc" id="L1285">			standardizedExposureGeneratorScheme.collateralizedExposureSegmentBuilderControl();</span>

		org.drip.spline.params.SegmentCustomBuilderControl
<span class="nc" id="L1288">			collateralizedPositiveExposureSegmentBuilderControl =</span>
<span class="nc" id="L1289">				standardizedExposureGeneratorScheme.collateralizedPositiveExposureSegmentBuilderControl();</span>

<span class="nc bnc" id="L1291" title="All 2 branches missed.">		for (int i = 0; i &lt; vertexCount - 1; ++i)</span>
		{
<span class="nc" id="L1293">			collateralizedExposureSegmentBuilderControlArray[i] =</span>
				collateralizedExposureSegmentBuilderControl;
<span class="nc" id="L1295">			collateralizedPositiveExposureSegmentBuilderControlArray[i] =</span>
				collateralizedPositiveExposureSegmentBuilderControl;
		}

<span class="nc bnc" id="L1299" title="All 2 branches missed.">		for (int vertexIndex = 0; vertexIndex &lt; vertexCount; ++vertexIndex)</span>
		{
<span class="nc" id="L1301">			collateralizedPositiveExposure[vertexIndex] = 0.;</span>

<span class="nc" id="L1303">			vertexDateArray[vertexIndex] = vertexJulianDateArray[vertexIndex].julian();</span>
		}

<span class="nc bnc" id="L1306" title="All 2 branches missed.">		for (int pathIndex = 0; pathIndex &lt; pathCount; ++pathIndex)</span>
		{
<span class="nc" id="L1308">			double[] pathCollateralizedPositiveExposure =</span>
<span class="nc" id="L1309">				_pathExposureAdjustmentArray[pathIndex].vertexCollateralizedPositiveExposure();</span>

<span class="nc bnc" id="L1311" title="All 2 branches missed.">			for (int vertexIndex = 0; vertexIndex &lt; vertexCount; ++vertexIndex)</span>
			{
<span class="nc" id="L1313">				collateralizedPositiveExposure[vertexIndex] +=</span>
					pathCollateralizedPositiveExposure[vertexIndex];
			}
		}

<span class="nc bnc" id="L1318" title="All 2 branches missed.">		for (int vertexIndex = 0; vertexIndex &lt; vertexCount; ++vertexIndex)</span>
		{
<span class="nc" id="L1320">			collateralizedPositiveExposure[vertexIndex] /= pathCount;</span>

<span class="nc bnc" id="L1322" title="All 2 branches missed.">			if (0 == vertexIndex)</span>
			{
<span class="nc" id="L1324">				effectiveCollateralizedPositiveExposure[0] = collateralizedPositiveExposure[0];</span>
			}
			else
			{
<span class="nc bnc" id="L1328" title="All 2 branches missed.">				effectiveCollateralizedPositiveExposure[vertexIndex] =</span>
					collateralizedPositiveExposure[vertexIndex] &gt;
					effectiveCollateralizedPositiveExposure[vertexIndex - 1] ?
					collateralizedPositiveExposure[vertexIndex] :
					effectiveCollateralizedPositiveExposure[vertexIndex - 1];
			}
		}

		try
		{
<span class="nc" id="L1338">			org.drip.spline.stretch.MultiSegmentSequence multiSegmentSequenceCollateralizedPositiveExposure =</span>
<span class="nc" id="L1339">				org.drip.spline.stretch.MultiSegmentSequenceBuilder.CreateCalibratedStretchEstimator (</span>
					&quot;CollateralizedPositiveExposure&quot;,
					vertexDateArray,
					collateralizedPositiveExposure,
					collateralizedExposureSegmentBuilderControlArray,
					null,
<span class="nc" id="L1345">					org.drip.spline.stretch.BoundarySettings.NaturalStandard(),</span>
					org.drip.spline.stretch.MultiSegmentSequence.CALIBRATE
				);

			org.drip.spline.stretch.MultiSegmentSequence
<span class="nc" id="L1350">				multiSegmentSequenceEffectiveCollateralizedPositiveExposure =</span>
<span class="nc" id="L1351">					org.drip.spline.stretch.MultiSegmentSequenceBuilder.CreateCalibratedStretchEstimator (</span>
						&quot;EffectiveCollateralizedPositiveExposure&quot;,
						vertexDateArray,
						effectiveCollateralizedPositiveExposure,
						collateralizedPositiveExposureSegmentBuilderControlArray,
						null,
<span class="nc" id="L1357">						org.drip.spline.stretch.BoundarySettings.NaturalStandard(),</span>
						org.drip.spline.stretch.MultiSegmentSequence.CALIBRATE
					);

<span class="nc bnc" id="L1361" title="All 4 branches missed.">			if (null == multiSegmentSequenceCollateralizedPositiveExposure ||</span>
				null == multiSegmentSequenceEffectiveCollateralizedPositiveExposure)
			{
<span class="nc" id="L1364">				return null;</span>
			}

<span class="nc" id="L1367">			int exposureGeneratorTimeIntegrand = standardizedExposureGeneratorScheme.timeIntegrand();</span>

<span class="nc" id="L1369">			int integrandFinishDate = vertexDateArray[0] + exposureGeneratorTimeIntegrand;</span>

<span class="nc" id="L1371">			double effectiveExpectedPositiveExposure =</span>
<span class="nc" id="L1372">				multiSegmentSequenceEffectiveCollateralizedPositiveExposure.toAU().integrate (</span>
					vertexDateArray[0],
					integrandFinishDate
				) / exposureGeneratorTimeIntegrand;

<span class="nc" id="L1377">			return new BaselExposureDigest (</span>
				collateralizedPositiveExposure[0],
<span class="nc" id="L1379">				multiSegmentSequenceCollateralizedPositiveExposure.toAU().integrate (</span>
					vertexDateArray[0],
					integrandFinishDate
				) / exposureGeneratorTimeIntegrand,
				effectiveCollateralizedPositiveExposure[vertexCount - 1],
				effectiveExpectedPositiveExposure,
<span class="nc" id="L1385">				effectiveExpectedPositiveExposure * standardizedExposureGeneratorScheme.eadMultiplier()</span>
			);
		}
<span class="nc" id="L1388">		catch (java.lang.Exception e)</span>
		{
<span class="nc" id="L1390">			e.printStackTrace();</span>
		}

<span class="nc" id="L1393">		return null;</span>
	}
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.7.9.201702052155</span></div></body></html>