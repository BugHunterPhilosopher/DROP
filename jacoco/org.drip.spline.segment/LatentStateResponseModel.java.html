<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>LatentStateResponseModel.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">DROP</a> &gt; <a href="index.source.html" class="el_package">org.drip.spline.segment</a> &gt; <span class="el_source">LatentStateResponseModel.java</span></div><h1>LatentStateResponseModel.java</h1><pre class="source lang-java linenums">
package org.drip.spline.segment;

/*
 * -*- mode: java; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*-
 */

/*!
 * Copyright (C) 2019 Lakshmi Krishnamurthy
 * Copyright (C) 2018 Lakshmi Krishnamurthy
 * Copyright (C) 2017 Lakshmi Krishnamurthy
 * Copyright (C) 2016 Lakshmi Krishnamurthy
 * Copyright (C) 2015 Lakshmi Krishnamurthy
 * Copyright (C) 2014 Lakshmi Krishnamurthy
 * Copyright (C) 2013 Lakshmi Krishnamurthy
 * 
 *  This file is part of DROP, an open-source library targeting risk, transaction costs, exposure, margin
 *  	calculations, and portfolio construction within and across fixed income, credit, commodity, equity,
 *  	FX, and structured products.
 *  
 *  	https://lakshmidrip.github.io/DROP/
 *  
 *  DROP is composed of three main modules:
 *  
 *  - DROP Analytics Core - https://lakshmidrip.github.io/DROP-Analytics-Core/
 *  - DROP Portfolio Core - https://lakshmidrip.github.io/DROP-Portfolio-Core/
 *  - DROP Numerical Core - https://lakshmidrip.github.io/DROP-Numerical-Core/
 * 
 * 	DROP Analytics Core implements libraries for the following:
 * 	- Fixed Income Analytics
 * 	- Asset Backed Analytics
 * 	- XVA Analytics
 * 	- Exposure and Margin Analytics
 * 
 * 	DROP Portfolio Core implements libraries for the following:
 * 	- Asset Allocation Analytics
 * 	- Transaction Cost Analytics
 * 
 * 	DROP Numerical Core implements libraries for the following:
 * 	- Statistical Learning Library
 * 	- Numerical Optimizer Library
 * 	- Machine Learning Library
 * 	- Spline Builder Library
 * 
 * 	Documentation for DROP is Spread Over:
 * 
 * 	- Main                     =&gt; https://lakshmidrip.github.io/DROP/
 * 	- Wiki                     =&gt; https://github.com/lakshmiDRIP/DROP/wiki
 * 	- GitHub                   =&gt; https://github.com/lakshmiDRIP/DROP
 * 	- Javadoc                  =&gt; https://lakshmidrip.github.io/DROP/Javadoc/index.html
 * 	- Technical Specifications =&gt; https://github.com/lakshmiDRIP/DROP/tree/master/Docs/Internal
 * 	- Release Versions         =&gt; https://lakshmidrip.github.io/DROP/version.html
 * 	- Community Credits        =&gt; https://lakshmidrip.github.io/DROP/credits.html
 * 	- Issues Catalog           =&gt; https://github.com/lakshmiDRIP/DROP/issues
 * 	- JUnit                    =&gt; https://lakshmidrip.github.io/DROP/junit/index.html
 * 	- Jacoco                   =&gt; https://lakshmidrip.github.io/DROP/jacoco/index.html
 * 
 *  Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 *   	you may not use this file except in compliance with the License.
 *   
 *  You may obtain a copy of the License at
 *  	http://www.apache.org/licenses/LICENSE-2.0
 *  
 *  Unless required by applicable law or agreed to in writing, software
 *  	distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 *  	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  
 *  See the License for the specific language governing permissions and
 *  	limitations under the License.
 */

/**
 * &lt;i&gt;LatentStateResponseModel&lt;/i&gt; implements the single segment basis calibration and inference
 * functionality. It exports the following functionality:
 *
 * &lt;br&gt;&lt;br&gt;
 *  &lt;ul&gt;
 *  	&lt;li&gt;
 * 			Build the LatentStateResponseModel instance from the Basis Function/Shape Controller Set
 *  	&lt;/li&gt;
 *  	&lt;li&gt;
 * 			Build the LatentStateResponseModel instance from the Basis Evaluator Set
 *  	&lt;/li&gt;
 *  	&lt;li&gt;
 * 			Retrieve the Number of Parameters, Basis Evaluator, Array of the Response Basis Coefficients, and
 * 				Segment Design Inelastic Control
 *  	&lt;/li&gt;
 *  	&lt;li&gt;
 * 			Calibrate the Segment State from the Calibration Parameter Set
 *  	&lt;/li&gt;
 *  	&lt;li&gt;
 * 			Sensitivity Calibrator: Calibrate the Segment Manifest Jacobian from the Calibration Parameter
 * 				Set
 *  	&lt;/li&gt;
 *  	&lt;li&gt;
 * 			Calibrate the coefficients from the prior Predictor/Response Segment, the Constraint, and fitness
 * 				Weights
 *  	&lt;/li&gt;
 *  	&lt;li&gt;
 *			Calibrate the coefficients from the prior Segment and the Response Value at the Right Predictor
 *				Ordinate
 *  	&lt;/li&gt;
 *  	&lt;li&gt;
 *			Calibrate the Coefficients from the Edge Response Values and the Left Edge Response Slope
 *  	&lt;/li&gt;
 *  	&lt;li&gt;
 *			Calibrate the coefficients from the Left Edge Response Value Constraint, the Left Edge Response
 *				Value Slope, and the Right Edge Response Value Constraint
 *  	&lt;/li&gt;
 *  	&lt;li&gt;
 *			Retrieve the Segment Curvature, Length, and the Best Fit DPE
 *  	&lt;/li&gt;
 *  	&lt;li&gt;
 *			Calculate the Response Value and its Derivative at the given Predictor Ordinate
 *  	&lt;/li&gt;
 *  	&lt;li&gt;
 *			Calculate the Ordered Derivative of the Coefficient to the Manifest
 *  	&lt;/li&gt;
 *  	&lt;li&gt;
 *			Calculate the Jacobian of the Segment's Response Basis Function Coefficients to the Edge Inputs
 *  	&lt;/li&gt;
 *  	&lt;li&gt;
 *			Calculate the Jacobian of the Response to the Edge Inputs at the given Predictor Ordinate
 *  	&lt;/li&gt;
 *  	&lt;li&gt;
 *			Calculate the Jacobian of the Response to the Basis Coefficients at the given Predictor Ordinate
 *  	&lt;/li&gt;
 *  	&lt;li&gt;
 *			Calibrate the segment and calculate the Jacobian of the Segment's Response Basis Function
 *				Coefficients to the Edge Parameters
 *  	&lt;/li&gt;
 *  	&lt;li&gt;
 *			Calibrate the Coefficients from the Edge Response Values and the Left Edge Response Value Slope
 *				and calculate the Jacobian of the Segment's Response Basis Function Coefficients to the Edge
 *				Parameters
 *  	&lt;/li&gt;
 *  	&lt;li&gt;
 *			Calibrate the coefficients from the prior Segment and the Response Value at the Right Predictor
 *				Ordinate and calculate the Jacobian of the Segment's Response Basis Function Coefficients to
 *				the Edge Parameters
 *  	&lt;/li&gt;
 *  	&lt;li&gt;
 *  		Indicate whether the given segment is monotone. If monotone, may optionally indicate the nature
 *  			of the extrema contained inside (maxima/minima/infection)
 *  	&lt;/li&gt;
 *  	&lt;li&gt;
 *  		Clip the part of the Segment to the Right of the specified Predictor Ordinate. Retain all other
 *  			constraints the same
 *  	&lt;/li&gt;
 *  	&lt;li&gt;
 *  		Clip the part of the Segment to the Left of the specified Predictor Ordinate. Retain all other
 *  			constraints the same
 *  	&lt;/li&gt;
 *  	&lt;li&gt;
 *  		Display the string representation for diagnostic purposes
 *  	&lt;/li&gt;
 *  &lt;/ul&gt;
 *
 * &lt;br&gt;&lt;br&gt;
 *  &lt;ul&gt;
 *		&lt;li&gt;&lt;b&gt;Module &lt;/b&gt; = &lt;a href = &quot;https://github.com/lakshmiDRIP/DROP/tree/master/NumericalCore.md&quot;&gt;Numerical Core Module&lt;/a&gt;&lt;/li&gt;
 *		&lt;li&gt;&lt;b&gt;Library&lt;/b&gt; = &lt;a href = &quot;https://github.com/lakshmiDRIP/DROP/tree/master/SplineBuilderLibrary.md&quot;&gt;Spline Builder Library&lt;/a&gt;&lt;/li&gt;
 *		&lt;li&gt;&lt;b&gt;Project&lt;/b&gt; = &lt;a href = &quot;https://github.com/lakshmiDRIP/DROP/tree/master/src/main/java/org/drip/spline&quot;&gt;Spline&lt;/a&gt;&lt;/li&gt;
 *		&lt;li&gt;&lt;b&gt;Package&lt;/b&gt; = &lt;a href = &quot;https://github.com/lakshmiDRIP/DROP/tree/master/src/main/java/org/drip/spline/segment&quot;&gt;Segment&lt;/a&gt;&lt;/li&gt;
 *  &lt;/ul&gt;
 * &lt;br&gt;&lt;br&gt;
 *
 * @author Lakshmi Krishnamurthy
 */

public class LatentStateResponseModel extends org.drip.spline.segment.LatentStateInelastic {

	/**
	 * LEFT NODE VALUE PARAMETER INDEX
	 */

	public static final int LEFT_NODE_VALUE_PARAMETER_INDEX = 0;

	/**
	 * RIGHT NODE VALUE PARAMETER INDEX
	 */

	public static final int RIGHT_NODE_VALUE_PARAMETER_INDEX = 1;

<span class="fc" id="L185">	private double[] _adblResponseBasisCoeff = null;</span>
<span class="fc" id="L186">	private org.drip.spline.segment.BasisEvaluator _be = null;</span>
<span class="fc" id="L187">	private double[][] _aadblDResponseBasisCoeffDConstraint = null;</span>
<span class="fc" id="L188">	private org.drip.spline.params.SegmentInelasticDesignControl _sidc = null;</span>
<span class="fc" id="L189">	private org.drip.numerical.differentiation.WengertJacobian _wjDBasisCoeffDEdgeValue = null;</span>

<span class="fc" id="L191">	private</span>
		org.drip.analytics.support.CaseInsensitiveHashMap&lt;org.drip.spline.segment.LatentStateManifestSensitivity&gt;
			_mapLSMS = new
				org.drip.analytics.support.CaseInsensitiveHashMap&lt;org.drip.spline.segment.LatentStateManifestSensitivity&gt;();

	/**
	 * Build the LatentStateResponseModel instance from the Basis Function/Shape Controller Set
	 * 
	 * @param dblLeftPredictorOrdinate Left Predictor Ordinate
	 * @param dblRightPredictorOrdinate Right Predictor Ordinate
	 * @param fs Response Basis Function Set
	 * @param rssc Shape Controller
	 * @param sidc Segment Inelastic Design Parameters
	 * 
	 * @return Instance of LatentStateResponseModel
	 */

	public static final org.drip.spline.segment.LatentStateResponseModel Create (
		final double dblLeftPredictorOrdinate,
		final double dblRightPredictorOrdinate,
		final org.drip.spline.basis.FunctionSet fs,
		final org.drip.spline.params.ResponseScalingShapeControl rssc,
		final org.drip.spline.params.SegmentInelasticDesignControl sidc)
	{
		try {
<span class="fc" id="L216">			org.drip.spline.segment.SegmentBasisEvaluator sbe = new</span>
				org.drip.spline.segment.SegmentBasisEvaluator (fs, rssc);

<span class="pc bpc" id="L219" title="1 of 2 branches missed.">			if (!org.drip.numerical.common.NumberUtil.IsValid (dblLeftPredictorOrdinate) ||</span>
<span class="pc bpc" id="L220" title="2 of 4 branches missed.">				!org.drip.numerical.common.NumberUtil.IsValid (dblRightPredictorOrdinate) ||</span>
				dblLeftPredictorOrdinate == dblRightPredictorOrdinate)
			{
<span class="nc" id="L223">				return null;</span>
			}

<span class="fc" id="L226">			org.drip.spline.segment.LatentStateResponseModel lsrm = new</span>
				org.drip.spline.segment.LatentStateResponseModel (dblLeftPredictorOrdinate,
					dblRightPredictorOrdinate, sbe, sidc);

<span class="pc bpc" id="L230" title="1 of 2 branches missed.">			return sbe.setContainingInelastics (lsrm) ? lsrm : null;</span>
<span class="nc" id="L231">		} catch (java.lang.Exception e) {</span>
<span class="nc" id="L232">			e.printStackTrace();</span>
		}

<span class="nc" id="L235">		return null;</span>
	}

	/**
	 * Build the LatentStateResponseModel instance from the Basis Evaluator Set
	 * 
	 * @param dblLeftPredictorOrdinate Left Predictor Ordinate
	 * @param dblRightPredictorOrdinate Right Predictor Ordinate
	 * @param be Basis Evaluator
	 * @param sidc Segment Inelastic Design Parameters
	 * 
	 * @return Instance of LatentStateResponseModel
	 */

	public static final org.drip.spline.segment.LatentStateResponseModel Create (
		final double dblLeftPredictorOrdinate,
		final double dblRightPredictorOrdinate,
		final org.drip.spline.segment.BasisEvaluator be,
		final org.drip.spline.params.SegmentInelasticDesignControl sidc)
	{
		try {
<span class="fc" id="L256">			org.drip.spline.segment.LatentStateResponseModel lsrm = new</span>
				org.drip.spline.segment.LatentStateResponseModel (dblLeftPredictorOrdinate,
					dblRightPredictorOrdinate, be, sidc);

<span class="pc bpc" id="L260" title="1 of 2 branches missed.">			return be.setContainingInelastics (lsrm) ? lsrm : null;</span>
<span class="nc" id="L261">		} catch (java.lang.Exception e) {</span>
<span class="nc" id="L262">			e.printStackTrace();</span>
		}

<span class="nc" id="L265">		return null;</span>
	}

	private LatentStateResponseModel (
		final double dblLeftPredictorOrdinate,
		final double dblRightPredictorOrdinate,
		final org.drip.spline.segment.BasisEvaluator be,
		final org.drip.spline.params.SegmentInelasticDesignControl sidc)
		throws java.lang.Exception
	{
<span class="fc" id="L275">		super (dblLeftPredictorOrdinate, dblRightPredictorOrdinate);</span>

<span class="pc bpc" id="L277" title="2 of 4 branches missed.">		if (null == (_be = be) || null == (_sidc = sidc))</span>
<span class="nc" id="L278">			throw new java.lang.Exception (&quot;LatentStateResponseModel ctr: Invalid Basis Functions!&quot;);</span>

<span class="fc" id="L280">		int iNumBasis = _be.numBasis();</span>

<span class="fc" id="L282">		_adblResponseBasisCoeff = new double[iNumBasis];</span>

<span class="pc bpc" id="L284" title="2 of 4 branches missed.">		if (0 &gt;= iNumBasis || _sidc.Ck() &gt; iNumBasis - 2)</span>
<span class="nc" id="L285">			throw new java.lang.Exception (&quot;LatentStateResponseModel ctr: Invalid inputs!&quot;);</span>
<span class="fc" id="L286">	}</span>

	private double[] DResponseDBasisCoeff (
		final double dblPredictorOrdinate,
		final int iOrder)
	{
<span class="pc bpc" id="L292" title="1 of 2 branches missed.">		if (0 == iOrder) return null;</span>

<span class="fc" id="L294">		int iNumBasis = _be.numBasis();</span>

<span class="fc" id="L296">		double[] adblDResponseDBasisCoeff = new double[iNumBasis];</span>

<span class="fc bfc" id="L298" title="All 2 branches covered.">		for (int i = 0; i &lt; iNumBasis; ++i) {</span>
			try {
<span class="pc bpc" id="L300" title="1 of 2 branches missed.">				adblDResponseDBasisCoeff[i] = 1 == iOrder ? _be.shapedBasisFunctionResponse</span>
<span class="pc" id="L301">					(dblPredictorOrdinate, i) : 0.;</span>
<span class="nc" id="L302">			} catch (java.lang.Exception e) {</span>
<span class="nc" id="L303">				e.printStackTrace();</span>

<span class="nc" id="L305">				return null;</span>
<span class="fc" id="L306">			}</span>
		}

<span class="fc" id="L309">		return adblDResponseDBasisCoeff;</span>
	}

	private double[] transmissionCk (
		final double dblPredictorOrdinate,
		final org.drip.spline.segment.LatentStateResponseModel csPreceeding,
		final int iCk)
	{
<span class="fc" id="L317">		double[] adblDeriv = new double[iCk];</span>

<span class="fc bfc" id="L319" title="All 2 branches covered.">		for (int i = 0; i &lt; iCk; ++i) {</span>
			try {
<span class="fc" id="L321">				adblDeriv[i] = csPreceeding.calcResponseValueDerivative (dblPredictorOrdinate, i + 1);</span>
<span class="nc" id="L322">			} catch (java.lang.Exception e) {</span>
<span class="nc" id="L323">				e.printStackTrace();</span>

<span class="nc" id="L325">				return null;</span>
<span class="fc" id="L326">			}</span>
		}

<span class="fc" id="L329">		return adblDeriv;</span>
	}

	private org.drip.spline.segment.LatentStateManifestSensitivity manifestSensitivity (
		final java.lang.String strManifestMeasure)
	{
<span class="pc bpc" id="L335" title="2 of 4 branches missed.">		return null == strManifestMeasure || strManifestMeasure.isEmpty() || !_mapLSMS.containsKey</span>
<span class="fc bfc" id="L336" title="All 2 branches covered.">			(strManifestMeasure) ? null : _mapLSMS.get (strManifestMeasure);</span>
	}

	private double[] CkDBasisCoeffDPreceedingManifestMeasure (
		final java.lang.String strManifestMeasure)
	{
<span class="fc" id="L342">		org.drip.spline.segment.LatentStateManifestSensitivity lsms = manifestSensitivity</span>
<span class="fc" id="L343">			(strManifestMeasure);</span>

<span class="pc bpc" id="L345" title="1 of 2 branches missed.">		if (null == lsms) return null;</span>

<span class="fc" id="L347">		int iCk = lsms.getPMSC().Ck();</span>

<span class="pc bpc" id="L349" title="1 of 2 branches missed.">		if (0 == iCk) return null;</span>

<span class="nc" id="L351">		double[] adblDBasisCoeffDPreceedingManifestTail = new double[iCk];</span>

<span class="nc bnc" id="L353" title="All 2 branches missed.">		for (int i = 0; i &lt; iCk; ++i)</span>
<span class="nc" id="L354">			adblDBasisCoeffDPreceedingManifestTail[i] = 0.;</span>

<span class="nc" id="L356">		return adblDBasisCoeffDPreceedingManifestTail;</span>
	}

	/**
	 * Set the Preceeding Manifest Sensitivity Control Parameters for the specified Manifest Measure
	 * 
	 * @param strManifestMeasure The Manifest Measure
	 * @param pmsc The Preceeding Manifest Sensitivity Control Instance
	 * 
	 * @return TRUE - Named Preceeding Manifest Sensitivity Control Instance Successfully Set
	 */

	public boolean setPreceedingManifestSensitivityControl (
		final java.lang.String strManifestMeasure,
		final org.drip.spline.params.PreceedingManifestSensitivityControl pmsc)
	{
<span class="pc bpc" id="L372" title="2 of 4 branches missed.">		if (null == strManifestMeasure || strManifestMeasure.isEmpty()) return false;</span>

		try {
<span class="fc" id="L375">			_mapLSMS.put (strManifestMeasure, new org.drip.spline.segment.LatentStateManifestSensitivity</span>
				(pmsc));

<span class="fc" id="L378">			return true;</span>
<span class="nc" id="L379">		} catch (java.lang.Exception e) {</span>
<span class="nc" id="L380">			e.printStackTrace();</span>
		}

<span class="nc" id="L383">		return false;</span>
	}

	/**
	 * Retrieve the Number of Parameters
	 * 
	 * @return The Number of Parameters
	 */

	public int numParameters()
	{
<span class="fc" id="L394">		return _sidc.Ck() + 2;</span>
	}

	/**
	 * Retrieve the Basis Evaluator
	 * 
	 * @return The Basis Evaluator
	 */

	public org.drip.spline.segment.BasisEvaluator basisEvaluator()
	{
<span class="fc" id="L405">		return _be;</span>
	}

	/**
	 * Retrieve the Array of Response Basis Coefficients
	 * 
	 * @return The Array of Response Basis Coefficients
	 */

	public double[] responseBasisCoefficient()
	{
<span class="nc" id="L416">		return _adblResponseBasisCoeff;</span>
	}

	/**
	 * Retrieve the Segment Inelastic Design Control
	 * 
	 * @return The Segment Inelastic Design Control
	 */

	public org.drip.spline.params.SegmentInelasticDesignControl designControl()
	{
<span class="nc" id="L427">		return _sidc;</span>
	}

	/**
	 * Main Calibrator: Calibrate the Segment State from the Calibration Parameter Set
	 * 
	 * @param ssciState The Segment State Calibration Inputs Set
	 * 
	 * @return TRUE - Calibration Successful
	 */

	public boolean calibrateState (
		final org.drip.spline.params.SegmentStateCalibrationInputs ssciState)
	{
<span class="pc bpc" id="L441" title="1 of 2 branches missed.">		if (null == ssciState) return false;</span>

<span class="fc" id="L443">		double[] adblPredictorOrdinate = ssciState.predictorOrdinates();</span>

<span class="fc" id="L445">		double[] adblResponseValue = ssciState.responseValues();</span>

<span class="fc" id="L447">		double[] adblLeftEdgeDeriv = ssciState.leftEdgeDeriv();</span>

<span class="fc" id="L449">		double[] adblRightEdgeDeriv = ssciState.rightEdgeDeriv();</span>

<span class="fc" id="L451">		org.drip.spline.params.SegmentBestFitResponse sbfr = ssciState.bestFitResponse();</span>

<span class="fc" id="L453">		org.drip.spline.params.SegmentBasisFlexureConstraint[] aSBFC = ssciState.flexureConstraint();</span>

<span class="fc" id="L455">		int iNumConstraint = 0;</span>
<span class="fc" id="L456">		int iNumResponseBasisCoeff = _adblResponseBasisCoeff.length;</span>
<span class="fc bfc" id="L457" title="All 2 branches covered.">		int iNumLeftDeriv = null == adblLeftEdgeDeriv ? 0 : adblLeftEdgeDeriv.length;</span>
<span class="fc bfc" id="L458" title="All 2 branches covered.">		int iNumRightDeriv = null == adblRightEdgeDeriv ? 0 : adblRightEdgeDeriv.length;</span>
<span class="fc" id="L459">		double[] adblPredictorResponseConstraintValue = new double[iNumResponseBasisCoeff];</span>
<span class="fc bfc" id="L460" title="All 2 branches covered.">		int iNumPredictorOrdinate = null == adblPredictorOrdinate ? 0 : adblPredictorOrdinate.length;</span>
<span class="fc" id="L461">		double[][] aadblResponseBasisCoeffConstraint = new</span>
			double[iNumResponseBasisCoeff][iNumResponseBasisCoeff];

<span class="fc bfc" id="L464" title="All 2 branches covered.">		if (null != aSBFC) {</span>
<span class="fc" id="L465">			int iNumPotentialConstraint = aSBFC.length;</span>

<span class="fc bfc" id="L467" title="All 2 branches covered.">			for (int i = 0; i &lt; iNumPotentialConstraint; ++i) {</span>
<span class="fc bfc" id="L468" title="All 2 branches covered.">				if (null != aSBFC[i]) ++iNumConstraint;</span>
			}
		}

<span class="pc bpc" id="L472" title="1 of 2 branches missed.">		if (iNumResponseBasisCoeff &lt; iNumPredictorOrdinate + iNumLeftDeriv + iNumRightDeriv + iNumConstraint)</span>
<span class="nc" id="L473">			return false;</span>

		try {
<span class="fc" id="L476">			org.drip.spline.segment.BestFitFlexurePenalizer bffp = new</span>
<span class="fc" id="L477">				org.drip.spline.segment.BestFitFlexurePenalizer (this, _sidc.curvaturePenaltyControl(),</span>
<span class="fc" id="L478">					_sidc.lengthPenaltyControl(), sbfr, _be);</span>

<span class="fc bfc" id="L480" title="All 2 branches covered.">			for (int j = 0; j &lt; iNumResponseBasisCoeff; ++j) {</span>
<span class="fc bfc" id="L481" title="All 2 branches covered.">				if (j &lt; iNumPredictorOrdinate)</span>
<span class="fc" id="L482">					adblPredictorResponseConstraintValue[j] = adblResponseValue[j];</span>
<span class="fc bfc" id="L483" title="All 2 branches covered.">				else if (j &lt; iNumPredictorOrdinate + iNumConstraint)</span>
<span class="fc" id="L484">					adblPredictorResponseConstraintValue[j] = aSBFC[j -</span>
<span class="fc" id="L485">					    iNumPredictorOrdinate].contraintValue();</span>
<span class="fc bfc" id="L486" title="All 2 branches covered.">				else if (j &lt; iNumPredictorOrdinate + iNumConstraint + iNumLeftDeriv)</span>
<span class="fc" id="L487">					adblPredictorResponseConstraintValue[j] = adblLeftEdgeDeriv[j - iNumPredictorOrdinate -</span>
					    iNumConstraint];
<span class="fc bfc" id="L489" title="All 2 branches covered.">				else if (j &lt; iNumPredictorOrdinate + iNumConstraint + iNumLeftDeriv + iNumRightDeriv)</span>
<span class="fc" id="L490">					adblPredictorResponseConstraintValue[j] = adblRightEdgeDeriv[j - iNumPredictorOrdinate -</span>
					    iNumConstraint - iNumLeftDeriv];
				else
<span class="fc" id="L493">					adblPredictorResponseConstraintValue[j] = bffp.basisPairPenaltyConstraint (j);</span>
			}

<span class="fc bfc" id="L496" title="All 2 branches covered.">			for (int i = 0; i &lt; iNumResponseBasisCoeff; ++i) {</span>
<span class="fc bfc" id="L497" title="All 2 branches covered.">				for (int l = 0; l &lt; iNumResponseBasisCoeff; ++l) {</span>
<span class="fc" id="L498">					double[] adblCalibBasisConstraintWeight = null;</span>

<span class="fc bfc" id="L500" title="All 6 branches covered.">					if (0 != iNumConstraint &amp;&amp; (l &gt;= iNumPredictorOrdinate &amp;&amp; l &lt; iNumPredictorOrdinate +</span>
						iNumConstraint))
<span class="fc" id="L502">						adblCalibBasisConstraintWeight = aSBFC[l -</span>
<span class="fc" id="L503">						    iNumPredictorOrdinate].responseBasisCoeffWeights();</span>

<span class="fc bfc" id="L505" title="All 2 branches covered.">					if (l &lt; iNumPredictorOrdinate)</span>
<span class="fc" id="L506">						aadblResponseBasisCoeffConstraint[l][i] = _be.shapedBasisFunctionResponse</span>
<span class="fc" id="L507">							(adblPredictorOrdinate[l], i);</span>
<span class="fc bfc" id="L508" title="All 2 branches covered.">					else if (l &lt; iNumPredictorOrdinate + iNumConstraint)</span>
<span class="fc" id="L509">						aadblResponseBasisCoeffConstraint[l][i] = adblCalibBasisConstraintWeight[i];</span>
<span class="fc bfc" id="L510" title="All 2 branches covered.">					else if (l &lt; iNumPredictorOrdinate + iNumConstraint + iNumLeftDeriv)</span>
<span class="fc" id="L511">						aadblResponseBasisCoeffConstraint[l][i] = _be.shapedBasisFunctionDerivative (left(),</span>
							l - iNumPredictorOrdinate - iNumConstraint + 1, i);
<span class="fc bfc" id="L513" title="All 2 branches covered.">					else if (l &lt; iNumPredictorOrdinate + iNumConstraint + iNumLeftDeriv + iNumRightDeriv)</span>
<span class="fc" id="L514">						aadblResponseBasisCoeffConstraint[l][i] = _be.shapedBasisFunctionDerivative</span>
<span class="fc" id="L515">							(right(), l - iNumPredictorOrdinate - iNumConstraint - iNumLeftDeriv + 1, i);</span>
					else
<span class="fc" id="L517">						aadblResponseBasisCoeffConstraint[l][i] = bffp.basisPairConstraintCoefficient (i, l);</span>
				}
			}
<span class="nc" id="L520">		} catch (java.lang.Exception e) {</span>
<span class="nc" id="L521">			e.printStackTrace();</span>

<span class="nc" id="L523">			return false;</span>
<span class="fc" id="L524">		}</span>

<span class="fc" id="L526">		org.drip.numerical.linearalgebra.LinearizationOutput lo =</span>
			org.drip.numerical.linearalgebra.LinearSystemSolver.SolveUsingMatrixInversion
<span class="fc" id="L528">				(aadblResponseBasisCoeffConstraint, adblPredictorResponseConstraintValue);</span>

<span class="fc bfc" id="L530" title="All 2 branches covered.">		if (null == lo) return false;</span>

<span class="fc" id="L532">		double[] adblCalibResponseBasisCoeff = lo.getTransformedRHS();</span>

<span class="pc bpc" id="L534" title="2 of 4 branches missed.">		if (null == adblCalibResponseBasisCoeff || adblCalibResponseBasisCoeff.length !=</span>
			iNumResponseBasisCoeff || null == (_aadblDResponseBasisCoeffDConstraint =
<span class="pc bpc" id="L536" title="3 of 6 branches missed.">				lo.getTransformedMatrix()) || _aadblDResponseBasisCoeffDConstraint.length !=</span>
					iNumResponseBasisCoeff || _aadblDResponseBasisCoeffDConstraint[0].length !=
						iNumResponseBasisCoeff)
<span class="nc" id="L539">			return false;</span>

<span class="fc bfc" id="L541" title="All 2 branches covered.">		for (int i = 0; i &lt; iNumResponseBasisCoeff; ++i) {</span>
<span class="pc bpc" id="L542" title="1 of 2 branches missed.">			if (!org.drip.numerical.common.NumberUtil.IsValid (_adblResponseBasisCoeff[i] =</span>
				adblCalibResponseBasisCoeff[i]))
<span class="nc" id="L544">				return false;</span>
		}

<span class="fc" id="L547">		return true;</span>
	}

	/**
	 * Sensitivity Calibrator: Calibrate the Segment Manifest Measure Jacobian from the Calibration Inputs
	 * 
	 * @param ssciManifestSensitivity The Segment Manifest Calibration Sensitivity Inputs
	 * @param aSBFCState Array of Segment State Basis Flexure Constraints
	 * 
	 * @return The Manifest Sensitivity Coefficients
	 */

	public double[] calibrateManifestJacobian (
		final org.drip.spline.params.SegmentStateCalibrationInputs ssciManifestSensitivity,
		final org.drip.spline.params.SegmentBasisFlexureConstraint[] aSBFCState)
	{
<span class="pc bpc" id="L563" title="1 of 2 branches missed.">		if (null == ssciManifestSensitivity) return null;</span>

<span class="fc" id="L565">		double[] adblPredictorOrdinate = ssciManifestSensitivity.predictorOrdinates();</span>

<span class="fc" id="L567">		double[] adblResponseValueManifestSensitivity = ssciManifestSensitivity.responseValues();</span>

<span class="fc" id="L569">		double[] adblLeftEdgeDerivManifestSensitivity = ssciManifestSensitivity.leftEdgeDeriv();</span>

<span class="fc" id="L571">		double[] adblRightEdgeDerivManifestSensitivity = ssciManifestSensitivity.rightEdgeDeriv();</span>

<span class="fc" id="L573">		org.drip.spline.params.SegmentBestFitResponse sbfrManifestSensitivity =</span>
<span class="fc" id="L574">			ssciManifestSensitivity.bestFitResponse();</span>

<span class="fc" id="L576">		org.drip.spline.params.SegmentBasisFlexureConstraint[] aSBFCManifestSensitivity =</span>
<span class="fc" id="L577">			ssciManifestSensitivity.flexureConstraint();</span>

<span class="fc" id="L579">		int iNumConstraint = 0;</span>
<span class="fc" id="L580">		int iNumResponseBasisCoeff = _adblResponseBasisCoeff.length;</span>
<span class="fc bfc" id="L581" title="All 2 branches covered.">		int iNumPredictorOrdinate = null == adblPredictorOrdinate ? 0 : adblPredictorOrdinate.length;</span>
<span class="fc" id="L582">		double[] adblPredictorResponseManifestSensitivityConstraint = new double[iNumResponseBasisCoeff];</span>
<span class="fc bfc" id="L583" title="All 2 branches covered.">		int iNumLeftDerivManifestSensitivity = null == adblLeftEdgeDerivManifestSensitivity ? 0 :</span>
			adblLeftEdgeDerivManifestSensitivity.length;
<span class="pc bpc" id="L585" title="1 of 2 branches missed.">		int iNumRightDerivManifestSensitivity = null == adblRightEdgeDerivManifestSensitivity ? 0 :</span>
			adblRightEdgeDerivManifestSensitivity.length;
<span class="fc" id="L587">		double[][] aadblResponseCoeffConstraintManifestSensitivity = new</span>
			double[iNumResponseBasisCoeff][iNumResponseBasisCoeff];

<span class="fc bfc" id="L590" title="All 2 branches covered.">		if (null != aSBFCState) {</span>
<span class="fc" id="L591">			int iNumPotentialConstraint = aSBFCState.length;</span>

<span class="fc bfc" id="L593" title="All 2 branches covered.">			for (int i = 0; i &lt; iNumPotentialConstraint; ++i) {</span>
<span class="pc bpc" id="L594" title="1 of 2 branches missed.">				if (null != aSBFCState[i]) ++iNumConstraint;</span>
			}
		}

<span class="pc bpc" id="L598" title="1 of 2 branches missed.">		if (iNumResponseBasisCoeff &lt; iNumPredictorOrdinate + iNumLeftDerivManifestSensitivity +</span>
			iNumRightDerivManifestSensitivity + iNumConstraint)
<span class="nc" id="L600">			return null;</span>

		try {
<span class="pc bpc" id="L603" title="1 of 2 branches missed.">			org.drip.spline.segment.BestFitFlexurePenalizer bffpManifestSensitivity = new</span>
				org.drip.spline.segment.BestFitFlexurePenalizer (this, null == _sidc ? null :
<span class="pc bpc" id="L605" title="1 of 2 branches missed.">					_sidc.curvaturePenaltyControl(), null == _sidc ? null : _sidc.lengthPenaltyControl(),</span>
						sbfrManifestSensitivity, _be);

<span class="fc bfc" id="L608" title="All 2 branches covered.">			for (int j = 0; j &lt; iNumResponseBasisCoeff; ++j) {</span>
<span class="fc bfc" id="L609" title="All 2 branches covered.">				if (j &lt; iNumPredictorOrdinate)</span>
<span class="fc" id="L610">					adblPredictorResponseManifestSensitivityConstraint[j] =</span>
						adblResponseValueManifestSensitivity[j];
<span class="fc bfc" id="L612" title="All 2 branches covered.">				else if (j &lt; iNumPredictorOrdinate + iNumConstraint) {</span>
<span class="fc" id="L613">					adblPredictorResponseManifestSensitivityConstraint[j] = 0.;</span>
<span class="fc" id="L614">					org.drip.spline.params.SegmentBasisFlexureConstraint sbfcManifestSensitivity =</span>
						aSBFCManifestSensitivity[j - iNumPredictorOrdinate];

<span class="pc bpc" id="L617" title="1 of 2 branches missed.">					if (null != sbfcManifestSensitivity) {</span>
<span class="fc" id="L618">						adblPredictorResponseManifestSensitivityConstraint[j] =</span>
<span class="fc" id="L619">							sbfcManifestSensitivity.contraintValue();</span>

<span class="fc" id="L621">						double[] adblCalibConstraintWeightManifestSensitivity =</span>
<span class="fc" id="L622">							sbfcManifestSensitivity.responseBasisCoeffWeights();</span>

<span class="fc bfc" id="L624" title="All 2 branches covered.">						for (int i = 0; i &lt; iNumResponseBasisCoeff; ++i)</span>
<span class="fc" id="L625">							adblPredictorResponseManifestSensitivityConstraint[j] -=</span>
								_adblResponseBasisCoeff[i] * adblCalibConstraintWeightManifestSensitivity[i];
					}
<span class="fc bfc" id="L628" title="All 2 branches covered.">				} else if (j &lt; iNumPredictorOrdinate + iNumConstraint + iNumLeftDerivManifestSensitivity)</span>
<span class="fc" id="L629">					adblPredictorResponseManifestSensitivityConstraint[j] =</span>
						adblLeftEdgeDerivManifestSensitivity[j - iNumPredictorOrdinate - iNumConstraint];
<span class="pc bpc" id="L631" title="1 of 2 branches missed.">				else if (j &lt; iNumPredictorOrdinate + iNumConstraint + iNumLeftDerivManifestSensitivity +</span>
					iNumRightDerivManifestSensitivity)
<span class="nc" id="L633">					adblPredictorResponseManifestSensitivityConstraint[j] =</span>
						adblRightEdgeDerivManifestSensitivity[j - iNumPredictorOrdinate - iNumConstraint -
						    iNumLeftDerivManifestSensitivity];
				else
<span class="fc" id="L637">					adblPredictorResponseManifestSensitivityConstraint[j] =</span>
<span class="fc" id="L638">						bffpManifestSensitivity.basisPairPenaltyConstraint (j);</span>
			}

<span class="fc bfc" id="L641" title="All 2 branches covered.">			for (int i = 0; i &lt; iNumResponseBasisCoeff; ++i) {</span>
<span class="fc bfc" id="L642" title="All 2 branches covered.">				for (int l = 0; l &lt; iNumResponseBasisCoeff; ++l) {</span>
<span class="fc" id="L643">					double[] adblCalibBasisConstraintWeight = null;</span>

<span class="fc bfc" id="L645" title="All 6 branches covered.">					if (0 != iNumConstraint &amp;&amp; (l &gt;= iNumPredictorOrdinate &amp;&amp; l &lt; iNumPredictorOrdinate +</span>
						iNumConstraint))
<span class="fc" id="L647">						adblCalibBasisConstraintWeight = aSBFCState[l -</span>
<span class="fc" id="L648">						    iNumPredictorOrdinate].responseBasisCoeffWeights();</span>

<span class="fc bfc" id="L650" title="All 2 branches covered.">					if (l &lt; iNumPredictorOrdinate)</span>
<span class="fc" id="L651">						aadblResponseCoeffConstraintManifestSensitivity[l][i] =</span>
<span class="fc" id="L652">							_be.shapedBasisFunctionResponse (adblPredictorOrdinate[l], i);</span>
<span class="fc bfc" id="L653" title="All 2 branches covered.">					else if (l &lt; iNumPredictorOrdinate + iNumConstraint)</span>
<span class="fc" id="L654">						aadblResponseCoeffConstraintManifestSensitivity[l][i] =</span>
							adblCalibBasisConstraintWeight[i];
<span class="fc bfc" id="L656" title="All 2 branches covered.">					else if (l &lt; iNumPredictorOrdinate + iNumConstraint + iNumLeftDerivManifestSensitivity)</span>
<span class="fc" id="L657">						aadblResponseCoeffConstraintManifestSensitivity[l][i] =</span>
<span class="fc" id="L658">							_be.shapedBasisFunctionDerivative (left(), l - iNumPredictorOrdinate -</span>
								iNumConstraint + 1, i);
<span class="pc bpc" id="L660" title="1 of 2 branches missed.">					else if (l &lt; iNumPredictorOrdinate + iNumConstraint + iNumLeftDerivManifestSensitivity +</span>
						iNumRightDerivManifestSensitivity)
<span class="nc" id="L662">						aadblResponseCoeffConstraintManifestSensitivity[l][i] =</span>
<span class="nc" id="L663">							_be.shapedBasisFunctionDerivative (right(), l - iNumPredictorOrdinate -</span>
								iNumConstraint - iNumLeftDerivManifestSensitivity + 1, i);
					else
<span class="fc" id="L666">						aadblResponseCoeffConstraintManifestSensitivity[l][i] =</span>
<span class="fc" id="L667">							bffpManifestSensitivity.basisPairConstraintCoefficient (i, l);</span>
				}
			}
<span class="nc" id="L670">		} catch (java.lang.Exception e) {</span>
<span class="nc" id="L671">			e.printStackTrace();</span>

<span class="nc" id="L673">			return null;</span>
<span class="fc" id="L674">		}</span>

<span class="fc" id="L676">		org.drip.numerical.linearalgebra.LinearizationOutput lo =</span>
			org.drip.numerical.linearalgebra.LinearSystemSolver.SolveUsingMatrixInversion
<span class="fc" id="L678">				(aadblResponseCoeffConstraintManifestSensitivity,</span>
					adblPredictorResponseManifestSensitivityConstraint);

<span class="pc bpc" id="L681" title="1 of 2 branches missed.">		return null == lo ? null : lo.getTransformedRHS();</span>
	}

	/**
	 * Sensitivity Calibrator: Calibrate the Segment Local Manifest Jacobian from the Calibration Parameter
	 * 	Set
	 * 
	 * @param strManifestMeasure Latent State Manifest Measure
	 * @param ssciManifestSensitivity The Segment Manifest Calibration Parameter Sensitivity
	 * @param aSBFCState Array of Segment State Basis Flexure Constraints
	 * 
	 * @return TRUE - Local Manifest Sensitivity Calibration Successful
	 */

	public boolean calibrateLocalManifestJacobian (
		final java.lang.String strManifestMeasure,
		final org.drip.spline.params.SegmentStateCalibrationInputs ssciManifestSensitivity,
		final org.drip.spline.params.SegmentBasisFlexureConstraint[] aSBFCState)
	{
<span class="fc" id="L700">		org.drip.spline.segment.LatentStateManifestSensitivity lsms = manifestSensitivity</span>
<span class="fc" id="L701">			(strManifestMeasure);</span>

<span class="pc bpc" id="L703" title="1 of 2 branches missed.">		if (null == lsms) return false;</span>

<span class="fc" id="L705">		double[] adblDBasisCoeffDLocalManifest = calibrateManifestJacobian (ssciManifestSensitivity,</span>
			aSBFCState);

<span class="pc bpc" id="L708" title="2 of 4 branches missed.">		return null == adblDBasisCoeffDLocalManifest || adblDBasisCoeffDLocalManifest.length !=</span>
			_adblResponseBasisCoeff.length ? false : lsms.setDBasisCoeffDLocalManifest
<span class="fc" id="L710">				(adblDBasisCoeffDLocalManifest);</span>
	}

	/**
	 * Sensitivity Calibrator: Calibrate the Segment Preceeding Manifest Jacobian from the Calibration
	 *	Parameter Set
	 * 
	 * @param strManifestMeasure Latent State Manifest
	 * @param ssciPreceedingManifestSensitivity The Segment Preceeding Manifest Calibration Parameter
	 * 	Sensitivity
	 * 
	 * @return TRUE - Preceeding Manifest Sensitivity Calibration Successful
	 */

	public boolean calibratePreceedingManifestJacobian (
		final java.lang.String strManifestMeasure,
		final org.drip.spline.params.SegmentStateCalibrationInputs ssciPreceedingManifestSensitivity)
	{
<span class="fc" id="L728">		org.drip.spline.segment.LatentStateManifestSensitivity lsms = manifestSensitivity</span>
<span class="fc" id="L729">			(strManifestMeasure);</span>

<span class="pc bpc" id="L731" title="1 of 2 branches missed.">		if (null == lsms) return false;</span>

<span class="fc" id="L733">		double[] adblDBasisCoeffDPreceedingManifest = calibrateManifestJacobian</span>
<span class="fc" id="L734">			(ssciPreceedingManifestSensitivity, null);</span>

<span class="pc bpc" id="L736" title="2 of 4 branches missed.">		return null == adblDBasisCoeffDPreceedingManifest || adblDBasisCoeffDPreceedingManifest.length !=</span>
			_adblResponseBasisCoeff.length ? false : lsms.setDBasisCoeffDPreceedingManifest
<span class="fc" id="L738">				(adblDBasisCoeffDPreceedingManifest);</span>
	}

	/**
	 * Calibrate the coefficients from the prior Predictor/Response Segment, the Constraint, and fitness
	 * 	Weights
	 * 
	 * @param csPreceeding Preceeding Predictor/Response Segment
	 * @param srvcState The Segment State Response Value Constraint
	 * @param sbfrState Segment's Best Fit Weighted State Response Values
	 * 
	 * @return TRUE - If the calibration succeeds
	 */

	public boolean calibrate (
		final org.drip.spline.segment.LatentStateResponseModel csPreceeding,
		final org.drip.spline.params.SegmentResponseValueConstraint srvcState,
		final org.drip.spline.params.SegmentBestFitResponse sbfrState)
	{
<span class="fc" id="L757">		int iCk = _sidc.Ck();</span>

<span class="fc bfc" id="L759" title="All 2 branches covered.">		org.drip.spline.params.SegmentBasisFlexureConstraint[] aSBFCState = null == srvcState ? null : new</span>
			org.drip.spline.params.SegmentBasisFlexureConstraint[] {srvcState.responseIndexedBasisConstraint
<span class="fc" id="L761">				(_be, this)};</span>

<span class="fc" id="L763">		double[] adblManifestJacobianDerivAtLeftOrdinate = null;</span>

<span class="fc bfc" id="L765" title="All 2 branches covered.">		if (0 != iCk) {</span>
<span class="fc" id="L766">			adblManifestJacobianDerivAtLeftOrdinate = new double[iCk];</span>

<span class="fc bfc" id="L768" title="All 2 branches covered.">			for (int i = 0; i &lt; iCk; ++i)</span>
<span class="fc" id="L769">				adblManifestJacobianDerivAtLeftOrdinate[i] = 0.;</span>
		}

<span class="pc bpc" id="L772" title="1 of 2 branches missed.">		if (null == csPreceeding) {</span>
			try {
<span class="nc" id="L774">				double[] adblStateDerivAtLeftOrdinate = null;</span>

<span class="nc bnc" id="L776" title="All 2 branches missed.">				if (0 != iCk) {</span>
<span class="nc" id="L777">					adblStateDerivAtLeftOrdinate = new double[iCk];</span>

<span class="nc bnc" id="L779" title="All 2 branches missed.">					for (int i = 0; i &lt; iCk; ++i)</span>
<span class="nc" id="L780">						adblStateDerivAtLeftOrdinate[i] = _be.responseValueDerivative</span>
<span class="nc" id="L781">							(_adblResponseBasisCoeff, left(), i);</span>
				}

<span class="nc" id="L784">				return calibrateState (new org.drip.spline.params.SegmentStateCalibrationInputs (new double[]</span>
<span class="nc" id="L785">					{left()}, new double[] {_be.responseValue (_adblResponseBasisCoeff, left())},</span>
						adblStateDerivAtLeftOrdinate, null, aSBFCState, sbfrState));
<span class="nc" id="L787">			} catch (java.lang.Exception e) {</span>
<span class="nc" id="L788">				e.printStackTrace();</span>
			}

<span class="nc" id="L791">			return false;</span>
		}

		try {
<span class="fc" id="L795">			return calibrateState (new org.drip.spline.params.SegmentStateCalibrationInputs (new double[]</span>
<span class="fc bfc" id="L796" title="All 2 branches covered.">				{left()}, new double[] {csPreceeding.responseValue (left())}, 0 == iCk ? null :</span>
<span class="fc" id="L797">					transmissionCk (left(), csPreceeding, iCk), null, aSBFCState, sbfrState));</span>
<span class="nc" id="L798">		} catch (java.lang.Exception e) {</span>
<span class="nc" id="L799">			e.printStackTrace();</span>
		}

<span class="nc" id="L802">		return false;</span>
	}

	/**
	 * Calibrate the coefficients from the prior Segment and the Response Value at the Right Predictor
	 *  Ordinate
	 * 
	 * @param csPreceeding Preceeding Predictor/Response Segment
	 * @param dblRightStateValue Response Value at the Right Predictor Ordinate
	 * @param sbfrState Segment's Best Fit Weighted Response Values
	 * 
	 * @return TRUE - If the calibration succeeds
	 */

	public boolean calibrate (
		final LatentStateResponseModel csPreceeding,
		final double dblRightStateValue,
		final org.drip.spline.params.SegmentBestFitResponse sbfrState)
	{
<span class="pc bpc" id="L821" title="1 of 2 branches missed.">		if (null == csPreceeding) return false;</span>

<span class="fc" id="L823">		int iCk = _sidc.Ck();</span>

		try {
<span class="fc" id="L826">			return calibrateState (new org.drip.spline.params.SegmentStateCalibrationInputs (new double[]</span>
<span class="fc bfc" id="L827" title="All 2 branches covered.">				{left(), right()}, new double[] {csPreceeding.responseValue (left()), dblRightStateValue}, 0</span>
<span class="fc" id="L828">					!= iCk ? csPreceeding.transmissionCk (left(), this, iCk) : null, null, null, sbfrState));</span>
<span class="nc" id="L829">		} catch (java.lang.Exception e) {</span>
<span class="nc" id="L830">			e.printStackTrace();</span>
		}

<span class="nc" id="L833">		return false;</span>
	}

	/**
	 * Calibrate the Coefficients from the Edge Response Values and the Left Edge Response Slope
	 * 
	 * @param dblLeftValue Left Edge Response Value
	 * @param dblLeftSlope Left Edge Response Slope
	 * @param dblRightValue Right Edge Response Value
	 * @param sbfrState Segment's Best Fit Weighted Response Values
	 * 
	 * @return TRUE - The Calibration Succeeded
	 */

	public boolean calibrate (
		final double dblLeftValue,
		final double dblLeftSlope,
		final double dblRightValue,
		final org.drip.spline.params.SegmentBestFitResponse sbfrState)
	{
<span class="pc bpc" id="L853" title="1 of 2 branches missed.">		if (!org.drip.numerical.common.NumberUtil.IsValid (dblLeftValue) ||</span>
<span class="pc bpc" id="L854" title="1 of 2 branches missed.">			!org.drip.numerical.common.NumberUtil.IsValid (dblLeftSlope) ||</span>
<span class="pc bpc" id="L855" title="1 of 2 branches missed.">				!org.drip.numerical.common.NumberUtil.IsValid (dblRightValue))</span>
<span class="nc" id="L856">			return false;</span>

		try {
<span class="fc" id="L859">			return calibrateState (new org.drip.spline.params.SegmentStateCalibrationInputs (new double[]</span>
<span class="fc" id="L860">				{left(), right()}, new double[] {dblLeftValue, dblRightValue},</span>
<span class="fc" id="L861">					org.drip.numerical.common.CollectionUtil.DerivArrayFromSlope (numParameters() - 2,</span>
						dblLeftSlope), null, null, sbfrState));
<span class="nc" id="L863">		} catch (java.lang.Exception e) {</span>
<span class="nc" id="L864">			e.printStackTrace();</span>
		}

<span class="nc" id="L867">		return false;</span>
	}

	/**
	 * Calibrate the coefficients from the Left Edge Response Value Constraint, the Left Edge Response Value
	 *  Slope, and the Right Edge Response Value Constraint
	 * 
	 * @param wrvcStateLeft Left Edge Response Value Constraint
	 * @param dblLeftSlope Left Edge Response Value Slope
	 * @param wrvcStateRight Right Edge Response Value Constraint
	 * @param sbfrState Segment's Best Fit Weighted Response
	 * 
	 * @return TRUE - If the calibration succeeds
	 */

	public boolean calibrate (
		final org.drip.spline.params.SegmentResponseValueConstraint wrvcStateLeft,
		final double dblLeftSlope,
		final org.drip.spline.params.SegmentResponseValueConstraint wrvcStateRight,
		final org.drip.spline.params.SegmentBestFitResponse sbfrState)
	{
<span class="fc" id="L888">		org.drip.spline.params.SegmentBasisFlexureConstraint[] aSBFCState = null;</span>

		try {
<span class="pc bpc" id="L891" title="1 of 4 branches missed.">			if (null != wrvcStateLeft || null != wrvcStateRight)</span>
<span class="pc bpc" id="L892" title="1 of 2 branches missed.">				aSBFCState = new org.drip.spline.params.SegmentBasisFlexureConstraint[] {null ==</span>
<span class="fc bfc" id="L893" title="All 2 branches covered.">					wrvcStateLeft ? null : wrvcStateLeft.responseIndexedBasisConstraint (_be, this), null ==</span>
<span class="fc" id="L894">						wrvcStateRight ? null : wrvcStateRight.responseIndexedBasisConstraint (_be, this)};</span>

<span class="fc" id="L896">			return calibrateState (new org.drip.spline.params.SegmentStateCalibrationInputs (null, null,</span>
<span class="fc" id="L897">				org.drip.numerical.common.CollectionUtil.DerivArrayFromSlope (numParameters() - 2, dblLeftSlope),</span>
					null, aSBFCState, sbfrState));
<span class="nc" id="L899">		} catch (java.lang.Exception e) {</span>
<span class="nc" id="L900">			e.printStackTrace();</span>
		}

<span class="nc" id="L903">		return false;</span>
	}

	/**
	 * Compute the Local and the Preceeding Manifest Measure Sensitivity Coefficients from the Preceeding
	 * 	Segment, the Local Response Value, the Local Response Value Manifest Measure Sensitivity, and the
	 * 	Local Best Fit Response Sensitivity
	 * 
	 * @param csPreceeding Preceeding Predictor/Response Segment
	 * @param strManifestMeasure Manifest Measure whose Sensitivity is sought
	 * @param srvcState The Segment State Response Value Constraint
	 * @param srvcManifestSensitivity The Segment State Response Value Constraint Manifest Sensitivity
	 * @param sbfrManifestSensitivity Segment's Best Fit Weighted State Response Value Manifest Sensitivity
	 * 
	 * @return TRUE - If the calibration succeeds
	 */

	public boolean manifestMeasureSensitivity (
		final org.drip.spline.segment.LatentStateResponseModel csPreceeding,
		final java.lang.String strManifestMeasure,
		final org.drip.spline.params.SegmentResponseValueConstraint srvcState,
		final org.drip.spline.params.SegmentResponseValueConstraint srvcManifestSensitivity,
		final org.drip.spline.params.SegmentBestFitResponse sbfrManifestSensitivity)
	{
<span class="pc bpc" id="L927" title="3 of 4 branches missed.">		if (null == srvcState &amp;&amp; null != srvcManifestSensitivity) return false;</span>

<span class="pc bpc" id="L929" title="1 of 2 branches missed.">		org.drip.spline.params.SegmentBasisFlexureConstraint[] aSBFCState = null == srvcState ? null : new</span>
			org.drip.spline.params.SegmentBasisFlexureConstraint[] {srvcState.responseIndexedBasisConstraint
<span class="fc" id="L931">				(_be, this)};</span>

<span class="pc bpc" id="L933" title="1 of 2 branches missed.">		org.drip.spline.params.SegmentBasisFlexureConstraint[] aSBFCManifestSensitivity = null ==</span>
			srvcManifestSensitivity ? null : new org.drip.spline.params.SegmentBasisFlexureConstraint[]
<span class="fc" id="L935">				{srvcManifestSensitivity.responseIndexedBasisConstraint (_be, this)};</span>

<span class="fc" id="L937">		double[] adblManifestJacobianDerivAtLeftOrdinate = null;</span>

<span class="fc" id="L939">		int iCk = _sidc.Ck();</span>

<span class="fc bfc" id="L941" title="All 2 branches covered.">		if (0 != iCk) {</span>
<span class="fc" id="L942">			adblManifestJacobianDerivAtLeftOrdinate = new double[iCk];</span>

<span class="fc bfc" id="L944" title="All 2 branches covered.">			for (int i = 0; i &lt; iCk; ++i)</span>
<span class="fc" id="L945">				adblManifestJacobianDerivAtLeftOrdinate[i] = 0.;</span>
		}

<span class="pc bpc" id="L948" title="1 of 2 branches missed.">		if (null == csPreceeding) return false;</span>

		try {
<span class="pc bpc" id="L951" title="1 of 2 branches missed.">			if (null == aSBFCManifestSensitivity) return true;</span>

<span class="pc bpc" id="L953" title="1 of 2 branches missed.">			if (!calibrateLocalManifestJacobian (strManifestMeasure, new</span>
<span class="fc" id="L954">				org.drip.spline.params.SegmentStateCalibrationInputs (new double[] {left()}, new double[]</span>
					{0.}, adblManifestJacobianDerivAtLeftOrdinate, null, aSBFCManifestSensitivity,
						sbfrManifestSensitivity), aSBFCState))
<span class="nc" id="L957">				return false;</span>

<span class="fc" id="L959">			org.drip.spline.segment.LatentStateManifestSensitivity lsms = manifestSensitivity</span>
<span class="fc" id="L960">				(strManifestMeasure);</span>

<span class="pc bpc" id="L962" title="1 of 2 branches missed.">			if (null == lsms) return true;</span>

<span class="pc bpc" id="L964" title="1 of 2 branches missed.">			return lsms.getPMSC().impactFade() ? calibratePreceedingManifestJacobian (strManifestMeasure, new</span>
<span class="fc" id="L965">				org.drip.spline.params.SegmentStateCalibrationInputs (new double[] {left(), right()}, new</span>
<span class="fc" id="L966">					double[] {csPreceeding.calcDResponseDManifest (strManifestMeasure, left(), 1), 0.}, null,</span>
<span class="fc" id="L967">						CkDBasisCoeffDPreceedingManifestMeasure (strManifestMeasure), null, null)) :</span>
<span class="nc" id="L968">							lsms.setDResponseDPreceedingManifest (csPreceeding.calcDResponseDManifest</span>
<span class="nc" id="L969">								(strManifestMeasure, left(), 1));</span>
<span class="nc" id="L970">		} catch (java.lang.Exception e) {</span>
<span class="nc" id="L971">			e.printStackTrace();</span>
		}

<span class="nc" id="L974">		return false;</span>
	}

	/**
	 * Compute the Local and the Preceeding Manifest Measure Sensitivity Coefficients from the Preceeding
	 * 	Segments, the Local Response Value Sensitivity at the Right Predictor Ordinate, and the Local Best
	 * 	Fit Response Sensitivity
	 * 
	 * @param csPreceeding Preceeding Predictor/Response Segment
	 * @param strManifestMeasure Manifest Measure whose Sensitivity is sought
	 * @param dblRightStateManifestSensitivity Response Value Manifest Sensitivity at the Right Predictor
	 * 	Ordinate
	 * @param sbfrManifestSensitivity Segment's Best Fit Weighted Response Value Manifest Sensitivity
	 * 
	 * @return TRUE - If the calibration succeeds
	 */

	public boolean manifestMeasureSensitivity (
		final LatentStateResponseModel csPreceeding,
		final java.lang.String strManifestMeasure,
		final double dblRightStateManifestSensitivity,
		final org.drip.spline.params.SegmentBestFitResponse sbfrManifestSensitivity)
	{
<span class="pc bpc" id="L997" title="1 of 2 branches missed.">		if (null == csPreceeding) return false;</span>

<span class="fc" id="L999">		int iCk = _sidc.Ck();</span>

		try {
<span class="fc" id="L1002">			double[] adblManifestJacobianDerivAtLeftOrdinate = null;</span>

<span class="fc bfc" id="L1004" title="All 2 branches covered.">			if (0 != iCk) {</span>
<span class="fc" id="L1005">				adblManifestJacobianDerivAtLeftOrdinate = new double[iCk];</span>

<span class="fc bfc" id="L1007" title="All 2 branches covered.">				for (int i = 0; i &lt; iCk; ++i)</span>
<span class="fc" id="L1008">					adblManifestJacobianDerivAtLeftOrdinate[i] = 0.;</span>
			}

<span class="pc bpc" id="L1011" title="1 of 2 branches missed.">			if (!org.drip.numerical.common.NumberUtil.IsValid (dblRightStateManifestSensitivity)) return true;</span>

<span class="nc bnc" id="L1013" title="All 2 branches missed.">			if (!calibrateLocalManifestJacobian (strManifestMeasure, new</span>
<span class="nc bnc" id="L1014" title="All 2 branches missed.">				org.drip.spline.params.SegmentStateCalibrationInputs (new double[] {left(), right()}, new</span>
					double[] {0., dblRightStateManifestSensitivity}, 0 != iCk ?
						adblManifestJacobianDerivAtLeftOrdinate : null, null, null, sbfrManifestSensitivity),
							null))
<span class="nc" id="L1018">				return false;</span>

<span class="nc" id="L1020">			org.drip.spline.segment.LatentStateManifestSensitivity lsms = manifestSensitivity</span>
<span class="nc" id="L1021">				(strManifestMeasure);</span>

<span class="nc bnc" id="L1023" title="All 2 branches missed.">			if (null == lsms) return true;</span>

<span class="nc bnc" id="L1025" title="All 2 branches missed.">			return lsms.getPMSC().impactFade() ? calibratePreceedingManifestJacobian (strManifestMeasure, new</span>
<span class="nc" id="L1026">				org.drip.spline.params.SegmentStateCalibrationInputs (new double[] {left(), right()}, new</span>
<span class="nc" id="L1027">					double[] {csPreceeding.calcDResponseDManifest (strManifestMeasure, left(), 1), 0.}, null,</span>
<span class="nc" id="L1028">						CkDBasisCoeffDPreceedingManifestMeasure (strManifestMeasure), null, null)) :</span>
<span class="nc" id="L1029">							lsms.setDResponseDPreceedingManifest (csPreceeding.calcDResponseDManifest</span>
<span class="nc" id="L1030">								(strManifestMeasure, left(), 1));</span>
<span class="nc" id="L1031">		} catch (java.lang.Exception e) {</span>
<span class="nc" id="L1032">			e.printStackTrace();</span>
		}

<span class="nc" id="L1035">		return false;</span>
	}

	/**
	 * Compute the Local and the Preceeding Manifest Measure Sensitivity Coefficients from the Local
	 * 	Response Value Sensitivity at the Left/Right Predictor Ordinate, the Local Left Response Value
	 * 	Sensitivity Slope, and the Local Best Fit Response Sensitivity.
	 * 
	 * @param strManifestMeasure Manifest Measure whose Sensitivity is sought
	 * @param dblLeftManifestSensitivity Left Edge Response Value Manifest Sensitivity
	 * @param dblLeftSlopeManifestSensitivity Left Edge Response Slope Manifest Sensitivity
	 * @param dblRightManifestSensitivity Right Edge Response Value Manifest Sensitivity
	 * @param sbfrManifestSensitivity Segment's Best Fit Weighted Response Values Manifest Sensitivity
	 * 
	 * @return TRUE - The Calibration Succeeded
	 */

	public boolean manifestMeasureSensitivity (
		final java.lang.String strManifestMeasure,
		final double dblLeftManifestSensitivity,
		final double dblLeftSlopeManifestSensitivity,
		final double dblRightManifestSensitivity,
		final org.drip.spline.params.SegmentBestFitResponse sbfrManifestSensitivity)
	{
		try {
<span class="nc bnc" id="L1060" title="All 2 branches missed.">			return org.drip.numerical.common.NumberUtil.IsValid (dblLeftManifestSensitivity) &amp;&amp;</span>
<span class="nc bnc" id="L1061" title="All 2 branches missed.">				org.drip.numerical.common.NumberUtil.IsValid (dblLeftSlopeManifestSensitivity) &amp;&amp;</span>
<span class="nc bnc" id="L1062" title="All 2 branches missed.">					org.drip.numerical.common.NumberUtil.IsValid (dblRightManifestSensitivity) ?</span>
<span class="nc" id="L1063">						calibrateLocalManifestJacobian (strManifestMeasure, new</span>
<span class="nc" id="L1064">							org.drip.spline.params.SegmentStateCalibrationInputs (new double[] {left(),</span>
<span class="nc" id="L1065">								right()}, new double[] {dblLeftManifestSensitivity,</span>
									dblRightManifestSensitivity},
										org.drip.numerical.common.CollectionUtil.DerivArrayFromSlope
<span class="nc" id="L1068">											(numParameters() - 2, dblLeftSlopeManifestSensitivity), null,</span>
												null, sbfrManifestSensitivity), null) : true;
<span class="nc" id="L1070">		} catch (java.lang.Exception e) {</span>
<span class="nc" id="L1071">			e.printStackTrace();</span>
		}

<span class="nc" id="L1074">		return false;</span>
	}

	/**
	 * Compute the Local and the Preceeding Manifest Measure Sensitivity Coefficients from the Local
	 * 	Response Value/Sensitivity Constraints at the Left/Right Predictor Ordinate, the Local Left
	 * 	Response Value Sensitivity Slope, and the Local Best Fit Response Sensitivity
	 * 
	 * @param strManifestMeasure Manifest Measure whose Sensitivity is sought
	 * @param wrvcStateLeft Left Edge Response Value Constraint
	 * @param wrvcStateRight Right Edge Response Value Constraint
	 * @param dblLeftSlopeManifestSensitivity Left Edge Response Value Slope Manifest Sensitivity
	 * @param wrvcStateLeftManifestSensitivity Left Edge Response Value Constraint Manifest Sensitivity
	 * @param wrvcStateRightManifestSensitivity Right Edge Response Value Constraint Manifest Sensitivity
	 * @param sbfrManifestSensitivity Segment's Best Fit Weighted Response Manifest Sensitivity
	 * 
	 * @return TRUE - If the calibration succeeds
	 */

	public boolean manifestMeasureSensitivity (
		final java.lang.String strManifestMeasure,
		final org.drip.spline.params.SegmentResponseValueConstraint wrvcStateLeft,
		final org.drip.spline.params.SegmentResponseValueConstraint wrvcStateRight,
		final double dblLeftSlopeManifestSensitivity,
		final org.drip.spline.params.SegmentResponseValueConstraint wrvcStateLeftManifestSensitivity,
		final org.drip.spline.params.SegmentResponseValueConstraint wrvcStateRightManifestSensitivity,
		final org.drip.spline.params.SegmentBestFitResponse sbfrManifestSensitivity)
	{
<span class="fc" id="L1102">		org.drip.spline.params.SegmentBasisFlexureConstraint[] aSBFCState = null;</span>
<span class="fc" id="L1103">		org.drip.spline.params.SegmentBasisFlexureConstraint[] aSBFCManifestSensitivity = null;</span>

		try {
<span class="pc bpc" id="L1106" title="3 of 4 branches missed.">			if (null != wrvcStateLeft || null != wrvcStateRight)</span>
<span class="pc bpc" id="L1107" title="1 of 2 branches missed.">				aSBFCState = new org.drip.spline.params.SegmentBasisFlexureConstraint[] {null ==</span>
<span class="pc bpc" id="L1108" title="1 of 2 branches missed.">					wrvcStateLeft ? null : wrvcStateLeft.responseIndexedBasisConstraint (_be, this), null ==</span>
<span class="fc" id="L1109">						wrvcStateRight ? null : wrvcStateRight.responseIndexedBasisConstraint (_be, this)};</span>

<span class="pc bpc" id="L1111" title="3 of 4 branches missed.">			if (null != wrvcStateLeftManifestSensitivity || null != wrvcStateRightManifestSensitivity)</span>
<span class="pc bpc" id="L1112" title="1 of 2 branches missed.">				aSBFCManifestSensitivity = new org.drip.spline.params.SegmentBasisFlexureConstraint[] {null</span>
					== wrvcStateLeftManifestSensitivity ? null :
<span class="pc bpc" id="L1114" title="1 of 2 branches missed.">						wrvcStateLeftManifestSensitivity.responseIndexedBasisConstraint (_be, this), null ==</span>
							wrvcStateRightManifestSensitivity ? null :
<span class="fc" id="L1116">								wrvcStateRightManifestSensitivity.responseIndexedBasisConstraint (_be,</span>
									this)};

<span class="pc bpc" id="L1119" title="1 of 2 branches missed.">			return null == aSBFCManifestSensitivity ? true : calibrateLocalManifestJacobian</span>
<span class="fc" id="L1120">				(strManifestMeasure, new org.drip.spline.params.SegmentStateCalibrationInputs (null, null,</span>
<span class="fc" id="L1121">					org.drip.numerical.common.CollectionUtil.DerivArrayFromSlope (numParameters() - 2,</span>
						dblLeftSlopeManifestSensitivity), null, aSBFCManifestSensitivity,
							sbfrManifestSensitivity), aSBFCState);
<span class="nc" id="L1124">		} catch (java.lang.Exception e) {</span>
<span class="nc" id="L1125">			e.printStackTrace();</span>
		}

<span class="nc" id="L1128">		return false;</span>
	}

	/**
	 * Retrieve the Segment Curvature DPE
	 * 
	 * @return The Segment Curvature DPE
	 * 
	 * @throws java.lang.Exception Thrown if the Segment Curvature DPE cannot be computed
	 */

	public double curvatureDPE()
		throws java.lang.Exception
	{
<span class="fc" id="L1142">		double dblDPE = 0.;</span>

<span class="fc" id="L1144">		int iNumBasis = _be.numBasis();</span>

<span class="fc" id="L1146">		org.drip.spline.params.SegmentFlexurePenaltyControl sfpc = _sidc.curvaturePenaltyControl();</span>

<span class="pc bpc" id="L1148" title="1 of 2 branches missed.">		if (null == sfpc) sfpc = new org.drip.spline.params.SegmentFlexurePenaltyControl (2, 1.);</span>

<span class="fc" id="L1150">		org.drip.spline.segment.BestFitFlexurePenalizer bffp = new</span>
			org.drip.spline.segment.BestFitFlexurePenalizer (this, sfpc, null, null, _be);

<span class="fc bfc" id="L1153" title="All 2 branches covered.">		for (int i = 0; i &lt; iNumBasis; ++i) {</span>
<span class="fc bfc" id="L1154" title="All 2 branches covered.">			for (int j = 0; j &lt; iNumBasis; ++j)</span>
<span class="fc" id="L1155">				dblDPE += _adblResponseBasisCoeff[i] * _adblResponseBasisCoeff[j] *</span>
<span class="fc" id="L1156">					bffp.basisPairCurvaturePenalty (i, j);</span>
		}

<span class="fc" id="L1159">		return sfpc.amplitude() * dblDPE;</span>
	}

	/**
	 * Retrieve the Segment Length DPE
	 * 
	 * @return The Segment Length DPE
	 * 
	 * @throws java.lang.Exception Thrown if the Segment Length DPE cannot be computed
	 */

	public double lengthDPE()
		throws java.lang.Exception
	{
<span class="fc" id="L1173">		double dblDPE = 0.;</span>

<span class="fc" id="L1175">		int iNumBasis = _be.numBasis();</span>

<span class="fc" id="L1177">		org.drip.spline.params.SegmentFlexurePenaltyControl sfpcLength = _sidc.lengthPenaltyControl();</span>

<span class="pc bpc" id="L1179" title="1 of 2 branches missed.">		if (null == sfpcLength) sfpcLength = new org.drip.spline.params.SegmentFlexurePenaltyControl (1, 1.);</span>

<span class="fc" id="L1181">		org.drip.spline.segment.BestFitFlexurePenalizer bffp = new</span>
			org.drip.spline.segment.BestFitFlexurePenalizer (this, null, sfpcLength, null, _be);

<span class="fc bfc" id="L1184" title="All 2 branches covered.">		for (int i = 0; i &lt; iNumBasis; ++i) {</span>
<span class="fc bfc" id="L1185" title="All 2 branches covered.">			for (int j = 0; j &lt; iNumBasis; ++j)</span>
<span class="fc" id="L1186">				dblDPE += _adblResponseBasisCoeff[i] * _adblResponseBasisCoeff[j] *</span>
<span class="fc" id="L1187">					bffp.basisPairLengthPenalty (i, j);</span>
		}

<span class="fc" id="L1190">		return sfpcLength.amplitude() * dblDPE;</span>
	}

	/**
	 * Retrieve the Segment Best Fit DPE
	 * 
	 * @param sbfr The Segment's Best Fit Response Inputs
	 * 
	 * @return The Segment Best Fit DPE
	 * 
	 * @throws java.lang.Exception Thrown if the Segment Best Fit DPE cannot be computed
	 */

	public double bestFitDPE (
		final org.drip.spline.params.SegmentBestFitResponse sbfr)
		throws java.lang.Exception
	{
<span class="fc bfc" id="L1207" title="All 2 branches covered.">		if (null == sbfr) return 0.;</span>

<span class="fc" id="L1209">		double dblDPE = 0.;</span>

<span class="fc" id="L1211">		int iNumBasis = _be.numBasis();</span>

<span class="fc" id="L1213">		org.drip.spline.segment.BestFitFlexurePenalizer bffp = new</span>
			org.drip.spline.segment.BestFitFlexurePenalizer (this, null, null, sbfr, _be);

<span class="fc bfc" id="L1216" title="All 2 branches covered.">		for (int i = 0; i &lt; iNumBasis; ++i) {</span>
<span class="fc bfc" id="L1217" title="All 2 branches covered.">			for (int j = 0; j &lt; iNumBasis; ++j)</span>
<span class="fc" id="L1218">				dblDPE += _adblResponseBasisCoeff[i] * _adblResponseBasisCoeff[j] * bffp.basisBestFitPenalty</span>
<span class="fc" id="L1219">					(i, j);</span>
		}

<span class="fc" id="L1222">		return dblDPE;</span>
	}

	/**
	 * Calculate the Response Value at the given Predictor Ordinate
	 * 
	 * @param dblPredictorOrdinate Predictor Ordinate
	 * 
	 * @return The Response Value
	 * 
	 * @throws java.lang.Exception Thrown if the calculation did not succeed
	 */

	public double responseValue (
		final double dblPredictorOrdinate)
		throws java.lang.Exception
	{
<span class="fc" id="L1239">		return _be.responseValue (_adblResponseBasisCoeff, dblPredictorOrdinate);</span>
	}

	/**
	 * Calculate the Ordered Response Value Derivative at the Predictor Ordinate
	 * 
	 * @param dblPredictorOrdinate Predictor Ordinate at which the ordered Response Derivative is to be
	 * 	calculated
	 * @param iOrder Derivative Order
	 * 
	 * @throws java.lang.Exception Thrown if the Ordered Response Value Derivative cannot be calculated
	 * 
	 * @return Retrieve the Ordered Response Value Derivative
	 */

	public double calcResponseValueDerivative (
		final double dblPredictorOrdinate,
		final int iOrder)
		throws java.lang.Exception
	{
<span class="fc bfc" id="L1259" title="All 2 branches covered.">		return 0 == iOrder ? responseValue (dblPredictorOrdinate) : _be.responseValueDerivative</span>
<span class="fc" id="L1260">			(_adblResponseBasisCoeff, dblPredictorOrdinate, iOrder);</span>
	}

	/**
	 * Calculate the Ordered Derivative of the Response to the Manifest
	 * 
	 * @param strManifestMeasure Manifest Measure whose Sensitivity is sought
	 * @param dblPredictorOrdinate Predictor Ordinate at which the ordered Derivative of the Response to the
	 * 	Manifest is to be calculated
	 * @param iOrder Derivative Order
	 * 
	 * @throws java.lang.Exception Thrown if the Ordered Derivative of the Response to the Manifest cannot be
	 *  calculated
	 * 
	 * @return Retrieve the Ordered Derivative of the Response to the Manifest
	 */

	public double calcDResponseDManifest (
		final java.lang.String strManifestMeasure,
		final double dblPredictorOrdinate,
		final int iOrder)
		throws java.lang.Exception
	{
<span class="pc bpc" id="L1283" title="1 of 2 branches missed.">		if (0 == iOrder)</span>
<span class="nc" id="L1284">			throw new java.lang.Exception</span>
				(&quot;LatentStateResponseModel::calcDResponseDManifest =&gt; Invalid Inputs&quot;);

<span class="fc" id="L1287">		org.drip.spline.segment.LatentStateManifestSensitivity lsms = manifestSensitivity</span>
<span class="fc" id="L1288">			(strManifestMeasure);</span>

<span class="pc bpc" id="L1290" title="1 of 2 branches missed.">		if (null == lsms)</span>
<span class="nc" id="L1291">			throw new java.lang.Exception</span>
				(&quot;LatentStateResponseModel::calcDResponseDManifest =&gt; Invalid Inputs&quot;);

<span class="fc" id="L1294">		return _be.responseValue (lsms.getDBasisCoeffDLocalManifest(), dblPredictorOrdinate);</span>
	}

	/**
	 * Calculate the Ordered Derivative of the Response to the Preceeding Manifest
	 * 
	 * @param strManifestMeasure Manifest Measure whose Sensitivity is sought
	 * @param dblPredictorOrdinate Predictor Ordinate at which the ordered Derivative of the Response to the
	 * 	Manifest is to be calculated
	 * @param iOrder Derivative Order
	 * 
	 * @throws java.lang.Exception Thrown if the Ordered Derivative of the Response to the Manifest cannot be
	 *  calculated
	 * 
	 * @return Retrieve the Ordered Derivative of the Response to the Preceeding Manifest
	 */

	public double calcDResponseDPreceedingManifest (
		final java.lang.String strManifestMeasure,
		final double dblPredictorOrdinate,
		final int iOrder)
		throws java.lang.Exception
	{
<span class="pc bpc" id="L1317" title="1 of 2 branches missed.">		if (0 == iOrder)</span>
<span class="nc" id="L1318">			throw new java.lang.Exception</span>
				(&quot;LatentStateResponseModel::calcDResponseDPreceedingManifest =&gt; Invalid Inputs&quot;);

<span class="fc" id="L1321">		org.drip.spline.segment.LatentStateManifestSensitivity lsms = manifestSensitivity</span>
<span class="fc" id="L1322">			(strManifestMeasure);</span>

<span class="pc bpc" id="L1324" title="1 of 2 branches missed.">		if (null == lsms)</span>
<span class="nc" id="L1325">			throw new java.lang.Exception</span>
				(&quot;LatentStateResponseModel::calcDResponseDPreceedingManifest =&gt; Cannot locate state Manifest sensitivity&quot;);

<span class="fc" id="L1328">		org.drip.spline.params.PreceedingManifestSensitivityControl pqsc = lsms.getPMSC();</span>

<span class="fc" id="L1330">		double dblDResponseDPreceedingManifest = lsms.getDResponseDPreceedingManifest();</span>

<span class="pc bpc" id="L1332" title="1 of 2 branches missed.">		if (!pqsc.impactFade())</span>
<span class="nc bnc" id="L1333" title="All 2 branches missed.">			return org.drip.numerical.common.NumberUtil.IsValid (dblDResponseDPreceedingManifest) ?</span>
				dblDResponseDPreceedingManifest : 0.;

<span class="fc" id="L1336">		org.drip.spline.segment.BasisEvaluator be = pqsc.basisEvaluator();</span>

<span class="fc" id="L1338">		double[] adblDBasisCoeffDPreceedingManifest = lsms.getDBasisCoeffDPreceedingManifest();</span>

<span class="pc bpc" id="L1340" title="2 of 4 branches missed.">		return null == adblDBasisCoeffDPreceedingManifest ? 0. : (null == be ? _be : be).responseValue</span>
<span class="fc" id="L1341">			(adblDBasisCoeffDPreceedingManifest, dblPredictorOrdinate);</span>
	}

	/**
	 * Retrieve the Manifest Measure Preceeding Manifest Impact Flag
	 * 
	 * @param strManifestMeasure Manifest Measure whose Sensitivity is sought
	 * 
	 * @return The Manifest Measure Preceeding Manifest Impact Flag
	 * 
	 * @throws java.lang.Exception Thrown if the Inputs are Invalid
	 */

	public boolean impactFade (
		final java.lang.String strManifestMeasure)
		throws java.lang.Exception
	{
<span class="fc" id="L1358">		org.drip.spline.segment.LatentStateManifestSensitivity lsms = manifestSensitivity</span>
<span class="fc" id="L1359">			(strManifestMeasure);</span>

<span class="fc bfc" id="L1361" title="All 2 branches covered.">		if (null == lsms)</span>
<span class="fc" id="L1362">			throw new java.lang.Exception</span>
				(&quot;LatentStateResponseModel::impactFade =&gt; Cannot locate state Manifest sensitivity&quot;);

<span class="fc" id="L1365">		return lsms.getPMSC().impactFade();</span>
	}

	/**
	 * Calculate the Jacobian of the Segment's Response Basis Function Coefficients to the Edge Inputs
	 * 
	 * @return The Jacobian of the Segment's Response Basis Function Coefficients to the Edge Inputs
	 */

	public org.drip.numerical.differentiation.WengertJacobian jackDCoeffDEdgeInputs()
	{
<span class="fc bfc" id="L1376" title="All 2 branches covered.">		if (null != _wjDBasisCoeffDEdgeValue) return _wjDBasisCoeffDEdgeValue;</span>

<span class="fc" id="L1378">		int iNumResponseBasisCoeff = _be.numBasis();</span>

		try {
<span class="fc" id="L1381">			_wjDBasisCoeffDEdgeValue = new org.drip.numerical.differentiation.WengertJacobian (iNumResponseBasisCoeff,</span>
				iNumResponseBasisCoeff);
<span class="nc" id="L1383">		} catch (java.lang.Exception e) {</span>
<span class="nc" id="L1384">			e.printStackTrace();</span>

<span class="nc" id="L1386">			return _wjDBasisCoeffDEdgeValue = null;</span>
<span class="fc" id="L1387">		}</span>

<span class="fc bfc" id="L1389" title="All 2 branches covered.">		for (int i = 0; i &lt; iNumResponseBasisCoeff; ++i) {</span>
<span class="pc bpc" id="L1390" title="1 of 2 branches missed.">			if (!_wjDBasisCoeffDEdgeValue.setWengert (i, _adblResponseBasisCoeff[i]))</span>
<span class="nc" id="L1391">				return _wjDBasisCoeffDEdgeValue = null;</span>
		}

<span class="fc bfc" id="L1394" title="All 2 branches covered.">		if (null == _aadblDResponseBasisCoeffDConstraint) return null;</span>

<span class="fc" id="L1396">		int iSize = _aadblDResponseBasisCoeffDConstraint.length;</span>

<span class="fc bfc" id="L1398" title="All 2 branches covered.">		for (int i = 0; i &lt; iSize; ++i) {</span>
<span class="fc bfc" id="L1399" title="All 2 branches covered.">			for (int j = 0; j &lt; iSize; ++j) {</span>
<span class="pc bpc" id="L1400" title="1 of 2 branches missed.">				if (!_wjDBasisCoeffDEdgeValue.accumulatePartialFirstDerivative (i, j,</span>
					_aadblDResponseBasisCoeffDConstraint[i][j]))
<span class="nc" id="L1402">					return null;</span>
			}
		}

<span class="fc" id="L1406">		return _wjDBasisCoeffDEdgeValue;</span>
	}

	/**
	 * Calculate the Jacobian of the Response to the Edge Inputs at the given Predictor Ordinate
	 * 
	 * @param dblPredictorOrdinate The Predictor Ordinate
	 * @param iOrder Order of the Derivative Desired
	 * 
	 * @return The Jacobian of the Response to the Edge Inputs at the given Predictor Ordinate
	 */

	public org.drip.numerical.differentiation.WengertJacobian jackDResponseDEdgeInput (
		final double dblPredictorOrdinate,
		final int iOrder)
	{
		try {
<span class="fc" id="L1423">			int iNumResponseBasisCoeff = _be.numBasis();</span>

<span class="fc" id="L1425">			org.drip.numerical.differentiation.WengertJacobian wjDResponseDEdgeParams = null;</span>
<span class="fc" id="L1426">			double[][] aadblDBasisCoeffDEdgeParams = new</span>
				double[iNumResponseBasisCoeff][iNumResponseBasisCoeff];

<span class="fc" id="L1429">			double[] adblDResponseDBasisCoeff = DResponseDBasisCoeff (dblPredictorOrdinate, iOrder);</span>

<span class="pc bpc" id="L1431" title="2 of 4 branches missed.">			if (null == adblDResponseDBasisCoeff || iNumResponseBasisCoeff !=</span>
				adblDResponseDBasisCoeff.length)
<span class="nc" id="L1433">				return null;</span>

<span class="fc bfc" id="L1435" title="All 2 branches covered.">			org.drip.numerical.differentiation.WengertJacobian wjDBasisCoeffDEdgeParams = (null ==</span>
<span class="fc" id="L1436">				_wjDBasisCoeffDEdgeValue) ? jackDCoeffDEdgeInputs() : _wjDBasisCoeffDEdgeValue;</span>

<span class="fc bfc" id="L1438" title="All 2 branches covered.">			for (int i = 0; i &lt; iNumResponseBasisCoeff; ++i) {</span>
<span class="fc bfc" id="L1439" title="All 2 branches covered.">				for (int j = 0; j &lt; iNumResponseBasisCoeff; ++j)</span>
<span class="fc" id="L1440">					aadblDBasisCoeffDEdgeParams[j][i] = wjDBasisCoeffDEdgeParams.firstDerivative (j, i);</span>
			}

<span class="fc" id="L1443">			if (!(wjDResponseDEdgeParams = new org.drip.numerical.differentiation.WengertJacobian (1,</span>
<span class="pc bpc" id="L1444" title="1 of 2 branches missed.">				iNumResponseBasisCoeff)).setWengert (0, responseValue (dblPredictorOrdinate)))</span>
<span class="nc" id="L1445">				return null;</span>

<span class="fc bfc" id="L1447" title="All 2 branches covered.">			for (int i = 0; i &lt; iNumResponseBasisCoeff; ++i) {</span>
<span class="fc bfc" id="L1448" title="All 2 branches covered.">				for (int j = 0; j &lt; iNumResponseBasisCoeff; ++j) {</span>
<span class="pc bpc" id="L1449" title="1 of 2 branches missed.">					if (!wjDResponseDEdgeParams.accumulatePartialFirstDerivative (0, i,</span>
						adblDResponseDBasisCoeff[j] * aadblDBasisCoeffDEdgeParams[j][i]))
<span class="nc" id="L1451">						return null;</span>
				}
			}

<span class="fc" id="L1455">			return wjDResponseDEdgeParams;</span>
<span class="nc" id="L1456">		} catch (java.lang.Exception e) {</span>
<span class="nc" id="L1457">			e.printStackTrace();</span>
		}

<span class="nc" id="L1460">		return null;</span>
	}

	/**
	 * Calculate the Jacobian of the Response to the Basis Coefficients at the given Predictor Ordinate
	 * 
	 * @param dblPredictorOrdinate The Predictor Ordinate
	 * @param iOrder Order of the Derivative Desired
	 * 
	 * @return The Jacobian of the Response to the Basis Coefficients at the given Predictor Ordinate
	 */

	public org.drip.numerical.differentiation.WengertJacobian jackDResponseDBasisCoeff (
		final double dblPredictorOrdinate,
		final int iOrder)
	{
		try {
<span class="nc" id="L1477">			int iNumResponseBasisCoeff = _be.numBasis();</span>

<span class="nc" id="L1479">			double[] adblBasisDResponseDBasisCoeff = DResponseDBasisCoeff (dblPredictorOrdinate, iOrder);</span>

<span class="nc bnc" id="L1481" title="All 4 branches missed.">			if (null == adblBasisDResponseDBasisCoeff || iNumResponseBasisCoeff !=</span>
				adblBasisDResponseDBasisCoeff.length)
<span class="nc" id="L1483">				return null;</span>

<span class="nc" id="L1485">			org.drip.numerical.differentiation.WengertJacobian wjDResponseDBasisCoeff = new</span>
				org.drip.numerical.differentiation.WengertJacobian (1, iNumResponseBasisCoeff);

<span class="nc bnc" id="L1488" title="All 2 branches missed.">			for (int i = 0; i &lt; iNumResponseBasisCoeff; ++i) {</span>
<span class="nc bnc" id="L1489" title="All 2 branches missed.">				if (!wjDResponseDBasisCoeff.accumulatePartialFirstDerivative (0, i,</span>
					adblBasisDResponseDBasisCoeff[i]))
<span class="nc" id="L1491">					return null;</span>
			}

<span class="nc" id="L1494">			return wjDResponseDBasisCoeff;</span>
<span class="nc" id="L1495">		} catch (java.lang.Exception e) {</span>
<span class="nc" id="L1496">			e.printStackTrace();</span>
		}

<span class="nc" id="L1499">		return null;</span>
	}

	/**
	 * Calibrate the segment and calculate the Jacobian of the Segment's Response Basis Function Coefficients
	 *  to the Edge Parameters
	 * 
	 * @param adblPredictorOrdinate Array of Predictor Ordinates
	 * @param adblResponseValue Array of Response Values
	 * @param adblLeftEdgeDeriv Array of Left Edge Derivatives
	 * @param adblRightEdgeDeriv Array of Right Edge Derivatives
	 * @param aSBFC Array of Segment Flexure Constraints, expressed as Basis Coefficients
	 * @param sbfr Segment Best Fit Response Instance
	 * 
	 * @return The Jacobian of the Segment's Response Basis Function Coefficients to the Edge Parameters
	 */

	public org.drip.numerical.differentiation.WengertJacobian jackDCoeffDEdgeParams (
		final double[] adblPredictorOrdinate,
		final double[] adblResponseValue,
		final double[] adblLeftEdgeDeriv,
		final double[] adblRightEdgeDeriv,
		final org.drip.spline.params.SegmentBasisFlexureConstraint[] aSBFC,
		final org.drip.spline.params.SegmentBestFitResponse sbfr)
	{
		try {
<span class="pc bpc" id="L1525" title="1 of 2 branches missed.">			return calibrateState (new org.drip.spline.params.SegmentStateCalibrationInputs</span>
				(adblPredictorOrdinate, adblResponseValue, adblLeftEdgeDeriv, adblRightEdgeDeriv, aSBFC,
<span class="pc" id="L1527">					sbfr)) ? jackDCoeffDEdgeInputs() : null;</span>
<span class="nc" id="L1528">		} catch (java.lang.Exception e) {</span>
<span class="nc" id="L1529">			e.printStackTrace();</span>
		}

<span class="nc" id="L1532">		return null;</span>
	}

	/**
	 * Calibrate the Coefficients from the Edge Response Values and the Left Edge Response Value Slope and
	 *  calculate the Jacobian of the Segment's Response Basis Function Coefficients to the Edge Parameters
	 * 
	 * @param dblLeftValue Left Edge Response Value
	 * @param dblLeftSlope Left Edge Response Slope
	 * @param dblRightValue Right Edge Response Value
	 * @param sbfrState Segment's Best Fit Weighted Response Values
	 * 
	 * @return The Jacobian of the Segment's Response Basis Function Coefficients to the Edge Parameters
	 */

	public org.drip.numerical.differentiation.WengertJacobian jackDCoeffDEdgeParams (
		final double dblLeftValue,
		final double dblLeftSlope,
		final double dblRightValue,
		final org.drip.spline.params.SegmentBestFitResponse sbfrState)
	{
<span class="pc bpc" id="L1553" title="1 of 2 branches missed.">		return calibrate (dblLeftValue, dblLeftSlope, dblRightValue, sbfrState) ? jackDCoeffDEdgeInputs() :</span>
			null;
	}

	/**
	 * Calibrate the coefficients from the prior Segment and the Response Value at the Right Predictor
	 *  Ordinate and calculate the Jacobian of the Segment's Response Basis Function Coefficients to the Edge
	 *  Parameters
	 * 
	 * @param csPreceeding Previous Predictor/Response Segment
	 * @param strManifestMeasure Manifest Measure whose Sensitivity is sought
	 * @param dblRightStateValue Response Value at the Right Predictor Ordinate
	 * @param sbfrState Segment's Best Fit Weighted Response Values
	 * @param dblRightStateManifestSensitivity Response Value Manifest Sensitivity at the Right Predictor
	 * 	Ordinate
	 * @param sbfrManifestSensitivity Segment's Best Fit Weighted Response Value Manifest Sensitivity
	 * 
	 * @return The Jacobian
	 */

	public org.drip.numerical.differentiation.WengertJacobian jackDCoeffDEdgeParams (
		final LatentStateResponseModel csPreceeding,
		final java.lang.String strManifestMeasure,
		final double dblRightStateValue,
		final org.drip.spline.params.SegmentBestFitResponse sbfrState,
		final double dblRightStateManifestSensitivity,
		final org.drip.spline.params.SegmentBestFitResponse sbfrManifestSensitivity)
	{
<span class="pc bpc" id="L1581" title="1 of 2 branches missed.">		return !calibrate (csPreceeding, dblRightStateValue, sbfrState) || !manifestMeasureSensitivity</span>
<span class="pc bpc" id="L1582" title="1 of 2 branches missed.">			(csPreceeding, strManifestMeasure, dblRightStateManifestSensitivity, sbfrManifestSensitivity) ?</span>
<span class="fc" id="L1583">				null : jackDCoeffDEdgeInputs();</span>
	}

	/**
	 * Indicate whether the given segment is monotone. If monotone, may optionally indicate the nature of
	 * 	the extrema contained inside (maxima/minima/infection).
	 *  
	 * @return The monotone Type
	 */

	public org.drip.spline.segment.Monotonocity monotoneType()
	{
<span class="fc bfc" id="L1595" title="All 2 branches covered.">		if (1 &gt;= _sidc.Ck()) {</span>
			try {
<span class="fc" id="L1597">				return new org.drip.spline.segment.Monotonocity</span>
					(org.drip.spline.segment.Monotonocity.MONOTONIC);
<span class="nc" id="L1599">			} catch (java.lang.Exception e) {</span>
<span class="nc" id="L1600">				e.printStackTrace();</span>

<span class="nc" id="L1602">				return null;</span>
			}
		}

<span class="fc" id="L1606">		org.drip.function.definition.R1ToR1 ofDeriv = new</span>
<span class="fc" id="L1607">			org.drip.function.definition.R1ToR1 (null) {</span>
			@Override public double evaluate (
				final double dblX)
				throws java.lang.Exception
			{
<span class="fc" id="L1612">				return _be.responseValueDerivative (_adblResponseBasisCoeff, dblX, 1);</span>
			}

			@Override public org.drip.numerical.differentiation.Differential differential (
				final double dblX,
				final double dblOFBase,
				final int iOrder)
			{
				try {
<span class="nc" id="L1621">					double dblVariateInfinitesimal = _dc.getVariateInfinitesimal (dblX);</span>

<span class="nc" id="L1623">					return new org.drip.numerical.differentiation.Differential (dblVariateInfinitesimal,</span>
<span class="nc" id="L1624">						_be.responseValueDerivative (_adblResponseBasisCoeff, dblX, iOrder) *</span>
							dblVariateInfinitesimal);
<span class="nc" id="L1626">				} catch (java.lang.Exception e) {</span>
<span class="nc" id="L1627">					e.printStackTrace();</span>
				}

<span class="nc" id="L1630">				return null;</span>
			}

			@Override public double integrate (
				final double dblBegin,
				final double dblEnd)
				throws java.lang.Exception
			{
<span class="nc" id="L1638">				return org.drip.numerical.integration.R1ToR1Integrator.Boole (this, dblBegin, dblEnd);</span>
			}
		};

		try {
<span class="fc" id="L1643">			org.drip.function.r1tor1solver.FixedPointFinderOutput fpop = new</span>
				org.drip.function.r1tor1solver.FixedPointFinderBrent (0., ofDeriv, false).findRoot
<span class="fc" id="L1645">					(org.drip.function.r1tor1solver.InitializationHeuristics.FromHardSearchEdges (0., 1.));</span>

<span class="pc bpc" id="L1647" title="1 of 4 branches missed.">			if (null == fpop || !fpop.containsRoot())</span>
<span class="fc" id="L1648">				return new org.drip.spline.segment.Monotonocity</span>
					(org.drip.spline.segment.Monotonocity.MONOTONIC);

<span class="fc" id="L1651">			double dblExtremum = fpop.getRoot();</span>

<span class="pc bpc" id="L1653" title="3 of 6 branches missed.">			if (!org.drip.numerical.common.NumberUtil.IsValid (dblExtremum) || dblExtremum &lt;= 0. || dblExtremum</span>
				&gt;= 1.)
<span class="nc" id="L1655">				return new org.drip.spline.segment.Monotonocity</span>
					(org.drip.spline.segment.Monotonocity.MONOTONIC);

<span class="fc" id="L1658">			double dbl2ndDeriv = _be.responseValueDerivative (_adblResponseBasisCoeff, dblExtremum, 2);</span>

<span class="pc bpc" id="L1660" title="1 of 2 branches missed.">			if (0. &gt; dbl2ndDeriv)</span>
<span class="nc" id="L1661">				return new org.drip.spline.segment.Monotonocity</span>
					(org.drip.spline.segment.Monotonocity.MAXIMA);

<span class="pc bpc" id="L1664" title="1 of 2 branches missed.">			if (0. &lt; dbl2ndDeriv)</span>
<span class="fc" id="L1665">				return new org.drip.spline.segment.Monotonocity</span>
					(org.drip.spline.segment.Monotonocity.MINIMA);

<span class="nc bnc" id="L1668" title="All 2 branches missed.">			if (0. == dbl2ndDeriv)</span>
<span class="nc" id="L1669">				return new org.drip.spline.segment.Monotonocity</span>
					(org.drip.spline.segment.Monotonocity.INFLECTION);

<span class="nc" id="L1672">			return new org.drip.spline.segment.Monotonocity</span>
				(org.drip.spline.segment.Monotonocity.NON_MONOTONIC);
<span class="nc" id="L1674">		} catch (java.lang.Exception e) {</span>
<span class="nc" id="L1675">			e.printStackTrace();</span>
		}

		try {
<span class="nc" id="L1679">			return new org.drip.spline.segment.Monotonocity (org.drip.spline.segment.Monotonocity.MONOTONIC);</span>
<span class="nc" id="L1680">		} catch (java.lang.Exception e) {</span>
<span class="nc" id="L1681">			e.printStackTrace();</span>
		}

<span class="nc" id="L1684">		return null;</span>
	}

	/**
	 * Clip the part of the Segment to the Right of the specified Predictor Ordinate. Retain all other
	 * 	constraints the same.
	 * 
	 * @param dblPredictorOrdinate The Predictor Ordinate
	 * 
	 * @return The Clipped Segment
	 */

	public LatentStateResponseModel clipLeftOfPredictorOrdinate (
		final double dblPredictorOrdinate)
	{
		try {
<span class="fc" id="L1700">			LatentStateResponseModel csLeftSnipped = LatentStateResponseModel.Create (dblPredictorOrdinate,</span>
<span class="fc" id="L1701">				right(), _be.replicate(), _sidc);</span>

<span class="fc" id="L1703">			int iCk = _sidc.Ck();</span>

<span class="pc bpc" id="L1705" title="1 of 2 branches missed.">			double[] adblCalibLeftEdgeDeriv = 0 != iCk ? csLeftSnipped.transmissionCk (dblPredictorOrdinate,</span>
				this, iCk) : null;

<span class="pc bpc" id="L1708" title="1 of 2 branches missed.">			return csLeftSnipped.calibrateState (new org.drip.spline.params.SegmentStateCalibrationInputs</span>
<span class="fc" id="L1709">				(new double[] {dblPredictorOrdinate, right()}, new double[] {responseValue</span>
<span class="fc" id="L1710">					(dblPredictorOrdinate), responseValue (right())}, adblCalibLeftEdgeDeriv, null, null,</span>
						null)) ? csLeftSnipped : null;
<span class="nc" id="L1712">		} catch (java.lang.Exception e) {</span>
<span class="nc" id="L1713">			e.printStackTrace();</span>
		}

<span class="nc" id="L1716">		return null;</span>
	}

	/**
	 * Clip the part of the Segment to the Right of the specified Predictor Ordinate. Retain all other
	 * 	constraints the same.
	 * 
	 * @param dblPredictorOrdinate The Predictor Ordinate
	 * 
	 * @return The Clipped Segment
	 */

	public LatentStateResponseModel clipRightOfPredictorOrdinate (
		final double dblPredictorOrdinate)
	{
		try {
<span class="fc" id="L1732">			LatentStateResponseModel csRightSnipped = LatentStateResponseModel.Create (left(),</span>
<span class="fc" id="L1733">				dblPredictorOrdinate, _be.replicate(), _sidc);</span>

<span class="fc" id="L1735">			int iCk = _sidc.Ck();</span>

<span class="pc bpc" id="L1737" title="1 of 2 branches missed.">			return csRightSnipped.calibrateState (new org.drip.spline.params.SegmentStateCalibrationInputs</span>
<span class="fc" id="L1738">				(new double[] {left(), dblPredictorOrdinate}, new double[] {responseValue (left()),</span>
<span class="pc bpc" id="L1739" title="1 of 2 branches missed.">					responseValue (dblPredictorOrdinate)}, 0 != iCk ? csRightSnipped.transmissionCk (left(),</span>
						this, iCk) : null, null, null, null)) ? csRightSnipped : null;
<span class="nc" id="L1741">		} catch (java.lang.Exception e) {</span>
<span class="nc" id="L1742">			e.printStackTrace();</span>
		}

<span class="nc" id="L1745">		return null;</span>
	}

	/**
	 * Display the string representation for diagnostic purposes
	 * 
	 * @return The string representation
	 */

	public java.lang.String displayString()
	{
<span class="nc" id="L1756">		java.lang.StringBuffer sb = new java.lang.StringBuffer();</span>

<span class="nc" id="L1758">		sb.append (&quot;\t\t\t[&quot; + left() + &quot; =&gt; &quot; + right() + &quot;\n&quot;);</span>

<span class="nc bnc" id="L1760" title="All 2 branches missed.">		for (int i = 0; i &lt; _adblResponseBasisCoeff.length; ++i) {</span>
<span class="nc bnc" id="L1761" title="All 2 branches missed.">			if (0 != i) sb.append (&quot;  |  &quot;);</span>

<span class="nc" id="L1763">			sb.append (_adblResponseBasisCoeff[i] + &quot;\n&quot;);</span>
		}

<span class="nc" id="L1766">		return sb.toString();</span>
	}
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.7.9.201702052155</span></div></body></html>