<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>LatentStateResponseModel.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">DROP</a> &gt; <a href="index.source.html" class="el_package">org.drip.spline.segment</a> &gt; <span class="el_source">LatentStateResponseModel.java</span></div><h1>LatentStateResponseModel.java</h1><pre class="source lang-java linenums">
package org.drip.spline.segment;

/*
 * -*- mode: java; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*-
 */

/*!
 * Copyright (C) 2020 Lakshmi Krishnamurthy
 * Copyright (C) 2019 Lakshmi Krishnamurthy
 * Copyright (C) 2018 Lakshmi Krishnamurthy
 * Copyright (C) 2017 Lakshmi Krishnamurthy
 * Copyright (C) 2016 Lakshmi Krishnamurthy
 * Copyright (C) 2015 Lakshmi Krishnamurthy
 * Copyright (C) 2014 Lakshmi Krishnamurthy
 * Copyright (C) 2013 Lakshmi Krishnamurthy
 * 
 *  This file is part of DROP, an open-source library targeting analytics/risk, transaction cost analytics,
 *  	asset liability management analytics, capital, exposure, and margin analytics, valuation adjustment
 *  	analytics, and portfolio construction analytics within and across fixed income, credit, commodity,
 *  	equity, FX, and structured products. It also includes auxiliary libraries for algorithm support,
 *  	numerical analysis, numerical optimization, spline builder, model validation, statistical learning,
 *  	and computational support.
 *  
 *  	https://lakshmidrip.github.io/DROP/
 *  
 *  DROP is composed of three modules:
 *  
 *  - DROP Product Core - https://lakshmidrip.github.io/DROP-Product-Core/
 *  - DROP Portfolio Core - https://lakshmidrip.github.io/DROP-Portfolio-Core/
 *  - DROP Computational Core - https://lakshmidrip.github.io/DROP-Computational-Core/
 * 
 * 	DROP Product Core implements libraries for the following:
 * 	- Fixed Income Analytics
 * 	- Loan Analytics
 * 	- Transaction Cost Analytics
 * 
 * 	DROP Portfolio Core implements libraries for the following:
 * 	- Asset Allocation Analytics
 *  - Asset Liability Management Analytics
 * 	- Capital Estimation Analytics
 * 	- Exposure Analytics
 * 	- Margin Analytics
 * 	- XVA Analytics
 * 
 * 	DROP Computational Core implements libraries for the following:
 * 	- Algorithm Support
 * 	- Computation Support
 * 	- Function Analysis
 *  - Model Validation
 * 	- Numerical Analysis
 * 	- Numerical Optimizer
 * 	- Spline Builder
 *  - Statistical Learning
 * 
 * 	Documentation for DROP is Spread Over:
 * 
 * 	- Main                     =&gt; https://lakshmidrip.github.io/DROP/
 * 	- Wiki                     =&gt; https://github.com/lakshmiDRIP/DROP/wiki
 * 	- GitHub                   =&gt; https://github.com/lakshmiDRIP/DROP
 * 	- Repo Layout Taxonomy     =&gt; https://github.com/lakshmiDRIP/DROP/blob/master/Taxonomy.md
 * 	- Javadoc                  =&gt; https://lakshmidrip.github.io/DROP/Javadoc/index.html
 * 	- Technical Specifications =&gt; https://github.com/lakshmiDRIP/DROP/tree/master/Docs/Internal
 * 	- Release Versions         =&gt; https://lakshmidrip.github.io/DROP/version.html
 * 	- Community Credits        =&gt; https://lakshmidrip.github.io/DROP/credits.html
 * 	- Issues Catalog           =&gt; https://github.com/lakshmiDRIP/DROP/issues
 * 	- JUnit                    =&gt; https://lakshmidrip.github.io/DROP/junit/index.html
 * 	- Jacoco                   =&gt; https://lakshmidrip.github.io/DROP/jacoco/index.html
 * 
 *  Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 *   	you may not use this file except in compliance with the License.
 *   
 *  You may obtain a copy of the License at
 *  	http://www.apache.org/licenses/LICENSE-2.0
 *  
 *  Unless required by applicable law or agreed to in writing, software
 *  	distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 *  	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  
 *  See the License for the specific language governing permissions and
 *  	limitations under the License.
 */

/**
 * &lt;i&gt;LatentStateResponseModel&lt;/i&gt; implements the single segment basis calibration and inference
 * functionality. It exports the following functionality:
 *
 * &lt;br&gt;&lt;br&gt;
 *  &lt;ul&gt;
 *  	&lt;li&gt;
 * 			Build the LatentStateResponseModel instance from the Basis Function/Shape Controller Set
 *  	&lt;/li&gt;
 *  	&lt;li&gt;
 * 			Build the LatentStateResponseModel instance from the Basis Evaluator Set
 *  	&lt;/li&gt;
 *  	&lt;li&gt;
 * 			Retrieve the Number of Parameters, Basis Evaluator, Array of the Response Basis Coefficients, and
 * 				Segment Design Inelastic Control
 *  	&lt;/li&gt;
 *  	&lt;li&gt;
 * 			Calibrate the Segment State from the Calibration Parameter Set
 *  	&lt;/li&gt;
 *  	&lt;li&gt;
 * 			Sensitivity Calibrator: Calibrate the Segment Manifest Jacobian from the Calibration Parameter
 * 				Set
 *  	&lt;/li&gt;
 *  	&lt;li&gt;
 * 			Calibrate the coefficients from the prior Predictor/Response Segment, the Constraint, and fitness
 * 				Weights
 *  	&lt;/li&gt;
 *  	&lt;li&gt;
 *			Calibrate the coefficients from the prior Segment and the Response Value at the Right Predictor
 *				Ordinate
 *  	&lt;/li&gt;
 *  	&lt;li&gt;
 *			Calibrate the Coefficients from the Edge Response Values and the Left Edge Response Slope
 *  	&lt;/li&gt;
 *  	&lt;li&gt;
 *			Calibrate the coefficients from the Left Edge Response Value Constraint, the Left Edge Response
 *				Value Slope, and the Right Edge Response Value Constraint
 *  	&lt;/li&gt;
 *  	&lt;li&gt;
 *			Retrieve the Segment Curvature, Length, and the Best Fit DPE
 *  	&lt;/li&gt;
 *  	&lt;li&gt;
 *			Calculate the Response Value and its Derivative at the given Predictor Ordinate
 *  	&lt;/li&gt;
 *  	&lt;li&gt;
 *			Calculate the Ordered Derivative of the Coefficient to the Manifest
 *  	&lt;/li&gt;
 *  	&lt;li&gt;
 *			Calculate the Jacobian of the Segment's Response Basis Function Coefficients to the Edge Inputs
 *  	&lt;/li&gt;
 *  	&lt;li&gt;
 *			Calculate the Jacobian of the Response to the Edge Inputs at the given Predictor Ordinate
 *  	&lt;/li&gt;
 *  	&lt;li&gt;
 *			Calculate the Jacobian of the Response to the Basis Coefficients at the given Predictor Ordinate
 *  	&lt;/li&gt;
 *  	&lt;li&gt;
 *			Calibrate the segment and calculate the Jacobian of the Segment's Response Basis Function
 *				Coefficients to the Edge Parameters
 *  	&lt;/li&gt;
 *  	&lt;li&gt;
 *			Calibrate the Coefficients from the Edge Response Values and the Left Edge Response Value Slope
 *				and calculate the Jacobian of the Segment's Response Basis Function Coefficients to the Edge
 *				Parameters
 *  	&lt;/li&gt;
 *  	&lt;li&gt;
 *			Calibrate the coefficients from the prior Segment and the Response Value at the Right Predictor
 *				Ordinate and calculate the Jacobian of the Segment's Response Basis Function Coefficients to
 *				the Edge Parameters
 *  	&lt;/li&gt;
 *  	&lt;li&gt;
 *  		Indicate whether the given segment is monotone. If monotone, may optionally indicate the nature
 *  			of the extrema contained inside (maxima/minima/infection)
 *  	&lt;/li&gt;
 *  	&lt;li&gt;
 *  		Clip the part of the Segment to the Right of the specified Predictor Ordinate. Retain all other
 *  			constraints the same
 *  	&lt;/li&gt;
 *  	&lt;li&gt;
 *  		Clip the part of the Segment to the Left of the specified Predictor Ordinate. Retain all other
 *  			constraints the same
 *  	&lt;/li&gt;
 *  	&lt;li&gt;
 *  		Display the string representation for diagnostic purposes
 *  	&lt;/li&gt;
 *  &lt;/ul&gt;
 *
 * &lt;br&gt;&lt;br&gt;
 *  &lt;ul&gt;
 *		&lt;li&gt;&lt;b&gt;Module &lt;/b&gt; = &lt;a href = &quot;https://github.com/lakshmiDRIP/DROP/tree/master/ComputationalCore.md&quot;&gt;Computational Core Module&lt;/a&gt;&lt;/li&gt;
 *		&lt;li&gt;&lt;b&gt;Library&lt;/b&gt; = &lt;a href = &quot;https://github.com/lakshmiDRIP/DROP/tree/master/SplineBuilderLibrary.md&quot;&gt;Spline Builder Library&lt;/a&gt;&lt;/li&gt;
 *		&lt;li&gt;&lt;b&gt;Project&lt;/b&gt; = &lt;a href = &quot;https://github.com/lakshmiDRIP/DROP/tree/master/src/main/java/org/drip/spline/README.md&quot;&gt;Basis Splines and Linear Compounders across a Broad Family of Spline Basis Functions&lt;/a&gt;&lt;/li&gt;
 *		&lt;li&gt;&lt;b&gt;Package&lt;/b&gt; = &lt;a href = &quot;https://github.com/lakshmiDRIP/DROP/tree/master/src/main/java/org/drip/spline/segment/README.md&quot;&gt;Flexure Penalizing Best Fit Segment&lt;/a&gt;&lt;/li&gt;
 *  &lt;/ul&gt;
 * &lt;br&gt;&lt;br&gt;
 *
 * @author Lakshmi Krishnamurthy
 */

public class LatentStateResponseModel extends org.drip.spline.segment.LatentStateInelastic {

	/**
	 * LEFT NODE VALUE PARAMETER INDEX
	 */

	public static final int LEFT_NODE_VALUE_PARAMETER_INDEX = 0;

	/**
	 * RIGHT NODE VALUE PARAMETER INDEX
	 */

	public static final int RIGHT_NODE_VALUE_PARAMETER_INDEX = 1;

<span class="fc" id="L197">	private double[] _adblResponseBasisCoeff = null;</span>
<span class="fc" id="L198">	private org.drip.spline.segment.BasisEvaluator _be = null;</span>
<span class="fc" id="L199">	private double[][] _aadblDResponseBasisCoeffDConstraint = null;</span>
<span class="fc" id="L200">	private org.drip.spline.params.SegmentInelasticDesignControl _sidc = null;</span>
<span class="fc" id="L201">	private org.drip.numerical.differentiation.WengertJacobian _wjDBasisCoeffDEdgeValue = null;</span>

<span class="fc" id="L203">	private</span>
		org.drip.analytics.support.CaseInsensitiveHashMap&lt;org.drip.spline.segment.LatentStateManifestSensitivity&gt;
			_mapLSMS = new
				org.drip.analytics.support.CaseInsensitiveHashMap&lt;org.drip.spline.segment.LatentStateManifestSensitivity&gt;();

	/**
	 * Build the LatentStateResponseModel instance from the Basis Function/Shape Controller Set
	 * 
	 * @param dblLeftPredictorOrdinate Left Predictor Ordinate
	 * @param dblRightPredictorOrdinate Right Predictor Ordinate
	 * @param fs Response Basis Function Set
	 * @param rssc Shape Controller
	 * @param sidc Segment Inelastic Design Parameters
	 * 
	 * @return Instance of LatentStateResponseModel
	 */

	public static final org.drip.spline.segment.LatentStateResponseModel Create (
		final double dblLeftPredictorOrdinate,
		final double dblRightPredictorOrdinate,
		final org.drip.spline.basis.FunctionSet fs,
		final org.drip.spline.params.ResponseScalingShapeControl rssc,
		final org.drip.spline.params.SegmentInelasticDesignControl sidc)
	{
		try {
<span class="fc" id="L228">			org.drip.spline.segment.SegmentBasisEvaluator sbe = new</span>
				org.drip.spline.segment.SegmentBasisEvaluator (fs, rssc);

<span class="pc bpc" id="L231" title="1 of 2 branches missed.">			if (!org.drip.numerical.common.NumberUtil.IsValid (dblLeftPredictorOrdinate) ||</span>
<span class="pc bpc" id="L232" title="2 of 4 branches missed.">				!org.drip.numerical.common.NumberUtil.IsValid (dblRightPredictorOrdinate) ||</span>
				dblLeftPredictorOrdinate == dblRightPredictorOrdinate)
			{
<span class="nc" id="L235">				return null;</span>
			}

<span class="fc" id="L238">			org.drip.spline.segment.LatentStateResponseModel lsrm = new</span>
				org.drip.spline.segment.LatentStateResponseModel (dblLeftPredictorOrdinate,
					dblRightPredictorOrdinate, sbe, sidc);

<span class="pc bpc" id="L242" title="1 of 2 branches missed.">			return sbe.setContainingInelastics (lsrm) ? lsrm : null;</span>
<span class="nc" id="L243">		} catch (java.lang.Exception e) {</span>
<span class="nc" id="L244">			e.printStackTrace();</span>
		}

<span class="nc" id="L247">		return null;</span>
	}

	/**
	 * Build the LatentStateResponseModel instance from the Basis Evaluator Set
	 * 
	 * @param dblLeftPredictorOrdinate Left Predictor Ordinate
	 * @param dblRightPredictorOrdinate Right Predictor Ordinate
	 * @param be Basis Evaluator
	 * @param sidc Segment Inelastic Design Parameters
	 * 
	 * @return Instance of LatentStateResponseModel
	 */

	public static final org.drip.spline.segment.LatentStateResponseModel Create (
		final double dblLeftPredictorOrdinate,
		final double dblRightPredictorOrdinate,
		final org.drip.spline.segment.BasisEvaluator be,
		final org.drip.spline.params.SegmentInelasticDesignControl sidc)
	{
		try {
<span class="fc" id="L268">			org.drip.spline.segment.LatentStateResponseModel lsrm = new</span>
				org.drip.spline.segment.LatentStateResponseModel (dblLeftPredictorOrdinate,
					dblRightPredictorOrdinate, be, sidc);

<span class="pc bpc" id="L272" title="1 of 2 branches missed.">			return be.setContainingInelastics (lsrm) ? lsrm : null;</span>
<span class="nc" id="L273">		} catch (java.lang.Exception e) {</span>
<span class="nc" id="L274">			e.printStackTrace();</span>
		}

<span class="nc" id="L277">		return null;</span>
	}

	private LatentStateResponseModel (
		final double dblLeftPredictorOrdinate,
		final double dblRightPredictorOrdinate,
		final org.drip.spline.segment.BasisEvaluator be,
		final org.drip.spline.params.SegmentInelasticDesignControl sidc)
		throws java.lang.Exception
	{
<span class="fc" id="L287">		super (dblLeftPredictorOrdinate, dblRightPredictorOrdinate);</span>

<span class="pc bpc" id="L289" title="2 of 4 branches missed.">		if (null == (_be = be) || null == (_sidc = sidc))</span>
<span class="nc" id="L290">			throw new java.lang.Exception (&quot;LatentStateResponseModel ctr: Invalid Basis Functions!&quot;);</span>

<span class="fc" id="L292">		int iNumBasis = _be.numBasis();</span>

<span class="fc" id="L294">		_adblResponseBasisCoeff = new double[iNumBasis];</span>

<span class="pc bpc" id="L296" title="2 of 4 branches missed.">		if (0 &gt;= iNumBasis || _sidc.Ck() &gt; iNumBasis - 2)</span>
<span class="nc" id="L297">			throw new java.lang.Exception (&quot;LatentStateResponseModel ctr: Invalid inputs!&quot;);</span>
<span class="fc" id="L298">	}</span>

	private double[] DResponseDBasisCoeff (
		final double dblPredictorOrdinate,
		final int iOrder)
	{
<span class="pc bpc" id="L304" title="1 of 2 branches missed.">		if (0 == iOrder) return null;</span>

<span class="fc" id="L306">		int iNumBasis = _be.numBasis();</span>

<span class="fc" id="L308">		double[] adblDResponseDBasisCoeff = new double[iNumBasis];</span>

<span class="fc bfc" id="L310" title="All 2 branches covered.">		for (int i = 0; i &lt; iNumBasis; ++i) {</span>
			try {
<span class="pc bpc" id="L312" title="1 of 2 branches missed.">				adblDResponseDBasisCoeff[i] = 1 == iOrder ? _be.shapedBasisFunctionResponse</span>
<span class="pc" id="L313">					(dblPredictorOrdinate, i) : 0.;</span>
<span class="nc" id="L314">			} catch (java.lang.Exception e) {</span>
<span class="nc" id="L315">				e.printStackTrace();</span>

<span class="nc" id="L317">				return null;</span>
<span class="fc" id="L318">			}</span>
		}

<span class="fc" id="L321">		return adblDResponseDBasisCoeff;</span>
	}

	private double[] transmissionCk (
		final double dblPredictorOrdinate,
		final org.drip.spline.segment.LatentStateResponseModel csPreceeding,
		final int iCk)
	{
<span class="fc" id="L329">		double[] adblDeriv = new double[iCk];</span>

<span class="fc bfc" id="L331" title="All 2 branches covered.">		for (int i = 0; i &lt; iCk; ++i) {</span>
			try {
<span class="fc" id="L333">				adblDeriv[i] = csPreceeding.calcResponseValueDerivative (dblPredictorOrdinate, i + 1);</span>
<span class="nc" id="L334">			} catch (java.lang.Exception e) {</span>
<span class="nc" id="L335">				e.printStackTrace();</span>

<span class="nc" id="L337">				return null;</span>
<span class="fc" id="L338">			}</span>
		}

<span class="fc" id="L341">		return adblDeriv;</span>
	}

	private org.drip.spline.segment.LatentStateManifestSensitivity manifestSensitivity (
		final java.lang.String strManifestMeasure)
	{
<span class="pc bpc" id="L347" title="2 of 4 branches missed.">		return null == strManifestMeasure || strManifestMeasure.isEmpty() || !_mapLSMS.containsKey</span>
<span class="fc bfc" id="L348" title="All 2 branches covered.">			(strManifestMeasure) ? null : _mapLSMS.get (strManifestMeasure);</span>
	}

	private double[] CkDBasisCoeffDPreceedingManifestMeasure (
		final java.lang.String strManifestMeasure)
	{
<span class="fc" id="L354">		org.drip.spline.segment.LatentStateManifestSensitivity lsms = manifestSensitivity</span>
<span class="fc" id="L355">			(strManifestMeasure);</span>

<span class="pc bpc" id="L357" title="1 of 2 branches missed.">		if (null == lsms) return null;</span>

<span class="fc" id="L359">		int iCk = lsms.getPMSC().Ck();</span>

<span class="pc bpc" id="L361" title="1 of 2 branches missed.">		if (0 == iCk) return null;</span>

<span class="nc" id="L363">		double[] adblDBasisCoeffDPreceedingManifestTail = new double[iCk];</span>

<span class="nc bnc" id="L365" title="All 2 branches missed.">		for (int i = 0; i &lt; iCk; ++i)</span>
<span class="nc" id="L366">			adblDBasisCoeffDPreceedingManifestTail[i] = 0.;</span>

<span class="nc" id="L368">		return adblDBasisCoeffDPreceedingManifestTail;</span>
	}

	/**
	 * Set the Preceeding Manifest Sensitivity Control Parameters for the specified Manifest Measure
	 * 
	 * @param strManifestMeasure The Manifest Measure
	 * @param pmsc The Preceeding Manifest Sensitivity Control Instance
	 * 
	 * @return TRUE - Named Preceeding Manifest Sensitivity Control Instance Successfully Set
	 */

	public boolean setPreceedingManifestSensitivityControl (
		final java.lang.String strManifestMeasure,
		final org.drip.spline.params.PreceedingManifestSensitivityControl pmsc)
	{
<span class="pc bpc" id="L384" title="2 of 4 branches missed.">		if (null == strManifestMeasure || strManifestMeasure.isEmpty()) return false;</span>

		try {
<span class="fc" id="L387">			_mapLSMS.put (strManifestMeasure, new org.drip.spline.segment.LatentStateManifestSensitivity</span>
				(pmsc));

<span class="fc" id="L390">			return true;</span>
<span class="nc" id="L391">		} catch (java.lang.Exception e) {</span>
<span class="nc" id="L392">			e.printStackTrace();</span>
		}

<span class="nc" id="L395">		return false;</span>
	}

	/**
	 * Retrieve the Number of Parameters
	 * 
	 * @return The Number of Parameters
	 */

	public int numParameters()
	{
<span class="fc" id="L406">		return _sidc.Ck() + 2;</span>
	}

	/**
	 * Retrieve the Basis Evaluator
	 * 
	 * @return The Basis Evaluator
	 */

	public org.drip.spline.segment.BasisEvaluator basisEvaluator()
	{
<span class="fc" id="L417">		return _be;</span>
	}

	/**
	 * Retrieve the Array of Response Basis Coefficients
	 * 
	 * @return The Array of Response Basis Coefficients
	 */

	public double[] responseBasisCoefficient()
	{
<span class="nc" id="L428">		return _adblResponseBasisCoeff;</span>
	}

	/**
	 * Retrieve the Segment Inelastic Design Control
	 * 
	 * @return The Segment Inelastic Design Control
	 */

	public org.drip.spline.params.SegmentInelasticDesignControl designControl()
	{
<span class="nc" id="L439">		return _sidc;</span>
	}

	/**
	 * Main Calibrator: Calibrate the Segment State from the Calibration Parameter Set
	 * 
	 * @param ssciState The Segment State Calibration Inputs Set
	 * 
	 * @return TRUE - Calibration Successful
	 */

	public boolean calibrateState (
		final org.drip.spline.params.SegmentStateCalibrationInputs ssciState)
	{
<span class="pc bpc" id="L453" title="1 of 2 branches missed.">		if (null == ssciState) return false;</span>

<span class="fc" id="L455">		double[] adblPredictorOrdinate = ssciState.predictorOrdinates();</span>

<span class="fc" id="L457">		double[] adblResponseValue = ssciState.responseValues();</span>

<span class="fc" id="L459">		double[] adblLeftEdgeDeriv = ssciState.leftEdgeDeriv();</span>

<span class="fc" id="L461">		double[] adblRightEdgeDeriv = ssciState.rightEdgeDeriv();</span>

<span class="fc" id="L463">		org.drip.spline.params.SegmentBestFitResponse sbfr = ssciState.bestFitResponse();</span>

<span class="fc" id="L465">		org.drip.spline.params.SegmentBasisFlexureConstraint[] aSBFC = ssciState.flexureConstraint();</span>

<span class="fc" id="L467">		int iNumConstraint = 0;</span>
<span class="fc" id="L468">		int iNumResponseBasisCoeff = _adblResponseBasisCoeff.length;</span>
<span class="fc bfc" id="L469" title="All 2 branches covered.">		int iNumLeftDeriv = null == adblLeftEdgeDeriv ? 0 : adblLeftEdgeDeriv.length;</span>
<span class="fc bfc" id="L470" title="All 2 branches covered.">		int iNumRightDeriv = null == adblRightEdgeDeriv ? 0 : adblRightEdgeDeriv.length;</span>
<span class="fc" id="L471">		double[] adblPredictorResponseConstraintValue = new double[iNumResponseBasisCoeff];</span>
<span class="fc bfc" id="L472" title="All 2 branches covered.">		int iNumPredictorOrdinate = null == adblPredictorOrdinate ? 0 : adblPredictorOrdinate.length;</span>
<span class="fc" id="L473">		double[][] aadblResponseBasisCoeffConstraint = new</span>
			double[iNumResponseBasisCoeff][iNumResponseBasisCoeff];

<span class="fc bfc" id="L476" title="All 2 branches covered.">		if (null != aSBFC) {</span>
<span class="fc" id="L477">			int iNumPotentialConstraint = aSBFC.length;</span>

<span class="fc bfc" id="L479" title="All 2 branches covered.">			for (int i = 0; i &lt; iNumPotentialConstraint; ++i) {</span>
<span class="fc bfc" id="L480" title="All 2 branches covered.">				if (null != aSBFC[i]) ++iNumConstraint;</span>
			}
		}

<span class="pc bpc" id="L484" title="1 of 2 branches missed.">		if (iNumResponseBasisCoeff &lt; iNumPredictorOrdinate + iNumLeftDeriv + iNumRightDeriv + iNumConstraint)</span>
<span class="nc" id="L485">			return false;</span>

		try {
<span class="fc" id="L488">			org.drip.spline.segment.BestFitFlexurePenalizer bffp = new</span>
<span class="fc" id="L489">				org.drip.spline.segment.BestFitFlexurePenalizer (this, _sidc.curvaturePenaltyControl(),</span>
<span class="fc" id="L490">					_sidc.lengthPenaltyControl(), sbfr, _be);</span>

<span class="fc bfc" id="L492" title="All 2 branches covered.">			for (int j = 0; j &lt; iNumResponseBasisCoeff; ++j) {</span>
<span class="fc bfc" id="L493" title="All 2 branches covered.">				if (j &lt; iNumPredictorOrdinate)</span>
<span class="fc" id="L494">					adblPredictorResponseConstraintValue[j] = adblResponseValue[j];</span>
<span class="fc bfc" id="L495" title="All 2 branches covered.">				else if (j &lt; iNumPredictorOrdinate + iNumConstraint)</span>
<span class="fc" id="L496">					adblPredictorResponseConstraintValue[j] = aSBFC[j -</span>
<span class="fc" id="L497">					    iNumPredictorOrdinate].contraintValue();</span>
<span class="fc bfc" id="L498" title="All 2 branches covered.">				else if (j &lt; iNumPredictorOrdinate + iNumConstraint + iNumLeftDeriv)</span>
<span class="fc" id="L499">					adblPredictorResponseConstraintValue[j] = adblLeftEdgeDeriv[j - iNumPredictorOrdinate -</span>
					    iNumConstraint];
<span class="fc bfc" id="L501" title="All 2 branches covered.">				else if (j &lt; iNumPredictorOrdinate + iNumConstraint + iNumLeftDeriv + iNumRightDeriv)</span>
<span class="fc" id="L502">					adblPredictorResponseConstraintValue[j] = adblRightEdgeDeriv[j - iNumPredictorOrdinate -</span>
					    iNumConstraint - iNumLeftDeriv];
				else
<span class="fc" id="L505">					adblPredictorResponseConstraintValue[j] = bffp.basisPairPenaltyConstraint (j);</span>
			}

<span class="fc bfc" id="L508" title="All 2 branches covered.">			for (int i = 0; i &lt; iNumResponseBasisCoeff; ++i) {</span>
<span class="fc bfc" id="L509" title="All 2 branches covered.">				for (int l = 0; l &lt; iNumResponseBasisCoeff; ++l) {</span>
<span class="fc" id="L510">					double[] adblCalibBasisConstraintWeight = null;</span>

<span class="fc bfc" id="L512" title="All 6 branches covered.">					if (0 != iNumConstraint &amp;&amp; (l &gt;= iNumPredictorOrdinate &amp;&amp; l &lt; iNumPredictorOrdinate +</span>
						iNumConstraint))
<span class="fc" id="L514">						adblCalibBasisConstraintWeight = aSBFC[l -</span>
<span class="fc" id="L515">						    iNumPredictorOrdinate].responseBasisCoeffWeights();</span>

<span class="fc bfc" id="L517" title="All 2 branches covered.">					if (l &lt; iNumPredictorOrdinate)</span>
<span class="fc" id="L518">						aadblResponseBasisCoeffConstraint[l][i] = _be.shapedBasisFunctionResponse</span>
<span class="fc" id="L519">							(adblPredictorOrdinate[l], i);</span>
<span class="fc bfc" id="L520" title="All 2 branches covered.">					else if (l &lt; iNumPredictorOrdinate + iNumConstraint)</span>
<span class="fc" id="L521">						aadblResponseBasisCoeffConstraint[l][i] = adblCalibBasisConstraintWeight[i];</span>
<span class="fc bfc" id="L522" title="All 2 branches covered.">					else if (l &lt; iNumPredictorOrdinate + iNumConstraint + iNumLeftDeriv)</span>
<span class="fc" id="L523">						aadblResponseBasisCoeffConstraint[l][i] = _be.shapedBasisFunctionDerivative (left(),</span>
							l - iNumPredictorOrdinate - iNumConstraint + 1, i);
<span class="fc bfc" id="L525" title="All 2 branches covered.">					else if (l &lt; iNumPredictorOrdinate + iNumConstraint + iNumLeftDeriv + iNumRightDeriv)</span>
<span class="fc" id="L526">						aadblResponseBasisCoeffConstraint[l][i] = _be.shapedBasisFunctionDerivative</span>
<span class="fc" id="L527">							(right(), l - iNumPredictorOrdinate - iNumConstraint - iNumLeftDeriv + 1, i);</span>
					else
<span class="fc" id="L529">						aadblResponseBasisCoeffConstraint[l][i] = bffp.basisPairConstraintCoefficient (i, l);</span>
				}
			}
<span class="nc" id="L532">		} catch (java.lang.Exception e) {</span>
<span class="nc" id="L533">			e.printStackTrace();</span>

<span class="nc" id="L535">			return false;</span>
<span class="fc" id="L536">		}</span>

<span class="fc" id="L538">		org.drip.numerical.linearalgebra.LinearizationOutput lo =</span>
			org.drip.numerical.linearalgebra.LinearSystemSolver.SolveUsingMatrixInversion
<span class="fc" id="L540">				(aadblResponseBasisCoeffConstraint, adblPredictorResponseConstraintValue);</span>

<span class="fc bfc" id="L542" title="All 2 branches covered.">		if (null == lo) return false;</span>

<span class="fc" id="L544">		double[] adblCalibResponseBasisCoeff = lo.getTransformedRHS();</span>

<span class="pc bpc" id="L546" title="2 of 4 branches missed.">		if (null == adblCalibResponseBasisCoeff || adblCalibResponseBasisCoeff.length !=</span>
			iNumResponseBasisCoeff || null == (_aadblDResponseBasisCoeffDConstraint =
<span class="pc bpc" id="L548" title="3 of 6 branches missed.">				lo.getTransformedMatrix()) || _aadblDResponseBasisCoeffDConstraint.length !=</span>
					iNumResponseBasisCoeff || _aadblDResponseBasisCoeffDConstraint[0].length !=
						iNumResponseBasisCoeff)
<span class="nc" id="L551">			return false;</span>

<span class="fc bfc" id="L553" title="All 2 branches covered.">		for (int i = 0; i &lt; iNumResponseBasisCoeff; ++i) {</span>
<span class="pc bpc" id="L554" title="1 of 2 branches missed.">			if (!org.drip.numerical.common.NumberUtil.IsValid (_adblResponseBasisCoeff[i] =</span>
				adblCalibResponseBasisCoeff[i]))
<span class="nc" id="L556">				return false;</span>
		}

<span class="fc" id="L559">		return true;</span>
	}

	/**
	 * Sensitivity Calibrator: Calibrate the Segment Manifest Measure Jacobian from the Calibration Inputs
	 * 
	 * @param ssciManifestSensitivity The Segment Manifest Calibration Sensitivity Inputs
	 * @param aSBFCState Array of Segment State Basis Flexure Constraints
	 * 
	 * @return The Manifest Sensitivity Coefficients
	 */

	public double[] calibrateManifestJacobian (
		final org.drip.spline.params.SegmentStateCalibrationInputs ssciManifestSensitivity,
		final org.drip.spline.params.SegmentBasisFlexureConstraint[] aSBFCState)
	{
<span class="pc bpc" id="L575" title="1 of 2 branches missed.">		if (null == ssciManifestSensitivity) return null;</span>

<span class="fc" id="L577">		double[] adblPredictorOrdinate = ssciManifestSensitivity.predictorOrdinates();</span>

<span class="fc" id="L579">		double[] adblResponseValueManifestSensitivity = ssciManifestSensitivity.responseValues();</span>

<span class="fc" id="L581">		double[] adblLeftEdgeDerivManifestSensitivity = ssciManifestSensitivity.leftEdgeDeriv();</span>

<span class="fc" id="L583">		double[] adblRightEdgeDerivManifestSensitivity = ssciManifestSensitivity.rightEdgeDeriv();</span>

<span class="fc" id="L585">		org.drip.spline.params.SegmentBestFitResponse sbfrManifestSensitivity =</span>
<span class="fc" id="L586">			ssciManifestSensitivity.bestFitResponse();</span>

<span class="fc" id="L588">		org.drip.spline.params.SegmentBasisFlexureConstraint[] aSBFCManifestSensitivity =</span>
<span class="fc" id="L589">			ssciManifestSensitivity.flexureConstraint();</span>

<span class="fc" id="L591">		int iNumConstraint = 0;</span>
<span class="fc" id="L592">		int iNumResponseBasisCoeff = _adblResponseBasisCoeff.length;</span>
<span class="fc bfc" id="L593" title="All 2 branches covered.">		int iNumPredictorOrdinate = null == adblPredictorOrdinate ? 0 : adblPredictorOrdinate.length;</span>
<span class="fc" id="L594">		double[] adblPredictorResponseManifestSensitivityConstraint = new double[iNumResponseBasisCoeff];</span>
<span class="fc bfc" id="L595" title="All 2 branches covered.">		int iNumLeftDerivManifestSensitivity = null == adblLeftEdgeDerivManifestSensitivity ? 0 :</span>
			adblLeftEdgeDerivManifestSensitivity.length;
<span class="pc bpc" id="L597" title="1 of 2 branches missed.">		int iNumRightDerivManifestSensitivity = null == adblRightEdgeDerivManifestSensitivity ? 0 :</span>
			adblRightEdgeDerivManifestSensitivity.length;
<span class="fc" id="L599">		double[][] aadblResponseCoeffConstraintManifestSensitivity = new</span>
			double[iNumResponseBasisCoeff][iNumResponseBasisCoeff];

<span class="fc bfc" id="L602" title="All 2 branches covered.">		if (null != aSBFCState) {</span>
<span class="fc" id="L603">			int iNumPotentialConstraint = aSBFCState.length;</span>

<span class="fc bfc" id="L605" title="All 2 branches covered.">			for (int i = 0; i &lt; iNumPotentialConstraint; ++i) {</span>
<span class="pc bpc" id="L606" title="1 of 2 branches missed.">				if (null != aSBFCState[i]) ++iNumConstraint;</span>
			}
		}

<span class="pc bpc" id="L610" title="1 of 2 branches missed.">		if (iNumResponseBasisCoeff &lt; iNumPredictorOrdinate + iNumLeftDerivManifestSensitivity +</span>
			iNumRightDerivManifestSensitivity + iNumConstraint)
<span class="nc" id="L612">			return null;</span>

		try {
<span class="pc bpc" id="L615" title="1 of 2 branches missed.">			org.drip.spline.segment.BestFitFlexurePenalizer bffpManifestSensitivity = new</span>
				org.drip.spline.segment.BestFitFlexurePenalizer (this, null == _sidc ? null :
<span class="pc bpc" id="L617" title="1 of 2 branches missed.">					_sidc.curvaturePenaltyControl(), null == _sidc ? null : _sidc.lengthPenaltyControl(),</span>
						sbfrManifestSensitivity, _be);

<span class="fc bfc" id="L620" title="All 2 branches covered.">			for (int j = 0; j &lt; iNumResponseBasisCoeff; ++j) {</span>
<span class="fc bfc" id="L621" title="All 2 branches covered.">				if (j &lt; iNumPredictorOrdinate)</span>
<span class="fc" id="L622">					adblPredictorResponseManifestSensitivityConstraint[j] =</span>
						adblResponseValueManifestSensitivity[j];
<span class="fc bfc" id="L624" title="All 2 branches covered.">				else if (j &lt; iNumPredictorOrdinate + iNumConstraint) {</span>
<span class="fc" id="L625">					adblPredictorResponseManifestSensitivityConstraint[j] = 0.;</span>
<span class="fc" id="L626">					org.drip.spline.params.SegmentBasisFlexureConstraint sbfcManifestSensitivity =</span>
						aSBFCManifestSensitivity[j - iNumPredictorOrdinate];

<span class="pc bpc" id="L629" title="1 of 2 branches missed.">					if (null != sbfcManifestSensitivity) {</span>
<span class="fc" id="L630">						adblPredictorResponseManifestSensitivityConstraint[j] =</span>
<span class="fc" id="L631">							sbfcManifestSensitivity.contraintValue();</span>

<span class="fc" id="L633">						double[] adblCalibConstraintWeightManifestSensitivity =</span>
<span class="fc" id="L634">							sbfcManifestSensitivity.responseBasisCoeffWeights();</span>

<span class="fc bfc" id="L636" title="All 2 branches covered.">						for (int i = 0; i &lt; iNumResponseBasisCoeff; ++i)</span>
<span class="fc" id="L637">							adblPredictorResponseManifestSensitivityConstraint[j] -=</span>
								_adblResponseBasisCoeff[i] * adblCalibConstraintWeightManifestSensitivity[i];
					}
<span class="fc bfc" id="L640" title="All 2 branches covered.">				} else if (j &lt; iNumPredictorOrdinate + iNumConstraint + iNumLeftDerivManifestSensitivity)</span>
<span class="fc" id="L641">					adblPredictorResponseManifestSensitivityConstraint[j] =</span>
						adblLeftEdgeDerivManifestSensitivity[j - iNumPredictorOrdinate - iNumConstraint];
<span class="pc bpc" id="L643" title="1 of 2 branches missed.">				else if (j &lt; iNumPredictorOrdinate + iNumConstraint + iNumLeftDerivManifestSensitivity +</span>
					iNumRightDerivManifestSensitivity)
<span class="nc" id="L645">					adblPredictorResponseManifestSensitivityConstraint[j] =</span>
						adblRightEdgeDerivManifestSensitivity[j - iNumPredictorOrdinate - iNumConstraint -
						    iNumLeftDerivManifestSensitivity];
				else
<span class="fc" id="L649">					adblPredictorResponseManifestSensitivityConstraint[j] =</span>
<span class="fc" id="L650">						bffpManifestSensitivity.basisPairPenaltyConstraint (j);</span>
			}

<span class="fc bfc" id="L653" title="All 2 branches covered.">			for (int i = 0; i &lt; iNumResponseBasisCoeff; ++i) {</span>
<span class="fc bfc" id="L654" title="All 2 branches covered.">				for (int l = 0; l &lt; iNumResponseBasisCoeff; ++l) {</span>
<span class="fc" id="L655">					double[] adblCalibBasisConstraintWeight = null;</span>

<span class="fc bfc" id="L657" title="All 6 branches covered.">					if (0 != iNumConstraint &amp;&amp; (l &gt;= iNumPredictorOrdinate &amp;&amp; l &lt; iNumPredictorOrdinate +</span>
						iNumConstraint))
<span class="fc" id="L659">						adblCalibBasisConstraintWeight = aSBFCState[l -</span>
<span class="fc" id="L660">						    iNumPredictorOrdinate].responseBasisCoeffWeights();</span>

<span class="fc bfc" id="L662" title="All 2 branches covered.">					if (l &lt; iNumPredictorOrdinate)</span>
<span class="fc" id="L663">						aadblResponseCoeffConstraintManifestSensitivity[l][i] =</span>
<span class="fc" id="L664">							_be.shapedBasisFunctionResponse (adblPredictorOrdinate[l], i);</span>
<span class="fc bfc" id="L665" title="All 2 branches covered.">					else if (l &lt; iNumPredictorOrdinate + iNumConstraint)</span>
<span class="fc" id="L666">						aadblResponseCoeffConstraintManifestSensitivity[l][i] =</span>
							adblCalibBasisConstraintWeight[i];
<span class="fc bfc" id="L668" title="All 2 branches covered.">					else if (l &lt; iNumPredictorOrdinate + iNumConstraint + iNumLeftDerivManifestSensitivity)</span>
<span class="fc" id="L669">						aadblResponseCoeffConstraintManifestSensitivity[l][i] =</span>
<span class="fc" id="L670">							_be.shapedBasisFunctionDerivative (left(), l - iNumPredictorOrdinate -</span>
								iNumConstraint + 1, i);
<span class="pc bpc" id="L672" title="1 of 2 branches missed.">					else if (l &lt; iNumPredictorOrdinate + iNumConstraint + iNumLeftDerivManifestSensitivity +</span>
						iNumRightDerivManifestSensitivity)
<span class="nc" id="L674">						aadblResponseCoeffConstraintManifestSensitivity[l][i] =</span>
<span class="nc" id="L675">							_be.shapedBasisFunctionDerivative (right(), l - iNumPredictorOrdinate -</span>
								iNumConstraint - iNumLeftDerivManifestSensitivity + 1, i);
					else
<span class="fc" id="L678">						aadblResponseCoeffConstraintManifestSensitivity[l][i] =</span>
<span class="fc" id="L679">							bffpManifestSensitivity.basisPairConstraintCoefficient (i, l);</span>
				}
			}
<span class="nc" id="L682">		} catch (java.lang.Exception e) {</span>
<span class="nc" id="L683">			e.printStackTrace();</span>

<span class="nc" id="L685">			return null;</span>
<span class="fc" id="L686">		}</span>

<span class="fc" id="L688">		org.drip.numerical.linearalgebra.LinearizationOutput lo =</span>
			org.drip.numerical.linearalgebra.LinearSystemSolver.SolveUsingMatrixInversion
<span class="fc" id="L690">				(aadblResponseCoeffConstraintManifestSensitivity,</span>
					adblPredictorResponseManifestSensitivityConstraint);

<span class="pc bpc" id="L693" title="1 of 2 branches missed.">		return null == lo ? null : lo.getTransformedRHS();</span>
	}

	/**
	 * Sensitivity Calibrator: Calibrate the Segment Local Manifest Jacobian from the Calibration Parameter
	 * 	Set
	 * 
	 * @param strManifestMeasure Latent State Manifest Measure
	 * @param ssciManifestSensitivity The Segment Manifest Calibration Parameter Sensitivity
	 * @param aSBFCState Array of Segment State Basis Flexure Constraints
	 * 
	 * @return TRUE - Local Manifest Sensitivity Calibration Successful
	 */

	public boolean calibrateLocalManifestJacobian (
		final java.lang.String strManifestMeasure,
		final org.drip.spline.params.SegmentStateCalibrationInputs ssciManifestSensitivity,
		final org.drip.spline.params.SegmentBasisFlexureConstraint[] aSBFCState)
	{
<span class="fc" id="L712">		org.drip.spline.segment.LatentStateManifestSensitivity lsms = manifestSensitivity</span>
<span class="fc" id="L713">			(strManifestMeasure);</span>

<span class="pc bpc" id="L715" title="1 of 2 branches missed.">		if (null == lsms) return false;</span>

<span class="fc" id="L717">		double[] adblDBasisCoeffDLocalManifest = calibrateManifestJacobian (ssciManifestSensitivity,</span>
			aSBFCState);

<span class="pc bpc" id="L720" title="2 of 4 branches missed.">		return null == adblDBasisCoeffDLocalManifest || adblDBasisCoeffDLocalManifest.length !=</span>
			_adblResponseBasisCoeff.length ? false : lsms.setDBasisCoeffDLocalManifest
<span class="fc" id="L722">				(adblDBasisCoeffDLocalManifest);</span>
	}

	/**
	 * Sensitivity Calibrator: Calibrate the Segment Preceeding Manifest Jacobian from the Calibration
	 *	Parameter Set
	 * 
	 * @param strManifestMeasure Latent State Manifest
	 * @param ssciPreceedingManifestSensitivity The Segment Preceeding Manifest Calibration Parameter
	 * 	Sensitivity
	 * 
	 * @return TRUE - Preceeding Manifest Sensitivity Calibration Successful
	 */

	public boolean calibratePreceedingManifestJacobian (
		final java.lang.String strManifestMeasure,
		final org.drip.spline.params.SegmentStateCalibrationInputs ssciPreceedingManifestSensitivity)
	{
<span class="fc" id="L740">		org.drip.spline.segment.LatentStateManifestSensitivity lsms = manifestSensitivity</span>
<span class="fc" id="L741">			(strManifestMeasure);</span>

<span class="pc bpc" id="L743" title="1 of 2 branches missed.">		if (null == lsms) return false;</span>

<span class="fc" id="L745">		double[] adblDBasisCoeffDPreceedingManifest = calibrateManifestJacobian</span>
<span class="fc" id="L746">			(ssciPreceedingManifestSensitivity, null);</span>

<span class="pc bpc" id="L748" title="2 of 4 branches missed.">		return null == adblDBasisCoeffDPreceedingManifest || adblDBasisCoeffDPreceedingManifest.length !=</span>
			_adblResponseBasisCoeff.length ? false : lsms.setDBasisCoeffDPreceedingManifest
<span class="fc" id="L750">				(adblDBasisCoeffDPreceedingManifest);</span>
	}

	/**
	 * Calibrate the coefficients from the prior Predictor/Response Segment, the Constraint, and fitness
	 * 	Weights
	 * 
	 * @param csPreceeding Preceeding Predictor/Response Segment
	 * @param srvcState The Segment State Response Value Constraint
	 * @param sbfrState Segment's Best Fit Weighted State Response Values
	 * 
	 * @return TRUE - If the calibration succeeds
	 */

	public boolean calibrate (
		final org.drip.spline.segment.LatentStateResponseModel csPreceeding,
		final org.drip.spline.params.SegmentResponseValueConstraint srvcState,
		final org.drip.spline.params.SegmentBestFitResponse sbfrState)
	{
<span class="fc" id="L769">		int iCk = _sidc.Ck();</span>

<span class="fc bfc" id="L771" title="All 2 branches covered.">		org.drip.spline.params.SegmentBasisFlexureConstraint[] aSBFCState = null == srvcState ? null : new</span>
			org.drip.spline.params.SegmentBasisFlexureConstraint[] {srvcState.responseIndexedBasisConstraint
<span class="fc" id="L773">				(_be, this)};</span>

<span class="fc" id="L775">		double[] adblManifestJacobianDerivAtLeftOrdinate = null;</span>

<span class="fc bfc" id="L777" title="All 2 branches covered.">		if (0 != iCk) {</span>
<span class="fc" id="L778">			adblManifestJacobianDerivAtLeftOrdinate = new double[iCk];</span>

<span class="fc bfc" id="L780" title="All 2 branches covered.">			for (int i = 0; i &lt; iCk; ++i)</span>
<span class="fc" id="L781">				adblManifestJacobianDerivAtLeftOrdinate[i] = 0.;</span>
		}

<span class="pc bpc" id="L784" title="1 of 2 branches missed.">		if (null == csPreceeding) {</span>
			try {
<span class="nc" id="L786">				double[] adblStateDerivAtLeftOrdinate = null;</span>

<span class="nc bnc" id="L788" title="All 2 branches missed.">				if (0 != iCk) {</span>
<span class="nc" id="L789">					adblStateDerivAtLeftOrdinate = new double[iCk];</span>

<span class="nc bnc" id="L791" title="All 2 branches missed.">					for (int i = 0; i &lt; iCk; ++i)</span>
<span class="nc" id="L792">						adblStateDerivAtLeftOrdinate[i] = _be.responseValueDerivative</span>
<span class="nc" id="L793">							(_adblResponseBasisCoeff, left(), i);</span>
				}

<span class="nc" id="L796">				return calibrateState (new org.drip.spline.params.SegmentStateCalibrationInputs (new double[]</span>
<span class="nc" id="L797">					{left()}, new double[] {_be.responseValue (_adblResponseBasisCoeff, left())},</span>
						adblStateDerivAtLeftOrdinate, null, aSBFCState, sbfrState));
<span class="nc" id="L799">			} catch (java.lang.Exception e) {</span>
<span class="nc" id="L800">				e.printStackTrace();</span>
			}

<span class="nc" id="L803">			return false;</span>
		}

		try {
<span class="fc" id="L807">			return calibrateState (new org.drip.spline.params.SegmentStateCalibrationInputs (new double[]</span>
<span class="fc bfc" id="L808" title="All 2 branches covered.">				{left()}, new double[] {csPreceeding.responseValue (left())}, 0 == iCk ? null :</span>
<span class="fc" id="L809">					transmissionCk (left(), csPreceeding, iCk), null, aSBFCState, sbfrState));</span>
<span class="nc" id="L810">		} catch (java.lang.Exception e) {</span>
<span class="nc" id="L811">			e.printStackTrace();</span>
		}

<span class="nc" id="L814">		return false;</span>
	}

	/**
	 * Calibrate the coefficients from the prior Segment and the Response Value at the Right Predictor
	 *  Ordinate
	 * 
	 * @param csPreceeding Preceeding Predictor/Response Segment
	 * @param dblRightStateValue Response Value at the Right Predictor Ordinate
	 * @param sbfrState Segment's Best Fit Weighted Response Values
	 * 
	 * @return TRUE - If the calibration succeeds
	 */

	public boolean calibrate (
		final LatentStateResponseModel csPreceeding,
		final double dblRightStateValue,
		final org.drip.spline.params.SegmentBestFitResponse sbfrState)
	{
<span class="pc bpc" id="L833" title="1 of 2 branches missed.">		if (null == csPreceeding) return false;</span>

<span class="fc" id="L835">		int iCk = _sidc.Ck();</span>

		try {
<span class="fc" id="L838">			return calibrateState (new org.drip.spline.params.SegmentStateCalibrationInputs (new double[]</span>
<span class="fc bfc" id="L839" title="All 2 branches covered.">				{left(), right()}, new double[] {csPreceeding.responseValue (left()), dblRightStateValue}, 0</span>
<span class="fc" id="L840">					!= iCk ? csPreceeding.transmissionCk (left(), this, iCk) : null, null, null, sbfrState));</span>
<span class="nc" id="L841">		} catch (java.lang.Exception e) {</span>
<span class="nc" id="L842">			e.printStackTrace();</span>
		}

<span class="nc" id="L845">		return false;</span>
	}

	/**
	 * Calibrate the Coefficients from the Edge Response Values and the Left Edge Response Slope
	 * 
	 * @param dblLeftValue Left Edge Response Value
	 * @param dblLeftSlope Left Edge Response Slope
	 * @param dblRightValue Right Edge Response Value
	 * @param sbfrState Segment's Best Fit Weighted Response Values
	 * 
	 * @return TRUE - The Calibration Succeeded
	 */

	public boolean calibrate (
		final double dblLeftValue,
		final double dblLeftSlope,
		final double dblRightValue,
		final org.drip.spline.params.SegmentBestFitResponse sbfrState)
	{
<span class="pc bpc" id="L865" title="1 of 2 branches missed.">		if (!org.drip.numerical.common.NumberUtil.IsValid (dblLeftValue) ||</span>
<span class="pc bpc" id="L866" title="1 of 2 branches missed.">			!org.drip.numerical.common.NumberUtil.IsValid (dblLeftSlope) ||</span>
<span class="pc bpc" id="L867" title="1 of 2 branches missed.">				!org.drip.numerical.common.NumberUtil.IsValid (dblRightValue))</span>
<span class="nc" id="L868">			return false;</span>

		try {
<span class="fc" id="L871">			return calibrateState (new org.drip.spline.params.SegmentStateCalibrationInputs (new double[]</span>
<span class="fc" id="L872">				{left(), right()}, new double[] {dblLeftValue, dblRightValue},</span>
<span class="fc" id="L873">					org.drip.numerical.common.CollectionUtil.DerivArrayFromSlope (numParameters() - 2,</span>
						dblLeftSlope), null, null, sbfrState));
<span class="nc" id="L875">		} catch (java.lang.Exception e) {</span>
<span class="nc" id="L876">			e.printStackTrace();</span>
		}

<span class="nc" id="L879">		return false;</span>
	}

	/**
	 * Calibrate the coefficients from the Left Edge Response Value Constraint, the Left Edge Response Value
	 *  Slope, and the Right Edge Response Value Constraint
	 * 
	 * @param wrvcStateLeft Left Edge Response Value Constraint
	 * @param dblLeftSlope Left Edge Response Value Slope
	 * @param wrvcStateRight Right Edge Response Value Constraint
	 * @param sbfrState Segment's Best Fit Weighted Response
	 * 
	 * @return TRUE - If the calibration succeeds
	 */

	public boolean calibrate (
		final org.drip.spline.params.SegmentResponseValueConstraint wrvcStateLeft,
		final double dblLeftSlope,
		final org.drip.spline.params.SegmentResponseValueConstraint wrvcStateRight,
		final org.drip.spline.params.SegmentBestFitResponse sbfrState)
	{
<span class="fc" id="L900">		org.drip.spline.params.SegmentBasisFlexureConstraint[] aSBFCState = null;</span>

		try {
<span class="pc bpc" id="L903" title="1 of 4 branches missed.">			if (null != wrvcStateLeft || null != wrvcStateRight)</span>
<span class="pc bpc" id="L904" title="1 of 2 branches missed.">				aSBFCState = new org.drip.spline.params.SegmentBasisFlexureConstraint[] {null ==</span>
<span class="fc bfc" id="L905" title="All 2 branches covered.">					wrvcStateLeft ? null : wrvcStateLeft.responseIndexedBasisConstraint (_be, this), null ==</span>
<span class="fc" id="L906">						wrvcStateRight ? null : wrvcStateRight.responseIndexedBasisConstraint (_be, this)};</span>

<span class="fc" id="L908">			return calibrateState (new org.drip.spline.params.SegmentStateCalibrationInputs (null, null,</span>
<span class="fc" id="L909">				org.drip.numerical.common.CollectionUtil.DerivArrayFromSlope (numParameters() - 2, dblLeftSlope),</span>
					null, aSBFCState, sbfrState));
<span class="nc" id="L911">		} catch (java.lang.Exception e) {</span>
<span class="nc" id="L912">			e.printStackTrace();</span>
		}

<span class="nc" id="L915">		return false;</span>
	}

	/**
	 * Compute the Local and the Preceeding Manifest Measure Sensitivity Coefficients from the Preceeding
	 * 	Segment, the Local Response Value, the Local Response Value Manifest Measure Sensitivity, and the
	 * 	Local Best Fit Response Sensitivity
	 * 
	 * @param csPreceeding Preceeding Predictor/Response Segment
	 * @param strManifestMeasure Manifest Measure whose Sensitivity is sought
	 * @param srvcState The Segment State Response Value Constraint
	 * @param srvcManifestSensitivity The Segment State Response Value Constraint Manifest Sensitivity
	 * @param sbfrManifestSensitivity Segment's Best Fit Weighted State Response Value Manifest Sensitivity
	 * 
	 * @return TRUE - If the calibration succeeds
	 */

	public boolean manifestMeasureSensitivity (
		final org.drip.spline.segment.LatentStateResponseModel csPreceeding,
		final java.lang.String strManifestMeasure,
		final org.drip.spline.params.SegmentResponseValueConstraint srvcState,
		final org.drip.spline.params.SegmentResponseValueConstraint srvcManifestSensitivity,
		final org.drip.spline.params.SegmentBestFitResponse sbfrManifestSensitivity)
	{
<span class="pc bpc" id="L939" title="3 of 4 branches missed.">		if (null == srvcState &amp;&amp; null != srvcManifestSensitivity) return false;</span>

<span class="pc bpc" id="L941" title="1 of 2 branches missed.">		org.drip.spline.params.SegmentBasisFlexureConstraint[] aSBFCState = null == srvcState ? null : new</span>
			org.drip.spline.params.SegmentBasisFlexureConstraint[] {srvcState.responseIndexedBasisConstraint
<span class="fc" id="L943">				(_be, this)};</span>

<span class="pc bpc" id="L945" title="1 of 2 branches missed.">		org.drip.spline.params.SegmentBasisFlexureConstraint[] aSBFCManifestSensitivity = null ==</span>
			srvcManifestSensitivity ? null : new org.drip.spline.params.SegmentBasisFlexureConstraint[]
<span class="fc" id="L947">				{srvcManifestSensitivity.responseIndexedBasisConstraint (_be, this)};</span>

<span class="fc" id="L949">		double[] adblManifestJacobianDerivAtLeftOrdinate = null;</span>

<span class="fc" id="L951">		int iCk = _sidc.Ck();</span>

<span class="fc bfc" id="L953" title="All 2 branches covered.">		if (0 != iCk) {</span>
<span class="fc" id="L954">			adblManifestJacobianDerivAtLeftOrdinate = new double[iCk];</span>

<span class="fc bfc" id="L956" title="All 2 branches covered.">			for (int i = 0; i &lt; iCk; ++i)</span>
<span class="fc" id="L957">				adblManifestJacobianDerivAtLeftOrdinate[i] = 0.;</span>
		}

<span class="pc bpc" id="L960" title="1 of 2 branches missed.">		if (null == csPreceeding) return false;</span>

		try {
<span class="pc bpc" id="L963" title="1 of 2 branches missed.">			if (null == aSBFCManifestSensitivity) return true;</span>

<span class="pc bpc" id="L965" title="1 of 2 branches missed.">			if (!calibrateLocalManifestJacobian (strManifestMeasure, new</span>
<span class="fc" id="L966">				org.drip.spline.params.SegmentStateCalibrationInputs (new double[] {left()}, new double[]</span>
					{0.}, adblManifestJacobianDerivAtLeftOrdinate, null, aSBFCManifestSensitivity,
						sbfrManifestSensitivity), aSBFCState))
<span class="nc" id="L969">				return false;</span>

<span class="fc" id="L971">			org.drip.spline.segment.LatentStateManifestSensitivity lsms = manifestSensitivity</span>
<span class="fc" id="L972">				(strManifestMeasure);</span>

<span class="pc bpc" id="L974" title="1 of 2 branches missed.">			if (null == lsms) return true;</span>

<span class="pc bpc" id="L976" title="1 of 2 branches missed.">			return lsms.getPMSC().impactFade() ? calibratePreceedingManifestJacobian (strManifestMeasure, new</span>
<span class="fc" id="L977">				org.drip.spline.params.SegmentStateCalibrationInputs (new double[] {left(), right()}, new</span>
<span class="fc" id="L978">					double[] {csPreceeding.calcDResponseDManifest (strManifestMeasure, left(), 1), 0.}, null,</span>
<span class="fc" id="L979">						CkDBasisCoeffDPreceedingManifestMeasure (strManifestMeasure), null, null)) :</span>
<span class="nc" id="L980">							lsms.setDResponseDPreceedingManifest (csPreceeding.calcDResponseDManifest</span>
<span class="nc" id="L981">								(strManifestMeasure, left(), 1));</span>
<span class="nc" id="L982">		} catch (java.lang.Exception e) {</span>
<span class="nc" id="L983">			e.printStackTrace();</span>
		}

<span class="nc" id="L986">		return false;</span>
	}

	/**
	 * Compute the Local and the Preceeding Manifest Measure Sensitivity Coefficients from the Preceeding
	 * 	Segments, the Local Response Value Sensitivity at the Right Predictor Ordinate, and the Local Best
	 * 	Fit Response Sensitivity
	 * 
	 * @param csPreceeding Preceeding Predictor/Response Segment
	 * @param strManifestMeasure Manifest Measure whose Sensitivity is sought
	 * @param dblRightStateManifestSensitivity Response Value Manifest Sensitivity at the Right Predictor
	 * 	Ordinate
	 * @param sbfrManifestSensitivity Segment's Best Fit Weighted Response Value Manifest Sensitivity
	 * 
	 * @return TRUE - If the calibration succeeds
	 */

	public boolean manifestMeasureSensitivity (
		final LatentStateResponseModel csPreceeding,
		final java.lang.String strManifestMeasure,
		final double dblRightStateManifestSensitivity,
		final org.drip.spline.params.SegmentBestFitResponse sbfrManifestSensitivity)
	{
<span class="pc bpc" id="L1009" title="1 of 2 branches missed.">		if (null == csPreceeding) return false;</span>

<span class="fc" id="L1011">		int iCk = _sidc.Ck();</span>

		try {
<span class="fc" id="L1014">			double[] adblManifestJacobianDerivAtLeftOrdinate = null;</span>

<span class="fc bfc" id="L1016" title="All 2 branches covered.">			if (0 != iCk) {</span>
<span class="fc" id="L1017">				adblManifestJacobianDerivAtLeftOrdinate = new double[iCk];</span>

<span class="fc bfc" id="L1019" title="All 2 branches covered.">				for (int i = 0; i &lt; iCk; ++i)</span>
<span class="fc" id="L1020">					adblManifestJacobianDerivAtLeftOrdinate[i] = 0.;</span>
			}

<span class="pc bpc" id="L1023" title="1 of 2 branches missed.">			if (!org.drip.numerical.common.NumberUtil.IsValid (dblRightStateManifestSensitivity)) return true;</span>

<span class="nc bnc" id="L1025" title="All 2 branches missed.">			if (!calibrateLocalManifestJacobian (strManifestMeasure, new</span>
<span class="nc bnc" id="L1026" title="All 2 branches missed.">				org.drip.spline.params.SegmentStateCalibrationInputs (new double[] {left(), right()}, new</span>
					double[] {0., dblRightStateManifestSensitivity}, 0 != iCk ?
						adblManifestJacobianDerivAtLeftOrdinate : null, null, null, sbfrManifestSensitivity),
							null))
<span class="nc" id="L1030">				return false;</span>

<span class="nc" id="L1032">			org.drip.spline.segment.LatentStateManifestSensitivity lsms = manifestSensitivity</span>
<span class="nc" id="L1033">				(strManifestMeasure);</span>

<span class="nc bnc" id="L1035" title="All 2 branches missed.">			if (null == lsms) return true;</span>

<span class="nc bnc" id="L1037" title="All 2 branches missed.">			return lsms.getPMSC().impactFade() ? calibratePreceedingManifestJacobian (strManifestMeasure, new</span>
<span class="nc" id="L1038">				org.drip.spline.params.SegmentStateCalibrationInputs (new double[] {left(), right()}, new</span>
<span class="nc" id="L1039">					double[] {csPreceeding.calcDResponseDManifest (strManifestMeasure, left(), 1), 0.}, null,</span>
<span class="nc" id="L1040">						CkDBasisCoeffDPreceedingManifestMeasure (strManifestMeasure), null, null)) :</span>
<span class="nc" id="L1041">							lsms.setDResponseDPreceedingManifest (csPreceeding.calcDResponseDManifest</span>
<span class="nc" id="L1042">								(strManifestMeasure, left(), 1));</span>
<span class="nc" id="L1043">		} catch (java.lang.Exception e) {</span>
<span class="nc" id="L1044">			e.printStackTrace();</span>
		}

<span class="nc" id="L1047">		return false;</span>
	}

	/**
	 * Compute the Local and the Preceeding Manifest Measure Sensitivity Coefficients from the Local
	 * 	Response Value Sensitivity at the Left/Right Predictor Ordinate, the Local Left Response Value
	 * 	Sensitivity Slope, and the Local Best Fit Response Sensitivity.
	 * 
	 * @param strManifestMeasure Manifest Measure whose Sensitivity is sought
	 * @param dblLeftManifestSensitivity Left Edge Response Value Manifest Sensitivity
	 * @param dblLeftSlopeManifestSensitivity Left Edge Response Slope Manifest Sensitivity
	 * @param dblRightManifestSensitivity Right Edge Response Value Manifest Sensitivity
	 * @param sbfrManifestSensitivity Segment's Best Fit Weighted Response Values Manifest Sensitivity
	 * 
	 * @return TRUE - The Calibration Succeeded
	 */

	public boolean manifestMeasureSensitivity (
		final java.lang.String strManifestMeasure,
		final double dblLeftManifestSensitivity,
		final double dblLeftSlopeManifestSensitivity,
		final double dblRightManifestSensitivity,
		final org.drip.spline.params.SegmentBestFitResponse sbfrManifestSensitivity)
	{
		try {
<span class="nc bnc" id="L1072" title="All 2 branches missed.">			return org.drip.numerical.common.NumberUtil.IsValid (dblLeftManifestSensitivity) &amp;&amp;</span>
<span class="nc bnc" id="L1073" title="All 2 branches missed.">				org.drip.numerical.common.NumberUtil.IsValid (dblLeftSlopeManifestSensitivity) &amp;&amp;</span>
<span class="nc bnc" id="L1074" title="All 2 branches missed.">					org.drip.numerical.common.NumberUtil.IsValid (dblRightManifestSensitivity) ?</span>
<span class="nc" id="L1075">						calibrateLocalManifestJacobian (strManifestMeasure, new</span>
<span class="nc" id="L1076">							org.drip.spline.params.SegmentStateCalibrationInputs (new double[] {left(),</span>
<span class="nc" id="L1077">								right()}, new double[] {dblLeftManifestSensitivity,</span>
									dblRightManifestSensitivity},
										org.drip.numerical.common.CollectionUtil.DerivArrayFromSlope
<span class="nc" id="L1080">											(numParameters() - 2, dblLeftSlopeManifestSensitivity), null,</span>
												null, sbfrManifestSensitivity), null) : true;
<span class="nc" id="L1082">		} catch (java.lang.Exception e) {</span>
<span class="nc" id="L1083">			e.printStackTrace();</span>
		}

<span class="nc" id="L1086">		return false;</span>
	}

	/**
	 * Compute the Local and the Preceeding Manifest Measure Sensitivity Coefficients from the Local
	 * 	Response Value/Sensitivity Constraints at the Left/Right Predictor Ordinate, the Local Left
	 * 	Response Value Sensitivity Slope, and the Local Best Fit Response Sensitivity
	 * 
	 * @param strManifestMeasure Manifest Measure whose Sensitivity is sought
	 * @param wrvcStateLeft Left Edge Response Value Constraint
	 * @param wrvcStateRight Right Edge Response Value Constraint
	 * @param dblLeftSlopeManifestSensitivity Left Edge Response Value Slope Manifest Sensitivity
	 * @param wrvcStateLeftManifestSensitivity Left Edge Response Value Constraint Manifest Sensitivity
	 * @param wrvcStateRightManifestSensitivity Right Edge Response Value Constraint Manifest Sensitivity
	 * @param sbfrManifestSensitivity Segment's Best Fit Weighted Response Manifest Sensitivity
	 * 
	 * @return TRUE - If the calibration succeeds
	 */

	public boolean manifestMeasureSensitivity (
		final java.lang.String strManifestMeasure,
		final org.drip.spline.params.SegmentResponseValueConstraint wrvcStateLeft,
		final org.drip.spline.params.SegmentResponseValueConstraint wrvcStateRight,
		final double dblLeftSlopeManifestSensitivity,
		final org.drip.spline.params.SegmentResponseValueConstraint wrvcStateLeftManifestSensitivity,
		final org.drip.spline.params.SegmentResponseValueConstraint wrvcStateRightManifestSensitivity,
		final org.drip.spline.params.SegmentBestFitResponse sbfrManifestSensitivity)
	{
<span class="fc" id="L1114">		org.drip.spline.params.SegmentBasisFlexureConstraint[] aSBFCState = null;</span>
<span class="fc" id="L1115">		org.drip.spline.params.SegmentBasisFlexureConstraint[] aSBFCManifestSensitivity = null;</span>

		try {
<span class="pc bpc" id="L1118" title="3 of 4 branches missed.">			if (null != wrvcStateLeft || null != wrvcStateRight)</span>
<span class="pc bpc" id="L1119" title="1 of 2 branches missed.">				aSBFCState = new org.drip.spline.params.SegmentBasisFlexureConstraint[] {null ==</span>
<span class="pc bpc" id="L1120" title="1 of 2 branches missed.">					wrvcStateLeft ? null : wrvcStateLeft.responseIndexedBasisConstraint (_be, this), null ==</span>
<span class="fc" id="L1121">						wrvcStateRight ? null : wrvcStateRight.responseIndexedBasisConstraint (_be, this)};</span>

<span class="pc bpc" id="L1123" title="3 of 4 branches missed.">			if (null != wrvcStateLeftManifestSensitivity || null != wrvcStateRightManifestSensitivity)</span>
<span class="pc bpc" id="L1124" title="1 of 2 branches missed.">				aSBFCManifestSensitivity = new org.drip.spline.params.SegmentBasisFlexureConstraint[] {null</span>
					== wrvcStateLeftManifestSensitivity ? null :
<span class="pc bpc" id="L1126" title="1 of 2 branches missed.">						wrvcStateLeftManifestSensitivity.responseIndexedBasisConstraint (_be, this), null ==</span>
							wrvcStateRightManifestSensitivity ? null :
<span class="fc" id="L1128">								wrvcStateRightManifestSensitivity.responseIndexedBasisConstraint (_be,</span>
									this)};

<span class="pc bpc" id="L1131" title="1 of 2 branches missed.">			return null == aSBFCManifestSensitivity ? true : calibrateLocalManifestJacobian</span>
<span class="fc" id="L1132">				(strManifestMeasure, new org.drip.spline.params.SegmentStateCalibrationInputs (null, null,</span>
<span class="fc" id="L1133">					org.drip.numerical.common.CollectionUtil.DerivArrayFromSlope (numParameters() - 2,</span>
						dblLeftSlopeManifestSensitivity), null, aSBFCManifestSensitivity,
							sbfrManifestSensitivity), aSBFCState);
<span class="nc" id="L1136">		} catch (java.lang.Exception e) {</span>
<span class="nc" id="L1137">			e.printStackTrace();</span>
		}

<span class="nc" id="L1140">		return false;</span>
	}

	/**
	 * Retrieve the Segment Curvature DPE
	 * 
	 * @return The Segment Curvature DPE
	 * 
	 * @throws java.lang.Exception Thrown if the Segment Curvature DPE cannot be computed
	 */

	public double curvatureDPE()
		throws java.lang.Exception
	{
<span class="fc" id="L1154">		double dblDPE = 0.;</span>

<span class="fc" id="L1156">		int iNumBasis = _be.numBasis();</span>

<span class="fc" id="L1158">		org.drip.spline.params.SegmentFlexurePenaltyControl sfpc = _sidc.curvaturePenaltyControl();</span>

<span class="pc bpc" id="L1160" title="1 of 2 branches missed.">		if (null == sfpc) sfpc = new org.drip.spline.params.SegmentFlexurePenaltyControl (2, 1.);</span>

<span class="fc" id="L1162">		org.drip.spline.segment.BestFitFlexurePenalizer bffp = new</span>
			org.drip.spline.segment.BestFitFlexurePenalizer (this, sfpc, null, null, _be);

<span class="fc bfc" id="L1165" title="All 2 branches covered.">		for (int i = 0; i &lt; iNumBasis; ++i) {</span>
<span class="fc bfc" id="L1166" title="All 2 branches covered.">			for (int j = 0; j &lt; iNumBasis; ++j)</span>
<span class="fc" id="L1167">				dblDPE += _adblResponseBasisCoeff[i] * _adblResponseBasisCoeff[j] *</span>
<span class="fc" id="L1168">					bffp.basisPairCurvaturePenalty (i, j);</span>
		}

<span class="fc" id="L1171">		return sfpc.amplitude() * dblDPE;</span>
	}

	/**
	 * Retrieve the Segment Length DPE
	 * 
	 * @return The Segment Length DPE
	 * 
	 * @throws java.lang.Exception Thrown if the Segment Length DPE cannot be computed
	 */

	public double lengthDPE()
		throws java.lang.Exception
	{
<span class="fc" id="L1185">		double dblDPE = 0.;</span>

<span class="fc" id="L1187">		int iNumBasis = _be.numBasis();</span>

<span class="fc" id="L1189">		org.drip.spline.params.SegmentFlexurePenaltyControl sfpcLength = _sidc.lengthPenaltyControl();</span>

<span class="pc bpc" id="L1191" title="1 of 2 branches missed.">		if (null == sfpcLength) sfpcLength = new org.drip.spline.params.SegmentFlexurePenaltyControl (1, 1.);</span>

<span class="fc" id="L1193">		org.drip.spline.segment.BestFitFlexurePenalizer bffp = new</span>
			org.drip.spline.segment.BestFitFlexurePenalizer (this, null, sfpcLength, null, _be);

<span class="fc bfc" id="L1196" title="All 2 branches covered.">		for (int i = 0; i &lt; iNumBasis; ++i) {</span>
<span class="fc bfc" id="L1197" title="All 2 branches covered.">			for (int j = 0; j &lt; iNumBasis; ++j)</span>
<span class="fc" id="L1198">				dblDPE += _adblResponseBasisCoeff[i] * _adblResponseBasisCoeff[j] *</span>
<span class="fc" id="L1199">					bffp.basisPairLengthPenalty (i, j);</span>
		}

<span class="fc" id="L1202">		return sfpcLength.amplitude() * dblDPE;</span>
	}

	/**
	 * Retrieve the Segment Best Fit DPE
	 * 
	 * @param sbfr The Segment's Best Fit Response Inputs
	 * 
	 * @return The Segment Best Fit DPE
	 * 
	 * @throws java.lang.Exception Thrown if the Segment Best Fit DPE cannot be computed
	 */

	public double bestFitDPE (
		final org.drip.spline.params.SegmentBestFitResponse sbfr)
		throws java.lang.Exception
	{
<span class="fc bfc" id="L1219" title="All 2 branches covered.">		if (null == sbfr) return 0.;</span>

<span class="fc" id="L1221">		double dblDPE = 0.;</span>

<span class="fc" id="L1223">		int iNumBasis = _be.numBasis();</span>

<span class="fc" id="L1225">		org.drip.spline.segment.BestFitFlexurePenalizer bffp = new</span>
			org.drip.spline.segment.BestFitFlexurePenalizer (this, null, null, sbfr, _be);

<span class="fc bfc" id="L1228" title="All 2 branches covered.">		for (int i = 0; i &lt; iNumBasis; ++i) {</span>
<span class="fc bfc" id="L1229" title="All 2 branches covered.">			for (int j = 0; j &lt; iNumBasis; ++j)</span>
<span class="fc" id="L1230">				dblDPE += _adblResponseBasisCoeff[i] * _adblResponseBasisCoeff[j] * bffp.basisBestFitPenalty</span>
<span class="fc" id="L1231">					(i, j);</span>
		}

<span class="fc" id="L1234">		return dblDPE;</span>
	}

	/**
	 * Calculate the Response Value at the given Predictor Ordinate
	 * 
	 * @param dblPredictorOrdinate Predictor Ordinate
	 * 
	 * @return The Response Value
	 * 
	 * @throws java.lang.Exception Thrown if the calculation did not succeed
	 */

	public double responseValue (
		final double dblPredictorOrdinate)
		throws java.lang.Exception
	{
<span class="fc" id="L1251">		return _be.responseValue (_adblResponseBasisCoeff, dblPredictorOrdinate);</span>
	}

	/**
	 * Calculate the Ordered Response Value Derivative at the Predictor Ordinate
	 * 
	 * @param dblPredictorOrdinate Predictor Ordinate at which the ordered Response Derivative is to be
	 * 	calculated
	 * @param iOrder Derivative Order
	 * 
	 * @throws java.lang.Exception Thrown if the Ordered Response Value Derivative cannot be calculated
	 * 
	 * @return Retrieve the Ordered Response Value Derivative
	 */

	public double calcResponseValueDerivative (
		final double dblPredictorOrdinate,
		final int iOrder)
		throws java.lang.Exception
	{
<span class="fc bfc" id="L1271" title="All 2 branches covered.">		return 0 == iOrder ? responseValue (dblPredictorOrdinate) : _be.responseValueDerivative</span>
<span class="fc" id="L1272">			(_adblResponseBasisCoeff, dblPredictorOrdinate, iOrder);</span>
	}

	/**
	 * Calculate the Ordered Derivative of the Response to the Manifest
	 * 
	 * @param strManifestMeasure Manifest Measure whose Sensitivity is sought
	 * @param dblPredictorOrdinate Predictor Ordinate at which the ordered Derivative of the Response to the
	 * 	Manifest is to be calculated
	 * @param iOrder Derivative Order
	 * 
	 * @throws java.lang.Exception Thrown if the Ordered Derivative of the Response to the Manifest cannot be
	 *  calculated
	 * 
	 * @return Retrieve the Ordered Derivative of the Response to the Manifest
	 */

	public double calcDResponseDManifest (
		final java.lang.String strManifestMeasure,
		final double dblPredictorOrdinate,
		final int iOrder)
		throws java.lang.Exception
	{
<span class="pc bpc" id="L1295" title="1 of 2 branches missed.">		if (0 == iOrder)</span>
<span class="nc" id="L1296">			throw new java.lang.Exception</span>
				(&quot;LatentStateResponseModel::calcDResponseDManifest =&gt; Invalid Inputs&quot;);

<span class="fc" id="L1299">		org.drip.spline.segment.LatentStateManifestSensitivity lsms = manifestSensitivity</span>
<span class="fc" id="L1300">			(strManifestMeasure);</span>

<span class="pc bpc" id="L1302" title="1 of 2 branches missed.">		if (null == lsms)</span>
<span class="nc" id="L1303">			throw new java.lang.Exception</span>
				(&quot;LatentStateResponseModel::calcDResponseDManifest =&gt; Invalid Inputs&quot;);

<span class="fc" id="L1306">		return _be.responseValue (lsms.getDBasisCoeffDLocalManifest(), dblPredictorOrdinate);</span>
	}

	/**
	 * Calculate the Ordered Derivative of the Response to the Preceeding Manifest
	 * 
	 * @param strManifestMeasure Manifest Measure whose Sensitivity is sought
	 * @param dblPredictorOrdinate Predictor Ordinate at which the ordered Derivative of the Response to the
	 * 	Manifest is to be calculated
	 * @param iOrder Derivative Order
	 * 
	 * @throws java.lang.Exception Thrown if the Ordered Derivative of the Response to the Manifest cannot be
	 *  calculated
	 * 
	 * @return Retrieve the Ordered Derivative of the Response to the Preceeding Manifest
	 */

	public double calcDResponseDPreceedingManifest (
		final java.lang.String strManifestMeasure,
		final double dblPredictorOrdinate,
		final int iOrder)
		throws java.lang.Exception
	{
<span class="pc bpc" id="L1329" title="1 of 2 branches missed.">		if (0 == iOrder)</span>
<span class="nc" id="L1330">			throw new java.lang.Exception</span>
				(&quot;LatentStateResponseModel::calcDResponseDPreceedingManifest =&gt; Invalid Inputs&quot;);

<span class="fc" id="L1333">		org.drip.spline.segment.LatentStateManifestSensitivity lsms = manifestSensitivity</span>
<span class="fc" id="L1334">			(strManifestMeasure);</span>

<span class="pc bpc" id="L1336" title="1 of 2 branches missed.">		if (null == lsms)</span>
<span class="nc" id="L1337">			throw new java.lang.Exception</span>
				(&quot;LatentStateResponseModel::calcDResponseDPreceedingManifest =&gt; Cannot locate state Manifest sensitivity&quot;);

<span class="fc" id="L1340">		org.drip.spline.params.PreceedingManifestSensitivityControl pqsc = lsms.getPMSC();</span>

<span class="fc" id="L1342">		double dblDResponseDPreceedingManifest = lsms.getDResponseDPreceedingManifest();</span>

<span class="pc bpc" id="L1344" title="1 of 2 branches missed.">		if (!pqsc.impactFade())</span>
<span class="nc bnc" id="L1345" title="All 2 branches missed.">			return org.drip.numerical.common.NumberUtil.IsValid (dblDResponseDPreceedingManifest) ?</span>
				dblDResponseDPreceedingManifest : 0.;

<span class="fc" id="L1348">		org.drip.spline.segment.BasisEvaluator be = pqsc.basisEvaluator();</span>

<span class="fc" id="L1350">		double[] adblDBasisCoeffDPreceedingManifest = lsms.getDBasisCoeffDPreceedingManifest();</span>

<span class="pc bpc" id="L1352" title="2 of 4 branches missed.">		return null == adblDBasisCoeffDPreceedingManifest ? 0. : (null == be ? _be : be).responseValue</span>
<span class="fc" id="L1353">			(adblDBasisCoeffDPreceedingManifest, dblPredictorOrdinate);</span>
	}

	/**
	 * Retrieve the Manifest Measure Preceeding Manifest Impact Flag
	 * 
	 * @param strManifestMeasure Manifest Measure whose Sensitivity is sought
	 * 
	 * @return The Manifest Measure Preceeding Manifest Impact Flag
	 * 
	 * @throws java.lang.Exception Thrown if the Inputs are Invalid
	 */

	public boolean impactFade (
		final java.lang.String strManifestMeasure)
		throws java.lang.Exception
	{
<span class="fc" id="L1370">		org.drip.spline.segment.LatentStateManifestSensitivity lsms = manifestSensitivity</span>
<span class="fc" id="L1371">			(strManifestMeasure);</span>

<span class="fc bfc" id="L1373" title="All 2 branches covered.">		if (null == lsms)</span>
<span class="fc" id="L1374">			throw new java.lang.Exception</span>
				(&quot;LatentStateResponseModel::impactFade =&gt; Cannot locate state Manifest sensitivity&quot;);

<span class="fc" id="L1377">		return lsms.getPMSC().impactFade();</span>
	}

	/**
	 * Calculate the Jacobian of the Segment's Response Basis Function Coefficients to the Edge Inputs
	 * 
	 * @return The Jacobian of the Segment's Response Basis Function Coefficients to the Edge Inputs
	 */

	public org.drip.numerical.differentiation.WengertJacobian jackDCoeffDEdgeInputs()
	{
<span class="fc bfc" id="L1388" title="All 2 branches covered.">		if (null != _wjDBasisCoeffDEdgeValue) return _wjDBasisCoeffDEdgeValue;</span>

<span class="fc" id="L1390">		int iNumResponseBasisCoeff = _be.numBasis();</span>

		try {
<span class="fc" id="L1393">			_wjDBasisCoeffDEdgeValue = new org.drip.numerical.differentiation.WengertJacobian (iNumResponseBasisCoeff,</span>
				iNumResponseBasisCoeff);
<span class="nc" id="L1395">		} catch (java.lang.Exception e) {</span>
<span class="nc" id="L1396">			e.printStackTrace();</span>

<span class="nc" id="L1398">			return _wjDBasisCoeffDEdgeValue = null;</span>
<span class="fc" id="L1399">		}</span>

<span class="fc bfc" id="L1401" title="All 2 branches covered.">		for (int i = 0; i &lt; iNumResponseBasisCoeff; ++i) {</span>
<span class="pc bpc" id="L1402" title="1 of 2 branches missed.">			if (!_wjDBasisCoeffDEdgeValue.setWengert (i, _adblResponseBasisCoeff[i]))</span>
<span class="nc" id="L1403">				return _wjDBasisCoeffDEdgeValue = null;</span>
		}

<span class="fc bfc" id="L1406" title="All 2 branches covered.">		if (null == _aadblDResponseBasisCoeffDConstraint) return null;</span>

<span class="fc" id="L1408">		int iSize = _aadblDResponseBasisCoeffDConstraint.length;</span>

<span class="fc bfc" id="L1410" title="All 2 branches covered.">		for (int i = 0; i &lt; iSize; ++i) {</span>
<span class="fc bfc" id="L1411" title="All 2 branches covered.">			for (int j = 0; j &lt; iSize; ++j) {</span>
<span class="pc bpc" id="L1412" title="1 of 2 branches missed.">				if (!_wjDBasisCoeffDEdgeValue.accumulatePartialFirstDerivative (i, j,</span>
					_aadblDResponseBasisCoeffDConstraint[i][j]))
<span class="nc" id="L1414">					return null;</span>
			}
		}

<span class="fc" id="L1418">		return _wjDBasisCoeffDEdgeValue;</span>
	}

	/**
	 * Calculate the Jacobian of the Response to the Edge Inputs at the given Predictor Ordinate
	 * 
	 * @param dblPredictorOrdinate The Predictor Ordinate
	 * @param iOrder Order of the Derivative Desired
	 * 
	 * @return The Jacobian of the Response to the Edge Inputs at the given Predictor Ordinate
	 */

	public org.drip.numerical.differentiation.WengertJacobian jackDResponseDEdgeInput (
		final double dblPredictorOrdinate,
		final int iOrder)
	{
		try {
<span class="fc" id="L1435">			int iNumResponseBasisCoeff = _be.numBasis();</span>

<span class="fc" id="L1437">			org.drip.numerical.differentiation.WengertJacobian wjDResponseDEdgeParams = null;</span>
<span class="fc" id="L1438">			double[][] aadblDBasisCoeffDEdgeParams = new</span>
				double[iNumResponseBasisCoeff][iNumResponseBasisCoeff];

<span class="fc" id="L1441">			double[] adblDResponseDBasisCoeff = DResponseDBasisCoeff (dblPredictorOrdinate, iOrder);</span>

<span class="pc bpc" id="L1443" title="2 of 4 branches missed.">			if (null == adblDResponseDBasisCoeff || iNumResponseBasisCoeff !=</span>
				adblDResponseDBasisCoeff.length)
<span class="nc" id="L1445">				return null;</span>

<span class="fc bfc" id="L1447" title="All 2 branches covered.">			org.drip.numerical.differentiation.WengertJacobian wjDBasisCoeffDEdgeParams = (null ==</span>
<span class="fc" id="L1448">				_wjDBasisCoeffDEdgeValue) ? jackDCoeffDEdgeInputs() : _wjDBasisCoeffDEdgeValue;</span>

<span class="fc bfc" id="L1450" title="All 2 branches covered.">			for (int i = 0; i &lt; iNumResponseBasisCoeff; ++i) {</span>
<span class="fc bfc" id="L1451" title="All 2 branches covered.">				for (int j = 0; j &lt; iNumResponseBasisCoeff; ++j)</span>
<span class="fc" id="L1452">					aadblDBasisCoeffDEdgeParams[j][i] = wjDBasisCoeffDEdgeParams.firstDerivative (j, i);</span>
			}

<span class="fc" id="L1455">			if (!(wjDResponseDEdgeParams = new org.drip.numerical.differentiation.WengertJacobian (1,</span>
<span class="pc bpc" id="L1456" title="1 of 2 branches missed.">				iNumResponseBasisCoeff)).setWengert (0, responseValue (dblPredictorOrdinate)))</span>
<span class="nc" id="L1457">				return null;</span>

<span class="fc bfc" id="L1459" title="All 2 branches covered.">			for (int i = 0; i &lt; iNumResponseBasisCoeff; ++i) {</span>
<span class="fc bfc" id="L1460" title="All 2 branches covered.">				for (int j = 0; j &lt; iNumResponseBasisCoeff; ++j) {</span>
<span class="pc bpc" id="L1461" title="1 of 2 branches missed.">					if (!wjDResponseDEdgeParams.accumulatePartialFirstDerivative (0, i,</span>
						adblDResponseDBasisCoeff[j] * aadblDBasisCoeffDEdgeParams[j][i]))
<span class="nc" id="L1463">						return null;</span>
				}
			}

<span class="fc" id="L1467">			return wjDResponseDEdgeParams;</span>
<span class="nc" id="L1468">		} catch (java.lang.Exception e) {</span>
<span class="nc" id="L1469">			e.printStackTrace();</span>
		}

<span class="nc" id="L1472">		return null;</span>
	}

	/**
	 * Calculate the Jacobian of the Response to the Basis Coefficients at the given Predictor Ordinate
	 * 
	 * @param dblPredictorOrdinate The Predictor Ordinate
	 * @param iOrder Order of the Derivative Desired
	 * 
	 * @return The Jacobian of the Response to the Basis Coefficients at the given Predictor Ordinate
	 */

	public org.drip.numerical.differentiation.WengertJacobian jackDResponseDBasisCoeff (
		final double dblPredictorOrdinate,
		final int iOrder)
	{
		try {
<span class="nc" id="L1489">			int iNumResponseBasisCoeff = _be.numBasis();</span>

<span class="nc" id="L1491">			double[] adblBasisDResponseDBasisCoeff = DResponseDBasisCoeff (dblPredictorOrdinate, iOrder);</span>

<span class="nc bnc" id="L1493" title="All 4 branches missed.">			if (null == adblBasisDResponseDBasisCoeff || iNumResponseBasisCoeff !=</span>
				adblBasisDResponseDBasisCoeff.length)
<span class="nc" id="L1495">				return null;</span>

<span class="nc" id="L1497">			org.drip.numerical.differentiation.WengertJacobian wjDResponseDBasisCoeff = new</span>
				org.drip.numerical.differentiation.WengertJacobian (1, iNumResponseBasisCoeff);

<span class="nc bnc" id="L1500" title="All 2 branches missed.">			for (int i = 0; i &lt; iNumResponseBasisCoeff; ++i) {</span>
<span class="nc bnc" id="L1501" title="All 2 branches missed.">				if (!wjDResponseDBasisCoeff.accumulatePartialFirstDerivative (0, i,</span>
					adblBasisDResponseDBasisCoeff[i]))
<span class="nc" id="L1503">					return null;</span>
			}

<span class="nc" id="L1506">			return wjDResponseDBasisCoeff;</span>
<span class="nc" id="L1507">		} catch (java.lang.Exception e) {</span>
<span class="nc" id="L1508">			e.printStackTrace();</span>
		}

<span class="nc" id="L1511">		return null;</span>
	}

	/**
	 * Calibrate the segment and calculate the Jacobian of the Segment's Response Basis Function Coefficients
	 *  to the Edge Parameters
	 * 
	 * @param adblPredictorOrdinate Array of Predictor Ordinates
	 * @param adblResponseValue Array of Response Values
	 * @param adblLeftEdgeDeriv Array of Left Edge Derivatives
	 * @param adblRightEdgeDeriv Array of Right Edge Derivatives
	 * @param aSBFC Array of Segment Flexure Constraints, expressed as Basis Coefficients
	 * @param sbfr Segment Best Fit Response Instance
	 * 
	 * @return The Jacobian of the Segment's Response Basis Function Coefficients to the Edge Parameters
	 */

	public org.drip.numerical.differentiation.WengertJacobian jackDCoeffDEdgeParams (
		final double[] adblPredictorOrdinate,
		final double[] adblResponseValue,
		final double[] adblLeftEdgeDeriv,
		final double[] adblRightEdgeDeriv,
		final org.drip.spline.params.SegmentBasisFlexureConstraint[] aSBFC,
		final org.drip.spline.params.SegmentBestFitResponse sbfr)
	{
		try {
<span class="pc bpc" id="L1537" title="1 of 2 branches missed.">			return calibrateState (new org.drip.spline.params.SegmentStateCalibrationInputs</span>
				(adblPredictorOrdinate, adblResponseValue, adblLeftEdgeDeriv, adblRightEdgeDeriv, aSBFC,
<span class="pc" id="L1539">					sbfr)) ? jackDCoeffDEdgeInputs() : null;</span>
<span class="nc" id="L1540">		} catch (java.lang.Exception e) {</span>
<span class="nc" id="L1541">			e.printStackTrace();</span>
		}

<span class="nc" id="L1544">		return null;</span>
	}

	/**
	 * Calibrate the Coefficients from the Edge Response Values and the Left Edge Response Value Slope and
	 *  calculate the Jacobian of the Segment's Response Basis Function Coefficients to the Edge Parameters
	 * 
	 * @param dblLeftValue Left Edge Response Value
	 * @param dblLeftSlope Left Edge Response Slope
	 * @param dblRightValue Right Edge Response Value
	 * @param sbfrState Segment's Best Fit Weighted Response Values
	 * 
	 * @return The Jacobian of the Segment's Response Basis Function Coefficients to the Edge Parameters
	 */

	public org.drip.numerical.differentiation.WengertJacobian jackDCoeffDEdgeParams (
		final double dblLeftValue,
		final double dblLeftSlope,
		final double dblRightValue,
		final org.drip.spline.params.SegmentBestFitResponse sbfrState)
	{
<span class="pc bpc" id="L1565" title="1 of 2 branches missed.">		return calibrate (dblLeftValue, dblLeftSlope, dblRightValue, sbfrState) ? jackDCoeffDEdgeInputs() :</span>
			null;
	}

	/**
	 * Calibrate the coefficients from the prior Segment and the Response Value at the Right Predictor
	 *  Ordinate and calculate the Jacobian of the Segment's Response Basis Function Coefficients to the Edge
	 *  Parameters
	 * 
	 * @param csPreceeding Previous Predictor/Response Segment
	 * @param strManifestMeasure Manifest Measure whose Sensitivity is sought
	 * @param dblRightStateValue Response Value at the Right Predictor Ordinate
	 * @param sbfrState Segment's Best Fit Weighted Response Values
	 * @param dblRightStateManifestSensitivity Response Value Manifest Sensitivity at the Right Predictor
	 * 	Ordinate
	 * @param sbfrManifestSensitivity Segment's Best Fit Weighted Response Value Manifest Sensitivity
	 * 
	 * @return The Jacobian
	 */

	public org.drip.numerical.differentiation.WengertJacobian jackDCoeffDEdgeParams (
		final LatentStateResponseModel csPreceeding,
		final java.lang.String strManifestMeasure,
		final double dblRightStateValue,
		final org.drip.spline.params.SegmentBestFitResponse sbfrState,
		final double dblRightStateManifestSensitivity,
		final org.drip.spline.params.SegmentBestFitResponse sbfrManifestSensitivity)
	{
<span class="pc bpc" id="L1593" title="1 of 2 branches missed.">		return !calibrate (csPreceeding, dblRightStateValue, sbfrState) || !manifestMeasureSensitivity</span>
<span class="pc bpc" id="L1594" title="1 of 2 branches missed.">			(csPreceeding, strManifestMeasure, dblRightStateManifestSensitivity, sbfrManifestSensitivity) ?</span>
<span class="fc" id="L1595">				null : jackDCoeffDEdgeInputs();</span>
	}

	/**
	 * Indicate whether the given segment is monotone. If monotone, may optionally indicate the nature of
	 * 	the extrema contained inside (maxima/minima/infection).
	 *  
	 * @return The monotone Type
	 */

	public org.drip.spline.segment.Monotonocity monotoneType()
	{
<span class="fc bfc" id="L1607" title="All 2 branches covered.">		if (1 &gt;= _sidc.Ck()) {</span>
			try {
<span class="fc" id="L1609">				return new org.drip.spline.segment.Monotonocity</span>
					(org.drip.spline.segment.Monotonocity.MONOTONIC);
<span class="nc" id="L1611">			} catch (java.lang.Exception e) {</span>
<span class="nc" id="L1612">				e.printStackTrace();</span>

<span class="nc" id="L1614">				return null;</span>
			}
		}

<span class="fc" id="L1618">		org.drip.function.definition.R1ToR1 ofDeriv = new</span>
<span class="fc" id="L1619">			org.drip.function.definition.R1ToR1 (null) {</span>
			@Override public double evaluate (
				final double dblX)
				throws java.lang.Exception
			{
<span class="fc" id="L1624">				return _be.responseValueDerivative (_adblResponseBasisCoeff, dblX, 1);</span>
			}

			@Override public org.drip.numerical.differentiation.Differential differential (
				final double dblX,
				final double dblOFBase,
				final int iOrder)
			{
				try {
<span class="nc" id="L1633">					double dblVariateInfinitesimal = _dc.getVariateInfinitesimal (dblX);</span>

<span class="nc" id="L1635">					return new org.drip.numerical.differentiation.Differential (dblVariateInfinitesimal,</span>
<span class="nc" id="L1636">						_be.responseValueDerivative (_adblResponseBasisCoeff, dblX, iOrder) *</span>
							dblVariateInfinitesimal);
<span class="nc" id="L1638">				} catch (java.lang.Exception e) {</span>
<span class="nc" id="L1639">					e.printStackTrace();</span>
				}

<span class="nc" id="L1642">				return null;</span>
			}

			@Override public double integrate (
				final double dblBegin,
				final double dblEnd)
				throws java.lang.Exception
			{
<span class="nc" id="L1650">				return org.drip.numerical.integration.R1ToR1Integrator.Boole (this, dblBegin, dblEnd);</span>
			}
		};

		try {
<span class="fc" id="L1655">			org.drip.function.r1tor1solver.FixedPointFinderOutput fpop = new</span>
				org.drip.function.r1tor1solver.FixedPointFinderBrent (0., ofDeriv, false).findRoot
<span class="fc" id="L1657">					(org.drip.function.r1tor1solver.InitializationHeuristics.FromHardSearchEdges (0., 1.));</span>

<span class="pc bpc" id="L1659" title="1 of 4 branches missed.">			if (null == fpop || !fpop.containsRoot())</span>
<span class="fc" id="L1660">				return new org.drip.spline.segment.Monotonocity</span>
					(org.drip.spline.segment.Monotonocity.MONOTONIC);

<span class="fc" id="L1663">			double dblExtremum = fpop.getRoot();</span>

<span class="pc bpc" id="L1665" title="3 of 6 branches missed.">			if (!org.drip.numerical.common.NumberUtil.IsValid (dblExtremum) || dblExtremum &lt;= 0. || dblExtremum</span>
				&gt;= 1.)
<span class="nc" id="L1667">				return new org.drip.spline.segment.Monotonocity</span>
					(org.drip.spline.segment.Monotonocity.MONOTONIC);

<span class="fc" id="L1670">			double dbl2ndDeriv = _be.responseValueDerivative (_adblResponseBasisCoeff, dblExtremum, 2);</span>

<span class="pc bpc" id="L1672" title="1 of 2 branches missed.">			if (0. &gt; dbl2ndDeriv)</span>
<span class="nc" id="L1673">				return new org.drip.spline.segment.Monotonocity</span>
					(org.drip.spline.segment.Monotonocity.MAXIMA);

<span class="pc bpc" id="L1676" title="1 of 2 branches missed.">			if (0. &lt; dbl2ndDeriv)</span>
<span class="fc" id="L1677">				return new org.drip.spline.segment.Monotonocity</span>
					(org.drip.spline.segment.Monotonocity.MINIMA);

<span class="nc bnc" id="L1680" title="All 2 branches missed.">			if (0. == dbl2ndDeriv)</span>
<span class="nc" id="L1681">				return new org.drip.spline.segment.Monotonocity</span>
					(org.drip.spline.segment.Monotonocity.INFLECTION);

<span class="nc" id="L1684">			return new org.drip.spline.segment.Monotonocity</span>
				(org.drip.spline.segment.Monotonocity.NON_MONOTONIC);
<span class="nc" id="L1686">		} catch (java.lang.Exception e) {</span>
<span class="nc" id="L1687">			e.printStackTrace();</span>
		}

		try {
<span class="nc" id="L1691">			return new org.drip.spline.segment.Monotonocity (org.drip.spline.segment.Monotonocity.MONOTONIC);</span>
<span class="nc" id="L1692">		} catch (java.lang.Exception e) {</span>
<span class="nc" id="L1693">			e.printStackTrace();</span>
		}

<span class="nc" id="L1696">		return null;</span>
	}

	/**
	 * Clip the part of the Segment to the Right of the specified Predictor Ordinate. Retain all other
	 * 	constraints the same.
	 * 
	 * @param dblPredictorOrdinate The Predictor Ordinate
	 * 
	 * @return The Clipped Segment
	 */

	public LatentStateResponseModel clipLeftOfPredictorOrdinate (
		final double dblPredictorOrdinate)
	{
		try {
<span class="fc" id="L1712">			LatentStateResponseModel csLeftSnipped = LatentStateResponseModel.Create (dblPredictorOrdinate,</span>
<span class="fc" id="L1713">				right(), _be.replicate(), _sidc);</span>

<span class="fc" id="L1715">			int iCk = _sidc.Ck();</span>

<span class="pc bpc" id="L1717" title="1 of 2 branches missed.">			double[] adblCalibLeftEdgeDeriv = 0 != iCk ? csLeftSnipped.transmissionCk (dblPredictorOrdinate,</span>
				this, iCk) : null;

<span class="pc bpc" id="L1720" title="1 of 2 branches missed.">			return csLeftSnipped.calibrateState (new org.drip.spline.params.SegmentStateCalibrationInputs</span>
<span class="fc" id="L1721">				(new double[] {dblPredictorOrdinate, right()}, new double[] {responseValue</span>
<span class="fc" id="L1722">					(dblPredictorOrdinate), responseValue (right())}, adblCalibLeftEdgeDeriv, null, null,</span>
						null)) ? csLeftSnipped : null;
<span class="nc" id="L1724">		} catch (java.lang.Exception e) {</span>
<span class="nc" id="L1725">			e.printStackTrace();</span>
		}

<span class="nc" id="L1728">		return null;</span>
	}

	/**
	 * Clip the part of the Segment to the Right of the specified Predictor Ordinate. Retain all other
	 * 	constraints the same.
	 * 
	 * @param dblPredictorOrdinate The Predictor Ordinate
	 * 
	 * @return The Clipped Segment
	 */

	public LatentStateResponseModel clipRightOfPredictorOrdinate (
		final double dblPredictorOrdinate)
	{
		try {
<span class="fc" id="L1744">			LatentStateResponseModel csRightSnipped = LatentStateResponseModel.Create (left(),</span>
<span class="fc" id="L1745">				dblPredictorOrdinate, _be.replicate(), _sidc);</span>

<span class="fc" id="L1747">			int iCk = _sidc.Ck();</span>

<span class="pc bpc" id="L1749" title="1 of 2 branches missed.">			return csRightSnipped.calibrateState (new org.drip.spline.params.SegmentStateCalibrationInputs</span>
<span class="fc" id="L1750">				(new double[] {left(), dblPredictorOrdinate}, new double[] {responseValue (left()),</span>
<span class="pc bpc" id="L1751" title="1 of 2 branches missed.">					responseValue (dblPredictorOrdinate)}, 0 != iCk ? csRightSnipped.transmissionCk (left(),</span>
						this, iCk) : null, null, null, null)) ? csRightSnipped : null;
<span class="nc" id="L1753">		} catch (java.lang.Exception e) {</span>
<span class="nc" id="L1754">			e.printStackTrace();</span>
		}

<span class="nc" id="L1757">		return null;</span>
	}

	/**
	 * Display the string representation for diagnostic purposes
	 * 
	 * @return The string representation
	 */

	public java.lang.String displayString()
	{
<span class="nc" id="L1768">		java.lang.StringBuffer sb = new java.lang.StringBuffer();</span>

<span class="nc" id="L1770">		sb.append (&quot;\t\t\t[&quot; + left() + &quot; =&gt; &quot; + right() + &quot;\n&quot;);</span>

<span class="nc bnc" id="L1772" title="All 2 branches missed.">		for (int i = 0; i &lt; _adblResponseBasisCoeff.length; ++i) {</span>
<span class="nc bnc" id="L1773" title="All 2 branches missed.">			if (0 != i) sb.append (&quot;  |  &quot;);</span>

<span class="nc" id="L1775">			sb.append (_adblResponseBasisCoeff[i] + &quot;\n&quot;);</span>
		}

<span class="nc" id="L1778">		return sb.toString();</span>
	}
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.7.9.201702052155</span></div></body></html>