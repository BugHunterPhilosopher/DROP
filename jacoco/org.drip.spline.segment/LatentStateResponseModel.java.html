<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>LatentStateResponseModel.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">DROP</a> &gt; <a href="index.source.html" class="el_package">org.drip.spline.segment</a> &gt; <span class="el_source">LatentStateResponseModel.java</span></div><h1>LatentStateResponseModel.java</h1><pre class="source lang-java linenums">
package org.drip.spline.segment;

/*
 * -*- mode: java; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*-
 */

/*!
 * Copyright (C) 2018 Lakshmi Krishnamurthy
 * Copyright (C) 2017 Lakshmi Krishnamurthy
 * Copyright (C) 2016 Lakshmi Krishnamurthy
 * Copyright (C) 2015 Lakshmi Krishnamurthy
 * Copyright (C) 2014 Lakshmi Krishnamurthy
 * Copyright (C) 2013 Lakshmi Krishnamurthy
 * 
 *  This file is part of DRIP, a free-software/open-source library for buy/side financial/trading model
 *  	libraries targeting analysts and developers
 *  	https://lakshmidrip.github.io/DRIP/
 *  
 *  DRIP is composed of four main libraries:
 *  
 *  - DRIP Fixed Income - https://lakshmidrip.github.io/DRIP-Fixed-Income/
 *  - DRIP Asset Allocation - https://lakshmidrip.github.io/DRIP-Asset-Allocation/
 *  - DRIP Numerical Optimizer - https://lakshmidrip.github.io/DRIP-Numerical-Optimizer/
 *  - DRIP Statistical Learning - https://lakshmidrip.github.io/DRIP-Statistical-Learning/
 * 
 *  - DRIP Fixed Income: Library for Instrument/Trading Conventions, Treasury Futures/Options,
 *  	Funding/Forward/Overnight Curves, Multi-Curve Construction/Valuation, Collateral Valuation and XVA
 *  	Metric Generation, Calibration and Hedge Attributions, Statistical Curve Construction, Bond RV
 *  	Metrics, Stochastic Evolution and Option Pricing, Interest Rate Dynamics and Option Pricing, LMM
 *  	Extensions/Calibrations/Greeks, Algorithmic Differentiation, and Asset Backed Models and Analytics.
 * 
 *  - DRIP Asset Allocation: Library for model libraries for MPT framework, Black Litterman Strategy
 *  	Incorporator, Holdings Constraint, and Transaction Costs.
 * 
 *  - DRIP Numerical Optimizer: Library for Numerical Optimization and Spline Functionality.
 * 
 *  - DRIP Statistical Learning: Library for Statistical Evaluation and Machine Learning.
 * 
 *  Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 *   	you may not use this file except in compliance with the License.
 *   
 *  You may obtain a copy of the License at
 *  	http://www.apache.org/licenses/LICENSE-2.0
 *  
 *  Unless required by applicable law or agreed to in writing, software
 *  	distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 *  	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  
 *  See the License for the specific language governing permissions and
 *  	limitations under the License.
 */

/**
 * LatentStateResponseModel implements the single segment basis calibration and inference functionality. It
 * 	exports the following functionality:
 * 	- Build the LatentStateResponseModel instance from the Basis Function/Shape Controller Set.
 * 	- Build the LatentStateResponseModel instance from the Basis Evaluator Set.
 * 	- Retrieve the Number of Parameters, Basis Evaluator, Array of the Response Basis Coefficients, and
 * 		Segment Design Inelastic Control.
 * 	- Calibrate the Segment State from the Calibration Parameter Set.
 * 	- Sensitivity Calibrator: Calibrate the Segment Manifest Jacobian from the Calibration Parameter Set.
 * 	- Calibrate the coefficients from the prior Predictor/Response Segment, the Constraint, and fitness
 *		Weights
 *	- Calibrate the coefficients from the prior Segment and the Response Value at the Right Predictor
 *		Ordinate.
 *	- Calibrate the Coefficients from the Edge Response Values and the Left Edge Response Slope.
 *	- Calibrate the coefficients from the Left Edge Response Value Constraint, the Left Edge Response Value
 *		Slope, and the Right Edge Response Value Constraint.
 *	- Retrieve the Segment Curvature, Length, and the Best Fit DPE.
 *	- Calculate the Response Value and its Derivative at the given Predictor Ordinate.
 *	- Calculate the Ordered Derivative of the Coefficient to the Manifest.
 *	- Calculate the Jacobian of the Segment's Response Basis Function Coefficients to the Edge Inputs.
 *	- Calculate the Jacobian of the Response to the Edge Inputs at the given Predictor Ordinate.
 *	- Calculate the Jacobian of the Response to the Basis Coefficients at the given Predictor Ordinate.
 *	- Calibrate the segment and calculate the Jacobian of the Segment's Response Basis Function Coefficients
 *		to the Edge Parameters.
 *	- Calibrate the Coefficients from the Edge Response Values and the Left Edge Response Value Slope and
 *		calculate the Jacobian of the Segment's Response Basis Function Coefficients to the Edge Parameters.
 *	- Calibrate the coefficients from the prior Segment and the Response Value at the Right Predictor
 *		Ordinate and calculate the Jacobian of the Segment's Response Basis Function Coefficients to the Edge
 *  	Parameters.
 *  - Indicate whether the given segment is monotone. If monotone, may optionally indicate the nature of the
 *  	extrema contained inside (maxima/minima/infection).
 *  - Clip the part of the Segment to the Right of the specified Predictor Ordinate. Retain all other
 *  	constraints the same.
 *  - Clip the part of the Segment to the Left of the specified Predictor Ordinate. Retain all other
 *  	constraints the same.
 *  - Display the string representation for diagnostic purposes.
 *
 * @author Lakshmi Krishnamurthy
 */

public class LatentStateResponseModel extends org.drip.spline.segment.LatentStateInelastic {

	/**
	 * LEFT NODE VALUE PARAMETER INDEX
	 */

	public static final int LEFT_NODE_VALUE_PARAMETER_INDEX = 0;

	/**
	 * RIGHT NODE VALUE PARAMETER INDEX
	 */

	public static final int RIGHT_NODE_VALUE_PARAMETER_INDEX = 1;

<span class="fc" id="L108">	private double[] _adblResponseBasisCoeff = null;</span>
<span class="fc" id="L109">	private org.drip.spline.segment.BasisEvaluator _be = null;</span>
<span class="fc" id="L110">	private double[][] _aadblDResponseBasisCoeffDConstraint = null;</span>
<span class="fc" id="L111">	private org.drip.spline.params.SegmentInelasticDesignControl _sidc = null;</span>
<span class="fc" id="L112">	private org.drip.quant.calculus.WengertJacobian _wjDBasisCoeffDEdgeValue = null;</span>

<span class="fc" id="L114">	private</span>
		org.drip.analytics.support.CaseInsensitiveHashMap&lt;org.drip.spline.segment.LatentStateManifestSensitivity&gt;
			_mapLSMS = new
				org.drip.analytics.support.CaseInsensitiveHashMap&lt;org.drip.spline.segment.LatentStateManifestSensitivity&gt;();

	/**
	 * Build the LatentStateResponseModel instance from the Basis Function/Shape Controller Set
	 * 
	 * @param dblLeftPredictorOrdinate Left Predictor Ordinate
	 * @param dblRightPredictorOrdinate Right Predictor Ordinate
	 * @param fs Response Basis Function Set
	 * @param rssc Shape Controller
	 * @param sidc Segment Inelastic Design Parameters
	 * 
	 * @return Instance of LatentStateResponseModel
	 */

	public static final org.drip.spline.segment.LatentStateResponseModel Create (
		final double dblLeftPredictorOrdinate,
		final double dblRightPredictorOrdinate,
		final org.drip.spline.basis.FunctionSet fs,
		final org.drip.spline.params.ResponseScalingShapeControl rssc,
		final org.drip.spline.params.SegmentInelasticDesignControl sidc)
	{
		try {
<span class="fc" id="L139">			org.drip.spline.segment.SegmentBasisEvaluator sbe = new</span>
				org.drip.spline.segment.SegmentBasisEvaluator (fs, rssc);

<span class="pc bpc" id="L142" title="1 of 2 branches missed.">			if (!org.drip.quant.common.NumberUtil.IsValid (dblLeftPredictorOrdinate) ||</span>
<span class="pc bpc" id="L143" title="2 of 4 branches missed.">				!org.drip.quant.common.NumberUtil.IsValid (dblRightPredictorOrdinate) ||</span>
				dblLeftPredictorOrdinate == dblRightPredictorOrdinate)
			{
<span class="nc" id="L146">				return null;</span>
			}

<span class="fc" id="L149">			org.drip.spline.segment.LatentStateResponseModel lsrm = new</span>
				org.drip.spline.segment.LatentStateResponseModel (dblLeftPredictorOrdinate,
					dblRightPredictorOrdinate, sbe, sidc);

<span class="pc bpc" id="L153" title="1 of 2 branches missed.">			return sbe.setContainingInelastics (lsrm) ? lsrm : null;</span>
<span class="nc" id="L154">		} catch (java.lang.Exception e) {</span>
<span class="nc" id="L155">			e.printStackTrace();</span>
		}

<span class="nc" id="L158">		return null;</span>
	}

	/**
	 * Build the LatentStateResponseModel instance from the Basis Evaluator Set
	 * 
	 * @param dblLeftPredictorOrdinate Left Predictor Ordinate
	 * @param dblRightPredictorOrdinate Right Predictor Ordinate
	 * @param be Basis Evaluator
	 * @param sidc Segment Inelastic Design Parameters
	 * 
	 * @return Instance of LatentStateResponseModel
	 */

	public static final org.drip.spline.segment.LatentStateResponseModel Create (
		final double dblLeftPredictorOrdinate,
		final double dblRightPredictorOrdinate,
		final org.drip.spline.segment.BasisEvaluator be,
		final org.drip.spline.params.SegmentInelasticDesignControl sidc)
	{
		try {
<span class="fc" id="L179">			org.drip.spline.segment.LatentStateResponseModel lsrm = new</span>
				org.drip.spline.segment.LatentStateResponseModel (dblLeftPredictorOrdinate,
					dblRightPredictorOrdinate, be, sidc);

<span class="pc bpc" id="L183" title="1 of 2 branches missed.">			return be.setContainingInelastics (lsrm) ? lsrm : null;</span>
<span class="nc" id="L184">		} catch (java.lang.Exception e) {</span>
<span class="nc" id="L185">			e.printStackTrace();</span>
		}

<span class="nc" id="L188">		return null;</span>
	}

	private LatentStateResponseModel (
		final double dblLeftPredictorOrdinate,
		final double dblRightPredictorOrdinate,
		final org.drip.spline.segment.BasisEvaluator be,
		final org.drip.spline.params.SegmentInelasticDesignControl sidc)
		throws java.lang.Exception
	{
<span class="fc" id="L198">		super (dblLeftPredictorOrdinate, dblRightPredictorOrdinate);</span>

<span class="pc bpc" id="L200" title="2 of 4 branches missed.">		if (null == (_be = be) || null == (_sidc = sidc))</span>
<span class="nc" id="L201">			throw new java.lang.Exception (&quot;LatentStateResponseModel ctr: Invalid Basis Functions!&quot;);</span>

<span class="fc" id="L203">		int iNumBasis = _be.numBasis();</span>

<span class="fc" id="L205">		_adblResponseBasisCoeff = new double[iNumBasis];</span>

<span class="pc bpc" id="L207" title="2 of 4 branches missed.">		if (0 &gt;= iNumBasis || _sidc.Ck() &gt; iNumBasis - 2)</span>
<span class="nc" id="L208">			throw new java.lang.Exception (&quot;LatentStateResponseModel ctr: Invalid inputs!&quot;);</span>
<span class="fc" id="L209">	}</span>

	private double[] DResponseDBasisCoeff (
		final double dblPredictorOrdinate,
		final int iOrder)
	{
<span class="pc bpc" id="L215" title="1 of 2 branches missed.">		if (0 == iOrder) return null;</span>

<span class="fc" id="L217">		int iNumBasis = _be.numBasis();</span>

<span class="fc" id="L219">		double[] adblDResponseDBasisCoeff = new double[iNumBasis];</span>

<span class="fc bfc" id="L221" title="All 2 branches covered.">		for (int i = 0; i &lt; iNumBasis; ++i) {</span>
			try {
<span class="pc bpc" id="L223" title="1 of 2 branches missed.">				adblDResponseDBasisCoeff[i] = 1 == iOrder ? _be.shapedBasisFunctionResponse</span>
<span class="pc" id="L224">					(dblPredictorOrdinate, i) : 0.;</span>
<span class="nc" id="L225">			} catch (java.lang.Exception e) {</span>
<span class="nc" id="L226">				e.printStackTrace();</span>

<span class="nc" id="L228">				return null;</span>
<span class="fc" id="L229">			}</span>
		}

<span class="fc" id="L232">		return adblDResponseDBasisCoeff;</span>
	}

	private double[] transmissionCk (
		final double dblPredictorOrdinate,
		final org.drip.spline.segment.LatentStateResponseModel csPreceeding,
		final int iCk)
	{
<span class="fc" id="L240">		double[] adblDeriv = new double[iCk];</span>

<span class="fc bfc" id="L242" title="All 2 branches covered.">		for (int i = 0; i &lt; iCk; ++i) {</span>
			try {
<span class="fc" id="L244">				adblDeriv[i] = csPreceeding.calcResponseValueDerivative (dblPredictorOrdinate, i + 1);</span>
<span class="nc" id="L245">			} catch (java.lang.Exception e) {</span>
<span class="nc" id="L246">				e.printStackTrace();</span>

<span class="nc" id="L248">				return null;</span>
<span class="fc" id="L249">			}</span>
		}

<span class="fc" id="L252">		return adblDeriv;</span>
	}

	private org.drip.spline.segment.LatentStateManifestSensitivity manifestSensitivity (
		final java.lang.String strManifestMeasure)
	{
<span class="pc bpc" id="L258" title="2 of 4 branches missed.">		return null == strManifestMeasure || strManifestMeasure.isEmpty() || !_mapLSMS.containsKey</span>
<span class="fc bfc" id="L259" title="All 2 branches covered.">			(strManifestMeasure) ? null : _mapLSMS.get (strManifestMeasure);</span>
	}

	private double[] CkDBasisCoeffDPreceedingManifestMeasure (
		final java.lang.String strManifestMeasure)
	{
<span class="fc" id="L265">		org.drip.spline.segment.LatentStateManifestSensitivity lsms = manifestSensitivity</span>
<span class="fc" id="L266">			(strManifestMeasure);</span>

<span class="pc bpc" id="L268" title="1 of 2 branches missed.">		if (null == lsms) return null;</span>

<span class="fc" id="L270">		int iCk = lsms.getPMSC().Ck();</span>

<span class="pc bpc" id="L272" title="1 of 2 branches missed.">		if (0 == iCk) return null;</span>

<span class="nc" id="L274">		double[] adblDBasisCoeffDPreceedingManifestTail = new double[iCk];</span>

<span class="nc bnc" id="L276" title="All 2 branches missed.">		for (int i = 0; i &lt; iCk; ++i)</span>
<span class="nc" id="L277">			adblDBasisCoeffDPreceedingManifestTail[i] = 0.;</span>

<span class="nc" id="L279">		return adblDBasisCoeffDPreceedingManifestTail;</span>
	}

	/**
	 * Set the Preceeding Manifest Sensitivity Control Parameters for the specified Manifest Measure
	 * 
	 * @param strManifestMeasure The Manifest Measure
	 * @param pmsc The Preceeding Manifest Sensitivity Control Instance
	 * 
	 * @return TRUE - Named Preceeding Manifest Sensitivity Control Instance Successfully Set
	 */

	public boolean setPreceedingManifestSensitivityControl (
		final java.lang.String strManifestMeasure,
		final org.drip.spline.params.PreceedingManifestSensitivityControl pmsc)
	{
<span class="pc bpc" id="L295" title="2 of 4 branches missed.">		if (null == strManifestMeasure || strManifestMeasure.isEmpty()) return false;</span>

		try {
<span class="fc" id="L298">			_mapLSMS.put (strManifestMeasure, new org.drip.spline.segment.LatentStateManifestSensitivity</span>
				(pmsc));

<span class="fc" id="L301">			return true;</span>
<span class="nc" id="L302">		} catch (java.lang.Exception e) {</span>
<span class="nc" id="L303">			e.printStackTrace();</span>
		}

<span class="nc" id="L306">		return false;</span>
	}

	/**
	 * Retrieve the Number of Parameters
	 * 
	 * @return The Number of Parameters
	 */

	public int numParameters()
	{
<span class="fc" id="L317">		return _sidc.Ck() + 2;</span>
	}

	/**
	 * Retrieve the Basis Evaluator
	 * 
	 * @return The Basis Evaluator
	 */

	public org.drip.spline.segment.BasisEvaluator basisEvaluator()
	{
<span class="fc" id="L328">		return _be;</span>
	}

	/**
	 * Retrieve the Array of Response Basis Coefficients
	 * 
	 * @return The Array of Response Basis Coefficients
	 */

	public double[] responseBasisCoefficient()
	{
<span class="nc" id="L339">		return _adblResponseBasisCoeff;</span>
	}

	/**
	 * Retrieve the Segment Inelastic Design Control
	 * 
	 * @return The Segment Inelastic Design Control
	 */

	public org.drip.spline.params.SegmentInelasticDesignControl designControl()
	{
<span class="nc" id="L350">		return _sidc;</span>
	}

	/**
	 * Main Calibrator: Calibrate the Segment State from the Calibration Parameter Set
	 * 
	 * @param ssciState The Segment State Calibration Inputs Set
	 * 
	 * @return TRUE - Calibration Successful
	 */

	public boolean calibrateState (
		final org.drip.spline.params.SegmentStateCalibrationInputs ssciState)
	{
<span class="pc bpc" id="L364" title="1 of 2 branches missed.">		if (null == ssciState) return false;</span>

<span class="fc" id="L366">		double[] adblPredictorOrdinate = ssciState.predictorOrdinates();</span>

<span class="fc" id="L368">		double[] adblResponseValue = ssciState.responseValues();</span>

<span class="fc" id="L370">		double[] adblLeftEdgeDeriv = ssciState.leftEdgeDeriv();</span>

<span class="fc" id="L372">		double[] adblRightEdgeDeriv = ssciState.rightEdgeDeriv();</span>

<span class="fc" id="L374">		org.drip.spline.params.SegmentBestFitResponse sbfr = ssciState.bestFitResponse();</span>

<span class="fc" id="L376">		org.drip.spline.params.SegmentBasisFlexureConstraint[] aSBFC = ssciState.flexureConstraint();</span>

<span class="fc" id="L378">		int iNumConstraint = 0;</span>
<span class="fc" id="L379">		int iNumResponseBasisCoeff = _adblResponseBasisCoeff.length;</span>
<span class="fc bfc" id="L380" title="All 2 branches covered.">		int iNumLeftDeriv = null == adblLeftEdgeDeriv ? 0 : adblLeftEdgeDeriv.length;</span>
<span class="fc bfc" id="L381" title="All 2 branches covered.">		int iNumRightDeriv = null == adblRightEdgeDeriv ? 0 : adblRightEdgeDeriv.length;</span>
<span class="fc" id="L382">		double[] adblPredictorResponseConstraintValue = new double[iNumResponseBasisCoeff];</span>
<span class="fc bfc" id="L383" title="All 2 branches covered.">		int iNumPredictorOrdinate = null == adblPredictorOrdinate ? 0 : adblPredictorOrdinate.length;</span>
<span class="fc" id="L384">		double[][] aadblResponseBasisCoeffConstraint = new</span>
			double[iNumResponseBasisCoeff][iNumResponseBasisCoeff];

<span class="fc bfc" id="L387" title="All 2 branches covered.">		if (null != aSBFC) {</span>
<span class="fc" id="L388">			int iNumPotentialConstraint = aSBFC.length;</span>

<span class="fc bfc" id="L390" title="All 2 branches covered.">			for (int i = 0; i &lt; iNumPotentialConstraint; ++i) {</span>
<span class="fc bfc" id="L391" title="All 2 branches covered.">				if (null != aSBFC[i]) ++iNumConstraint;</span>
			}
		}

<span class="pc bpc" id="L395" title="1 of 2 branches missed.">		if (iNumResponseBasisCoeff &lt; iNumPredictorOrdinate + iNumLeftDeriv + iNumRightDeriv + iNumConstraint)</span>
<span class="nc" id="L396">			return false;</span>

		try {
<span class="fc" id="L399">			org.drip.spline.segment.BestFitFlexurePenalizer bffp = new</span>
<span class="fc" id="L400">				org.drip.spline.segment.BestFitFlexurePenalizer (this, _sidc.curvaturePenaltyControl(),</span>
<span class="fc" id="L401">					_sidc.lengthPenaltyControl(), sbfr, _be);</span>

<span class="fc bfc" id="L403" title="All 2 branches covered.">			for (int j = 0; j &lt; iNumResponseBasisCoeff; ++j) {</span>
<span class="fc bfc" id="L404" title="All 2 branches covered.">				if (j &lt; iNumPredictorOrdinate)</span>
<span class="fc" id="L405">					adblPredictorResponseConstraintValue[j] = adblResponseValue[j];</span>
<span class="fc bfc" id="L406" title="All 2 branches covered.">				else if (j &lt; iNumPredictorOrdinate + iNumConstraint)</span>
<span class="fc" id="L407">					adblPredictorResponseConstraintValue[j] = aSBFC[j -</span>
<span class="fc" id="L408">					    iNumPredictorOrdinate].contraintValue();</span>
<span class="fc bfc" id="L409" title="All 2 branches covered.">				else if (j &lt; iNumPredictorOrdinate + iNumConstraint + iNumLeftDeriv)</span>
<span class="fc" id="L410">					adblPredictorResponseConstraintValue[j] = adblLeftEdgeDeriv[j - iNumPredictorOrdinate -</span>
					    iNumConstraint];
<span class="fc bfc" id="L412" title="All 2 branches covered.">				else if (j &lt; iNumPredictorOrdinate + iNumConstraint + iNumLeftDeriv + iNumRightDeriv)</span>
<span class="fc" id="L413">					adblPredictorResponseConstraintValue[j] = adblRightEdgeDeriv[j - iNumPredictorOrdinate -</span>
					    iNumConstraint - iNumLeftDeriv];
				else
<span class="fc" id="L416">					adblPredictorResponseConstraintValue[j] = bffp.basisPairPenaltyConstraint (j);</span>
			}

<span class="fc bfc" id="L419" title="All 2 branches covered.">			for (int i = 0; i &lt; iNumResponseBasisCoeff; ++i) {</span>
<span class="fc bfc" id="L420" title="All 2 branches covered.">				for (int l = 0; l &lt; iNumResponseBasisCoeff; ++l) {</span>
<span class="fc" id="L421">					double[] adblCalibBasisConstraintWeight = null;</span>

<span class="fc bfc" id="L423" title="All 6 branches covered.">					if (0 != iNumConstraint &amp;&amp; (l &gt;= iNumPredictorOrdinate &amp;&amp; l &lt; iNumPredictorOrdinate +</span>
						iNumConstraint))
<span class="fc" id="L425">						adblCalibBasisConstraintWeight = aSBFC[l -</span>
<span class="fc" id="L426">						    iNumPredictorOrdinate].responseBasisCoeffWeights();</span>

<span class="fc bfc" id="L428" title="All 2 branches covered.">					if (l &lt; iNumPredictorOrdinate)</span>
<span class="fc" id="L429">						aadblResponseBasisCoeffConstraint[l][i] = _be.shapedBasisFunctionResponse</span>
<span class="fc" id="L430">							(adblPredictorOrdinate[l], i);</span>
<span class="fc bfc" id="L431" title="All 2 branches covered.">					else if (l &lt; iNumPredictorOrdinate + iNumConstraint)</span>
<span class="fc" id="L432">						aadblResponseBasisCoeffConstraint[l][i] = adblCalibBasisConstraintWeight[i];</span>
<span class="fc bfc" id="L433" title="All 2 branches covered.">					else if (l &lt; iNumPredictorOrdinate + iNumConstraint + iNumLeftDeriv)</span>
<span class="fc" id="L434">						aadblResponseBasisCoeffConstraint[l][i] = _be.shapedBasisFunctionDerivative (left(),</span>
							l - iNumPredictorOrdinate - iNumConstraint + 1, i);
<span class="fc bfc" id="L436" title="All 2 branches covered.">					else if (l &lt; iNumPredictorOrdinate + iNumConstraint + iNumLeftDeriv + iNumRightDeriv)</span>
<span class="fc" id="L437">						aadblResponseBasisCoeffConstraint[l][i] = _be.shapedBasisFunctionDerivative</span>
<span class="fc" id="L438">							(right(), l - iNumPredictorOrdinate - iNumConstraint - iNumLeftDeriv + 1, i);</span>
					else
<span class="fc" id="L440">						aadblResponseBasisCoeffConstraint[l][i] = bffp.basisPairConstraintCoefficient (i, l);</span>
				}
			}
<span class="nc" id="L443">		} catch (java.lang.Exception e) {</span>
<span class="nc" id="L444">			e.printStackTrace();</span>

<span class="nc" id="L446">			return false;</span>
<span class="fc" id="L447">		}</span>

<span class="fc" id="L449">		org.drip.quant.linearalgebra.LinearizationOutput lo =</span>
			org.drip.quant.linearalgebra.LinearSystemSolver.SolveUsingMatrixInversion
<span class="fc" id="L451">				(aadblResponseBasisCoeffConstraint, adblPredictorResponseConstraintValue);</span>

<span class="fc bfc" id="L453" title="All 2 branches covered.">		if (null == lo) return false;</span>

<span class="fc" id="L455">		double[] adblCalibResponseBasisCoeff = lo.getTransformedRHS();</span>

<span class="pc bpc" id="L457" title="2 of 4 branches missed.">		if (null == adblCalibResponseBasisCoeff || adblCalibResponseBasisCoeff.length !=</span>
			iNumResponseBasisCoeff || null == (_aadblDResponseBasisCoeffDConstraint =
<span class="pc bpc" id="L459" title="3 of 6 branches missed.">				lo.getTransformedMatrix()) || _aadblDResponseBasisCoeffDConstraint.length !=</span>
					iNumResponseBasisCoeff || _aadblDResponseBasisCoeffDConstraint[0].length !=
						iNumResponseBasisCoeff)
<span class="nc" id="L462">			return false;</span>

<span class="fc bfc" id="L464" title="All 2 branches covered.">		for (int i = 0; i &lt; iNumResponseBasisCoeff; ++i) {</span>
<span class="pc bpc" id="L465" title="1 of 2 branches missed.">			if (!org.drip.quant.common.NumberUtil.IsValid (_adblResponseBasisCoeff[i] =</span>
				adblCalibResponseBasisCoeff[i]))
<span class="nc" id="L467">				return false;</span>
		}

<span class="fc" id="L470">		return true;</span>
	}

	/**
	 * Sensitivity Calibrator: Calibrate the Segment Manifest Measure Jacobian from the Calibration Inputs
	 * 
	 * @param ssciManifestSensitivity The Segment Manifest Calibration Sensitivity Inputs
	 * @param aSBFCState Array of Segment State Basis Flexure Constraints
	 * 
	 * @return The Manifest Sensitivity Coefficients
	 */

	public double[] calibrateManifestJacobian (
		final org.drip.spline.params.SegmentStateCalibrationInputs ssciManifestSensitivity,
		final org.drip.spline.params.SegmentBasisFlexureConstraint[] aSBFCState)
	{
<span class="pc bpc" id="L486" title="1 of 2 branches missed.">		if (null == ssciManifestSensitivity) return null;</span>

<span class="fc" id="L488">		double[] adblPredictorOrdinate = ssciManifestSensitivity.predictorOrdinates();</span>

<span class="fc" id="L490">		double[] adblResponseValueManifestSensitivity = ssciManifestSensitivity.responseValues();</span>

<span class="fc" id="L492">		double[] adblLeftEdgeDerivManifestSensitivity = ssciManifestSensitivity.leftEdgeDeriv();</span>

<span class="fc" id="L494">		double[] adblRightEdgeDerivManifestSensitivity = ssciManifestSensitivity.rightEdgeDeriv();</span>

<span class="fc" id="L496">		org.drip.spline.params.SegmentBestFitResponse sbfrManifestSensitivity =</span>
<span class="fc" id="L497">			ssciManifestSensitivity.bestFitResponse();</span>

<span class="fc" id="L499">		org.drip.spline.params.SegmentBasisFlexureConstraint[] aSBFCManifestSensitivity =</span>
<span class="fc" id="L500">			ssciManifestSensitivity.flexureConstraint();</span>

<span class="fc" id="L502">		int iNumConstraint = 0;</span>
<span class="fc" id="L503">		int iNumResponseBasisCoeff = _adblResponseBasisCoeff.length;</span>
<span class="fc bfc" id="L504" title="All 2 branches covered.">		int iNumPredictorOrdinate = null == adblPredictorOrdinate ? 0 : adblPredictorOrdinate.length;</span>
<span class="fc" id="L505">		double[] adblPredictorResponseManifestSensitivityConstraint = new double[iNumResponseBasisCoeff];</span>
<span class="fc bfc" id="L506" title="All 2 branches covered.">		int iNumLeftDerivManifestSensitivity = null == adblLeftEdgeDerivManifestSensitivity ? 0 :</span>
			adblLeftEdgeDerivManifestSensitivity.length;
<span class="pc bpc" id="L508" title="1 of 2 branches missed.">		int iNumRightDerivManifestSensitivity = null == adblRightEdgeDerivManifestSensitivity ? 0 :</span>
			adblRightEdgeDerivManifestSensitivity.length;
<span class="fc" id="L510">		double[][] aadblResponseCoeffConstraintManifestSensitivity = new</span>
			double[iNumResponseBasisCoeff][iNumResponseBasisCoeff];

<span class="fc bfc" id="L513" title="All 2 branches covered.">		if (null != aSBFCState) {</span>
<span class="fc" id="L514">			int iNumPotentialConstraint = aSBFCState.length;</span>

<span class="fc bfc" id="L516" title="All 2 branches covered.">			for (int i = 0; i &lt; iNumPotentialConstraint; ++i) {</span>
<span class="pc bpc" id="L517" title="1 of 2 branches missed.">				if (null != aSBFCState[i]) ++iNumConstraint;</span>
			}
		}

<span class="pc bpc" id="L521" title="1 of 2 branches missed.">		if (iNumResponseBasisCoeff &lt; iNumPredictorOrdinate + iNumLeftDerivManifestSensitivity +</span>
			iNumRightDerivManifestSensitivity + iNumConstraint)
<span class="nc" id="L523">			return null;</span>

		try {
<span class="pc bpc" id="L526" title="1 of 2 branches missed.">			org.drip.spline.segment.BestFitFlexurePenalizer bffpManifestSensitivity = new</span>
				org.drip.spline.segment.BestFitFlexurePenalizer (this, null == _sidc ? null :
<span class="pc bpc" id="L528" title="1 of 2 branches missed.">					_sidc.curvaturePenaltyControl(), null == _sidc ? null : _sidc.lengthPenaltyControl(),</span>
						sbfrManifestSensitivity, _be);

<span class="fc bfc" id="L531" title="All 2 branches covered.">			for (int j = 0; j &lt; iNumResponseBasisCoeff; ++j) {</span>
<span class="fc bfc" id="L532" title="All 2 branches covered.">				if (j &lt; iNumPredictorOrdinate)</span>
<span class="fc" id="L533">					adblPredictorResponseManifestSensitivityConstraint[j] =</span>
						adblResponseValueManifestSensitivity[j];
<span class="fc bfc" id="L535" title="All 2 branches covered.">				else if (j &lt; iNumPredictorOrdinate + iNumConstraint) {</span>
<span class="fc" id="L536">					adblPredictorResponseManifestSensitivityConstraint[j] = 0.;</span>
<span class="fc" id="L537">					org.drip.spline.params.SegmentBasisFlexureConstraint sbfcManifestSensitivity =</span>
						aSBFCManifestSensitivity[j - iNumPredictorOrdinate];

<span class="pc bpc" id="L540" title="1 of 2 branches missed.">					if (null != sbfcManifestSensitivity) {</span>
<span class="fc" id="L541">						adblPredictorResponseManifestSensitivityConstraint[j] =</span>
<span class="fc" id="L542">							sbfcManifestSensitivity.contraintValue();</span>

<span class="fc" id="L544">						double[] adblCalibConstraintWeightManifestSensitivity =</span>
<span class="fc" id="L545">							sbfcManifestSensitivity.responseBasisCoeffWeights();</span>

<span class="fc bfc" id="L547" title="All 2 branches covered.">						for (int i = 0; i &lt; iNumResponseBasisCoeff; ++i)</span>
<span class="fc" id="L548">							adblPredictorResponseManifestSensitivityConstraint[j] -=</span>
								_adblResponseBasisCoeff[i] * adblCalibConstraintWeightManifestSensitivity[i];
					}
<span class="fc bfc" id="L551" title="All 2 branches covered.">				} else if (j &lt; iNumPredictorOrdinate + iNumConstraint + iNumLeftDerivManifestSensitivity)</span>
<span class="fc" id="L552">					adblPredictorResponseManifestSensitivityConstraint[j] =</span>
						adblLeftEdgeDerivManifestSensitivity[j - iNumPredictorOrdinate - iNumConstraint];
<span class="pc bpc" id="L554" title="1 of 2 branches missed.">				else if (j &lt; iNumPredictorOrdinate + iNumConstraint + iNumLeftDerivManifestSensitivity +</span>
					iNumRightDerivManifestSensitivity)
<span class="nc" id="L556">					adblPredictorResponseManifestSensitivityConstraint[j] =</span>
						adblRightEdgeDerivManifestSensitivity[j - iNumPredictorOrdinate - iNumConstraint -
						    iNumLeftDerivManifestSensitivity];
				else
<span class="fc" id="L560">					adblPredictorResponseManifestSensitivityConstraint[j] =</span>
<span class="fc" id="L561">						bffpManifestSensitivity.basisPairPenaltyConstraint (j);</span>
			}

<span class="fc bfc" id="L564" title="All 2 branches covered.">			for (int i = 0; i &lt; iNumResponseBasisCoeff; ++i) {</span>
<span class="fc bfc" id="L565" title="All 2 branches covered.">				for (int l = 0; l &lt; iNumResponseBasisCoeff; ++l) {</span>
<span class="fc" id="L566">					double[] adblCalibBasisConstraintWeight = null;</span>

<span class="fc bfc" id="L568" title="All 6 branches covered.">					if (0 != iNumConstraint &amp;&amp; (l &gt;= iNumPredictorOrdinate &amp;&amp; l &lt; iNumPredictorOrdinate +</span>
						iNumConstraint))
<span class="fc" id="L570">						adblCalibBasisConstraintWeight = aSBFCState[l -</span>
<span class="fc" id="L571">						    iNumPredictorOrdinate].responseBasisCoeffWeights();</span>

<span class="fc bfc" id="L573" title="All 2 branches covered.">					if (l &lt; iNumPredictorOrdinate)</span>
<span class="fc" id="L574">						aadblResponseCoeffConstraintManifestSensitivity[l][i] =</span>
<span class="fc" id="L575">							_be.shapedBasisFunctionResponse (adblPredictorOrdinate[l], i);</span>
<span class="fc bfc" id="L576" title="All 2 branches covered.">					else if (l &lt; iNumPredictorOrdinate + iNumConstraint)</span>
<span class="fc" id="L577">						aadblResponseCoeffConstraintManifestSensitivity[l][i] =</span>
							adblCalibBasisConstraintWeight[i];
<span class="fc bfc" id="L579" title="All 2 branches covered.">					else if (l &lt; iNumPredictorOrdinate + iNumConstraint + iNumLeftDerivManifestSensitivity)</span>
<span class="fc" id="L580">						aadblResponseCoeffConstraintManifestSensitivity[l][i] =</span>
<span class="fc" id="L581">							_be.shapedBasisFunctionDerivative (left(), l - iNumPredictorOrdinate -</span>
								iNumConstraint + 1, i);
<span class="pc bpc" id="L583" title="1 of 2 branches missed.">					else if (l &lt; iNumPredictorOrdinate + iNumConstraint + iNumLeftDerivManifestSensitivity +</span>
						iNumRightDerivManifestSensitivity)
<span class="nc" id="L585">						aadblResponseCoeffConstraintManifestSensitivity[l][i] =</span>
<span class="nc" id="L586">							_be.shapedBasisFunctionDerivative (right(), l - iNumPredictorOrdinate -</span>
								iNumConstraint - iNumLeftDerivManifestSensitivity + 1, i);
					else
<span class="fc" id="L589">						aadblResponseCoeffConstraintManifestSensitivity[l][i] =</span>
<span class="fc" id="L590">							bffpManifestSensitivity.basisPairConstraintCoefficient (i, l);</span>
				}
			}
<span class="nc" id="L593">		} catch (java.lang.Exception e) {</span>
<span class="nc" id="L594">			e.printStackTrace();</span>

<span class="nc" id="L596">			return null;</span>
<span class="fc" id="L597">		}</span>

<span class="fc" id="L599">		org.drip.quant.linearalgebra.LinearizationOutput lo =</span>
			org.drip.quant.linearalgebra.LinearSystemSolver.SolveUsingMatrixInversion
<span class="fc" id="L601">				(aadblResponseCoeffConstraintManifestSensitivity,</span>
					adblPredictorResponseManifestSensitivityConstraint);

<span class="pc bpc" id="L604" title="1 of 2 branches missed.">		return null == lo ? null : lo.getTransformedRHS();</span>
	}

	/**
	 * Sensitivity Calibrator: Calibrate the Segment Local Manifest Jacobian from the Calibration Parameter
	 * 	Set
	 * 
	 * @param strManifestMeasure Latent State Manifest Measure
	 * @param ssciManifestSensitivity The Segment Manifest Calibration Parameter Sensitivity
	 * @param aSBFCState Array of Segment State Basis Flexure Constraints
	 * 
	 * @return TRUE - Local Manifest Sensitivity Calibration Successful
	 */

	public boolean calibrateLocalManifestJacobian (
		final java.lang.String strManifestMeasure,
		final org.drip.spline.params.SegmentStateCalibrationInputs ssciManifestSensitivity,
		final org.drip.spline.params.SegmentBasisFlexureConstraint[] aSBFCState)
	{
<span class="fc" id="L623">		org.drip.spline.segment.LatentStateManifestSensitivity lsms = manifestSensitivity</span>
<span class="fc" id="L624">			(strManifestMeasure);</span>

<span class="pc bpc" id="L626" title="1 of 2 branches missed.">		if (null == lsms) return false;</span>

<span class="fc" id="L628">		double[] adblDBasisCoeffDLocalManifest = calibrateManifestJacobian (ssciManifestSensitivity,</span>
			aSBFCState);

<span class="pc bpc" id="L631" title="2 of 4 branches missed.">		return null == adblDBasisCoeffDLocalManifest || adblDBasisCoeffDLocalManifest.length !=</span>
			_adblResponseBasisCoeff.length ? false : lsms.setDBasisCoeffDLocalManifest
<span class="fc" id="L633">				(adblDBasisCoeffDLocalManifest);</span>
	}

	/**
	 * Sensitivity Calibrator: Calibrate the Segment Preceeding Manifest Jacobian from the Calibration
	 *	Parameter Set
	 * 
	 * @param strManifestMeasure Latent State Manifest
	 * @param ssciPreceedingManifestSensitivity The Segment Preceeding Manifest Calibration Parameter
	 * 	Sensitivity
	 * 
	 * @return TRUE - Preceeding Manifest Sensitivity Calibration Successful
	 */

	public boolean calibratePreceedingManifestJacobian (
		final java.lang.String strManifestMeasure,
		final org.drip.spline.params.SegmentStateCalibrationInputs ssciPreceedingManifestSensitivity)
	{
<span class="fc" id="L651">		org.drip.spline.segment.LatentStateManifestSensitivity lsms = manifestSensitivity</span>
<span class="fc" id="L652">			(strManifestMeasure);</span>

<span class="pc bpc" id="L654" title="1 of 2 branches missed.">		if (null == lsms) return false;</span>

<span class="fc" id="L656">		double[] adblDBasisCoeffDPreceedingManifest = calibrateManifestJacobian</span>
<span class="fc" id="L657">			(ssciPreceedingManifestSensitivity, null);</span>

<span class="pc bpc" id="L659" title="2 of 4 branches missed.">		return null == adblDBasisCoeffDPreceedingManifest || adblDBasisCoeffDPreceedingManifest.length !=</span>
			_adblResponseBasisCoeff.length ? false : lsms.setDBasisCoeffDPreceedingManifest
<span class="fc" id="L661">				(adblDBasisCoeffDPreceedingManifest);</span>
	}

	/**
	 * Calibrate the coefficients from the prior Predictor/Response Segment, the Constraint, and fitness
	 * 	Weights
	 * 
	 * @param csPreceeding Preceeding Predictor/Response Segment
	 * @param srvcState The Segment State Response Value Constraint
	 * @param sbfrState Segment's Best Fit Weighted State Response Values
	 * 
	 * @return TRUE - If the calibration succeeds
	 */

	public boolean calibrate (
		final org.drip.spline.segment.LatentStateResponseModel csPreceeding,
		final org.drip.spline.params.SegmentResponseValueConstraint srvcState,
		final org.drip.spline.params.SegmentBestFitResponse sbfrState)
	{
<span class="fc" id="L680">		int iCk = _sidc.Ck();</span>

<span class="fc bfc" id="L682" title="All 2 branches covered.">		org.drip.spline.params.SegmentBasisFlexureConstraint[] aSBFCState = null == srvcState ? null : new</span>
			org.drip.spline.params.SegmentBasisFlexureConstraint[] {srvcState.responseIndexedBasisConstraint
<span class="fc" id="L684">				(_be, this)};</span>

<span class="fc" id="L686">		double[] adblManifestJacobianDerivAtLeftOrdinate = null;</span>

<span class="fc bfc" id="L688" title="All 2 branches covered.">		if (0 != iCk) {</span>
<span class="fc" id="L689">			adblManifestJacobianDerivAtLeftOrdinate = new double[iCk];</span>

<span class="fc bfc" id="L691" title="All 2 branches covered.">			for (int i = 0; i &lt; iCk; ++i)</span>
<span class="fc" id="L692">				adblManifestJacobianDerivAtLeftOrdinate[i] = 0.;</span>
		}

<span class="pc bpc" id="L695" title="1 of 2 branches missed.">		if (null == csPreceeding) {</span>
			try {
<span class="nc" id="L697">				double[] adblStateDerivAtLeftOrdinate = null;</span>

<span class="nc bnc" id="L699" title="All 2 branches missed.">				if (0 != iCk) {</span>
<span class="nc" id="L700">					adblStateDerivAtLeftOrdinate = new double[iCk];</span>

<span class="nc bnc" id="L702" title="All 2 branches missed.">					for (int i = 0; i &lt; iCk; ++i)</span>
<span class="nc" id="L703">						adblStateDerivAtLeftOrdinate[i] = _be.responseValueDerivative</span>
<span class="nc" id="L704">							(_adblResponseBasisCoeff, left(), i);</span>
				}

<span class="nc" id="L707">				return calibrateState (new org.drip.spline.params.SegmentStateCalibrationInputs (new double[]</span>
<span class="nc" id="L708">					{left()}, new double[] {_be.responseValue (_adblResponseBasisCoeff, left())},</span>
						adblStateDerivAtLeftOrdinate, null, aSBFCState, sbfrState));
<span class="nc" id="L710">			} catch (java.lang.Exception e) {</span>
<span class="nc" id="L711">				e.printStackTrace();</span>
			}

<span class="nc" id="L714">			return false;</span>
		}

		try {
<span class="fc" id="L718">			return calibrateState (new org.drip.spline.params.SegmentStateCalibrationInputs (new double[]</span>
<span class="fc bfc" id="L719" title="All 2 branches covered.">				{left()}, new double[] {csPreceeding.responseValue (left())}, 0 == iCk ? null :</span>
<span class="fc" id="L720">					transmissionCk (left(), csPreceeding, iCk), null, aSBFCState, sbfrState));</span>
<span class="nc" id="L721">		} catch (java.lang.Exception e) {</span>
<span class="nc" id="L722">			e.printStackTrace();</span>
		}

<span class="nc" id="L725">		return false;</span>
	}

	/**
	 * Calibrate the coefficients from the prior Segment and the Response Value at the Right Predictor
	 *  Ordinate
	 * 
	 * @param csPreceeding Preceeding Predictor/Response Segment
	 * @param dblRightStateValue Response Value at the Right Predictor Ordinate
	 * @param sbfrState Segment's Best Fit Weighted Response Values
	 * 
	 * @return TRUE - If the calibration succeeds
	 */

	public boolean calibrate (
		final LatentStateResponseModel csPreceeding,
		final double dblRightStateValue,
		final org.drip.spline.params.SegmentBestFitResponse sbfrState)
	{
<span class="pc bpc" id="L744" title="1 of 2 branches missed.">		if (null == csPreceeding) return false;</span>

<span class="fc" id="L746">		int iCk = _sidc.Ck();</span>

		try {
<span class="fc" id="L749">			return calibrateState (new org.drip.spline.params.SegmentStateCalibrationInputs (new double[]</span>
<span class="fc bfc" id="L750" title="All 2 branches covered.">				{left(), right()}, new double[] {csPreceeding.responseValue (left()), dblRightStateValue}, 0</span>
<span class="fc" id="L751">					!= iCk ? csPreceeding.transmissionCk (left(), this, iCk) : null, null, null, sbfrState));</span>
<span class="nc" id="L752">		} catch (java.lang.Exception e) {</span>
<span class="nc" id="L753">			e.printStackTrace();</span>
		}

<span class="nc" id="L756">		return false;</span>
	}

	/**
	 * Calibrate the Coefficients from the Edge Response Values and the Left Edge Response Slope
	 * 
	 * @param dblLeftValue Left Edge Response Value
	 * @param dblLeftSlope Left Edge Response Slope
	 * @param dblRightValue Right Edge Response Value
	 * @param sbfrState Segment's Best Fit Weighted Response Values
	 * 
	 * @return TRUE - The Calibration Succeeded
	 */

	public boolean calibrate (
		final double dblLeftValue,
		final double dblLeftSlope,
		final double dblRightValue,
		final org.drip.spline.params.SegmentBestFitResponse sbfrState)
	{
<span class="pc bpc" id="L776" title="1 of 2 branches missed.">		if (!org.drip.quant.common.NumberUtil.IsValid (dblLeftValue) ||</span>
<span class="pc bpc" id="L777" title="1 of 2 branches missed.">			!org.drip.quant.common.NumberUtil.IsValid (dblLeftSlope) ||</span>
<span class="pc bpc" id="L778" title="1 of 2 branches missed.">				!org.drip.quant.common.NumberUtil.IsValid (dblRightValue))</span>
<span class="nc" id="L779">			return false;</span>

		try {
<span class="fc" id="L782">			return calibrateState (new org.drip.spline.params.SegmentStateCalibrationInputs (new double[]</span>
<span class="fc" id="L783">				{left(), right()}, new double[] {dblLeftValue, dblRightValue},</span>
<span class="fc" id="L784">					org.drip.quant.common.CollectionUtil.DerivArrayFromSlope (numParameters() - 2,</span>
						dblLeftSlope), null, null, sbfrState));
<span class="nc" id="L786">		} catch (java.lang.Exception e) {</span>
<span class="nc" id="L787">			e.printStackTrace();</span>
		}

<span class="nc" id="L790">		return false;</span>
	}

	/**
	 * Calibrate the coefficients from the Left Edge Response Value Constraint, the Left Edge Response Value
	 *  Slope, and the Right Edge Response Value Constraint
	 * 
	 * @param wrvcStateLeft Left Edge Response Value Constraint
	 * @param dblLeftSlope Left Edge Response Value Slope
	 * @param wrvcStateRight Right Edge Response Value Constraint
	 * @param sbfrState Segment's Best Fit Weighted Response
	 * 
	 * @return TRUE - If the calibration succeeds
	 */

	public boolean calibrate (
		final org.drip.spline.params.SegmentResponseValueConstraint wrvcStateLeft,
		final double dblLeftSlope,
		final org.drip.spline.params.SegmentResponseValueConstraint wrvcStateRight,
		final org.drip.spline.params.SegmentBestFitResponse sbfrState)
	{
<span class="fc" id="L811">		org.drip.spline.params.SegmentBasisFlexureConstraint[] aSBFCState = null;</span>

		try {
<span class="pc bpc" id="L814" title="1 of 4 branches missed.">			if (null != wrvcStateLeft || null != wrvcStateRight)</span>
<span class="pc bpc" id="L815" title="1 of 2 branches missed.">				aSBFCState = new org.drip.spline.params.SegmentBasisFlexureConstraint[] {null ==</span>
<span class="fc bfc" id="L816" title="All 2 branches covered.">					wrvcStateLeft ? null : wrvcStateLeft.responseIndexedBasisConstraint (_be, this), null ==</span>
<span class="fc" id="L817">						wrvcStateRight ? null : wrvcStateRight.responseIndexedBasisConstraint (_be, this)};</span>

<span class="fc" id="L819">			return calibrateState (new org.drip.spline.params.SegmentStateCalibrationInputs (null, null,</span>
<span class="fc" id="L820">				org.drip.quant.common.CollectionUtil.DerivArrayFromSlope (numParameters() - 2, dblLeftSlope),</span>
					null, aSBFCState, sbfrState));
<span class="nc" id="L822">		} catch (java.lang.Exception e) {</span>
<span class="nc" id="L823">			e.printStackTrace();</span>
		}

<span class="nc" id="L826">		return false;</span>
	}

	/**
	 * Compute the Local and the Preceeding Manifest Measure Sensitivity Coefficients from the Preceeding
	 * 	Segment, the Local Response Value, the Local Response Value Manifest Measure Sensitivity, and the
	 * 	Local Best Fit Response Sensitivity
	 * 
	 * @param csPreceeding Preceeding Predictor/Response Segment
	 * @param strManifestMeasure Manifest Measure whose Sensitivity is sought
	 * @param srvcState The Segment State Response Value Constraint
	 * @param srvcManifestSensitivity The Segment State Response Value Constraint Manifest Sensitivity
	 * @param sbfrManifestSensitivity Segment's Best Fit Weighted State Response Value Manifest Sensitivity
	 * 
	 * @return TRUE - If the calibration succeeds
	 */

	public boolean manifestMeasureSensitivity (
		final org.drip.spline.segment.LatentStateResponseModel csPreceeding,
		final java.lang.String strManifestMeasure,
		final org.drip.spline.params.SegmentResponseValueConstraint srvcState,
		final org.drip.spline.params.SegmentResponseValueConstraint srvcManifestSensitivity,
		final org.drip.spline.params.SegmentBestFitResponse sbfrManifestSensitivity)
	{
<span class="pc bpc" id="L850" title="3 of 4 branches missed.">		if (null == srvcState &amp;&amp; null != srvcManifestSensitivity) return false;</span>

<span class="pc bpc" id="L852" title="1 of 2 branches missed.">		org.drip.spline.params.SegmentBasisFlexureConstraint[] aSBFCState = null == srvcState ? null : new</span>
			org.drip.spline.params.SegmentBasisFlexureConstraint[] {srvcState.responseIndexedBasisConstraint
<span class="fc" id="L854">				(_be, this)};</span>

<span class="pc bpc" id="L856" title="1 of 2 branches missed.">		org.drip.spline.params.SegmentBasisFlexureConstraint[] aSBFCManifestSensitivity = null ==</span>
			srvcManifestSensitivity ? null : new org.drip.spline.params.SegmentBasisFlexureConstraint[]
<span class="fc" id="L858">				{srvcManifestSensitivity.responseIndexedBasisConstraint (_be, this)};</span>

<span class="fc" id="L860">		double[] adblManifestJacobianDerivAtLeftOrdinate = null;</span>

<span class="fc" id="L862">		int iCk = _sidc.Ck();</span>

<span class="fc bfc" id="L864" title="All 2 branches covered.">		if (0 != iCk) {</span>
<span class="fc" id="L865">			adblManifestJacobianDerivAtLeftOrdinate = new double[iCk];</span>

<span class="fc bfc" id="L867" title="All 2 branches covered.">			for (int i = 0; i &lt; iCk; ++i)</span>
<span class="fc" id="L868">				adblManifestJacobianDerivAtLeftOrdinate[i] = 0.;</span>
		}

<span class="pc bpc" id="L871" title="1 of 2 branches missed.">		if (null == csPreceeding) return false;</span>

		try {
<span class="pc bpc" id="L874" title="1 of 2 branches missed.">			if (null == aSBFCManifestSensitivity) return true;</span>

<span class="pc bpc" id="L876" title="1 of 2 branches missed.">			if (!calibrateLocalManifestJacobian (strManifestMeasure, new</span>
<span class="fc" id="L877">				org.drip.spline.params.SegmentStateCalibrationInputs (new double[] {left()}, new double[]</span>
					{0.}, adblManifestJacobianDerivAtLeftOrdinate, null, aSBFCManifestSensitivity,
						sbfrManifestSensitivity), aSBFCState))
<span class="nc" id="L880">				return false;</span>

<span class="fc" id="L882">			org.drip.spline.segment.LatentStateManifestSensitivity lsms = manifestSensitivity</span>
<span class="fc" id="L883">				(strManifestMeasure);</span>

<span class="pc bpc" id="L885" title="1 of 2 branches missed.">			if (null == lsms) return true;</span>

<span class="pc bpc" id="L887" title="1 of 2 branches missed.">			return lsms.getPMSC().impactFade() ? calibratePreceedingManifestJacobian (strManifestMeasure, new</span>
<span class="fc" id="L888">				org.drip.spline.params.SegmentStateCalibrationInputs (new double[] {left(), right()}, new</span>
<span class="fc" id="L889">					double[] {csPreceeding.calcDResponseDManifest (strManifestMeasure, left(), 1), 0.}, null,</span>
<span class="fc" id="L890">						CkDBasisCoeffDPreceedingManifestMeasure (strManifestMeasure), null, null)) :</span>
<span class="nc" id="L891">							lsms.setDResponseDPreceedingManifest (csPreceeding.calcDResponseDManifest</span>
<span class="nc" id="L892">								(strManifestMeasure, left(), 1));</span>
<span class="nc" id="L893">		} catch (java.lang.Exception e) {</span>
<span class="nc" id="L894">			e.printStackTrace();</span>
		}

<span class="nc" id="L897">		return false;</span>
	}

	/**
	 * Compute the Local and the Preceeding Manifest Measure Sensitivity Coefficients from the Preceeding
	 * 	Segments, the Local Response Value Sensitivity at the Right Predictor Ordinate, and the Local Best
	 * 	Fit Response Sensitivity
	 * 
	 * @param csPreceeding Preceeding Predictor/Response Segment
	 * @param strManifestMeasure Manifest Measure whose Sensitivity is sought
	 * @param dblRightStateManifestSensitivity Response Value Manifest Sensitivity at the Right Predictor
	 * 	Ordinate
	 * @param sbfrManifestSensitivity Segment's Best Fit Weighted Response Value Manifest Sensitivity
	 * 
	 * @return TRUE - If the calibration succeeds
	 */

	public boolean manifestMeasureSensitivity (
		final LatentStateResponseModel csPreceeding,
		final java.lang.String strManifestMeasure,
		final double dblRightStateManifestSensitivity,
		final org.drip.spline.params.SegmentBestFitResponse sbfrManifestSensitivity)
	{
<span class="pc bpc" id="L920" title="1 of 2 branches missed.">		if (null == csPreceeding) return false;</span>

<span class="fc" id="L922">		int iCk = _sidc.Ck();</span>

		try {
<span class="fc" id="L925">			double[] adblManifestJacobianDerivAtLeftOrdinate = null;</span>

<span class="fc bfc" id="L927" title="All 2 branches covered.">			if (0 != iCk) {</span>
<span class="fc" id="L928">				adblManifestJacobianDerivAtLeftOrdinate = new double[iCk];</span>

<span class="fc bfc" id="L930" title="All 2 branches covered.">				for (int i = 0; i &lt; iCk; ++i)</span>
<span class="fc" id="L931">					adblManifestJacobianDerivAtLeftOrdinate[i] = 0.;</span>
			}

<span class="pc bpc" id="L934" title="1 of 2 branches missed.">			if (!org.drip.quant.common.NumberUtil.IsValid (dblRightStateManifestSensitivity)) return true;</span>

<span class="nc bnc" id="L936" title="All 2 branches missed.">			if (!calibrateLocalManifestJacobian (strManifestMeasure, new</span>
<span class="nc bnc" id="L937" title="All 2 branches missed.">				org.drip.spline.params.SegmentStateCalibrationInputs (new double[] {left(), right()}, new</span>
					double[] {0., dblRightStateManifestSensitivity}, 0 != iCk ?
						adblManifestJacobianDerivAtLeftOrdinate : null, null, null, sbfrManifestSensitivity),
							null))
<span class="nc" id="L941">				return false;</span>

<span class="nc" id="L943">			org.drip.spline.segment.LatentStateManifestSensitivity lsms = manifestSensitivity</span>
<span class="nc" id="L944">				(strManifestMeasure);</span>

<span class="nc bnc" id="L946" title="All 2 branches missed.">			if (null == lsms) return true;</span>

<span class="nc bnc" id="L948" title="All 2 branches missed.">			return lsms.getPMSC().impactFade() ? calibratePreceedingManifestJacobian (strManifestMeasure, new</span>
<span class="nc" id="L949">				org.drip.spline.params.SegmentStateCalibrationInputs (new double[] {left(), right()}, new</span>
<span class="nc" id="L950">					double[] {csPreceeding.calcDResponseDManifest (strManifestMeasure, left(), 1), 0.}, null,</span>
<span class="nc" id="L951">						CkDBasisCoeffDPreceedingManifestMeasure (strManifestMeasure), null, null)) :</span>
<span class="nc" id="L952">							lsms.setDResponseDPreceedingManifest (csPreceeding.calcDResponseDManifest</span>
<span class="nc" id="L953">								(strManifestMeasure, left(), 1));</span>
<span class="nc" id="L954">		} catch (java.lang.Exception e) {</span>
<span class="nc" id="L955">			e.printStackTrace();</span>
		}

<span class="nc" id="L958">		return false;</span>
	}

	/**
	 * Compute the Local and the Preceeding Manifest Measure Sensitivity Coefficients from the Local
	 * 	Response Value Sensitivity at the Left/Right Predictor Ordinate, the Local Left Response Value
	 * 	Sensitivity Slope, and the Local Best Fit Response Sensitivity.
	 * 
	 * @param strManifestMeasure Manifest Measure whose Sensitivity is sought
	 * @param dblLeftManifestSensitivity Left Edge Response Value Manifest Sensitivity
	 * @param dblLeftSlopeManifestSensitivity Left Edge Response Slope Manifest Sensitivity
	 * @param dblRightManifestSensitivity Right Edge Response Value Manifest Sensitivity
	 * @param sbfrManifestSensitivity Segment's Best Fit Weighted Response Values Manifest Sensitivity
	 * 
	 * @return TRUE - The Calibration Succeeded
	 */

	public boolean manifestMeasureSensitivity (
		final java.lang.String strManifestMeasure,
		final double dblLeftManifestSensitivity,
		final double dblLeftSlopeManifestSensitivity,
		final double dblRightManifestSensitivity,
		final org.drip.spline.params.SegmentBestFitResponse sbfrManifestSensitivity)
	{
		try {
<span class="nc bnc" id="L983" title="All 2 branches missed.">			return org.drip.quant.common.NumberUtil.IsValid (dblLeftManifestSensitivity) &amp;&amp;</span>
<span class="nc bnc" id="L984" title="All 2 branches missed.">				org.drip.quant.common.NumberUtil.IsValid (dblLeftSlopeManifestSensitivity) &amp;&amp;</span>
<span class="nc bnc" id="L985" title="All 2 branches missed.">					org.drip.quant.common.NumberUtil.IsValid (dblRightManifestSensitivity) ?</span>
<span class="nc" id="L986">						calibrateLocalManifestJacobian (strManifestMeasure, new</span>
<span class="nc" id="L987">							org.drip.spline.params.SegmentStateCalibrationInputs (new double[] {left(),</span>
<span class="nc" id="L988">								right()}, new double[] {dblLeftManifestSensitivity,</span>
									dblRightManifestSensitivity},
										org.drip.quant.common.CollectionUtil.DerivArrayFromSlope
<span class="nc" id="L991">											(numParameters() - 2, dblLeftSlopeManifestSensitivity), null,</span>
												null, sbfrManifestSensitivity), null) : true;
<span class="nc" id="L993">		} catch (java.lang.Exception e) {</span>
<span class="nc" id="L994">			e.printStackTrace();</span>
		}

<span class="nc" id="L997">		return false;</span>
	}

	/**
	 * Compute the Local and the Preceeding Manifest Measure Sensitivity Coefficients from the Local
	 * 	Response Value/Sensitivity Constraints at the Left/Right Predictor Ordinate, the Local Left
	 * 	Response Value Sensitivity Slope, and the Local Best Fit Response Sensitivity
	 * 
	 * @param strManifestMeasure Manifest Measure whose Sensitivity is sought
	 * @param wrvcStateLeft Left Edge Response Value Constraint
	 * @param wrvcStateRight Right Edge Response Value Constraint
	 * @param dblLeftSlopeManifestSensitivity Left Edge Response Value Slope Manifest Sensitivity
	 * @param wrvcStateLeftManifestSensitivity Left Edge Response Value Constraint Manifest Sensitivity
	 * @param wrvcStateRightManifestSensitivity Right Edge Response Value Constraint Manifest Sensitivity
	 * @param sbfrManifestSensitivity Segment's Best Fit Weighted Response Manifest Sensitivity
	 * 
	 * @return TRUE - If the calibration succeeds
	 */

	public boolean manifestMeasureSensitivity (
		final java.lang.String strManifestMeasure,
		final org.drip.spline.params.SegmentResponseValueConstraint wrvcStateLeft,
		final org.drip.spline.params.SegmentResponseValueConstraint wrvcStateRight,
		final double dblLeftSlopeManifestSensitivity,
		final org.drip.spline.params.SegmentResponseValueConstraint wrvcStateLeftManifestSensitivity,
		final org.drip.spline.params.SegmentResponseValueConstraint wrvcStateRightManifestSensitivity,
		final org.drip.spline.params.SegmentBestFitResponse sbfrManifestSensitivity)
	{
<span class="fc" id="L1025">		org.drip.spline.params.SegmentBasisFlexureConstraint[] aSBFCState = null;</span>
<span class="fc" id="L1026">		org.drip.spline.params.SegmentBasisFlexureConstraint[] aSBFCManifestSensitivity = null;</span>

		try {
<span class="pc bpc" id="L1029" title="3 of 4 branches missed.">			if (null != wrvcStateLeft || null != wrvcStateRight)</span>
<span class="pc bpc" id="L1030" title="1 of 2 branches missed.">				aSBFCState = new org.drip.spline.params.SegmentBasisFlexureConstraint[] {null ==</span>
<span class="pc bpc" id="L1031" title="1 of 2 branches missed.">					wrvcStateLeft ? null : wrvcStateLeft.responseIndexedBasisConstraint (_be, this), null ==</span>
<span class="fc" id="L1032">						wrvcStateRight ? null : wrvcStateRight.responseIndexedBasisConstraint (_be, this)};</span>

<span class="pc bpc" id="L1034" title="3 of 4 branches missed.">			if (null != wrvcStateLeftManifestSensitivity || null != wrvcStateRightManifestSensitivity)</span>
<span class="pc bpc" id="L1035" title="1 of 2 branches missed.">				aSBFCManifestSensitivity = new org.drip.spline.params.SegmentBasisFlexureConstraint[] {null</span>
					== wrvcStateLeftManifestSensitivity ? null :
<span class="pc bpc" id="L1037" title="1 of 2 branches missed.">						wrvcStateLeftManifestSensitivity.responseIndexedBasisConstraint (_be, this), null ==</span>
							wrvcStateRightManifestSensitivity ? null :
<span class="fc" id="L1039">								wrvcStateRightManifestSensitivity.responseIndexedBasisConstraint (_be,</span>
									this)};

<span class="pc bpc" id="L1042" title="1 of 2 branches missed.">			return null == aSBFCManifestSensitivity ? true : calibrateLocalManifestJacobian</span>
<span class="fc" id="L1043">				(strManifestMeasure, new org.drip.spline.params.SegmentStateCalibrationInputs (null, null,</span>
<span class="fc" id="L1044">					org.drip.quant.common.CollectionUtil.DerivArrayFromSlope (numParameters() - 2,</span>
						dblLeftSlopeManifestSensitivity), null, aSBFCManifestSensitivity,
							sbfrManifestSensitivity), aSBFCState);
<span class="nc" id="L1047">		} catch (java.lang.Exception e) {</span>
<span class="nc" id="L1048">			e.printStackTrace();</span>
		}

<span class="nc" id="L1051">		return false;</span>
	}

	/**
	 * Retrieve the Segment Curvature DPE
	 * 
	 * @return The Segment Curvature DPE
	 * 
	 * @throws java.lang.Exception Thrown if the Segment Curvature DPE cannot be computed
	 */

	public double curvatureDPE()
		throws java.lang.Exception
	{
<span class="fc" id="L1065">		double dblDPE = 0.;</span>

<span class="fc" id="L1067">		int iNumBasis = _be.numBasis();</span>

<span class="fc" id="L1069">		org.drip.spline.params.SegmentFlexurePenaltyControl sfpc = _sidc.curvaturePenaltyControl();</span>

<span class="pc bpc" id="L1071" title="1 of 2 branches missed.">		if (null == sfpc) sfpc = new org.drip.spline.params.SegmentFlexurePenaltyControl (2, 1.);</span>

<span class="fc" id="L1073">		org.drip.spline.segment.BestFitFlexurePenalizer bffp = new</span>
			org.drip.spline.segment.BestFitFlexurePenalizer (this, sfpc, null, null, _be);

<span class="fc bfc" id="L1076" title="All 2 branches covered.">		for (int i = 0; i &lt; iNumBasis; ++i) {</span>
<span class="fc bfc" id="L1077" title="All 2 branches covered.">			for (int j = 0; j &lt; iNumBasis; ++j)</span>
<span class="fc" id="L1078">				dblDPE += _adblResponseBasisCoeff[i] * _adblResponseBasisCoeff[j] *</span>
<span class="fc" id="L1079">					bffp.basisPairCurvaturePenalty (i, j);</span>
		}

<span class="fc" id="L1082">		return sfpc.amplitude() * dblDPE;</span>
	}

	/**
	 * Retrieve the Segment Length DPE
	 * 
	 * @return The Segment Length DPE
	 * 
	 * @throws java.lang.Exception Thrown if the Segment Length DPE cannot be computed
	 */

	public double lengthDPE()
		throws java.lang.Exception
	{
<span class="fc" id="L1096">		double dblDPE = 0.;</span>

<span class="fc" id="L1098">		int iNumBasis = _be.numBasis();</span>

<span class="fc" id="L1100">		org.drip.spline.params.SegmentFlexurePenaltyControl sfpcLength = _sidc.lengthPenaltyControl();</span>

<span class="pc bpc" id="L1102" title="1 of 2 branches missed.">		if (null == sfpcLength) sfpcLength = new org.drip.spline.params.SegmentFlexurePenaltyControl (1, 1.);</span>

<span class="fc" id="L1104">		org.drip.spline.segment.BestFitFlexurePenalizer bffp = new</span>
			org.drip.spline.segment.BestFitFlexurePenalizer (this, null, sfpcLength, null, _be);

<span class="fc bfc" id="L1107" title="All 2 branches covered.">		for (int i = 0; i &lt; iNumBasis; ++i) {</span>
<span class="fc bfc" id="L1108" title="All 2 branches covered.">			for (int j = 0; j &lt; iNumBasis; ++j)</span>
<span class="fc" id="L1109">				dblDPE += _adblResponseBasisCoeff[i] * _adblResponseBasisCoeff[j] *</span>
<span class="fc" id="L1110">					bffp.basisPairLengthPenalty (i, j);</span>
		}

<span class="fc" id="L1113">		return sfpcLength.amplitude() * dblDPE;</span>
	}

	/**
	 * Retrieve the Segment Best Fit DPE
	 * 
	 * @param sbfr The Segment's Best Fit Response Inputs
	 * 
	 * @return The Segment Best Fit DPE
	 * 
	 * @throws java.lang.Exception Thrown if the Segment Best Fit DPE cannot be computed
	 */

	public double bestFitDPE (
		final org.drip.spline.params.SegmentBestFitResponse sbfr)
		throws java.lang.Exception
	{
<span class="fc bfc" id="L1130" title="All 2 branches covered.">		if (null == sbfr) return 0.;</span>

<span class="fc" id="L1132">		double dblDPE = 0.;</span>

<span class="fc" id="L1134">		int iNumBasis = _be.numBasis();</span>

<span class="fc" id="L1136">		org.drip.spline.segment.BestFitFlexurePenalizer bffp = new</span>
			org.drip.spline.segment.BestFitFlexurePenalizer (this, null, null, sbfr, _be);

<span class="fc bfc" id="L1139" title="All 2 branches covered.">		for (int i = 0; i &lt; iNumBasis; ++i) {</span>
<span class="fc bfc" id="L1140" title="All 2 branches covered.">			for (int j = 0; j &lt; iNumBasis; ++j)</span>
<span class="fc" id="L1141">				dblDPE += _adblResponseBasisCoeff[i] * _adblResponseBasisCoeff[j] * bffp.basisBestFitPenalty</span>
<span class="fc" id="L1142">					(i, j);</span>
		}

<span class="fc" id="L1145">		return dblDPE;</span>
	}

	/**
	 * Calculate the Response Value at the given Predictor Ordinate
	 * 
	 * @param dblPredictorOrdinate Predictor Ordinate
	 * 
	 * @return The Response Value
	 * 
	 * @throws java.lang.Exception Thrown if the calculation did not succeed
	 */

	public double responseValue (
		final double dblPredictorOrdinate)
		throws java.lang.Exception
	{
<span class="fc" id="L1162">		return _be.responseValue (_adblResponseBasisCoeff, dblPredictorOrdinate);</span>
	}

	/**
	 * Calculate the Ordered Response Value Derivative at the Predictor Ordinate
	 * 
	 * @param dblPredictorOrdinate Predictor Ordinate at which the ordered Response Derivative is to be
	 * 	calculated
	 * @param iOrder Derivative Order
	 * 
	 * @throws java.lang.Exception Thrown if the Ordered Response Value Derivative cannot be calculated
	 * 
	 * @return Retrieve the Ordered Response Value Derivative
	 */

	public double calcResponseValueDerivative (
		final double dblPredictorOrdinate,
		final int iOrder)
		throws java.lang.Exception
	{
<span class="fc bfc" id="L1182" title="All 2 branches covered.">		return 0 == iOrder ? responseValue (dblPredictorOrdinate) : _be.responseValueDerivative</span>
<span class="fc" id="L1183">			(_adblResponseBasisCoeff, dblPredictorOrdinate, iOrder);</span>
	}

	/**
	 * Calculate the Ordered Derivative of the Response to the Manifest
	 * 
	 * @param strManifestMeasure Manifest Measure whose Sensitivity is sought
	 * @param dblPredictorOrdinate Predictor Ordinate at which the ordered Derivative of the Response to the
	 * 	Manifest is to be calculated
	 * @param iOrder Derivative Order
	 * 
	 * @throws java.lang.Exception Thrown if the Ordered Derivative of the Response to the Manifest cannot be
	 *  calculated
	 * 
	 * @return Retrieve the Ordered Derivative of the Response to the Manifest
	 */

	public double calcDResponseDManifest (
		final java.lang.String strManifestMeasure,
		final double dblPredictorOrdinate,
		final int iOrder)
		throws java.lang.Exception
	{
<span class="pc bpc" id="L1206" title="1 of 2 branches missed.">		if (0 == iOrder)</span>
<span class="nc" id="L1207">			throw new java.lang.Exception</span>
				(&quot;LatentStateResponseModel::calcDResponseDManifest =&gt; Invalid Inputs&quot;);

<span class="fc" id="L1210">		org.drip.spline.segment.LatentStateManifestSensitivity lsms = manifestSensitivity</span>
<span class="fc" id="L1211">			(strManifestMeasure);</span>

<span class="pc bpc" id="L1213" title="1 of 2 branches missed.">		if (null == lsms)</span>
<span class="nc" id="L1214">			throw new java.lang.Exception</span>
				(&quot;LatentStateResponseModel::calcDResponseDManifest =&gt; Invalid Inputs&quot;);

<span class="fc" id="L1217">		return _be.responseValue (lsms.getDBasisCoeffDLocalManifest(), dblPredictorOrdinate);</span>
	}

	/**
	 * Calculate the Ordered Derivative of the Response to the Preceeding Manifest
	 * 
	 * @param strManifestMeasure Manifest Measure whose Sensitivity is sought
	 * @param dblPredictorOrdinate Predictor Ordinate at which the ordered Derivative of the Response to the
	 * 	Manifest is to be calculated
	 * @param iOrder Derivative Order
	 * 
	 * @throws java.lang.Exception Thrown if the Ordered Derivative of the Response to the Manifest cannot be
	 *  calculated
	 * 
	 * @return Retrieve the Ordered Derivative of the Response to the Preceeding Manifest
	 */

	public double calcDResponseDPreceedingManifest (
		final java.lang.String strManifestMeasure,
		final double dblPredictorOrdinate,
		final int iOrder)
		throws java.lang.Exception
	{
<span class="pc bpc" id="L1240" title="1 of 2 branches missed.">		if (0 == iOrder)</span>
<span class="nc" id="L1241">			throw new java.lang.Exception</span>
				(&quot;LatentStateResponseModel::calcDResponseDPreceedingManifest =&gt; Invalid Inputs&quot;);

<span class="fc" id="L1244">		org.drip.spline.segment.LatentStateManifestSensitivity lsms = manifestSensitivity</span>
<span class="fc" id="L1245">			(strManifestMeasure);</span>

<span class="pc bpc" id="L1247" title="1 of 2 branches missed.">		if (null == lsms)</span>
<span class="nc" id="L1248">			throw new java.lang.Exception</span>
				(&quot;LatentStateResponseModel::calcDResponseDPreceedingManifest =&gt; Cannot locate state Manifest sensitivity&quot;);

<span class="fc" id="L1251">		org.drip.spline.params.PreceedingManifestSensitivityControl pqsc = lsms.getPMSC();</span>

<span class="fc" id="L1253">		double dblDResponseDPreceedingManifest = lsms.getDResponseDPreceedingManifest();</span>

<span class="pc bpc" id="L1255" title="1 of 2 branches missed.">		if (!pqsc.impactFade())</span>
<span class="nc bnc" id="L1256" title="All 2 branches missed.">			return org.drip.quant.common.NumberUtil.IsValid (dblDResponseDPreceedingManifest) ?</span>
				dblDResponseDPreceedingManifest : 0.;

<span class="fc" id="L1259">		org.drip.spline.segment.BasisEvaluator be = pqsc.basisEvaluator();</span>

<span class="fc" id="L1261">		double[] adblDBasisCoeffDPreceedingManifest = lsms.getDBasisCoeffDPreceedingManifest();</span>

<span class="pc bpc" id="L1263" title="2 of 4 branches missed.">		return null == adblDBasisCoeffDPreceedingManifest ? 0. : (null == be ? _be : be).responseValue</span>
<span class="fc" id="L1264">			(adblDBasisCoeffDPreceedingManifest, dblPredictorOrdinate);</span>
	}

	/**
	 * Retrieve the Manifest Measure Preceeding Manifest Impact Flag
	 * 
	 * @param strManifestMeasure Manifest Measure whose Sensitivity is sought
	 * 
	 * @return The Manifest Measure Preceeding Manifest Impact Flag
	 * 
	 * @throws java.lang.Exception Thrown if the Inputs are Invalid
	 */

	public boolean impactFade (
		final java.lang.String strManifestMeasure)
		throws java.lang.Exception
	{
<span class="fc" id="L1281">		org.drip.spline.segment.LatentStateManifestSensitivity lsms = manifestSensitivity</span>
<span class="fc" id="L1282">			(strManifestMeasure);</span>

<span class="fc bfc" id="L1284" title="All 2 branches covered.">		if (null == lsms)</span>
<span class="fc" id="L1285">			throw new java.lang.Exception</span>
				(&quot;LatentStateResponseModel::impactFade =&gt; Cannot locate state Manifest sensitivity&quot;);

<span class="fc" id="L1288">		return lsms.getPMSC().impactFade();</span>
	}

	/**
	 * Calculate the Jacobian of the Segment's Response Basis Function Coefficients to the Edge Inputs
	 * 
	 * @return The Jacobian of the Segment's Response Basis Function Coefficients to the Edge Inputs
	 */

	public org.drip.quant.calculus.WengertJacobian jackDCoeffDEdgeInputs()
	{
<span class="fc bfc" id="L1299" title="All 2 branches covered.">		if (null != _wjDBasisCoeffDEdgeValue) return _wjDBasisCoeffDEdgeValue;</span>

<span class="fc" id="L1301">		int iNumResponseBasisCoeff = _be.numBasis();</span>

		try {
<span class="fc" id="L1304">			_wjDBasisCoeffDEdgeValue = new org.drip.quant.calculus.WengertJacobian (iNumResponseBasisCoeff,</span>
				iNumResponseBasisCoeff);
<span class="nc" id="L1306">		} catch (java.lang.Exception e) {</span>
<span class="nc" id="L1307">			e.printStackTrace();</span>

<span class="nc" id="L1309">			return _wjDBasisCoeffDEdgeValue = null;</span>
<span class="fc" id="L1310">		}</span>

<span class="fc bfc" id="L1312" title="All 2 branches covered.">		for (int i = 0; i &lt; iNumResponseBasisCoeff; ++i) {</span>
<span class="pc bpc" id="L1313" title="1 of 2 branches missed.">			if (!_wjDBasisCoeffDEdgeValue.setWengert (i, _adblResponseBasisCoeff[i]))</span>
<span class="nc" id="L1314">				return _wjDBasisCoeffDEdgeValue = null;</span>
		}

<span class="fc bfc" id="L1317" title="All 2 branches covered.">		if (null == _aadblDResponseBasisCoeffDConstraint) return null;</span>

<span class="fc" id="L1319">		int iSize = _aadblDResponseBasisCoeffDConstraint.length;</span>

<span class="fc bfc" id="L1321" title="All 2 branches covered.">		for (int i = 0; i &lt; iSize; ++i) {</span>
<span class="fc bfc" id="L1322" title="All 2 branches covered.">			for (int j = 0; j &lt; iSize; ++j) {</span>
<span class="pc bpc" id="L1323" title="1 of 2 branches missed.">				if (!_wjDBasisCoeffDEdgeValue.accumulatePartialFirstDerivative (i, j,</span>
					_aadblDResponseBasisCoeffDConstraint[i][j]))
<span class="nc" id="L1325">					return null;</span>
			}
		}

<span class="fc" id="L1329">		return _wjDBasisCoeffDEdgeValue;</span>
	}

	/**
	 * Calculate the Jacobian of the Response to the Edge Inputs at the given Predictor Ordinate
	 * 
	 * @param dblPredictorOrdinate The Predictor Ordinate
	 * @param iOrder Order of the Derivative Desired
	 * 
	 * @return The Jacobian of the Response to the Edge Inputs at the given Predictor Ordinate
	 */

	public org.drip.quant.calculus.WengertJacobian jackDResponseDEdgeInput (
		final double dblPredictorOrdinate,
		final int iOrder)
	{
		try {
<span class="fc" id="L1346">			int iNumResponseBasisCoeff = _be.numBasis();</span>

<span class="fc" id="L1348">			org.drip.quant.calculus.WengertJacobian wjDResponseDEdgeParams = null;</span>
<span class="fc" id="L1349">			double[][] aadblDBasisCoeffDEdgeParams = new</span>
				double[iNumResponseBasisCoeff][iNumResponseBasisCoeff];

<span class="fc" id="L1352">			double[] adblDResponseDBasisCoeff = DResponseDBasisCoeff (dblPredictorOrdinate, iOrder);</span>

<span class="pc bpc" id="L1354" title="2 of 4 branches missed.">			if (null == adblDResponseDBasisCoeff || iNumResponseBasisCoeff !=</span>
				adblDResponseDBasisCoeff.length)
<span class="nc" id="L1356">				return null;</span>

<span class="fc bfc" id="L1358" title="All 2 branches covered.">			org.drip.quant.calculus.WengertJacobian wjDBasisCoeffDEdgeParams = (null ==</span>
<span class="fc" id="L1359">				_wjDBasisCoeffDEdgeValue) ? jackDCoeffDEdgeInputs() : _wjDBasisCoeffDEdgeValue;</span>

<span class="fc bfc" id="L1361" title="All 2 branches covered.">			for (int i = 0; i &lt; iNumResponseBasisCoeff; ++i) {</span>
<span class="fc bfc" id="L1362" title="All 2 branches covered.">				for (int j = 0; j &lt; iNumResponseBasisCoeff; ++j)</span>
<span class="fc" id="L1363">					aadblDBasisCoeffDEdgeParams[j][i] = wjDBasisCoeffDEdgeParams.firstDerivative (j, i);</span>
			}

<span class="fc" id="L1366">			if (!(wjDResponseDEdgeParams = new org.drip.quant.calculus.WengertJacobian (1,</span>
<span class="pc bpc" id="L1367" title="1 of 2 branches missed.">				iNumResponseBasisCoeff)).setWengert (0, responseValue (dblPredictorOrdinate)))</span>
<span class="nc" id="L1368">				return null;</span>

<span class="fc bfc" id="L1370" title="All 2 branches covered.">			for (int i = 0; i &lt; iNumResponseBasisCoeff; ++i) {</span>
<span class="fc bfc" id="L1371" title="All 2 branches covered.">				for (int j = 0; j &lt; iNumResponseBasisCoeff; ++j) {</span>
<span class="pc bpc" id="L1372" title="1 of 2 branches missed.">					if (!wjDResponseDEdgeParams.accumulatePartialFirstDerivative (0, i,</span>
						adblDResponseDBasisCoeff[j] * aadblDBasisCoeffDEdgeParams[j][i]))
<span class="nc" id="L1374">						return null;</span>
				}
			}

<span class="fc" id="L1378">			return wjDResponseDEdgeParams;</span>
<span class="nc" id="L1379">		} catch (java.lang.Exception e) {</span>
<span class="nc" id="L1380">			e.printStackTrace();</span>
		}

<span class="nc" id="L1383">		return null;</span>
	}

	/**
	 * Calculate the Jacobian of the Response to the Basis Coefficients at the given Predictor Ordinate
	 * 
	 * @param dblPredictorOrdinate The Predictor Ordinate
	 * @param iOrder Order of the Derivative Desired
	 * 
	 * @return The Jacobian of the Response to the Basis Coefficients at the given Predictor Ordinate
	 */

	public org.drip.quant.calculus.WengertJacobian jackDResponseDBasisCoeff (
		final double dblPredictorOrdinate,
		final int iOrder)
	{
		try {
<span class="nc" id="L1400">			int iNumResponseBasisCoeff = _be.numBasis();</span>

<span class="nc" id="L1402">			double[] adblBasisDResponseDBasisCoeff = DResponseDBasisCoeff (dblPredictorOrdinate, iOrder);</span>

<span class="nc bnc" id="L1404" title="All 4 branches missed.">			if (null == adblBasisDResponseDBasisCoeff || iNumResponseBasisCoeff !=</span>
				adblBasisDResponseDBasisCoeff.length)
<span class="nc" id="L1406">				return null;</span>

<span class="nc" id="L1408">			org.drip.quant.calculus.WengertJacobian wjDResponseDBasisCoeff = new</span>
				org.drip.quant.calculus.WengertJacobian (1, iNumResponseBasisCoeff);

<span class="nc bnc" id="L1411" title="All 2 branches missed.">			for (int i = 0; i &lt; iNumResponseBasisCoeff; ++i) {</span>
<span class="nc bnc" id="L1412" title="All 2 branches missed.">				if (!wjDResponseDBasisCoeff.accumulatePartialFirstDerivative (0, i,</span>
					adblBasisDResponseDBasisCoeff[i]))
<span class="nc" id="L1414">					return null;</span>
			}

<span class="nc" id="L1417">			return wjDResponseDBasisCoeff;</span>
<span class="nc" id="L1418">		} catch (java.lang.Exception e) {</span>
<span class="nc" id="L1419">			e.printStackTrace();</span>
		}

<span class="nc" id="L1422">		return null;</span>
	}

	/**
	 * Calibrate the segment and calculate the Jacobian of the Segment's Response Basis Function Coefficients
	 *  to the Edge Parameters
	 * 
	 * @param adblPredictorOrdinate Array of Predictor Ordinates
	 * @param adblResponseValue Array of Response Values
	 * @param adblLeftEdgeDeriv Array of Left Edge Derivatives
	 * @param adblRightEdgeDeriv Array of Right Edge Derivatives
	 * @param aSBFC Array of Segment Flexure Constraints, expressed as Basis Coefficients
	 * @param sbfr Segment Best Fit Response Instance
	 * 
	 * @return The Jacobian of the Segment's Response Basis Function Coefficients to the Edge Parameters
	 */

	public org.drip.quant.calculus.WengertJacobian jackDCoeffDEdgeParams (
		final double[] adblPredictorOrdinate,
		final double[] adblResponseValue,
		final double[] adblLeftEdgeDeriv,
		final double[] adblRightEdgeDeriv,
		final org.drip.spline.params.SegmentBasisFlexureConstraint[] aSBFC,
		final org.drip.spline.params.SegmentBestFitResponse sbfr)
	{
		try {
<span class="pc bpc" id="L1448" title="1 of 2 branches missed.">			return calibrateState (new org.drip.spline.params.SegmentStateCalibrationInputs</span>
				(adblPredictorOrdinate, adblResponseValue, adblLeftEdgeDeriv, adblRightEdgeDeriv, aSBFC,
<span class="pc" id="L1450">					sbfr)) ? jackDCoeffDEdgeInputs() : null;</span>
<span class="nc" id="L1451">		} catch (java.lang.Exception e) {</span>
<span class="nc" id="L1452">			e.printStackTrace();</span>
		}

<span class="nc" id="L1455">		return null;</span>
	}

	/**
	 * Calibrate the Coefficients from the Edge Response Values and the Left Edge Response Value Slope and
	 *  calculate the Jacobian of the Segment's Response Basis Function Coefficients to the Edge Parameters
	 * 
	 * @param dblLeftValue Left Edge Response Value
	 * @param dblLeftSlope Left Edge Response Slope
	 * @param dblRightValue Right Edge Response Value
	 * @param sbfrState Segment's Best Fit Weighted Response Values
	 * 
	 * @return The Jacobian of the Segment's Response Basis Function Coefficients to the Edge Parameters
	 */

	public org.drip.quant.calculus.WengertJacobian jackDCoeffDEdgeParams (
		final double dblLeftValue,
		final double dblLeftSlope,
		final double dblRightValue,
		final org.drip.spline.params.SegmentBestFitResponse sbfrState)
	{
<span class="pc bpc" id="L1476" title="1 of 2 branches missed.">		return calibrate (dblLeftValue, dblLeftSlope, dblRightValue, sbfrState) ? jackDCoeffDEdgeInputs() :</span>
			null;
	}

	/**
	 * Calibrate the coefficients from the prior Segment and the Response Value at the Right Predictor
	 *  Ordinate and calculate the Jacobian of the Segment's Response Basis Function Coefficients to the Edge
	 *  Parameters
	 * 
	 * @param csPreceeding Previous Predictor/Response Segment
	 * @param strManifestMeasure Manifest Measure whose Sensitivity is sought
	 * @param dblRightStateValue Response Value at the Right Predictor Ordinate
	 * @param sbfrState Segment's Best Fit Weighted Response Values
	 * @param dblRightStateManifestSensitivity Response Value Manifest Sensitivity at the Right Predictor
	 * 	Ordinate
	 * @param sbfrManifestSensitivity Segment's Best Fit Weighted Response Value Manifest Sensitivity
	 * 
	 * @return The Jacobian
	 */

	public org.drip.quant.calculus.WengertJacobian jackDCoeffDEdgeParams (
		final LatentStateResponseModel csPreceeding,
		final java.lang.String strManifestMeasure,
		final double dblRightStateValue,
		final org.drip.spline.params.SegmentBestFitResponse sbfrState,
		final double dblRightStateManifestSensitivity,
		final org.drip.spline.params.SegmentBestFitResponse sbfrManifestSensitivity)
	{
<span class="pc bpc" id="L1504" title="1 of 2 branches missed.">		return !calibrate (csPreceeding, dblRightStateValue, sbfrState) || !manifestMeasureSensitivity</span>
<span class="pc bpc" id="L1505" title="1 of 2 branches missed.">			(csPreceeding, strManifestMeasure, dblRightStateManifestSensitivity, sbfrManifestSensitivity) ?</span>
<span class="fc" id="L1506">				null : jackDCoeffDEdgeInputs();</span>
	}

	/**
	 * Indicate whether the given segment is monotone. If monotone, may optionally indicate the nature of
	 * 	the extrema contained inside (maxima/minima/infection).
	 *  
	 * @return The monotone Type
	 */

	public org.drip.spline.segment.Monotonocity monotoneType()
	{
<span class="fc bfc" id="L1518" title="All 2 branches covered.">		if (1 &gt;= _sidc.Ck()) {</span>
			try {
<span class="fc" id="L1520">				return new org.drip.spline.segment.Monotonocity</span>
					(org.drip.spline.segment.Monotonocity.MONOTONIC);
<span class="nc" id="L1522">			} catch (java.lang.Exception e) {</span>
<span class="nc" id="L1523">				e.printStackTrace();</span>

<span class="nc" id="L1525">				return null;</span>
			}
		}

<span class="fc" id="L1529">		org.drip.function.definition.R1ToR1 ofDeriv = new</span>
<span class="fc" id="L1530">			org.drip.function.definition.R1ToR1 (null) {</span>
			@Override public double evaluate (
				final double dblX)
				throws java.lang.Exception
			{
<span class="fc" id="L1535">				return _be.responseValueDerivative (_adblResponseBasisCoeff, dblX, 1);</span>
			}

			@Override public org.drip.quant.calculus.Differential differential (
				final double dblX,
				final double dblOFBase,
				final int iOrder)
			{
				try {
<span class="nc" id="L1544">					double dblVariateInfinitesimal = _dc.getVariateInfinitesimal (dblX);</span>

<span class="nc" id="L1546">					return new org.drip.quant.calculus.Differential (dblVariateInfinitesimal,</span>
<span class="nc" id="L1547">						_be.responseValueDerivative (_adblResponseBasisCoeff, dblX, iOrder) *</span>
							dblVariateInfinitesimal);
<span class="nc" id="L1549">				} catch (java.lang.Exception e) {</span>
<span class="nc" id="L1550">					e.printStackTrace();</span>
				}

<span class="nc" id="L1553">				return null;</span>
			}

			@Override public double integrate (
				final double dblBegin,
				final double dblEnd)
				throws java.lang.Exception
			{
<span class="nc" id="L1561">				return org.drip.quant.calculus.R1ToR1Integrator.Boole (this, dblBegin, dblEnd);</span>
			}
		};

		try {
<span class="fc" id="L1566">			org.drip.function.r1tor1solver.FixedPointFinderOutput fpop = new</span>
				org.drip.function.r1tor1solver.FixedPointFinderBrent (0., ofDeriv, false).findRoot
<span class="fc" id="L1568">					(org.drip.function.r1tor1solver.InitializationHeuristics.FromHardSearchEdges (0., 1.));</span>

<span class="pc bpc" id="L1570" title="1 of 4 branches missed.">			if (null == fpop || !fpop.containsRoot())</span>
<span class="fc" id="L1571">				return new org.drip.spline.segment.Monotonocity</span>
					(org.drip.spline.segment.Monotonocity.MONOTONIC);

<span class="fc" id="L1574">			double dblExtremum = fpop.getRoot();</span>

<span class="pc bpc" id="L1576" title="3 of 6 branches missed.">			if (!org.drip.quant.common.NumberUtil.IsValid (dblExtremum) || dblExtremum &lt;= 0. || dblExtremum</span>
				&gt;= 1.)
<span class="nc" id="L1578">				return new org.drip.spline.segment.Monotonocity</span>
					(org.drip.spline.segment.Monotonocity.MONOTONIC);

<span class="fc" id="L1581">			double dbl2ndDeriv = _be.responseValueDerivative (_adblResponseBasisCoeff, dblExtremum, 2);</span>

<span class="pc bpc" id="L1583" title="1 of 2 branches missed.">			if (0. &gt; dbl2ndDeriv)</span>
<span class="nc" id="L1584">				return new org.drip.spline.segment.Monotonocity</span>
					(org.drip.spline.segment.Monotonocity.MAXIMA);

<span class="pc bpc" id="L1587" title="1 of 2 branches missed.">			if (0. &lt; dbl2ndDeriv)</span>
<span class="fc" id="L1588">				return new org.drip.spline.segment.Monotonocity</span>
					(org.drip.spline.segment.Monotonocity.MINIMA);

<span class="nc bnc" id="L1591" title="All 2 branches missed.">			if (0. == dbl2ndDeriv)</span>
<span class="nc" id="L1592">				return new org.drip.spline.segment.Monotonocity</span>
					(org.drip.spline.segment.Monotonocity.INFLECTION);

<span class="nc" id="L1595">			return new org.drip.spline.segment.Monotonocity</span>
				(org.drip.spline.segment.Monotonocity.NON_MONOTONIC);
<span class="nc" id="L1597">		} catch (java.lang.Exception e) {</span>
<span class="nc" id="L1598">			e.printStackTrace();</span>
		}

		try {
<span class="nc" id="L1602">			return new org.drip.spline.segment.Monotonocity (org.drip.spline.segment.Monotonocity.MONOTONIC);</span>
<span class="nc" id="L1603">		} catch (java.lang.Exception e) {</span>
<span class="nc" id="L1604">			e.printStackTrace();</span>
		}

<span class="nc" id="L1607">		return null;</span>
	}

	/**
	 * Clip the part of the Segment to the Right of the specified Predictor Ordinate. Retain all other
	 * 	constraints the same.
	 * 
	 * @param dblPredictorOrdinate The Predictor Ordinate
	 * 
	 * @return The Clipped Segment
	 */

	public LatentStateResponseModel clipLeftOfPredictorOrdinate (
		final double dblPredictorOrdinate)
	{
		try {
<span class="fc" id="L1623">			LatentStateResponseModel csLeftSnipped = LatentStateResponseModel.Create (dblPredictorOrdinate,</span>
<span class="fc" id="L1624">				right(), _be.replicate(), _sidc);</span>

<span class="fc" id="L1626">			int iCk = _sidc.Ck();</span>

<span class="pc bpc" id="L1628" title="1 of 2 branches missed.">			double[] adblCalibLeftEdgeDeriv = 0 != iCk ? csLeftSnipped.transmissionCk (dblPredictorOrdinate,</span>
				this, iCk) : null;

<span class="pc bpc" id="L1631" title="1 of 2 branches missed.">			return csLeftSnipped.calibrateState (new org.drip.spline.params.SegmentStateCalibrationInputs</span>
<span class="fc" id="L1632">				(new double[] {dblPredictorOrdinate, right()}, new double[] {responseValue</span>
<span class="fc" id="L1633">					(dblPredictorOrdinate), responseValue (right())}, adblCalibLeftEdgeDeriv, null, null,</span>
						null)) ? csLeftSnipped : null;
<span class="nc" id="L1635">		} catch (java.lang.Exception e) {</span>
<span class="nc" id="L1636">			e.printStackTrace();</span>
		}

<span class="nc" id="L1639">		return null;</span>
	}

	/**
	 * Clip the part of the Segment to the Right of the specified Predictor Ordinate. Retain all other
	 * 	constraints the same.
	 * 
	 * @param dblPredictorOrdinate The Predictor Ordinate
	 * 
	 * @return The Clipped Segment
	 */

	public LatentStateResponseModel clipRightOfPredictorOrdinate (
		final double dblPredictorOrdinate)
	{
		try {
<span class="fc" id="L1655">			LatentStateResponseModel csRightSnipped = LatentStateResponseModel.Create (left(),</span>
<span class="fc" id="L1656">				dblPredictorOrdinate, _be.replicate(), _sidc);</span>

<span class="fc" id="L1658">			int iCk = _sidc.Ck();</span>

<span class="pc bpc" id="L1660" title="1 of 2 branches missed.">			return csRightSnipped.calibrateState (new org.drip.spline.params.SegmentStateCalibrationInputs</span>
<span class="fc" id="L1661">				(new double[] {left(), dblPredictorOrdinate}, new double[] {responseValue (left()),</span>
<span class="pc bpc" id="L1662" title="1 of 2 branches missed.">					responseValue (dblPredictorOrdinate)}, 0 != iCk ? csRightSnipped.transmissionCk (left(),</span>
						this, iCk) : null, null, null, null)) ? csRightSnipped : null;
<span class="nc" id="L1664">		} catch (java.lang.Exception e) {</span>
<span class="nc" id="L1665">			e.printStackTrace();</span>
		}

<span class="nc" id="L1668">		return null;</span>
	}

	/**
	 * Display the string representation for diagnostic purposes
	 * 
	 * @return The string representation
	 */

	public java.lang.String displayString()
	{
<span class="nc" id="L1679">		java.lang.StringBuffer sb = new java.lang.StringBuffer();</span>

<span class="nc" id="L1681">		sb.append (&quot;\t\t\t[&quot; + left() + &quot; =&gt; &quot; + right() + &quot;\n&quot;);</span>

<span class="nc bnc" id="L1683" title="All 2 branches missed.">		for (int i = 0; i &lt; _adblResponseBasisCoeff.length; ++i) {</span>
<span class="nc bnc" id="L1684" title="All 2 branches missed.">			if (0 != i) sb.append (&quot;  |  &quot;);</span>

<span class="nc" id="L1686">			sb.append (_adblResponseBasisCoeff[i] + &quot;\n&quot;);</span>
		}

<span class="nc" id="L1689">		return sb.toString();</span>
	}
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.7.9.201702052155</span></div></body></html>