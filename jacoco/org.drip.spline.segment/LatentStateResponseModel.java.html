<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>LatentStateResponseModel.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">DROP</a> &gt; <a href="index.source.html" class="el_package">org.drip.spline.segment</a> &gt; <span class="el_source">LatentStateResponseModel.java</span></div><h1>LatentStateResponseModel.java</h1><pre class="source lang-java linenums">
package org.drip.spline.segment;

/*
 * -*- mode: java; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*-
 */

/*!
 * Copyright (C) 2019 Lakshmi Krishnamurthy
 * Copyright (C) 2018 Lakshmi Krishnamurthy
 * Copyright (C) 2017 Lakshmi Krishnamurthy
 * Copyright (C) 2016 Lakshmi Krishnamurthy
 * Copyright (C) 2015 Lakshmi Krishnamurthy
 * Copyright (C) 2014 Lakshmi Krishnamurthy
 * Copyright (C) 2013 Lakshmi Krishnamurthy
 * 
 *  This file is part of DROP, an open-source library targeting risk, transaction costs, exposure, margin
 *  	calculations, and portfolio construction within and across fixed income, credit, commodity, equity,
 *  	FX, and structured products.
 *  
 *  	https://lakshmidrip.github.io/DROP/
 *  
 *  DROP is composed of three main modules:
 *  
 *  - DROP Analytics Core - https://lakshmidrip.github.io/DROP-Analytics-Core/
 *  - DROP Portfolio Core - https://lakshmidrip.github.io/DROP-Portfolio-Core/
 *  - DROP Numerical Core - https://lakshmidrip.github.io/DROP-Numerical-Core/
 * 
 * 	DROP Analytics Core implements libraries for the following:
 * 	- Fixed Income Analytics
 * 	- Asset Backed Analytics
 * 	- XVA Analytics
 * 	- Exposure and Margin Analytics
 * 
 * 	DROP Portfolio Core implements libraries for the following:
 * 	- Asset Allocation Analytics
 * 	- Transaction Cost Analytics
 * 
 * 	DROP Numerical Core implements libraries for the following:
 * 	- Statistical Learning Library
 * 	- Numerical Optimizer Library
 * 	- Machine Learning Library
 * 	- Spline Builder Library
 * 
 * 	Documentation for DROP is Spread Over:
 * 
 * 	- Main                     =&gt; https://lakshmidrip.github.io/DROP/
 * 	- Wiki                     =&gt; https://github.com/lakshmiDRIP/DROP/wiki
 * 	- GitHub                   =&gt; https://github.com/lakshmiDRIP/DROP
 * 	- Javadoc                  =&gt; https://lakshmidrip.github.io/DROP/Javadoc/index.html
 * 	- Technical Specifications =&gt; https://github.com/lakshmiDRIP/DROP/tree/master/Docs/Internal
 * 	- Release Versions         =&gt; https://lakshmidrip.github.io/DROP/version.html
 * 	- Community Credits        =&gt; https://lakshmidrip.github.io/DROP/credits.html
 * 	- Issues Catalog           =&gt; https://github.com/lakshmiDRIP/DROP/issues
 * 	- JUnit                    =&gt; https://lakshmidrip.github.io/DROP/junit/index.html
 * 	- Jacoco                   =&gt; https://lakshmidrip.github.io/DROP/jacoco/index.html
 * 
 *  Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 *   	you may not use this file except in compliance with the License.
 *   
 *  You may obtain a copy of the License at
 *  	http://www.apache.org/licenses/LICENSE-2.0
 *  
 *  Unless required by applicable law or agreed to in writing, software
 *  	distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 *  	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  
 *  See the License for the specific language governing permissions and
 *  	limitations under the License.
 */

/**
 * &lt;i&gt;LatentStateResponseModel&lt;/i&gt; implements the single segment basis calibration and inference
 * functionality. It exports the following functionality:
 *
 * &lt;br&gt;&lt;br&gt;
 *  &lt;ul&gt;
 *  	&lt;li&gt;
 * 			Build the LatentStateResponseModel instance from the Basis Function/Shape Controller Set
 *  	&lt;/li&gt;
 *  	&lt;li&gt;
 * 			Build the LatentStateResponseModel instance from the Basis Evaluator Set
 *  	&lt;/li&gt;
 *  	&lt;li&gt;
 * 			Retrieve the Number of Parameters, Basis Evaluator, Array of the Response Basis Coefficients, and
 * 				Segment Design Inelastic Control
 *  	&lt;/li&gt;
 *  	&lt;li&gt;
 * 			Calibrate the Segment State from the Calibration Parameter Set
 *  	&lt;/li&gt;
 *  	&lt;li&gt;
 * 			Sensitivity Calibrator: Calibrate the Segment Manifest Jacobian from the Calibration Parameter
 * 				Set
 *  	&lt;/li&gt;
 *  	&lt;li&gt;
 * 			Calibrate the coefficients from the prior Predictor/Response Segment, the Constraint, and fitness
 * 				Weights
 *  	&lt;/li&gt;
 *  	&lt;li&gt;
 *			Calibrate the coefficients from the prior Segment and the Response Value at the Right Predictor
 *				Ordinate
 *  	&lt;/li&gt;
 *  	&lt;li&gt;
 *			Calibrate the Coefficients from the Edge Response Values and the Left Edge Response Slope
 *  	&lt;/li&gt;
 *  	&lt;li&gt;
 *			Calibrate the coefficients from the Left Edge Response Value Constraint, the Left Edge Response
 *				Value Slope, and the Right Edge Response Value Constraint
 *  	&lt;/li&gt;
 *  	&lt;li&gt;
 *			Retrieve the Segment Curvature, Length, and the Best Fit DPE
 *  	&lt;/li&gt;
 *  	&lt;li&gt;
 *			Calculate the Response Value and its Derivative at the given Predictor Ordinate
 *  	&lt;/li&gt;
 *  	&lt;li&gt;
 *			Calculate the Ordered Derivative of the Coefficient to the Manifest
 *  	&lt;/li&gt;
 *  	&lt;li&gt;
 *			Calculate the Jacobian of the Segment's Response Basis Function Coefficients to the Edge Inputs
 *  	&lt;/li&gt;
 *  	&lt;li&gt;
 *			Calculate the Jacobian of the Response to the Edge Inputs at the given Predictor Ordinate
 *  	&lt;/li&gt;
 *  	&lt;li&gt;
 *			Calculate the Jacobian of the Response to the Basis Coefficients at the given Predictor Ordinate
 *  	&lt;/li&gt;
 *  	&lt;li&gt;
 *			Calibrate the segment and calculate the Jacobian of the Segment's Response Basis Function
 *				Coefficients to the Edge Parameters
 *  	&lt;/li&gt;
 *  	&lt;li&gt;
 *			Calibrate the Coefficients from the Edge Response Values and the Left Edge Response Value Slope
 *				and calculate the Jacobian of the Segment's Response Basis Function Coefficients to the Edge
 *				Parameters
 *  	&lt;/li&gt;
 *  	&lt;li&gt;
 *			Calibrate the coefficients from the prior Segment and the Response Value at the Right Predictor
 *				Ordinate and calculate the Jacobian of the Segment's Response Basis Function Coefficients to
 *				the Edge Parameters
 *  	&lt;/li&gt;
 *  	&lt;li&gt;
 *  		Indicate whether the given segment is monotone. If monotone, may optionally indicate the nature
 *  			of the extrema contained inside (maxima/minima/infection)
 *  	&lt;/li&gt;
 *  	&lt;li&gt;
 *  		Clip the part of the Segment to the Right of the specified Predictor Ordinate. Retain all other
 *  			constraints the same
 *  	&lt;/li&gt;
 *  	&lt;li&gt;
 *  		Clip the part of the Segment to the Left of the specified Predictor Ordinate. Retain all other
 *  			constraints the same
 *  	&lt;/li&gt;
 *  	&lt;li&gt;
 *  		Display the string representation for diagnostic purposes
 *  	&lt;/li&gt;
 *  &lt;/ul&gt;
 *
 * &lt;br&gt;&lt;br&gt;
 *  &lt;ul&gt;
 *		&lt;li&gt;&lt;b&gt;Project&lt;/b&gt;       = &lt;a href = &quot;https://github.com/lakshmiDRIP/DROP/tree/master/src/main/java/org/drip/spline&quot;&gt;Spaces&lt;/a&gt;&lt;/li&gt;
 *		&lt;li&gt;&lt;b&gt;Package&lt;/b&gt;       = &lt;a href = &quot;https://github.com/lakshmiDRIP/DROP/tree/master/src/main/java/org/drip/spline/segment&quot;&gt;Segment&lt;/a&gt;&lt;/li&gt;
 *		&lt;li&gt;&lt;b&gt;Specification&lt;/b&gt; = &lt;a href = &quot;https://github.com/lakshmiDRIP/DROP/tree/master/Docs/Internal/SplineBuilder&quot;&gt;Spline Builder Library&lt;/a&gt;&lt;/li&gt;
 *  &lt;/ul&gt;
 * &lt;br&gt;&lt;br&gt;
 *
 * @author Lakshmi Krishnamurthy
 */

public class LatentStateResponseModel extends org.drip.spline.segment.LatentStateInelastic {

	/**
	 * LEFT NODE VALUE PARAMETER INDEX
	 */

	public static final int LEFT_NODE_VALUE_PARAMETER_INDEX = 0;

	/**
	 * RIGHT NODE VALUE PARAMETER INDEX
	 */

	public static final int RIGHT_NODE_VALUE_PARAMETER_INDEX = 1;

<span class="fc" id="L184">	private double[] _adblResponseBasisCoeff = null;</span>
<span class="fc" id="L185">	private org.drip.spline.segment.BasisEvaluator _be = null;</span>
<span class="fc" id="L186">	private double[][] _aadblDResponseBasisCoeffDConstraint = null;</span>
<span class="fc" id="L187">	private org.drip.spline.params.SegmentInelasticDesignControl _sidc = null;</span>
<span class="fc" id="L188">	private org.drip.quant.calculus.WengertJacobian _wjDBasisCoeffDEdgeValue = null;</span>

<span class="fc" id="L190">	private</span>
		org.drip.analytics.support.CaseInsensitiveHashMap&lt;org.drip.spline.segment.LatentStateManifestSensitivity&gt;
			_mapLSMS = new
				org.drip.analytics.support.CaseInsensitiveHashMap&lt;org.drip.spline.segment.LatentStateManifestSensitivity&gt;();

	/**
	 * Build the LatentStateResponseModel instance from the Basis Function/Shape Controller Set
	 * 
	 * @param dblLeftPredictorOrdinate Left Predictor Ordinate
	 * @param dblRightPredictorOrdinate Right Predictor Ordinate
	 * @param fs Response Basis Function Set
	 * @param rssc Shape Controller
	 * @param sidc Segment Inelastic Design Parameters
	 * 
	 * @return Instance of LatentStateResponseModel
	 */

	public static final org.drip.spline.segment.LatentStateResponseModel Create (
		final double dblLeftPredictorOrdinate,
		final double dblRightPredictorOrdinate,
		final org.drip.spline.basis.FunctionSet fs,
		final org.drip.spline.params.ResponseScalingShapeControl rssc,
		final org.drip.spline.params.SegmentInelasticDesignControl sidc)
	{
		try {
<span class="fc" id="L215">			org.drip.spline.segment.SegmentBasisEvaluator sbe = new</span>
				org.drip.spline.segment.SegmentBasisEvaluator (fs, rssc);

<span class="pc bpc" id="L218" title="1 of 2 branches missed.">			if (!org.drip.quant.common.NumberUtil.IsValid (dblLeftPredictorOrdinate) ||</span>
<span class="pc bpc" id="L219" title="2 of 4 branches missed.">				!org.drip.quant.common.NumberUtil.IsValid (dblRightPredictorOrdinate) ||</span>
				dblLeftPredictorOrdinate == dblRightPredictorOrdinate)
			{
<span class="nc" id="L222">				return null;</span>
			}

<span class="fc" id="L225">			org.drip.spline.segment.LatentStateResponseModel lsrm = new</span>
				org.drip.spline.segment.LatentStateResponseModel (dblLeftPredictorOrdinate,
					dblRightPredictorOrdinate, sbe, sidc);

<span class="pc bpc" id="L229" title="1 of 2 branches missed.">			return sbe.setContainingInelastics (lsrm) ? lsrm : null;</span>
<span class="nc" id="L230">		} catch (java.lang.Exception e) {</span>
<span class="nc" id="L231">			e.printStackTrace();</span>
		}

<span class="nc" id="L234">		return null;</span>
	}

	/**
	 * Build the LatentStateResponseModel instance from the Basis Evaluator Set
	 * 
	 * @param dblLeftPredictorOrdinate Left Predictor Ordinate
	 * @param dblRightPredictorOrdinate Right Predictor Ordinate
	 * @param be Basis Evaluator
	 * @param sidc Segment Inelastic Design Parameters
	 * 
	 * @return Instance of LatentStateResponseModel
	 */

	public static final org.drip.spline.segment.LatentStateResponseModel Create (
		final double dblLeftPredictorOrdinate,
		final double dblRightPredictorOrdinate,
		final org.drip.spline.segment.BasisEvaluator be,
		final org.drip.spline.params.SegmentInelasticDesignControl sidc)
	{
		try {
<span class="fc" id="L255">			org.drip.spline.segment.LatentStateResponseModel lsrm = new</span>
				org.drip.spline.segment.LatentStateResponseModel (dblLeftPredictorOrdinate,
					dblRightPredictorOrdinate, be, sidc);

<span class="pc bpc" id="L259" title="1 of 2 branches missed.">			return be.setContainingInelastics (lsrm) ? lsrm : null;</span>
<span class="nc" id="L260">		} catch (java.lang.Exception e) {</span>
<span class="nc" id="L261">			e.printStackTrace();</span>
		}

<span class="nc" id="L264">		return null;</span>
	}

	private LatentStateResponseModel (
		final double dblLeftPredictorOrdinate,
		final double dblRightPredictorOrdinate,
		final org.drip.spline.segment.BasisEvaluator be,
		final org.drip.spline.params.SegmentInelasticDesignControl sidc)
		throws java.lang.Exception
	{
<span class="fc" id="L274">		super (dblLeftPredictorOrdinate, dblRightPredictorOrdinate);</span>

<span class="pc bpc" id="L276" title="2 of 4 branches missed.">		if (null == (_be = be) || null == (_sidc = sidc))</span>
<span class="nc" id="L277">			throw new java.lang.Exception (&quot;LatentStateResponseModel ctr: Invalid Basis Functions!&quot;);</span>

<span class="fc" id="L279">		int iNumBasis = _be.numBasis();</span>

<span class="fc" id="L281">		_adblResponseBasisCoeff = new double[iNumBasis];</span>

<span class="pc bpc" id="L283" title="2 of 4 branches missed.">		if (0 &gt;= iNumBasis || _sidc.Ck() &gt; iNumBasis - 2)</span>
<span class="nc" id="L284">			throw new java.lang.Exception (&quot;LatentStateResponseModel ctr: Invalid inputs!&quot;);</span>
<span class="fc" id="L285">	}</span>

	private double[] DResponseDBasisCoeff (
		final double dblPredictorOrdinate,
		final int iOrder)
	{
<span class="pc bpc" id="L291" title="1 of 2 branches missed.">		if (0 == iOrder) return null;</span>

<span class="fc" id="L293">		int iNumBasis = _be.numBasis();</span>

<span class="fc" id="L295">		double[] adblDResponseDBasisCoeff = new double[iNumBasis];</span>

<span class="fc bfc" id="L297" title="All 2 branches covered.">		for (int i = 0; i &lt; iNumBasis; ++i) {</span>
			try {
<span class="pc bpc" id="L299" title="1 of 2 branches missed.">				adblDResponseDBasisCoeff[i] = 1 == iOrder ? _be.shapedBasisFunctionResponse</span>
<span class="pc" id="L300">					(dblPredictorOrdinate, i) : 0.;</span>
<span class="nc" id="L301">			} catch (java.lang.Exception e) {</span>
<span class="nc" id="L302">				e.printStackTrace();</span>

<span class="nc" id="L304">				return null;</span>
<span class="fc" id="L305">			}</span>
		}

<span class="fc" id="L308">		return adblDResponseDBasisCoeff;</span>
	}

	private double[] transmissionCk (
		final double dblPredictorOrdinate,
		final org.drip.spline.segment.LatentStateResponseModel csPreceeding,
		final int iCk)
	{
<span class="fc" id="L316">		double[] adblDeriv = new double[iCk];</span>

<span class="fc bfc" id="L318" title="All 2 branches covered.">		for (int i = 0; i &lt; iCk; ++i) {</span>
			try {
<span class="fc" id="L320">				adblDeriv[i] = csPreceeding.calcResponseValueDerivative (dblPredictorOrdinate, i + 1);</span>
<span class="nc" id="L321">			} catch (java.lang.Exception e) {</span>
<span class="nc" id="L322">				e.printStackTrace();</span>

<span class="nc" id="L324">				return null;</span>
<span class="fc" id="L325">			}</span>
		}

<span class="fc" id="L328">		return adblDeriv;</span>
	}

	private org.drip.spline.segment.LatentStateManifestSensitivity manifestSensitivity (
		final java.lang.String strManifestMeasure)
	{
<span class="pc bpc" id="L334" title="2 of 4 branches missed.">		return null == strManifestMeasure || strManifestMeasure.isEmpty() || !_mapLSMS.containsKey</span>
<span class="fc bfc" id="L335" title="All 2 branches covered.">			(strManifestMeasure) ? null : _mapLSMS.get (strManifestMeasure);</span>
	}

	private double[] CkDBasisCoeffDPreceedingManifestMeasure (
		final java.lang.String strManifestMeasure)
	{
<span class="fc" id="L341">		org.drip.spline.segment.LatentStateManifestSensitivity lsms = manifestSensitivity</span>
<span class="fc" id="L342">			(strManifestMeasure);</span>

<span class="pc bpc" id="L344" title="1 of 2 branches missed.">		if (null == lsms) return null;</span>

<span class="fc" id="L346">		int iCk = lsms.getPMSC().Ck();</span>

<span class="pc bpc" id="L348" title="1 of 2 branches missed.">		if (0 == iCk) return null;</span>

<span class="nc" id="L350">		double[] adblDBasisCoeffDPreceedingManifestTail = new double[iCk];</span>

<span class="nc bnc" id="L352" title="All 2 branches missed.">		for (int i = 0; i &lt; iCk; ++i)</span>
<span class="nc" id="L353">			adblDBasisCoeffDPreceedingManifestTail[i] = 0.;</span>

<span class="nc" id="L355">		return adblDBasisCoeffDPreceedingManifestTail;</span>
	}

	/**
	 * Set the Preceeding Manifest Sensitivity Control Parameters for the specified Manifest Measure
	 * 
	 * @param strManifestMeasure The Manifest Measure
	 * @param pmsc The Preceeding Manifest Sensitivity Control Instance
	 * 
	 * @return TRUE - Named Preceeding Manifest Sensitivity Control Instance Successfully Set
	 */

	public boolean setPreceedingManifestSensitivityControl (
		final java.lang.String strManifestMeasure,
		final org.drip.spline.params.PreceedingManifestSensitivityControl pmsc)
	{
<span class="pc bpc" id="L371" title="2 of 4 branches missed.">		if (null == strManifestMeasure || strManifestMeasure.isEmpty()) return false;</span>

		try {
<span class="fc" id="L374">			_mapLSMS.put (strManifestMeasure, new org.drip.spline.segment.LatentStateManifestSensitivity</span>
				(pmsc));

<span class="fc" id="L377">			return true;</span>
<span class="nc" id="L378">		} catch (java.lang.Exception e) {</span>
<span class="nc" id="L379">			e.printStackTrace();</span>
		}

<span class="nc" id="L382">		return false;</span>
	}

	/**
	 * Retrieve the Number of Parameters
	 * 
	 * @return The Number of Parameters
	 */

	public int numParameters()
	{
<span class="fc" id="L393">		return _sidc.Ck() + 2;</span>
	}

	/**
	 * Retrieve the Basis Evaluator
	 * 
	 * @return The Basis Evaluator
	 */

	public org.drip.spline.segment.BasisEvaluator basisEvaluator()
	{
<span class="fc" id="L404">		return _be;</span>
	}

	/**
	 * Retrieve the Array of Response Basis Coefficients
	 * 
	 * @return The Array of Response Basis Coefficients
	 */

	public double[] responseBasisCoefficient()
	{
<span class="nc" id="L415">		return _adblResponseBasisCoeff;</span>
	}

	/**
	 * Retrieve the Segment Inelastic Design Control
	 * 
	 * @return The Segment Inelastic Design Control
	 */

	public org.drip.spline.params.SegmentInelasticDesignControl designControl()
	{
<span class="nc" id="L426">		return _sidc;</span>
	}

	/**
	 * Main Calibrator: Calibrate the Segment State from the Calibration Parameter Set
	 * 
	 * @param ssciState The Segment State Calibration Inputs Set
	 * 
	 * @return TRUE - Calibration Successful
	 */

	public boolean calibrateState (
		final org.drip.spline.params.SegmentStateCalibrationInputs ssciState)
	{
<span class="pc bpc" id="L440" title="1 of 2 branches missed.">		if (null == ssciState) return false;</span>

<span class="fc" id="L442">		double[] adblPredictorOrdinate = ssciState.predictorOrdinates();</span>

<span class="fc" id="L444">		double[] adblResponseValue = ssciState.responseValues();</span>

<span class="fc" id="L446">		double[] adblLeftEdgeDeriv = ssciState.leftEdgeDeriv();</span>

<span class="fc" id="L448">		double[] adblRightEdgeDeriv = ssciState.rightEdgeDeriv();</span>

<span class="fc" id="L450">		org.drip.spline.params.SegmentBestFitResponse sbfr = ssciState.bestFitResponse();</span>

<span class="fc" id="L452">		org.drip.spline.params.SegmentBasisFlexureConstraint[] aSBFC = ssciState.flexureConstraint();</span>

<span class="fc" id="L454">		int iNumConstraint = 0;</span>
<span class="fc" id="L455">		int iNumResponseBasisCoeff = _adblResponseBasisCoeff.length;</span>
<span class="fc bfc" id="L456" title="All 2 branches covered.">		int iNumLeftDeriv = null == adblLeftEdgeDeriv ? 0 : adblLeftEdgeDeriv.length;</span>
<span class="fc bfc" id="L457" title="All 2 branches covered.">		int iNumRightDeriv = null == adblRightEdgeDeriv ? 0 : adblRightEdgeDeriv.length;</span>
<span class="fc" id="L458">		double[] adblPredictorResponseConstraintValue = new double[iNumResponseBasisCoeff];</span>
<span class="fc bfc" id="L459" title="All 2 branches covered.">		int iNumPredictorOrdinate = null == adblPredictorOrdinate ? 0 : adblPredictorOrdinate.length;</span>
<span class="fc" id="L460">		double[][] aadblResponseBasisCoeffConstraint = new</span>
			double[iNumResponseBasisCoeff][iNumResponseBasisCoeff];

<span class="fc bfc" id="L463" title="All 2 branches covered.">		if (null != aSBFC) {</span>
<span class="fc" id="L464">			int iNumPotentialConstraint = aSBFC.length;</span>

<span class="fc bfc" id="L466" title="All 2 branches covered.">			for (int i = 0; i &lt; iNumPotentialConstraint; ++i) {</span>
<span class="fc bfc" id="L467" title="All 2 branches covered.">				if (null != aSBFC[i]) ++iNumConstraint;</span>
			}
		}

<span class="pc bpc" id="L471" title="1 of 2 branches missed.">		if (iNumResponseBasisCoeff &lt; iNumPredictorOrdinate + iNumLeftDeriv + iNumRightDeriv + iNumConstraint)</span>
<span class="nc" id="L472">			return false;</span>

		try {
<span class="fc" id="L475">			org.drip.spline.segment.BestFitFlexurePenalizer bffp = new</span>
<span class="fc" id="L476">				org.drip.spline.segment.BestFitFlexurePenalizer (this, _sidc.curvaturePenaltyControl(),</span>
<span class="fc" id="L477">					_sidc.lengthPenaltyControl(), sbfr, _be);</span>

<span class="fc bfc" id="L479" title="All 2 branches covered.">			for (int j = 0; j &lt; iNumResponseBasisCoeff; ++j) {</span>
<span class="fc bfc" id="L480" title="All 2 branches covered.">				if (j &lt; iNumPredictorOrdinate)</span>
<span class="fc" id="L481">					adblPredictorResponseConstraintValue[j] = adblResponseValue[j];</span>
<span class="fc bfc" id="L482" title="All 2 branches covered.">				else if (j &lt; iNumPredictorOrdinate + iNumConstraint)</span>
<span class="fc" id="L483">					adblPredictorResponseConstraintValue[j] = aSBFC[j -</span>
<span class="fc" id="L484">					    iNumPredictorOrdinate].contraintValue();</span>
<span class="fc bfc" id="L485" title="All 2 branches covered.">				else if (j &lt; iNumPredictorOrdinate + iNumConstraint + iNumLeftDeriv)</span>
<span class="fc" id="L486">					adblPredictorResponseConstraintValue[j] = adblLeftEdgeDeriv[j - iNumPredictorOrdinate -</span>
					    iNumConstraint];
<span class="fc bfc" id="L488" title="All 2 branches covered.">				else if (j &lt; iNumPredictorOrdinate + iNumConstraint + iNumLeftDeriv + iNumRightDeriv)</span>
<span class="fc" id="L489">					adblPredictorResponseConstraintValue[j] = adblRightEdgeDeriv[j - iNumPredictorOrdinate -</span>
					    iNumConstraint - iNumLeftDeriv];
				else
<span class="fc" id="L492">					adblPredictorResponseConstraintValue[j] = bffp.basisPairPenaltyConstraint (j);</span>
			}

<span class="fc bfc" id="L495" title="All 2 branches covered.">			for (int i = 0; i &lt; iNumResponseBasisCoeff; ++i) {</span>
<span class="fc bfc" id="L496" title="All 2 branches covered.">				for (int l = 0; l &lt; iNumResponseBasisCoeff; ++l) {</span>
<span class="fc" id="L497">					double[] adblCalibBasisConstraintWeight = null;</span>

<span class="fc bfc" id="L499" title="All 6 branches covered.">					if (0 != iNumConstraint &amp;&amp; (l &gt;= iNumPredictorOrdinate &amp;&amp; l &lt; iNumPredictorOrdinate +</span>
						iNumConstraint))
<span class="fc" id="L501">						adblCalibBasisConstraintWeight = aSBFC[l -</span>
<span class="fc" id="L502">						    iNumPredictorOrdinate].responseBasisCoeffWeights();</span>

<span class="fc bfc" id="L504" title="All 2 branches covered.">					if (l &lt; iNumPredictorOrdinate)</span>
<span class="fc" id="L505">						aadblResponseBasisCoeffConstraint[l][i] = _be.shapedBasisFunctionResponse</span>
<span class="fc" id="L506">							(adblPredictorOrdinate[l], i);</span>
<span class="fc bfc" id="L507" title="All 2 branches covered.">					else if (l &lt; iNumPredictorOrdinate + iNumConstraint)</span>
<span class="fc" id="L508">						aadblResponseBasisCoeffConstraint[l][i] = adblCalibBasisConstraintWeight[i];</span>
<span class="fc bfc" id="L509" title="All 2 branches covered.">					else if (l &lt; iNumPredictorOrdinate + iNumConstraint + iNumLeftDeriv)</span>
<span class="fc" id="L510">						aadblResponseBasisCoeffConstraint[l][i] = _be.shapedBasisFunctionDerivative (left(),</span>
							l - iNumPredictorOrdinate - iNumConstraint + 1, i);
<span class="fc bfc" id="L512" title="All 2 branches covered.">					else if (l &lt; iNumPredictorOrdinate + iNumConstraint + iNumLeftDeriv + iNumRightDeriv)</span>
<span class="fc" id="L513">						aadblResponseBasisCoeffConstraint[l][i] = _be.shapedBasisFunctionDerivative</span>
<span class="fc" id="L514">							(right(), l - iNumPredictorOrdinate - iNumConstraint - iNumLeftDeriv + 1, i);</span>
					else
<span class="fc" id="L516">						aadblResponseBasisCoeffConstraint[l][i] = bffp.basisPairConstraintCoefficient (i, l);</span>
				}
			}
<span class="nc" id="L519">		} catch (java.lang.Exception e) {</span>
<span class="nc" id="L520">			e.printStackTrace();</span>

<span class="nc" id="L522">			return false;</span>
<span class="fc" id="L523">		}</span>

<span class="fc" id="L525">		org.drip.quant.linearalgebra.LinearizationOutput lo =</span>
			org.drip.quant.linearalgebra.LinearSystemSolver.SolveUsingMatrixInversion
<span class="fc" id="L527">				(aadblResponseBasisCoeffConstraint, adblPredictorResponseConstraintValue);</span>

<span class="fc bfc" id="L529" title="All 2 branches covered.">		if (null == lo) return false;</span>

<span class="fc" id="L531">		double[] adblCalibResponseBasisCoeff = lo.getTransformedRHS();</span>

<span class="pc bpc" id="L533" title="2 of 4 branches missed.">		if (null == adblCalibResponseBasisCoeff || adblCalibResponseBasisCoeff.length !=</span>
			iNumResponseBasisCoeff || null == (_aadblDResponseBasisCoeffDConstraint =
<span class="pc bpc" id="L535" title="3 of 6 branches missed.">				lo.getTransformedMatrix()) || _aadblDResponseBasisCoeffDConstraint.length !=</span>
					iNumResponseBasisCoeff || _aadblDResponseBasisCoeffDConstraint[0].length !=
						iNumResponseBasisCoeff)
<span class="nc" id="L538">			return false;</span>

<span class="fc bfc" id="L540" title="All 2 branches covered.">		for (int i = 0; i &lt; iNumResponseBasisCoeff; ++i) {</span>
<span class="pc bpc" id="L541" title="1 of 2 branches missed.">			if (!org.drip.quant.common.NumberUtil.IsValid (_adblResponseBasisCoeff[i] =</span>
				adblCalibResponseBasisCoeff[i]))
<span class="nc" id="L543">				return false;</span>
		}

<span class="fc" id="L546">		return true;</span>
	}

	/**
	 * Sensitivity Calibrator: Calibrate the Segment Manifest Measure Jacobian from the Calibration Inputs
	 * 
	 * @param ssciManifestSensitivity The Segment Manifest Calibration Sensitivity Inputs
	 * @param aSBFCState Array of Segment State Basis Flexure Constraints
	 * 
	 * @return The Manifest Sensitivity Coefficients
	 */

	public double[] calibrateManifestJacobian (
		final org.drip.spline.params.SegmentStateCalibrationInputs ssciManifestSensitivity,
		final org.drip.spline.params.SegmentBasisFlexureConstraint[] aSBFCState)
	{
<span class="pc bpc" id="L562" title="1 of 2 branches missed.">		if (null == ssciManifestSensitivity) return null;</span>

<span class="fc" id="L564">		double[] adblPredictorOrdinate = ssciManifestSensitivity.predictorOrdinates();</span>

<span class="fc" id="L566">		double[] adblResponseValueManifestSensitivity = ssciManifestSensitivity.responseValues();</span>

<span class="fc" id="L568">		double[] adblLeftEdgeDerivManifestSensitivity = ssciManifestSensitivity.leftEdgeDeriv();</span>

<span class="fc" id="L570">		double[] adblRightEdgeDerivManifestSensitivity = ssciManifestSensitivity.rightEdgeDeriv();</span>

<span class="fc" id="L572">		org.drip.spline.params.SegmentBestFitResponse sbfrManifestSensitivity =</span>
<span class="fc" id="L573">			ssciManifestSensitivity.bestFitResponse();</span>

<span class="fc" id="L575">		org.drip.spline.params.SegmentBasisFlexureConstraint[] aSBFCManifestSensitivity =</span>
<span class="fc" id="L576">			ssciManifestSensitivity.flexureConstraint();</span>

<span class="fc" id="L578">		int iNumConstraint = 0;</span>
<span class="fc" id="L579">		int iNumResponseBasisCoeff = _adblResponseBasisCoeff.length;</span>
<span class="fc bfc" id="L580" title="All 2 branches covered.">		int iNumPredictorOrdinate = null == adblPredictorOrdinate ? 0 : adblPredictorOrdinate.length;</span>
<span class="fc" id="L581">		double[] adblPredictorResponseManifestSensitivityConstraint = new double[iNumResponseBasisCoeff];</span>
<span class="fc bfc" id="L582" title="All 2 branches covered.">		int iNumLeftDerivManifestSensitivity = null == adblLeftEdgeDerivManifestSensitivity ? 0 :</span>
			adblLeftEdgeDerivManifestSensitivity.length;
<span class="pc bpc" id="L584" title="1 of 2 branches missed.">		int iNumRightDerivManifestSensitivity = null == adblRightEdgeDerivManifestSensitivity ? 0 :</span>
			adblRightEdgeDerivManifestSensitivity.length;
<span class="fc" id="L586">		double[][] aadblResponseCoeffConstraintManifestSensitivity = new</span>
			double[iNumResponseBasisCoeff][iNumResponseBasisCoeff];

<span class="fc bfc" id="L589" title="All 2 branches covered.">		if (null != aSBFCState) {</span>
<span class="fc" id="L590">			int iNumPotentialConstraint = aSBFCState.length;</span>

<span class="fc bfc" id="L592" title="All 2 branches covered.">			for (int i = 0; i &lt; iNumPotentialConstraint; ++i) {</span>
<span class="pc bpc" id="L593" title="1 of 2 branches missed.">				if (null != aSBFCState[i]) ++iNumConstraint;</span>
			}
		}

<span class="pc bpc" id="L597" title="1 of 2 branches missed.">		if (iNumResponseBasisCoeff &lt; iNumPredictorOrdinate + iNumLeftDerivManifestSensitivity +</span>
			iNumRightDerivManifestSensitivity + iNumConstraint)
<span class="nc" id="L599">			return null;</span>

		try {
<span class="pc bpc" id="L602" title="1 of 2 branches missed.">			org.drip.spline.segment.BestFitFlexurePenalizer bffpManifestSensitivity = new</span>
				org.drip.spline.segment.BestFitFlexurePenalizer (this, null == _sidc ? null :
<span class="pc bpc" id="L604" title="1 of 2 branches missed.">					_sidc.curvaturePenaltyControl(), null == _sidc ? null : _sidc.lengthPenaltyControl(),</span>
						sbfrManifestSensitivity, _be);

<span class="fc bfc" id="L607" title="All 2 branches covered.">			for (int j = 0; j &lt; iNumResponseBasisCoeff; ++j) {</span>
<span class="fc bfc" id="L608" title="All 2 branches covered.">				if (j &lt; iNumPredictorOrdinate)</span>
<span class="fc" id="L609">					adblPredictorResponseManifestSensitivityConstraint[j] =</span>
						adblResponseValueManifestSensitivity[j];
<span class="fc bfc" id="L611" title="All 2 branches covered.">				else if (j &lt; iNumPredictorOrdinate + iNumConstraint) {</span>
<span class="fc" id="L612">					adblPredictorResponseManifestSensitivityConstraint[j] = 0.;</span>
<span class="fc" id="L613">					org.drip.spline.params.SegmentBasisFlexureConstraint sbfcManifestSensitivity =</span>
						aSBFCManifestSensitivity[j - iNumPredictorOrdinate];

<span class="pc bpc" id="L616" title="1 of 2 branches missed.">					if (null != sbfcManifestSensitivity) {</span>
<span class="fc" id="L617">						adblPredictorResponseManifestSensitivityConstraint[j] =</span>
<span class="fc" id="L618">							sbfcManifestSensitivity.contraintValue();</span>

<span class="fc" id="L620">						double[] adblCalibConstraintWeightManifestSensitivity =</span>
<span class="fc" id="L621">							sbfcManifestSensitivity.responseBasisCoeffWeights();</span>

<span class="fc bfc" id="L623" title="All 2 branches covered.">						for (int i = 0; i &lt; iNumResponseBasisCoeff; ++i)</span>
<span class="fc" id="L624">							adblPredictorResponseManifestSensitivityConstraint[j] -=</span>
								_adblResponseBasisCoeff[i] * adblCalibConstraintWeightManifestSensitivity[i];
					}
<span class="fc bfc" id="L627" title="All 2 branches covered.">				} else if (j &lt; iNumPredictorOrdinate + iNumConstraint + iNumLeftDerivManifestSensitivity)</span>
<span class="fc" id="L628">					adblPredictorResponseManifestSensitivityConstraint[j] =</span>
						adblLeftEdgeDerivManifestSensitivity[j - iNumPredictorOrdinate - iNumConstraint];
<span class="pc bpc" id="L630" title="1 of 2 branches missed.">				else if (j &lt; iNumPredictorOrdinate + iNumConstraint + iNumLeftDerivManifestSensitivity +</span>
					iNumRightDerivManifestSensitivity)
<span class="nc" id="L632">					adblPredictorResponseManifestSensitivityConstraint[j] =</span>
						adblRightEdgeDerivManifestSensitivity[j - iNumPredictorOrdinate - iNumConstraint -
						    iNumLeftDerivManifestSensitivity];
				else
<span class="fc" id="L636">					adblPredictorResponseManifestSensitivityConstraint[j] =</span>
<span class="fc" id="L637">						bffpManifestSensitivity.basisPairPenaltyConstraint (j);</span>
			}

<span class="fc bfc" id="L640" title="All 2 branches covered.">			for (int i = 0; i &lt; iNumResponseBasisCoeff; ++i) {</span>
<span class="fc bfc" id="L641" title="All 2 branches covered.">				for (int l = 0; l &lt; iNumResponseBasisCoeff; ++l) {</span>
<span class="fc" id="L642">					double[] adblCalibBasisConstraintWeight = null;</span>

<span class="fc bfc" id="L644" title="All 6 branches covered.">					if (0 != iNumConstraint &amp;&amp; (l &gt;= iNumPredictorOrdinate &amp;&amp; l &lt; iNumPredictorOrdinate +</span>
						iNumConstraint))
<span class="fc" id="L646">						adblCalibBasisConstraintWeight = aSBFCState[l -</span>
<span class="fc" id="L647">						    iNumPredictorOrdinate].responseBasisCoeffWeights();</span>

<span class="fc bfc" id="L649" title="All 2 branches covered.">					if (l &lt; iNumPredictorOrdinate)</span>
<span class="fc" id="L650">						aadblResponseCoeffConstraintManifestSensitivity[l][i] =</span>
<span class="fc" id="L651">							_be.shapedBasisFunctionResponse (adblPredictorOrdinate[l], i);</span>
<span class="fc bfc" id="L652" title="All 2 branches covered.">					else if (l &lt; iNumPredictorOrdinate + iNumConstraint)</span>
<span class="fc" id="L653">						aadblResponseCoeffConstraintManifestSensitivity[l][i] =</span>
							adblCalibBasisConstraintWeight[i];
<span class="fc bfc" id="L655" title="All 2 branches covered.">					else if (l &lt; iNumPredictorOrdinate + iNumConstraint + iNumLeftDerivManifestSensitivity)</span>
<span class="fc" id="L656">						aadblResponseCoeffConstraintManifestSensitivity[l][i] =</span>
<span class="fc" id="L657">							_be.shapedBasisFunctionDerivative (left(), l - iNumPredictorOrdinate -</span>
								iNumConstraint + 1, i);
<span class="pc bpc" id="L659" title="1 of 2 branches missed.">					else if (l &lt; iNumPredictorOrdinate + iNumConstraint + iNumLeftDerivManifestSensitivity +</span>
						iNumRightDerivManifestSensitivity)
<span class="nc" id="L661">						aadblResponseCoeffConstraintManifestSensitivity[l][i] =</span>
<span class="nc" id="L662">							_be.shapedBasisFunctionDerivative (right(), l - iNumPredictorOrdinate -</span>
								iNumConstraint - iNumLeftDerivManifestSensitivity + 1, i);
					else
<span class="fc" id="L665">						aadblResponseCoeffConstraintManifestSensitivity[l][i] =</span>
<span class="fc" id="L666">							bffpManifestSensitivity.basisPairConstraintCoefficient (i, l);</span>
				}
			}
<span class="nc" id="L669">		} catch (java.lang.Exception e) {</span>
<span class="nc" id="L670">			e.printStackTrace();</span>

<span class="nc" id="L672">			return null;</span>
<span class="fc" id="L673">		}</span>

<span class="fc" id="L675">		org.drip.quant.linearalgebra.LinearizationOutput lo =</span>
			org.drip.quant.linearalgebra.LinearSystemSolver.SolveUsingMatrixInversion
<span class="fc" id="L677">				(aadblResponseCoeffConstraintManifestSensitivity,</span>
					adblPredictorResponseManifestSensitivityConstraint);

<span class="pc bpc" id="L680" title="1 of 2 branches missed.">		return null == lo ? null : lo.getTransformedRHS();</span>
	}

	/**
	 * Sensitivity Calibrator: Calibrate the Segment Local Manifest Jacobian from the Calibration Parameter
	 * 	Set
	 * 
	 * @param strManifestMeasure Latent State Manifest Measure
	 * @param ssciManifestSensitivity The Segment Manifest Calibration Parameter Sensitivity
	 * @param aSBFCState Array of Segment State Basis Flexure Constraints
	 * 
	 * @return TRUE - Local Manifest Sensitivity Calibration Successful
	 */

	public boolean calibrateLocalManifestJacobian (
		final java.lang.String strManifestMeasure,
		final org.drip.spline.params.SegmentStateCalibrationInputs ssciManifestSensitivity,
		final org.drip.spline.params.SegmentBasisFlexureConstraint[] aSBFCState)
	{
<span class="fc" id="L699">		org.drip.spline.segment.LatentStateManifestSensitivity lsms = manifestSensitivity</span>
<span class="fc" id="L700">			(strManifestMeasure);</span>

<span class="pc bpc" id="L702" title="1 of 2 branches missed.">		if (null == lsms) return false;</span>

<span class="fc" id="L704">		double[] adblDBasisCoeffDLocalManifest = calibrateManifestJacobian (ssciManifestSensitivity,</span>
			aSBFCState);

<span class="pc bpc" id="L707" title="2 of 4 branches missed.">		return null == adblDBasisCoeffDLocalManifest || adblDBasisCoeffDLocalManifest.length !=</span>
			_adblResponseBasisCoeff.length ? false : lsms.setDBasisCoeffDLocalManifest
<span class="fc" id="L709">				(adblDBasisCoeffDLocalManifest);</span>
	}

	/**
	 * Sensitivity Calibrator: Calibrate the Segment Preceeding Manifest Jacobian from the Calibration
	 *	Parameter Set
	 * 
	 * @param strManifestMeasure Latent State Manifest
	 * @param ssciPreceedingManifestSensitivity The Segment Preceeding Manifest Calibration Parameter
	 * 	Sensitivity
	 * 
	 * @return TRUE - Preceeding Manifest Sensitivity Calibration Successful
	 */

	public boolean calibratePreceedingManifestJacobian (
		final java.lang.String strManifestMeasure,
		final org.drip.spline.params.SegmentStateCalibrationInputs ssciPreceedingManifestSensitivity)
	{
<span class="fc" id="L727">		org.drip.spline.segment.LatentStateManifestSensitivity lsms = manifestSensitivity</span>
<span class="fc" id="L728">			(strManifestMeasure);</span>

<span class="pc bpc" id="L730" title="1 of 2 branches missed.">		if (null == lsms) return false;</span>

<span class="fc" id="L732">		double[] adblDBasisCoeffDPreceedingManifest = calibrateManifestJacobian</span>
<span class="fc" id="L733">			(ssciPreceedingManifestSensitivity, null);</span>

<span class="pc bpc" id="L735" title="2 of 4 branches missed.">		return null == adblDBasisCoeffDPreceedingManifest || adblDBasisCoeffDPreceedingManifest.length !=</span>
			_adblResponseBasisCoeff.length ? false : lsms.setDBasisCoeffDPreceedingManifest
<span class="fc" id="L737">				(adblDBasisCoeffDPreceedingManifest);</span>
	}

	/**
	 * Calibrate the coefficients from the prior Predictor/Response Segment, the Constraint, and fitness
	 * 	Weights
	 * 
	 * @param csPreceeding Preceeding Predictor/Response Segment
	 * @param srvcState The Segment State Response Value Constraint
	 * @param sbfrState Segment's Best Fit Weighted State Response Values
	 * 
	 * @return TRUE - If the calibration succeeds
	 */

	public boolean calibrate (
		final org.drip.spline.segment.LatentStateResponseModel csPreceeding,
		final org.drip.spline.params.SegmentResponseValueConstraint srvcState,
		final org.drip.spline.params.SegmentBestFitResponse sbfrState)
	{
<span class="fc" id="L756">		int iCk = _sidc.Ck();</span>

<span class="fc bfc" id="L758" title="All 2 branches covered.">		org.drip.spline.params.SegmentBasisFlexureConstraint[] aSBFCState = null == srvcState ? null : new</span>
			org.drip.spline.params.SegmentBasisFlexureConstraint[] {srvcState.responseIndexedBasisConstraint
<span class="fc" id="L760">				(_be, this)};</span>

<span class="fc" id="L762">		double[] adblManifestJacobianDerivAtLeftOrdinate = null;</span>

<span class="fc bfc" id="L764" title="All 2 branches covered.">		if (0 != iCk) {</span>
<span class="fc" id="L765">			adblManifestJacobianDerivAtLeftOrdinate = new double[iCk];</span>

<span class="fc bfc" id="L767" title="All 2 branches covered.">			for (int i = 0; i &lt; iCk; ++i)</span>
<span class="fc" id="L768">				adblManifestJacobianDerivAtLeftOrdinate[i] = 0.;</span>
		}

<span class="pc bpc" id="L771" title="1 of 2 branches missed.">		if (null == csPreceeding) {</span>
			try {
<span class="nc" id="L773">				double[] adblStateDerivAtLeftOrdinate = null;</span>

<span class="nc bnc" id="L775" title="All 2 branches missed.">				if (0 != iCk) {</span>
<span class="nc" id="L776">					adblStateDerivAtLeftOrdinate = new double[iCk];</span>

<span class="nc bnc" id="L778" title="All 2 branches missed.">					for (int i = 0; i &lt; iCk; ++i)</span>
<span class="nc" id="L779">						adblStateDerivAtLeftOrdinate[i] = _be.responseValueDerivative</span>
<span class="nc" id="L780">							(_adblResponseBasisCoeff, left(), i);</span>
				}

<span class="nc" id="L783">				return calibrateState (new org.drip.spline.params.SegmentStateCalibrationInputs (new double[]</span>
<span class="nc" id="L784">					{left()}, new double[] {_be.responseValue (_adblResponseBasisCoeff, left())},</span>
						adblStateDerivAtLeftOrdinate, null, aSBFCState, sbfrState));
<span class="nc" id="L786">			} catch (java.lang.Exception e) {</span>
<span class="nc" id="L787">				e.printStackTrace();</span>
			}

<span class="nc" id="L790">			return false;</span>
		}

		try {
<span class="fc" id="L794">			return calibrateState (new org.drip.spline.params.SegmentStateCalibrationInputs (new double[]</span>
<span class="fc bfc" id="L795" title="All 2 branches covered.">				{left()}, new double[] {csPreceeding.responseValue (left())}, 0 == iCk ? null :</span>
<span class="fc" id="L796">					transmissionCk (left(), csPreceeding, iCk), null, aSBFCState, sbfrState));</span>
<span class="nc" id="L797">		} catch (java.lang.Exception e) {</span>
<span class="nc" id="L798">			e.printStackTrace();</span>
		}

<span class="nc" id="L801">		return false;</span>
	}

	/**
	 * Calibrate the coefficients from the prior Segment and the Response Value at the Right Predictor
	 *  Ordinate
	 * 
	 * @param csPreceeding Preceeding Predictor/Response Segment
	 * @param dblRightStateValue Response Value at the Right Predictor Ordinate
	 * @param sbfrState Segment's Best Fit Weighted Response Values
	 * 
	 * @return TRUE - If the calibration succeeds
	 */

	public boolean calibrate (
		final LatentStateResponseModel csPreceeding,
		final double dblRightStateValue,
		final org.drip.spline.params.SegmentBestFitResponse sbfrState)
	{
<span class="pc bpc" id="L820" title="1 of 2 branches missed.">		if (null == csPreceeding) return false;</span>

<span class="fc" id="L822">		int iCk = _sidc.Ck();</span>

		try {
<span class="fc" id="L825">			return calibrateState (new org.drip.spline.params.SegmentStateCalibrationInputs (new double[]</span>
<span class="fc bfc" id="L826" title="All 2 branches covered.">				{left(), right()}, new double[] {csPreceeding.responseValue (left()), dblRightStateValue}, 0</span>
<span class="fc" id="L827">					!= iCk ? csPreceeding.transmissionCk (left(), this, iCk) : null, null, null, sbfrState));</span>
<span class="nc" id="L828">		} catch (java.lang.Exception e) {</span>
<span class="nc" id="L829">			e.printStackTrace();</span>
		}

<span class="nc" id="L832">		return false;</span>
	}

	/**
	 * Calibrate the Coefficients from the Edge Response Values and the Left Edge Response Slope
	 * 
	 * @param dblLeftValue Left Edge Response Value
	 * @param dblLeftSlope Left Edge Response Slope
	 * @param dblRightValue Right Edge Response Value
	 * @param sbfrState Segment's Best Fit Weighted Response Values
	 * 
	 * @return TRUE - The Calibration Succeeded
	 */

	public boolean calibrate (
		final double dblLeftValue,
		final double dblLeftSlope,
		final double dblRightValue,
		final org.drip.spline.params.SegmentBestFitResponse sbfrState)
	{
<span class="pc bpc" id="L852" title="1 of 2 branches missed.">		if (!org.drip.quant.common.NumberUtil.IsValid (dblLeftValue) ||</span>
<span class="pc bpc" id="L853" title="1 of 2 branches missed.">			!org.drip.quant.common.NumberUtil.IsValid (dblLeftSlope) ||</span>
<span class="pc bpc" id="L854" title="1 of 2 branches missed.">				!org.drip.quant.common.NumberUtil.IsValid (dblRightValue))</span>
<span class="nc" id="L855">			return false;</span>

		try {
<span class="fc" id="L858">			return calibrateState (new org.drip.spline.params.SegmentStateCalibrationInputs (new double[]</span>
<span class="fc" id="L859">				{left(), right()}, new double[] {dblLeftValue, dblRightValue},</span>
<span class="fc" id="L860">					org.drip.quant.common.CollectionUtil.DerivArrayFromSlope (numParameters() - 2,</span>
						dblLeftSlope), null, null, sbfrState));
<span class="nc" id="L862">		} catch (java.lang.Exception e) {</span>
<span class="nc" id="L863">			e.printStackTrace();</span>
		}

<span class="nc" id="L866">		return false;</span>
	}

	/**
	 * Calibrate the coefficients from the Left Edge Response Value Constraint, the Left Edge Response Value
	 *  Slope, and the Right Edge Response Value Constraint
	 * 
	 * @param wrvcStateLeft Left Edge Response Value Constraint
	 * @param dblLeftSlope Left Edge Response Value Slope
	 * @param wrvcStateRight Right Edge Response Value Constraint
	 * @param sbfrState Segment's Best Fit Weighted Response
	 * 
	 * @return TRUE - If the calibration succeeds
	 */

	public boolean calibrate (
		final org.drip.spline.params.SegmentResponseValueConstraint wrvcStateLeft,
		final double dblLeftSlope,
		final org.drip.spline.params.SegmentResponseValueConstraint wrvcStateRight,
		final org.drip.spline.params.SegmentBestFitResponse sbfrState)
	{
<span class="fc" id="L887">		org.drip.spline.params.SegmentBasisFlexureConstraint[] aSBFCState = null;</span>

		try {
<span class="pc bpc" id="L890" title="1 of 4 branches missed.">			if (null != wrvcStateLeft || null != wrvcStateRight)</span>
<span class="pc bpc" id="L891" title="1 of 2 branches missed.">				aSBFCState = new org.drip.spline.params.SegmentBasisFlexureConstraint[] {null ==</span>
<span class="fc bfc" id="L892" title="All 2 branches covered.">					wrvcStateLeft ? null : wrvcStateLeft.responseIndexedBasisConstraint (_be, this), null ==</span>
<span class="fc" id="L893">						wrvcStateRight ? null : wrvcStateRight.responseIndexedBasisConstraint (_be, this)};</span>

<span class="fc" id="L895">			return calibrateState (new org.drip.spline.params.SegmentStateCalibrationInputs (null, null,</span>
<span class="fc" id="L896">				org.drip.quant.common.CollectionUtil.DerivArrayFromSlope (numParameters() - 2, dblLeftSlope),</span>
					null, aSBFCState, sbfrState));
<span class="nc" id="L898">		} catch (java.lang.Exception e) {</span>
<span class="nc" id="L899">			e.printStackTrace();</span>
		}

<span class="nc" id="L902">		return false;</span>
	}

	/**
	 * Compute the Local and the Preceeding Manifest Measure Sensitivity Coefficients from the Preceeding
	 * 	Segment, the Local Response Value, the Local Response Value Manifest Measure Sensitivity, and the
	 * 	Local Best Fit Response Sensitivity
	 * 
	 * @param csPreceeding Preceeding Predictor/Response Segment
	 * @param strManifestMeasure Manifest Measure whose Sensitivity is sought
	 * @param srvcState The Segment State Response Value Constraint
	 * @param srvcManifestSensitivity The Segment State Response Value Constraint Manifest Sensitivity
	 * @param sbfrManifestSensitivity Segment's Best Fit Weighted State Response Value Manifest Sensitivity
	 * 
	 * @return TRUE - If the calibration succeeds
	 */

	public boolean manifestMeasureSensitivity (
		final org.drip.spline.segment.LatentStateResponseModel csPreceeding,
		final java.lang.String strManifestMeasure,
		final org.drip.spline.params.SegmentResponseValueConstraint srvcState,
		final org.drip.spline.params.SegmentResponseValueConstraint srvcManifestSensitivity,
		final org.drip.spline.params.SegmentBestFitResponse sbfrManifestSensitivity)
	{
<span class="pc bpc" id="L926" title="3 of 4 branches missed.">		if (null == srvcState &amp;&amp; null != srvcManifestSensitivity) return false;</span>

<span class="pc bpc" id="L928" title="1 of 2 branches missed.">		org.drip.spline.params.SegmentBasisFlexureConstraint[] aSBFCState = null == srvcState ? null : new</span>
			org.drip.spline.params.SegmentBasisFlexureConstraint[] {srvcState.responseIndexedBasisConstraint
<span class="fc" id="L930">				(_be, this)};</span>

<span class="pc bpc" id="L932" title="1 of 2 branches missed.">		org.drip.spline.params.SegmentBasisFlexureConstraint[] aSBFCManifestSensitivity = null ==</span>
			srvcManifestSensitivity ? null : new org.drip.spline.params.SegmentBasisFlexureConstraint[]
<span class="fc" id="L934">				{srvcManifestSensitivity.responseIndexedBasisConstraint (_be, this)};</span>

<span class="fc" id="L936">		double[] adblManifestJacobianDerivAtLeftOrdinate = null;</span>

<span class="fc" id="L938">		int iCk = _sidc.Ck();</span>

<span class="fc bfc" id="L940" title="All 2 branches covered.">		if (0 != iCk) {</span>
<span class="fc" id="L941">			adblManifestJacobianDerivAtLeftOrdinate = new double[iCk];</span>

<span class="fc bfc" id="L943" title="All 2 branches covered.">			for (int i = 0; i &lt; iCk; ++i)</span>
<span class="fc" id="L944">				adblManifestJacobianDerivAtLeftOrdinate[i] = 0.;</span>
		}

<span class="pc bpc" id="L947" title="1 of 2 branches missed.">		if (null == csPreceeding) return false;</span>

		try {
<span class="pc bpc" id="L950" title="1 of 2 branches missed.">			if (null == aSBFCManifestSensitivity) return true;</span>

<span class="pc bpc" id="L952" title="1 of 2 branches missed.">			if (!calibrateLocalManifestJacobian (strManifestMeasure, new</span>
<span class="fc" id="L953">				org.drip.spline.params.SegmentStateCalibrationInputs (new double[] {left()}, new double[]</span>
					{0.}, adblManifestJacobianDerivAtLeftOrdinate, null, aSBFCManifestSensitivity,
						sbfrManifestSensitivity), aSBFCState))
<span class="nc" id="L956">				return false;</span>

<span class="fc" id="L958">			org.drip.spline.segment.LatentStateManifestSensitivity lsms = manifestSensitivity</span>
<span class="fc" id="L959">				(strManifestMeasure);</span>

<span class="pc bpc" id="L961" title="1 of 2 branches missed.">			if (null == lsms) return true;</span>

<span class="pc bpc" id="L963" title="1 of 2 branches missed.">			return lsms.getPMSC().impactFade() ? calibratePreceedingManifestJacobian (strManifestMeasure, new</span>
<span class="fc" id="L964">				org.drip.spline.params.SegmentStateCalibrationInputs (new double[] {left(), right()}, new</span>
<span class="fc" id="L965">					double[] {csPreceeding.calcDResponseDManifest (strManifestMeasure, left(), 1), 0.}, null,</span>
<span class="fc" id="L966">						CkDBasisCoeffDPreceedingManifestMeasure (strManifestMeasure), null, null)) :</span>
<span class="nc" id="L967">							lsms.setDResponseDPreceedingManifest (csPreceeding.calcDResponseDManifest</span>
<span class="nc" id="L968">								(strManifestMeasure, left(), 1));</span>
<span class="nc" id="L969">		} catch (java.lang.Exception e) {</span>
<span class="nc" id="L970">			e.printStackTrace();</span>
		}

<span class="nc" id="L973">		return false;</span>
	}

	/**
	 * Compute the Local and the Preceeding Manifest Measure Sensitivity Coefficients from the Preceeding
	 * 	Segments, the Local Response Value Sensitivity at the Right Predictor Ordinate, and the Local Best
	 * 	Fit Response Sensitivity
	 * 
	 * @param csPreceeding Preceeding Predictor/Response Segment
	 * @param strManifestMeasure Manifest Measure whose Sensitivity is sought
	 * @param dblRightStateManifestSensitivity Response Value Manifest Sensitivity at the Right Predictor
	 * 	Ordinate
	 * @param sbfrManifestSensitivity Segment's Best Fit Weighted Response Value Manifest Sensitivity
	 * 
	 * @return TRUE - If the calibration succeeds
	 */

	public boolean manifestMeasureSensitivity (
		final LatentStateResponseModel csPreceeding,
		final java.lang.String strManifestMeasure,
		final double dblRightStateManifestSensitivity,
		final org.drip.spline.params.SegmentBestFitResponse sbfrManifestSensitivity)
	{
<span class="pc bpc" id="L996" title="1 of 2 branches missed.">		if (null == csPreceeding) return false;</span>

<span class="fc" id="L998">		int iCk = _sidc.Ck();</span>

		try {
<span class="fc" id="L1001">			double[] adblManifestJacobianDerivAtLeftOrdinate = null;</span>

<span class="fc bfc" id="L1003" title="All 2 branches covered.">			if (0 != iCk) {</span>
<span class="fc" id="L1004">				adblManifestJacobianDerivAtLeftOrdinate = new double[iCk];</span>

<span class="fc bfc" id="L1006" title="All 2 branches covered.">				for (int i = 0; i &lt; iCk; ++i)</span>
<span class="fc" id="L1007">					adblManifestJacobianDerivAtLeftOrdinate[i] = 0.;</span>
			}

<span class="pc bpc" id="L1010" title="1 of 2 branches missed.">			if (!org.drip.quant.common.NumberUtil.IsValid (dblRightStateManifestSensitivity)) return true;</span>

<span class="nc bnc" id="L1012" title="All 2 branches missed.">			if (!calibrateLocalManifestJacobian (strManifestMeasure, new</span>
<span class="nc bnc" id="L1013" title="All 2 branches missed.">				org.drip.spline.params.SegmentStateCalibrationInputs (new double[] {left(), right()}, new</span>
					double[] {0., dblRightStateManifestSensitivity}, 0 != iCk ?
						adblManifestJacobianDerivAtLeftOrdinate : null, null, null, sbfrManifestSensitivity),
							null))
<span class="nc" id="L1017">				return false;</span>

<span class="nc" id="L1019">			org.drip.spline.segment.LatentStateManifestSensitivity lsms = manifestSensitivity</span>
<span class="nc" id="L1020">				(strManifestMeasure);</span>

<span class="nc bnc" id="L1022" title="All 2 branches missed.">			if (null == lsms) return true;</span>

<span class="nc bnc" id="L1024" title="All 2 branches missed.">			return lsms.getPMSC().impactFade() ? calibratePreceedingManifestJacobian (strManifestMeasure, new</span>
<span class="nc" id="L1025">				org.drip.spline.params.SegmentStateCalibrationInputs (new double[] {left(), right()}, new</span>
<span class="nc" id="L1026">					double[] {csPreceeding.calcDResponseDManifest (strManifestMeasure, left(), 1), 0.}, null,</span>
<span class="nc" id="L1027">						CkDBasisCoeffDPreceedingManifestMeasure (strManifestMeasure), null, null)) :</span>
<span class="nc" id="L1028">							lsms.setDResponseDPreceedingManifest (csPreceeding.calcDResponseDManifest</span>
<span class="nc" id="L1029">								(strManifestMeasure, left(), 1));</span>
<span class="nc" id="L1030">		} catch (java.lang.Exception e) {</span>
<span class="nc" id="L1031">			e.printStackTrace();</span>
		}

<span class="nc" id="L1034">		return false;</span>
	}

	/**
	 * Compute the Local and the Preceeding Manifest Measure Sensitivity Coefficients from the Local
	 * 	Response Value Sensitivity at the Left/Right Predictor Ordinate, the Local Left Response Value
	 * 	Sensitivity Slope, and the Local Best Fit Response Sensitivity.
	 * 
	 * @param strManifestMeasure Manifest Measure whose Sensitivity is sought
	 * @param dblLeftManifestSensitivity Left Edge Response Value Manifest Sensitivity
	 * @param dblLeftSlopeManifestSensitivity Left Edge Response Slope Manifest Sensitivity
	 * @param dblRightManifestSensitivity Right Edge Response Value Manifest Sensitivity
	 * @param sbfrManifestSensitivity Segment's Best Fit Weighted Response Values Manifest Sensitivity
	 * 
	 * @return TRUE - The Calibration Succeeded
	 */

	public boolean manifestMeasureSensitivity (
		final java.lang.String strManifestMeasure,
		final double dblLeftManifestSensitivity,
		final double dblLeftSlopeManifestSensitivity,
		final double dblRightManifestSensitivity,
		final org.drip.spline.params.SegmentBestFitResponse sbfrManifestSensitivity)
	{
		try {
<span class="nc bnc" id="L1059" title="All 2 branches missed.">			return org.drip.quant.common.NumberUtil.IsValid (dblLeftManifestSensitivity) &amp;&amp;</span>
<span class="nc bnc" id="L1060" title="All 2 branches missed.">				org.drip.quant.common.NumberUtil.IsValid (dblLeftSlopeManifestSensitivity) &amp;&amp;</span>
<span class="nc bnc" id="L1061" title="All 2 branches missed.">					org.drip.quant.common.NumberUtil.IsValid (dblRightManifestSensitivity) ?</span>
<span class="nc" id="L1062">						calibrateLocalManifestJacobian (strManifestMeasure, new</span>
<span class="nc" id="L1063">							org.drip.spline.params.SegmentStateCalibrationInputs (new double[] {left(),</span>
<span class="nc" id="L1064">								right()}, new double[] {dblLeftManifestSensitivity,</span>
									dblRightManifestSensitivity},
										org.drip.quant.common.CollectionUtil.DerivArrayFromSlope
<span class="nc" id="L1067">											(numParameters() - 2, dblLeftSlopeManifestSensitivity), null,</span>
												null, sbfrManifestSensitivity), null) : true;
<span class="nc" id="L1069">		} catch (java.lang.Exception e) {</span>
<span class="nc" id="L1070">			e.printStackTrace();</span>
		}

<span class="nc" id="L1073">		return false;</span>
	}

	/**
	 * Compute the Local and the Preceeding Manifest Measure Sensitivity Coefficients from the Local
	 * 	Response Value/Sensitivity Constraints at the Left/Right Predictor Ordinate, the Local Left
	 * 	Response Value Sensitivity Slope, and the Local Best Fit Response Sensitivity
	 * 
	 * @param strManifestMeasure Manifest Measure whose Sensitivity is sought
	 * @param wrvcStateLeft Left Edge Response Value Constraint
	 * @param wrvcStateRight Right Edge Response Value Constraint
	 * @param dblLeftSlopeManifestSensitivity Left Edge Response Value Slope Manifest Sensitivity
	 * @param wrvcStateLeftManifestSensitivity Left Edge Response Value Constraint Manifest Sensitivity
	 * @param wrvcStateRightManifestSensitivity Right Edge Response Value Constraint Manifest Sensitivity
	 * @param sbfrManifestSensitivity Segment's Best Fit Weighted Response Manifest Sensitivity
	 * 
	 * @return TRUE - If the calibration succeeds
	 */

	public boolean manifestMeasureSensitivity (
		final java.lang.String strManifestMeasure,
		final org.drip.spline.params.SegmentResponseValueConstraint wrvcStateLeft,
		final org.drip.spline.params.SegmentResponseValueConstraint wrvcStateRight,
		final double dblLeftSlopeManifestSensitivity,
		final org.drip.spline.params.SegmentResponseValueConstraint wrvcStateLeftManifestSensitivity,
		final org.drip.spline.params.SegmentResponseValueConstraint wrvcStateRightManifestSensitivity,
		final org.drip.spline.params.SegmentBestFitResponse sbfrManifestSensitivity)
	{
<span class="fc" id="L1101">		org.drip.spline.params.SegmentBasisFlexureConstraint[] aSBFCState = null;</span>
<span class="fc" id="L1102">		org.drip.spline.params.SegmentBasisFlexureConstraint[] aSBFCManifestSensitivity = null;</span>

		try {
<span class="pc bpc" id="L1105" title="3 of 4 branches missed.">			if (null != wrvcStateLeft || null != wrvcStateRight)</span>
<span class="pc bpc" id="L1106" title="1 of 2 branches missed.">				aSBFCState = new org.drip.spline.params.SegmentBasisFlexureConstraint[] {null ==</span>
<span class="pc bpc" id="L1107" title="1 of 2 branches missed.">					wrvcStateLeft ? null : wrvcStateLeft.responseIndexedBasisConstraint (_be, this), null ==</span>
<span class="fc" id="L1108">						wrvcStateRight ? null : wrvcStateRight.responseIndexedBasisConstraint (_be, this)};</span>

<span class="pc bpc" id="L1110" title="3 of 4 branches missed.">			if (null != wrvcStateLeftManifestSensitivity || null != wrvcStateRightManifestSensitivity)</span>
<span class="pc bpc" id="L1111" title="1 of 2 branches missed.">				aSBFCManifestSensitivity = new org.drip.spline.params.SegmentBasisFlexureConstraint[] {null</span>
					== wrvcStateLeftManifestSensitivity ? null :
<span class="pc bpc" id="L1113" title="1 of 2 branches missed.">						wrvcStateLeftManifestSensitivity.responseIndexedBasisConstraint (_be, this), null ==</span>
							wrvcStateRightManifestSensitivity ? null :
<span class="fc" id="L1115">								wrvcStateRightManifestSensitivity.responseIndexedBasisConstraint (_be,</span>
									this)};

<span class="pc bpc" id="L1118" title="1 of 2 branches missed.">			return null == aSBFCManifestSensitivity ? true : calibrateLocalManifestJacobian</span>
<span class="fc" id="L1119">				(strManifestMeasure, new org.drip.spline.params.SegmentStateCalibrationInputs (null, null,</span>
<span class="fc" id="L1120">					org.drip.quant.common.CollectionUtil.DerivArrayFromSlope (numParameters() - 2,</span>
						dblLeftSlopeManifestSensitivity), null, aSBFCManifestSensitivity,
							sbfrManifestSensitivity), aSBFCState);
<span class="nc" id="L1123">		} catch (java.lang.Exception e) {</span>
<span class="nc" id="L1124">			e.printStackTrace();</span>
		}

<span class="nc" id="L1127">		return false;</span>
	}

	/**
	 * Retrieve the Segment Curvature DPE
	 * 
	 * @return The Segment Curvature DPE
	 * 
	 * @throws java.lang.Exception Thrown if the Segment Curvature DPE cannot be computed
	 */

	public double curvatureDPE()
		throws java.lang.Exception
	{
<span class="fc" id="L1141">		double dblDPE = 0.;</span>

<span class="fc" id="L1143">		int iNumBasis = _be.numBasis();</span>

<span class="fc" id="L1145">		org.drip.spline.params.SegmentFlexurePenaltyControl sfpc = _sidc.curvaturePenaltyControl();</span>

<span class="pc bpc" id="L1147" title="1 of 2 branches missed.">		if (null == sfpc) sfpc = new org.drip.spline.params.SegmentFlexurePenaltyControl (2, 1.);</span>

<span class="fc" id="L1149">		org.drip.spline.segment.BestFitFlexurePenalizer bffp = new</span>
			org.drip.spline.segment.BestFitFlexurePenalizer (this, sfpc, null, null, _be);

<span class="fc bfc" id="L1152" title="All 2 branches covered.">		for (int i = 0; i &lt; iNumBasis; ++i) {</span>
<span class="fc bfc" id="L1153" title="All 2 branches covered.">			for (int j = 0; j &lt; iNumBasis; ++j)</span>
<span class="fc" id="L1154">				dblDPE += _adblResponseBasisCoeff[i] * _adblResponseBasisCoeff[j] *</span>
<span class="fc" id="L1155">					bffp.basisPairCurvaturePenalty (i, j);</span>
		}

<span class="fc" id="L1158">		return sfpc.amplitude() * dblDPE;</span>
	}

	/**
	 * Retrieve the Segment Length DPE
	 * 
	 * @return The Segment Length DPE
	 * 
	 * @throws java.lang.Exception Thrown if the Segment Length DPE cannot be computed
	 */

	public double lengthDPE()
		throws java.lang.Exception
	{
<span class="fc" id="L1172">		double dblDPE = 0.;</span>

<span class="fc" id="L1174">		int iNumBasis = _be.numBasis();</span>

<span class="fc" id="L1176">		org.drip.spline.params.SegmentFlexurePenaltyControl sfpcLength = _sidc.lengthPenaltyControl();</span>

<span class="pc bpc" id="L1178" title="1 of 2 branches missed.">		if (null == sfpcLength) sfpcLength = new org.drip.spline.params.SegmentFlexurePenaltyControl (1, 1.);</span>

<span class="fc" id="L1180">		org.drip.spline.segment.BestFitFlexurePenalizer bffp = new</span>
			org.drip.spline.segment.BestFitFlexurePenalizer (this, null, sfpcLength, null, _be);

<span class="fc bfc" id="L1183" title="All 2 branches covered.">		for (int i = 0; i &lt; iNumBasis; ++i) {</span>
<span class="fc bfc" id="L1184" title="All 2 branches covered.">			for (int j = 0; j &lt; iNumBasis; ++j)</span>
<span class="fc" id="L1185">				dblDPE += _adblResponseBasisCoeff[i] * _adblResponseBasisCoeff[j] *</span>
<span class="fc" id="L1186">					bffp.basisPairLengthPenalty (i, j);</span>
		}

<span class="fc" id="L1189">		return sfpcLength.amplitude() * dblDPE;</span>
	}

	/**
	 * Retrieve the Segment Best Fit DPE
	 * 
	 * @param sbfr The Segment's Best Fit Response Inputs
	 * 
	 * @return The Segment Best Fit DPE
	 * 
	 * @throws java.lang.Exception Thrown if the Segment Best Fit DPE cannot be computed
	 */

	public double bestFitDPE (
		final org.drip.spline.params.SegmentBestFitResponse sbfr)
		throws java.lang.Exception
	{
<span class="fc bfc" id="L1206" title="All 2 branches covered.">		if (null == sbfr) return 0.;</span>

<span class="fc" id="L1208">		double dblDPE = 0.;</span>

<span class="fc" id="L1210">		int iNumBasis = _be.numBasis();</span>

<span class="fc" id="L1212">		org.drip.spline.segment.BestFitFlexurePenalizer bffp = new</span>
			org.drip.spline.segment.BestFitFlexurePenalizer (this, null, null, sbfr, _be);

<span class="fc bfc" id="L1215" title="All 2 branches covered.">		for (int i = 0; i &lt; iNumBasis; ++i) {</span>
<span class="fc bfc" id="L1216" title="All 2 branches covered.">			for (int j = 0; j &lt; iNumBasis; ++j)</span>
<span class="fc" id="L1217">				dblDPE += _adblResponseBasisCoeff[i] * _adblResponseBasisCoeff[j] * bffp.basisBestFitPenalty</span>
<span class="fc" id="L1218">					(i, j);</span>
		}

<span class="fc" id="L1221">		return dblDPE;</span>
	}

	/**
	 * Calculate the Response Value at the given Predictor Ordinate
	 * 
	 * @param dblPredictorOrdinate Predictor Ordinate
	 * 
	 * @return The Response Value
	 * 
	 * @throws java.lang.Exception Thrown if the calculation did not succeed
	 */

	public double responseValue (
		final double dblPredictorOrdinate)
		throws java.lang.Exception
	{
<span class="fc" id="L1238">		return _be.responseValue (_adblResponseBasisCoeff, dblPredictorOrdinate);</span>
	}

	/**
	 * Calculate the Ordered Response Value Derivative at the Predictor Ordinate
	 * 
	 * @param dblPredictorOrdinate Predictor Ordinate at which the ordered Response Derivative is to be
	 * 	calculated
	 * @param iOrder Derivative Order
	 * 
	 * @throws java.lang.Exception Thrown if the Ordered Response Value Derivative cannot be calculated
	 * 
	 * @return Retrieve the Ordered Response Value Derivative
	 */

	public double calcResponseValueDerivative (
		final double dblPredictorOrdinate,
		final int iOrder)
		throws java.lang.Exception
	{
<span class="fc bfc" id="L1258" title="All 2 branches covered.">		return 0 == iOrder ? responseValue (dblPredictorOrdinate) : _be.responseValueDerivative</span>
<span class="fc" id="L1259">			(_adblResponseBasisCoeff, dblPredictorOrdinate, iOrder);</span>
	}

	/**
	 * Calculate the Ordered Derivative of the Response to the Manifest
	 * 
	 * @param strManifestMeasure Manifest Measure whose Sensitivity is sought
	 * @param dblPredictorOrdinate Predictor Ordinate at which the ordered Derivative of the Response to the
	 * 	Manifest is to be calculated
	 * @param iOrder Derivative Order
	 * 
	 * @throws java.lang.Exception Thrown if the Ordered Derivative of the Response to the Manifest cannot be
	 *  calculated
	 * 
	 * @return Retrieve the Ordered Derivative of the Response to the Manifest
	 */

	public double calcDResponseDManifest (
		final java.lang.String strManifestMeasure,
		final double dblPredictorOrdinate,
		final int iOrder)
		throws java.lang.Exception
	{
<span class="pc bpc" id="L1282" title="1 of 2 branches missed.">		if (0 == iOrder)</span>
<span class="nc" id="L1283">			throw new java.lang.Exception</span>
				(&quot;LatentStateResponseModel::calcDResponseDManifest =&gt; Invalid Inputs&quot;);

<span class="fc" id="L1286">		org.drip.spline.segment.LatentStateManifestSensitivity lsms = manifestSensitivity</span>
<span class="fc" id="L1287">			(strManifestMeasure);</span>

<span class="pc bpc" id="L1289" title="1 of 2 branches missed.">		if (null == lsms)</span>
<span class="nc" id="L1290">			throw new java.lang.Exception</span>
				(&quot;LatentStateResponseModel::calcDResponseDManifest =&gt; Invalid Inputs&quot;);

<span class="fc" id="L1293">		return _be.responseValue (lsms.getDBasisCoeffDLocalManifest(), dblPredictorOrdinate);</span>
	}

	/**
	 * Calculate the Ordered Derivative of the Response to the Preceeding Manifest
	 * 
	 * @param strManifestMeasure Manifest Measure whose Sensitivity is sought
	 * @param dblPredictorOrdinate Predictor Ordinate at which the ordered Derivative of the Response to the
	 * 	Manifest is to be calculated
	 * @param iOrder Derivative Order
	 * 
	 * @throws java.lang.Exception Thrown if the Ordered Derivative of the Response to the Manifest cannot be
	 *  calculated
	 * 
	 * @return Retrieve the Ordered Derivative of the Response to the Preceeding Manifest
	 */

	public double calcDResponseDPreceedingManifest (
		final java.lang.String strManifestMeasure,
		final double dblPredictorOrdinate,
		final int iOrder)
		throws java.lang.Exception
	{
<span class="pc bpc" id="L1316" title="1 of 2 branches missed.">		if (0 == iOrder)</span>
<span class="nc" id="L1317">			throw new java.lang.Exception</span>
				(&quot;LatentStateResponseModel::calcDResponseDPreceedingManifest =&gt; Invalid Inputs&quot;);

<span class="fc" id="L1320">		org.drip.spline.segment.LatentStateManifestSensitivity lsms = manifestSensitivity</span>
<span class="fc" id="L1321">			(strManifestMeasure);</span>

<span class="pc bpc" id="L1323" title="1 of 2 branches missed.">		if (null == lsms)</span>
<span class="nc" id="L1324">			throw new java.lang.Exception</span>
				(&quot;LatentStateResponseModel::calcDResponseDPreceedingManifest =&gt; Cannot locate state Manifest sensitivity&quot;);

<span class="fc" id="L1327">		org.drip.spline.params.PreceedingManifestSensitivityControl pqsc = lsms.getPMSC();</span>

<span class="fc" id="L1329">		double dblDResponseDPreceedingManifest = lsms.getDResponseDPreceedingManifest();</span>

<span class="pc bpc" id="L1331" title="1 of 2 branches missed.">		if (!pqsc.impactFade())</span>
<span class="nc bnc" id="L1332" title="All 2 branches missed.">			return org.drip.quant.common.NumberUtil.IsValid (dblDResponseDPreceedingManifest) ?</span>
				dblDResponseDPreceedingManifest : 0.;

<span class="fc" id="L1335">		org.drip.spline.segment.BasisEvaluator be = pqsc.basisEvaluator();</span>

<span class="fc" id="L1337">		double[] adblDBasisCoeffDPreceedingManifest = lsms.getDBasisCoeffDPreceedingManifest();</span>

<span class="pc bpc" id="L1339" title="2 of 4 branches missed.">		return null == adblDBasisCoeffDPreceedingManifest ? 0. : (null == be ? _be : be).responseValue</span>
<span class="fc" id="L1340">			(adblDBasisCoeffDPreceedingManifest, dblPredictorOrdinate);</span>
	}

	/**
	 * Retrieve the Manifest Measure Preceeding Manifest Impact Flag
	 * 
	 * @param strManifestMeasure Manifest Measure whose Sensitivity is sought
	 * 
	 * @return The Manifest Measure Preceeding Manifest Impact Flag
	 * 
	 * @throws java.lang.Exception Thrown if the Inputs are Invalid
	 */

	public boolean impactFade (
		final java.lang.String strManifestMeasure)
		throws java.lang.Exception
	{
<span class="fc" id="L1357">		org.drip.spline.segment.LatentStateManifestSensitivity lsms = manifestSensitivity</span>
<span class="fc" id="L1358">			(strManifestMeasure);</span>

<span class="fc bfc" id="L1360" title="All 2 branches covered.">		if (null == lsms)</span>
<span class="fc" id="L1361">			throw new java.lang.Exception</span>
				(&quot;LatentStateResponseModel::impactFade =&gt; Cannot locate state Manifest sensitivity&quot;);

<span class="fc" id="L1364">		return lsms.getPMSC().impactFade();</span>
	}

	/**
	 * Calculate the Jacobian of the Segment's Response Basis Function Coefficients to the Edge Inputs
	 * 
	 * @return The Jacobian of the Segment's Response Basis Function Coefficients to the Edge Inputs
	 */

	public org.drip.quant.calculus.WengertJacobian jackDCoeffDEdgeInputs()
	{
<span class="fc bfc" id="L1375" title="All 2 branches covered.">		if (null != _wjDBasisCoeffDEdgeValue) return _wjDBasisCoeffDEdgeValue;</span>

<span class="fc" id="L1377">		int iNumResponseBasisCoeff = _be.numBasis();</span>

		try {
<span class="fc" id="L1380">			_wjDBasisCoeffDEdgeValue = new org.drip.quant.calculus.WengertJacobian (iNumResponseBasisCoeff,</span>
				iNumResponseBasisCoeff);
<span class="nc" id="L1382">		} catch (java.lang.Exception e) {</span>
<span class="nc" id="L1383">			e.printStackTrace();</span>

<span class="nc" id="L1385">			return _wjDBasisCoeffDEdgeValue = null;</span>
<span class="fc" id="L1386">		}</span>

<span class="fc bfc" id="L1388" title="All 2 branches covered.">		for (int i = 0; i &lt; iNumResponseBasisCoeff; ++i) {</span>
<span class="pc bpc" id="L1389" title="1 of 2 branches missed.">			if (!_wjDBasisCoeffDEdgeValue.setWengert (i, _adblResponseBasisCoeff[i]))</span>
<span class="nc" id="L1390">				return _wjDBasisCoeffDEdgeValue = null;</span>
		}

<span class="fc bfc" id="L1393" title="All 2 branches covered.">		if (null == _aadblDResponseBasisCoeffDConstraint) return null;</span>

<span class="fc" id="L1395">		int iSize = _aadblDResponseBasisCoeffDConstraint.length;</span>

<span class="fc bfc" id="L1397" title="All 2 branches covered.">		for (int i = 0; i &lt; iSize; ++i) {</span>
<span class="fc bfc" id="L1398" title="All 2 branches covered.">			for (int j = 0; j &lt; iSize; ++j) {</span>
<span class="pc bpc" id="L1399" title="1 of 2 branches missed.">				if (!_wjDBasisCoeffDEdgeValue.accumulatePartialFirstDerivative (i, j,</span>
					_aadblDResponseBasisCoeffDConstraint[i][j]))
<span class="nc" id="L1401">					return null;</span>
			}
		}

<span class="fc" id="L1405">		return _wjDBasisCoeffDEdgeValue;</span>
	}

	/**
	 * Calculate the Jacobian of the Response to the Edge Inputs at the given Predictor Ordinate
	 * 
	 * @param dblPredictorOrdinate The Predictor Ordinate
	 * @param iOrder Order of the Derivative Desired
	 * 
	 * @return The Jacobian of the Response to the Edge Inputs at the given Predictor Ordinate
	 */

	public org.drip.quant.calculus.WengertJacobian jackDResponseDEdgeInput (
		final double dblPredictorOrdinate,
		final int iOrder)
	{
		try {
<span class="fc" id="L1422">			int iNumResponseBasisCoeff = _be.numBasis();</span>

<span class="fc" id="L1424">			org.drip.quant.calculus.WengertJacobian wjDResponseDEdgeParams = null;</span>
<span class="fc" id="L1425">			double[][] aadblDBasisCoeffDEdgeParams = new</span>
				double[iNumResponseBasisCoeff][iNumResponseBasisCoeff];

<span class="fc" id="L1428">			double[] adblDResponseDBasisCoeff = DResponseDBasisCoeff (dblPredictorOrdinate, iOrder);</span>

<span class="pc bpc" id="L1430" title="2 of 4 branches missed.">			if (null == adblDResponseDBasisCoeff || iNumResponseBasisCoeff !=</span>
				adblDResponseDBasisCoeff.length)
<span class="nc" id="L1432">				return null;</span>

<span class="fc bfc" id="L1434" title="All 2 branches covered.">			org.drip.quant.calculus.WengertJacobian wjDBasisCoeffDEdgeParams = (null ==</span>
<span class="fc" id="L1435">				_wjDBasisCoeffDEdgeValue) ? jackDCoeffDEdgeInputs() : _wjDBasisCoeffDEdgeValue;</span>

<span class="fc bfc" id="L1437" title="All 2 branches covered.">			for (int i = 0; i &lt; iNumResponseBasisCoeff; ++i) {</span>
<span class="fc bfc" id="L1438" title="All 2 branches covered.">				for (int j = 0; j &lt; iNumResponseBasisCoeff; ++j)</span>
<span class="fc" id="L1439">					aadblDBasisCoeffDEdgeParams[j][i] = wjDBasisCoeffDEdgeParams.firstDerivative (j, i);</span>
			}

<span class="fc" id="L1442">			if (!(wjDResponseDEdgeParams = new org.drip.quant.calculus.WengertJacobian (1,</span>
<span class="pc bpc" id="L1443" title="1 of 2 branches missed.">				iNumResponseBasisCoeff)).setWengert (0, responseValue (dblPredictorOrdinate)))</span>
<span class="nc" id="L1444">				return null;</span>

<span class="fc bfc" id="L1446" title="All 2 branches covered.">			for (int i = 0; i &lt; iNumResponseBasisCoeff; ++i) {</span>
<span class="fc bfc" id="L1447" title="All 2 branches covered.">				for (int j = 0; j &lt; iNumResponseBasisCoeff; ++j) {</span>
<span class="pc bpc" id="L1448" title="1 of 2 branches missed.">					if (!wjDResponseDEdgeParams.accumulatePartialFirstDerivative (0, i,</span>
						adblDResponseDBasisCoeff[j] * aadblDBasisCoeffDEdgeParams[j][i]))
<span class="nc" id="L1450">						return null;</span>
				}
			}

<span class="fc" id="L1454">			return wjDResponseDEdgeParams;</span>
<span class="nc" id="L1455">		} catch (java.lang.Exception e) {</span>
<span class="nc" id="L1456">			e.printStackTrace();</span>
		}

<span class="nc" id="L1459">		return null;</span>
	}

	/**
	 * Calculate the Jacobian of the Response to the Basis Coefficients at the given Predictor Ordinate
	 * 
	 * @param dblPredictorOrdinate The Predictor Ordinate
	 * @param iOrder Order of the Derivative Desired
	 * 
	 * @return The Jacobian of the Response to the Basis Coefficients at the given Predictor Ordinate
	 */

	public org.drip.quant.calculus.WengertJacobian jackDResponseDBasisCoeff (
		final double dblPredictorOrdinate,
		final int iOrder)
	{
		try {
<span class="nc" id="L1476">			int iNumResponseBasisCoeff = _be.numBasis();</span>

<span class="nc" id="L1478">			double[] adblBasisDResponseDBasisCoeff = DResponseDBasisCoeff (dblPredictorOrdinate, iOrder);</span>

<span class="nc bnc" id="L1480" title="All 4 branches missed.">			if (null == adblBasisDResponseDBasisCoeff || iNumResponseBasisCoeff !=</span>
				adblBasisDResponseDBasisCoeff.length)
<span class="nc" id="L1482">				return null;</span>

<span class="nc" id="L1484">			org.drip.quant.calculus.WengertJacobian wjDResponseDBasisCoeff = new</span>
				org.drip.quant.calculus.WengertJacobian (1, iNumResponseBasisCoeff);

<span class="nc bnc" id="L1487" title="All 2 branches missed.">			for (int i = 0; i &lt; iNumResponseBasisCoeff; ++i) {</span>
<span class="nc bnc" id="L1488" title="All 2 branches missed.">				if (!wjDResponseDBasisCoeff.accumulatePartialFirstDerivative (0, i,</span>
					adblBasisDResponseDBasisCoeff[i]))
<span class="nc" id="L1490">					return null;</span>
			}

<span class="nc" id="L1493">			return wjDResponseDBasisCoeff;</span>
<span class="nc" id="L1494">		} catch (java.lang.Exception e) {</span>
<span class="nc" id="L1495">			e.printStackTrace();</span>
		}

<span class="nc" id="L1498">		return null;</span>
	}

	/**
	 * Calibrate the segment and calculate the Jacobian of the Segment's Response Basis Function Coefficients
	 *  to the Edge Parameters
	 * 
	 * @param adblPredictorOrdinate Array of Predictor Ordinates
	 * @param adblResponseValue Array of Response Values
	 * @param adblLeftEdgeDeriv Array of Left Edge Derivatives
	 * @param adblRightEdgeDeriv Array of Right Edge Derivatives
	 * @param aSBFC Array of Segment Flexure Constraints, expressed as Basis Coefficients
	 * @param sbfr Segment Best Fit Response Instance
	 * 
	 * @return The Jacobian of the Segment's Response Basis Function Coefficients to the Edge Parameters
	 */

	public org.drip.quant.calculus.WengertJacobian jackDCoeffDEdgeParams (
		final double[] adblPredictorOrdinate,
		final double[] adblResponseValue,
		final double[] adblLeftEdgeDeriv,
		final double[] adblRightEdgeDeriv,
		final org.drip.spline.params.SegmentBasisFlexureConstraint[] aSBFC,
		final org.drip.spline.params.SegmentBestFitResponse sbfr)
	{
		try {
<span class="pc bpc" id="L1524" title="1 of 2 branches missed.">			return calibrateState (new org.drip.spline.params.SegmentStateCalibrationInputs</span>
				(adblPredictorOrdinate, adblResponseValue, adblLeftEdgeDeriv, adblRightEdgeDeriv, aSBFC,
<span class="pc" id="L1526">					sbfr)) ? jackDCoeffDEdgeInputs() : null;</span>
<span class="nc" id="L1527">		} catch (java.lang.Exception e) {</span>
<span class="nc" id="L1528">			e.printStackTrace();</span>
		}

<span class="nc" id="L1531">		return null;</span>
	}

	/**
	 * Calibrate the Coefficients from the Edge Response Values and the Left Edge Response Value Slope and
	 *  calculate the Jacobian of the Segment's Response Basis Function Coefficients to the Edge Parameters
	 * 
	 * @param dblLeftValue Left Edge Response Value
	 * @param dblLeftSlope Left Edge Response Slope
	 * @param dblRightValue Right Edge Response Value
	 * @param sbfrState Segment's Best Fit Weighted Response Values
	 * 
	 * @return The Jacobian of the Segment's Response Basis Function Coefficients to the Edge Parameters
	 */

	public org.drip.quant.calculus.WengertJacobian jackDCoeffDEdgeParams (
		final double dblLeftValue,
		final double dblLeftSlope,
		final double dblRightValue,
		final org.drip.spline.params.SegmentBestFitResponse sbfrState)
	{
<span class="pc bpc" id="L1552" title="1 of 2 branches missed.">		return calibrate (dblLeftValue, dblLeftSlope, dblRightValue, sbfrState) ? jackDCoeffDEdgeInputs() :</span>
			null;
	}

	/**
	 * Calibrate the coefficients from the prior Segment and the Response Value at the Right Predictor
	 *  Ordinate and calculate the Jacobian of the Segment's Response Basis Function Coefficients to the Edge
	 *  Parameters
	 * 
	 * @param csPreceeding Previous Predictor/Response Segment
	 * @param strManifestMeasure Manifest Measure whose Sensitivity is sought
	 * @param dblRightStateValue Response Value at the Right Predictor Ordinate
	 * @param sbfrState Segment's Best Fit Weighted Response Values
	 * @param dblRightStateManifestSensitivity Response Value Manifest Sensitivity at the Right Predictor
	 * 	Ordinate
	 * @param sbfrManifestSensitivity Segment's Best Fit Weighted Response Value Manifest Sensitivity
	 * 
	 * @return The Jacobian
	 */

	public org.drip.quant.calculus.WengertJacobian jackDCoeffDEdgeParams (
		final LatentStateResponseModel csPreceeding,
		final java.lang.String strManifestMeasure,
		final double dblRightStateValue,
		final org.drip.spline.params.SegmentBestFitResponse sbfrState,
		final double dblRightStateManifestSensitivity,
		final org.drip.spline.params.SegmentBestFitResponse sbfrManifestSensitivity)
	{
<span class="pc bpc" id="L1580" title="1 of 2 branches missed.">		return !calibrate (csPreceeding, dblRightStateValue, sbfrState) || !manifestMeasureSensitivity</span>
<span class="pc bpc" id="L1581" title="1 of 2 branches missed.">			(csPreceeding, strManifestMeasure, dblRightStateManifestSensitivity, sbfrManifestSensitivity) ?</span>
<span class="fc" id="L1582">				null : jackDCoeffDEdgeInputs();</span>
	}

	/**
	 * Indicate whether the given segment is monotone. If monotone, may optionally indicate the nature of
	 * 	the extrema contained inside (maxima/minima/infection).
	 *  
	 * @return The monotone Type
	 */

	public org.drip.spline.segment.Monotonocity monotoneType()
	{
<span class="fc bfc" id="L1594" title="All 2 branches covered.">		if (1 &gt;= _sidc.Ck()) {</span>
			try {
<span class="fc" id="L1596">				return new org.drip.spline.segment.Monotonocity</span>
					(org.drip.spline.segment.Monotonocity.MONOTONIC);
<span class="nc" id="L1598">			} catch (java.lang.Exception e) {</span>
<span class="nc" id="L1599">				e.printStackTrace();</span>

<span class="nc" id="L1601">				return null;</span>
			}
		}

<span class="fc" id="L1605">		org.drip.function.definition.R1ToR1 ofDeriv = new</span>
<span class="fc" id="L1606">			org.drip.function.definition.R1ToR1 (null) {</span>
			@Override public double evaluate (
				final double dblX)
				throws java.lang.Exception
			{
<span class="fc" id="L1611">				return _be.responseValueDerivative (_adblResponseBasisCoeff, dblX, 1);</span>
			}

			@Override public org.drip.quant.calculus.Differential differential (
				final double dblX,
				final double dblOFBase,
				final int iOrder)
			{
				try {
<span class="nc" id="L1620">					double dblVariateInfinitesimal = _dc.getVariateInfinitesimal (dblX);</span>

<span class="nc" id="L1622">					return new org.drip.quant.calculus.Differential (dblVariateInfinitesimal,</span>
<span class="nc" id="L1623">						_be.responseValueDerivative (_adblResponseBasisCoeff, dblX, iOrder) *</span>
							dblVariateInfinitesimal);
<span class="nc" id="L1625">				} catch (java.lang.Exception e) {</span>
<span class="nc" id="L1626">					e.printStackTrace();</span>
				}

<span class="nc" id="L1629">				return null;</span>
			}

			@Override public double integrate (
				final double dblBegin,
				final double dblEnd)
				throws java.lang.Exception
			{
<span class="nc" id="L1637">				return org.drip.quant.calculus.R1ToR1Integrator.Boole (this, dblBegin, dblEnd);</span>
			}
		};

		try {
<span class="fc" id="L1642">			org.drip.function.r1tor1solver.FixedPointFinderOutput fpop = new</span>
				org.drip.function.r1tor1solver.FixedPointFinderBrent (0., ofDeriv, false).findRoot
<span class="fc" id="L1644">					(org.drip.function.r1tor1solver.InitializationHeuristics.FromHardSearchEdges (0., 1.));</span>

<span class="pc bpc" id="L1646" title="1 of 4 branches missed.">			if (null == fpop || !fpop.containsRoot())</span>
<span class="fc" id="L1647">				return new org.drip.spline.segment.Monotonocity</span>
					(org.drip.spline.segment.Monotonocity.MONOTONIC);

<span class="fc" id="L1650">			double dblExtremum = fpop.getRoot();</span>

<span class="pc bpc" id="L1652" title="3 of 6 branches missed.">			if (!org.drip.quant.common.NumberUtil.IsValid (dblExtremum) || dblExtremum &lt;= 0. || dblExtremum</span>
				&gt;= 1.)
<span class="nc" id="L1654">				return new org.drip.spline.segment.Monotonocity</span>
					(org.drip.spline.segment.Monotonocity.MONOTONIC);

<span class="fc" id="L1657">			double dbl2ndDeriv = _be.responseValueDerivative (_adblResponseBasisCoeff, dblExtremum, 2);</span>

<span class="pc bpc" id="L1659" title="1 of 2 branches missed.">			if (0. &gt; dbl2ndDeriv)</span>
<span class="nc" id="L1660">				return new org.drip.spline.segment.Monotonocity</span>
					(org.drip.spline.segment.Monotonocity.MAXIMA);

<span class="pc bpc" id="L1663" title="1 of 2 branches missed.">			if (0. &lt; dbl2ndDeriv)</span>
<span class="fc" id="L1664">				return new org.drip.spline.segment.Monotonocity</span>
					(org.drip.spline.segment.Monotonocity.MINIMA);

<span class="nc bnc" id="L1667" title="All 2 branches missed.">			if (0. == dbl2ndDeriv)</span>
<span class="nc" id="L1668">				return new org.drip.spline.segment.Monotonocity</span>
					(org.drip.spline.segment.Monotonocity.INFLECTION);

<span class="nc" id="L1671">			return new org.drip.spline.segment.Monotonocity</span>
				(org.drip.spline.segment.Monotonocity.NON_MONOTONIC);
<span class="nc" id="L1673">		} catch (java.lang.Exception e) {</span>
<span class="nc" id="L1674">			e.printStackTrace();</span>
		}

		try {
<span class="nc" id="L1678">			return new org.drip.spline.segment.Monotonocity (org.drip.spline.segment.Monotonocity.MONOTONIC);</span>
<span class="nc" id="L1679">		} catch (java.lang.Exception e) {</span>
<span class="nc" id="L1680">			e.printStackTrace();</span>
		}

<span class="nc" id="L1683">		return null;</span>
	}

	/**
	 * Clip the part of the Segment to the Right of the specified Predictor Ordinate. Retain all other
	 * 	constraints the same.
	 * 
	 * @param dblPredictorOrdinate The Predictor Ordinate
	 * 
	 * @return The Clipped Segment
	 */

	public LatentStateResponseModel clipLeftOfPredictorOrdinate (
		final double dblPredictorOrdinate)
	{
		try {
<span class="fc" id="L1699">			LatentStateResponseModel csLeftSnipped = LatentStateResponseModel.Create (dblPredictorOrdinate,</span>
<span class="fc" id="L1700">				right(), _be.replicate(), _sidc);</span>

<span class="fc" id="L1702">			int iCk = _sidc.Ck();</span>

<span class="pc bpc" id="L1704" title="1 of 2 branches missed.">			double[] adblCalibLeftEdgeDeriv = 0 != iCk ? csLeftSnipped.transmissionCk (dblPredictorOrdinate,</span>
				this, iCk) : null;

<span class="pc bpc" id="L1707" title="1 of 2 branches missed.">			return csLeftSnipped.calibrateState (new org.drip.spline.params.SegmentStateCalibrationInputs</span>
<span class="fc" id="L1708">				(new double[] {dblPredictorOrdinate, right()}, new double[] {responseValue</span>
<span class="fc" id="L1709">					(dblPredictorOrdinate), responseValue (right())}, adblCalibLeftEdgeDeriv, null, null,</span>
						null)) ? csLeftSnipped : null;
<span class="nc" id="L1711">		} catch (java.lang.Exception e) {</span>
<span class="nc" id="L1712">			e.printStackTrace();</span>
		}

<span class="nc" id="L1715">		return null;</span>
	}

	/**
	 * Clip the part of the Segment to the Right of the specified Predictor Ordinate. Retain all other
	 * 	constraints the same.
	 * 
	 * @param dblPredictorOrdinate The Predictor Ordinate
	 * 
	 * @return The Clipped Segment
	 */

	public LatentStateResponseModel clipRightOfPredictorOrdinate (
		final double dblPredictorOrdinate)
	{
		try {
<span class="fc" id="L1731">			LatentStateResponseModel csRightSnipped = LatentStateResponseModel.Create (left(),</span>
<span class="fc" id="L1732">				dblPredictorOrdinate, _be.replicate(), _sidc);</span>

<span class="fc" id="L1734">			int iCk = _sidc.Ck();</span>

<span class="pc bpc" id="L1736" title="1 of 2 branches missed.">			return csRightSnipped.calibrateState (new org.drip.spline.params.SegmentStateCalibrationInputs</span>
<span class="fc" id="L1737">				(new double[] {left(), dblPredictorOrdinate}, new double[] {responseValue (left()),</span>
<span class="pc bpc" id="L1738" title="1 of 2 branches missed.">					responseValue (dblPredictorOrdinate)}, 0 != iCk ? csRightSnipped.transmissionCk (left(),</span>
						this, iCk) : null, null, null, null)) ? csRightSnipped : null;
<span class="nc" id="L1740">		} catch (java.lang.Exception e) {</span>
<span class="nc" id="L1741">			e.printStackTrace();</span>
		}

<span class="nc" id="L1744">		return null;</span>
	}

	/**
	 * Display the string representation for diagnostic purposes
	 * 
	 * @return The string representation
	 */

	public java.lang.String displayString()
	{
<span class="nc" id="L1755">		java.lang.StringBuffer sb = new java.lang.StringBuffer();</span>

<span class="nc" id="L1757">		sb.append (&quot;\t\t\t[&quot; + left() + &quot; =&gt; &quot; + right() + &quot;\n&quot;);</span>

<span class="nc bnc" id="L1759" title="All 2 branches missed.">		for (int i = 0; i &lt; _adblResponseBasisCoeff.length; ++i) {</span>
<span class="nc bnc" id="L1760" title="All 2 branches missed.">			if (0 != i) sb.append (&quot;  |  &quot;);</span>

<span class="nc" id="L1762">			sb.append (_adblResponseBasisCoeff[i] + &quot;\n&quot;);</span>
		}

<span class="nc" id="L1765">		return sb.toString();</span>
	}
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.7.9.201702052155</span></div></body></html>