<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>LatentStateResponseModel.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">DROP</a> &gt; <a href="index.source.html" class="el_package">org.drip.spline.segment</a> &gt; <span class="el_source">LatentStateResponseModel.java</span></div><h1>LatentStateResponseModel.java</h1><pre class="source lang-java linenums">
package org.drip.spline.segment;

/*
 * -*- mode: java; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*-
 */

/*!
 * Copyright (C) 2018 Lakshmi Krishnamurthy
 * Copyright (C) 2017 Lakshmi Krishnamurthy
 * Copyright (C) 2016 Lakshmi Krishnamurthy
 * Copyright (C) 2015 Lakshmi Krishnamurthy
 * Copyright (C) 2014 Lakshmi Krishnamurthy
 * Copyright (C) 2013 Lakshmi Krishnamurthy
 * 
 *  This file is part of DRIP, a free-software/open-source library for buy/side financial/trading model
 *  	libraries targeting analysts and developers
 *  	https://lakshmidrip.github.io/DRIP/
 *  
 *  DRIP is composed of four main libraries:
 *  
 *  - DRIP Fixed Income - https://lakshmidrip.github.io/DRIP-Fixed-Income/
 *  - DRIP Asset Allocation - https://lakshmidrip.github.io/DRIP-Asset-Allocation/
 *  - DRIP Numerical Optimizer - https://lakshmidrip.github.io/DRIP-Numerical-Optimizer/
 *  - DRIP Statistical Learning - https://lakshmidrip.github.io/DRIP-Statistical-Learning/
 * 
 *  - DRIP Fixed Income: Library for Instrument/Trading Conventions, Treasury Futures/Options,
 *  	Funding/Forward/Overnight Curves, Multi-Curve Construction/Valuation, Collateral Valuation and XVA
 *  	Metric Generation, Calibration and Hedge Attributions, Statistical Curve Construction, Bond RV
 *  	Metrics, Stochastic Evolution and Option Pricing, Interest Rate Dynamics and Option Pricing, LMM
 *  	Extensions/Calibrations/Greeks, Algorithmic Differentiation, and Asset Backed Models and Analytics.
 * 
 *  - DRIP Asset Allocation: Library for model libraries for MPT framework, Black Litterman Strategy
 *  	Incorporator, Holdings Constraint, and Transaction Costs.
 * 
 *  - DRIP Numerical Optimizer: Library for Numerical Optimization and Spline Functionality.
 * 
 *  - DRIP Statistical Learning: Library for Statistical Evaluation and Machine Learning.
 * 
 *  Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 *   	you may not use this file except in compliance with the License.
 *   
 *  You may obtain a copy of the License at
 *  	http://www.apache.org/licenses/LICENSE-2.0
 *  
 *  Unless required by applicable law or agreed to in writing, software
 *  	distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 *  	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  
 *  See the License for the specific language governing permissions and
 *  	limitations under the License.
 */

/**
 * LatentStateResponseModel implements the single segment basis calibration and inference functionality. It
 * 	exports the following functionality:
 * 	- Build the LatentStateResponseModel instance from the Basis Function/Shape Controller Set.
 * 	- Build the LatentStateResponseModel instance from the Basis Evaluator Set.
 * 	- Retrieve the Number of Parameters, Basis Evaluator, Array of the Response Basis Coefficients, and
 * 		Segment Design Inelastic Control.
 * 	- Calibrate the Segment State from the Calibration Parameter Set.
 * 	- Sensitivity Calibrator: Calibrate the Segment Manifest Jacobian from the Calibration Parameter Set.
 * 	- Calibrate the coefficients from the prior Predictor/Response Segment, the Constraint, and fitness
 *		Weights
 *	- Calibrate the coefficients from the prior Segment and the Response Value at the Right Predictor
 *		Ordinate.
 *	- Calibrate the Coefficients from the Edge Response Values and the Left Edge Response Slope.
 *	- Calibrate the coefficients from the Left Edge Response Value Constraint, the Left Edge Response Value
 *		Slope, and the Right Edge Response Value Constraint.
 *	- Retrieve the Segment Curvature, Length, and the Best Fit DPE.
 *	- Calculate the Response Value and its Derivative at the given Predictor Ordinate.
 *	- Calculate the Ordered Derivative of the Coefficient to the Manifest.
 *	- Calculate the Jacobian of the Segment's Response Basis Function Coefficients to the Edge Inputs.
 *	- Calculate the Jacobian of the Response to the Edge Inputs at the given Predictor Ordinate.
 *	- Calculate the Jacobian of the Response to the Basis Coefficients at the given Predictor Ordinate.
 *	- Calibrate the segment and calculate the Jacobian of the Segment's Response Basis Function Coefficients
 *		to the Edge Parameters.
 *	- Calibrate the Coefficients from the Edge Response Values and the Left Edge Response Value Slope and
 *		calculate the Jacobian of the Segment's Response Basis Function Coefficients to the Edge Parameters.
 *	- Calibrate the coefficients from the prior Segment and the Response Value at the Right Predictor
 *		Ordinate and calculate the Jacobian of the Segment's Response Basis Function Coefficients to the Edge
 *  	Parameters.
 *  - Indicate whether the given segment is monotone. If monotone, may optionally indicate the nature of the
 *  	extrema contained inside (maxima/minima/infection).
 *  - Clip the part of the Segment to the Right of the specified Predictor Ordinate. Retain all other
 *  	constraints the same.
 *  - Clip the part of the Segment to the Left of the specified Predictor Ordinate. Retain all other
 *  	constraints the same.
 *  - Display the string representation for diagnostic purposes.
 *
 * @author Lakshmi Krishnamurthy
 */

public class LatentStateResponseModel extends org.drip.spline.segment.LatentStateInelastic {

	/**
	 * LEFT NODE VALUE PARAMETER INDEX
	 */

	public static final int LEFT_NODE_VALUE_PARAMETER_INDEX = 0;

	/**
	 * RIGHT NODE VALUE PARAMETER INDEX
	 */

	public static final int RIGHT_NODE_VALUE_PARAMETER_INDEX = 1;

<span class="fc" id="L108">	private double[] _adblResponseBasisCoeff = null;</span>
<span class="fc" id="L109">	private org.drip.spline.segment.BasisEvaluator _be = null;</span>
<span class="fc" id="L110">	private double[][] _aadblDResponseBasisCoeffDConstraint = null;</span>
<span class="fc" id="L111">	private org.drip.spline.params.SegmentInelasticDesignControl _sidc = null;</span>
<span class="fc" id="L112">	private org.drip.quant.calculus.WengertJacobian _wjDBasisCoeffDEdgeValue = null;</span>

<span class="fc" id="L114">	private</span>
		org.drip.analytics.support.CaseInsensitiveHashMap&lt;org.drip.spline.segment.LatentStateManifestSensitivity&gt;
			_mapLSMS = new
				org.drip.analytics.support.CaseInsensitiveHashMap&lt;org.drip.spline.segment.LatentStateManifestSensitivity&gt;();

	/**
	 * Build the LatentStateResponseModel instance from the Basis Function/Shape Controller Set
	 * 
	 * @param dblLeftPredictorOrdinate Left Predictor Ordinate
	 * @param dblRightPredictorOrdinate Right Predictor Ordinate
	 * @param fs Response Basis Function Set
	 * @param rssc Shape Controller
	 * @param sidc Segment Inelastic Design Parameters
	 * 
	 * @return Instance of LatentStateResponseModel
	 */

	public static final org.drip.spline.segment.LatentStateResponseModel Create (
		final double dblLeftPredictorOrdinate,
		final double dblRightPredictorOrdinate,
		final org.drip.spline.basis.FunctionSet fs,
		final org.drip.spline.params.ResponseScalingShapeControl rssc,
		final org.drip.spline.params.SegmentInelasticDesignControl sidc)
	{
		try {
<span class="fc" id="L139">			org.drip.spline.segment.SegmentBasisEvaluator sbe = new</span>
				org.drip.spline.segment.SegmentBasisEvaluator (fs, rssc);

<span class="fc" id="L142">			org.drip.spline.segment.LatentStateResponseModel lsrm = new</span>
				org.drip.spline.segment.LatentStateResponseModel (dblLeftPredictorOrdinate,
					dblRightPredictorOrdinate, sbe, sidc);

<span class="pc bpc" id="L146" title="1 of 2 branches missed.">			return sbe.setContainingInelastics (lsrm) ? lsrm : null;</span>
<span class="nc" id="L147">		} catch (java.lang.Exception e) {</span>
<span class="nc" id="L148">			e.printStackTrace();</span>
		}

<span class="nc" id="L151">		return null;</span>
	}

	/**
	 * Build the LatentStateResponseModel instance from the Basis Evaluator Set
	 * 
	 * @param dblLeftPredictorOrdinate Left Predictor Ordinate
	 * @param dblRightPredictorOrdinate Right Predictor Ordinate
	 * @param be Basis Evaluator
	 * @param sidc Segment Inelastic Design Parameters
	 * 
	 * @return Instance of LatentStateResponseModel
	 */

	public static final org.drip.spline.segment.LatentStateResponseModel Create (
		final double dblLeftPredictorOrdinate,
		final double dblRightPredictorOrdinate,
		final org.drip.spline.segment.BasisEvaluator be,
		final org.drip.spline.params.SegmentInelasticDesignControl sidc)
	{
		try {
<span class="fc" id="L172">			org.drip.spline.segment.LatentStateResponseModel lsrm = new</span>
				org.drip.spline.segment.LatentStateResponseModel (dblLeftPredictorOrdinate,
					dblRightPredictorOrdinate, be, sidc);

<span class="pc bpc" id="L176" title="1 of 2 branches missed.">			return be.setContainingInelastics (lsrm) ? lsrm : null;</span>
<span class="nc" id="L177">		} catch (java.lang.Exception e) {</span>
<span class="nc" id="L178">			e.printStackTrace();</span>
		}

<span class="nc" id="L181">		return null;</span>
	}

	private LatentStateResponseModel (
		final double dblLeftPredictorOrdinate,
		final double dblRightPredictorOrdinate,
		final org.drip.spline.segment.BasisEvaluator be,
		final org.drip.spline.params.SegmentInelasticDesignControl sidc)
		throws java.lang.Exception
	{
<span class="fc" id="L191">		super (dblLeftPredictorOrdinate, dblRightPredictorOrdinate);</span>

<span class="pc bpc" id="L193" title="2 of 4 branches missed.">		if (null == (_be = be) || null == (_sidc = sidc))</span>
<span class="nc" id="L194">			throw new java.lang.Exception (&quot;LatentStateResponseModel ctr: Invalid Basis Functions!&quot;);</span>

<span class="fc" id="L196">		int iNumBasis = _be.numBasis();</span>

<span class="fc" id="L198">		_adblResponseBasisCoeff = new double[iNumBasis];</span>

<span class="pc bpc" id="L200" title="2 of 4 branches missed.">		if (0 &gt;= iNumBasis || _sidc.Ck() &gt; iNumBasis - 2)</span>
<span class="nc" id="L201">			throw new java.lang.Exception (&quot;LatentStateResponseModel ctr: Invalid inputs!&quot;);</span>
<span class="fc" id="L202">	}</span>

	private double[] DResponseDBasisCoeff (
		final double dblPredictorOrdinate,
		final int iOrder)
	{
<span class="pc bpc" id="L208" title="1 of 2 branches missed.">		if (0 == iOrder) return null;</span>

<span class="fc" id="L210">		int iNumBasis = _be.numBasis();</span>

<span class="fc" id="L212">		double[] adblDResponseDBasisCoeff = new double[iNumBasis];</span>

<span class="fc bfc" id="L214" title="All 2 branches covered.">		for (int i = 0; i &lt; iNumBasis; ++i) {</span>
			try {
<span class="pc bpc" id="L216" title="1 of 2 branches missed.">				adblDResponseDBasisCoeff[i] = 1 == iOrder ? _be.shapedBasisFunctionResponse</span>
<span class="pc" id="L217">					(dblPredictorOrdinate, i) : 0.;</span>
<span class="nc" id="L218">			} catch (java.lang.Exception e) {</span>
<span class="nc" id="L219">				e.printStackTrace();</span>

<span class="nc" id="L221">				return null;</span>
<span class="fc" id="L222">			}</span>
		}

<span class="fc" id="L225">		return adblDResponseDBasisCoeff;</span>
	}

	private double[] transmissionCk (
		final double dblPredictorOrdinate,
		final org.drip.spline.segment.LatentStateResponseModel csPreceeding,
		final int iCk)
	{
<span class="fc" id="L233">		double[] adblDeriv = new double[iCk];</span>

<span class="fc bfc" id="L235" title="All 2 branches covered.">		for (int i = 0; i &lt; iCk; ++i) {</span>
			try {
<span class="fc" id="L237">				adblDeriv[i] = csPreceeding.calcResponseValueDerivative (dblPredictorOrdinate, i + 1);</span>
<span class="nc" id="L238">			} catch (java.lang.Exception e) {</span>
<span class="nc" id="L239">				e.printStackTrace();</span>

<span class="nc" id="L241">				return null;</span>
<span class="fc" id="L242">			}</span>
		}

<span class="fc" id="L245">		return adblDeriv;</span>
	}

	private org.drip.spline.segment.LatentStateManifestSensitivity manifestSensitivity (
		final java.lang.String strManifestMeasure)
	{
<span class="pc bpc" id="L251" title="2 of 4 branches missed.">		return null == strManifestMeasure || strManifestMeasure.isEmpty() || !_mapLSMS.containsKey</span>
<span class="pc bpc" id="L252" title="1 of 2 branches missed.">			(strManifestMeasure) ? null : _mapLSMS.get (strManifestMeasure);</span>
	}

	private double[] CkDBasisCoeffDPreceedingManifestMeasure (
		final java.lang.String strManifestMeasure)
	{
<span class="fc" id="L258">		org.drip.spline.segment.LatentStateManifestSensitivity lsms = manifestSensitivity</span>
<span class="fc" id="L259">			(strManifestMeasure);</span>

<span class="pc bpc" id="L261" title="1 of 2 branches missed.">		if (null == lsms) return null;</span>

<span class="fc" id="L263">		int iCk = lsms.getPMSC().Ck();</span>

<span class="pc bpc" id="L265" title="1 of 2 branches missed.">		if (0 == iCk) return null;</span>

<span class="nc" id="L267">		double[] adblDBasisCoeffDPreceedingManifestTail = new double[iCk];</span>

<span class="nc bnc" id="L269" title="All 2 branches missed.">		for (int i = 0; i &lt; iCk; ++i)</span>
<span class="nc" id="L270">			adblDBasisCoeffDPreceedingManifestTail[i] = 0.;</span>

<span class="nc" id="L272">		return adblDBasisCoeffDPreceedingManifestTail;</span>
	}

	/**
	 * Set the Preceeding Manifest Sensitivity Control Parameters for the specified Manifest Measure
	 * 
	 * @param strManifestMeasure The Manifest Measure
	 * @param pmsc The Preceeding Manifest Sensitivity Control Instance
	 * 
	 * @return TRUE - Named Preceeding Manifest Sensitivity Control Instance Successfully Set
	 */

	public boolean setPreceedingManifestSensitivityControl (
		final java.lang.String strManifestMeasure,
		final org.drip.spline.params.PreceedingManifestSensitivityControl pmsc)
	{
<span class="pc bpc" id="L288" title="2 of 4 branches missed.">		if (null == strManifestMeasure || strManifestMeasure.isEmpty()) return false;</span>

		try {
<span class="fc" id="L291">			_mapLSMS.put (strManifestMeasure, new org.drip.spline.segment.LatentStateManifestSensitivity</span>
				(pmsc));

<span class="fc" id="L294">			return true;</span>
<span class="nc" id="L295">		} catch (java.lang.Exception e) {</span>
<span class="nc" id="L296">			e.printStackTrace();</span>
		}

<span class="nc" id="L299">		return false;</span>
	}

	/**
	 * Retrieve the Number of Parameters
	 * 
	 * @return The Number of Parameters
	 */

	public int numParameters()
	{
<span class="fc" id="L310">		return _sidc.Ck() + 2;</span>
	}

	/**
	 * Retrieve the Basis Evaluator
	 * 
	 * @return The Basis Evaluator
	 */

	public org.drip.spline.segment.BasisEvaluator basisEvaluator()
	{
<span class="fc" id="L321">		return _be;</span>
	}

	/**
	 * Retrieve the Array of Response Basis Coefficients
	 * 
	 * @return The Array of Response Basis Coefficients
	 */

	public double[] responseBasisCoefficient()
	{
<span class="nc" id="L332">		return _adblResponseBasisCoeff;</span>
	}

	/**
	 * Retrieve the Segment Inelastic Design Control
	 * 
	 * @return The Segment Inelastic Design Control
	 */

	public org.drip.spline.params.SegmentInelasticDesignControl designControl()
	{
<span class="nc" id="L343">		return _sidc;</span>
	}

	/**
	 * Main Calibrator: Calibrate the Segment State from the Calibration Parameter Set
	 * 
	 * @param ssciState The Segment State Calibration Inputs Set
	 * 
	 * @return TRUE - Calibration Successful
	 */

	public boolean calibrateState (
		final org.drip.spline.params.SegmentStateCalibrationInputs ssciState)
	{
<span class="pc bpc" id="L357" title="1 of 2 branches missed.">		if (null == ssciState) return false;</span>

<span class="fc" id="L359">		double[] adblPredictorOrdinate = ssciState.predictorOrdinates();</span>

<span class="fc" id="L361">		double[] adblResponseValue = ssciState.responseValues();</span>

<span class="fc" id="L363">		double[] adblLeftEdgeDeriv = ssciState.leftEdgeDeriv();</span>

<span class="fc" id="L365">		double[] adblRightEdgeDeriv = ssciState.rightEdgeDeriv();</span>

<span class="fc" id="L367">		org.drip.spline.params.SegmentBestFitResponse sbfr = ssciState.bestFitResponse();</span>

<span class="fc" id="L369">		org.drip.spline.params.SegmentBasisFlexureConstraint[] aSBFC = ssciState.flexureConstraint();</span>

<span class="fc" id="L371">		int iNumConstraint = 0;</span>
<span class="fc" id="L372">		int iNumResponseBasisCoeff = _adblResponseBasisCoeff.length;</span>
<span class="fc bfc" id="L373" title="All 2 branches covered.">		int iNumLeftDeriv = null == adblLeftEdgeDeriv ? 0 : adblLeftEdgeDeriv.length;</span>
<span class="fc bfc" id="L374" title="All 2 branches covered.">		int iNumRightDeriv = null == adblRightEdgeDeriv ? 0 : adblRightEdgeDeriv.length;</span>
<span class="fc" id="L375">		double[] adblPredictorResponseConstraintValue = new double[iNumResponseBasisCoeff];</span>
<span class="fc bfc" id="L376" title="All 2 branches covered.">		int iNumPredictorOrdinate = null == adblPredictorOrdinate ? 0 : adblPredictorOrdinate.length;</span>
<span class="fc" id="L377">		double[][] aadblResponseBasisCoeffConstraint = new</span>
			double[iNumResponseBasisCoeff][iNumResponseBasisCoeff];

<span class="fc bfc" id="L380" title="All 2 branches covered.">		if (null != aSBFC) {</span>
<span class="fc" id="L381">			int iNumPotentialConstraint = aSBFC.length;</span>

<span class="fc bfc" id="L383" title="All 2 branches covered.">			for (int i = 0; i &lt; iNumPotentialConstraint; ++i) {</span>
<span class="fc bfc" id="L384" title="All 2 branches covered.">				if (null != aSBFC[i]) ++iNumConstraint;</span>
			}
		}

<span class="pc bpc" id="L388" title="1 of 2 branches missed.">		if (iNumResponseBasisCoeff &lt; iNumPredictorOrdinate + iNumLeftDeriv + iNumRightDeriv + iNumConstraint)</span>
<span class="nc" id="L389">			return false;</span>

		try {
<span class="fc" id="L392">			org.drip.spline.segment.BestFitFlexurePenalizer bffp = new</span>
<span class="fc" id="L393">				org.drip.spline.segment.BestFitFlexurePenalizer (this, _sidc.curvaturePenaltyControl(),</span>
<span class="fc" id="L394">					_sidc.lengthPenaltyControl(), sbfr, _be);</span>

<span class="fc bfc" id="L396" title="All 2 branches covered.">			for (int j = 0; j &lt; iNumResponseBasisCoeff; ++j) {</span>
<span class="fc bfc" id="L397" title="All 2 branches covered.">				if (j &lt; iNumPredictorOrdinate)</span>
<span class="fc" id="L398">					adblPredictorResponseConstraintValue[j] = adblResponseValue[j];</span>
<span class="fc bfc" id="L399" title="All 2 branches covered.">				else if (j &lt; iNumPredictorOrdinate + iNumConstraint)</span>
<span class="fc" id="L400">					adblPredictorResponseConstraintValue[j] = aSBFC[j -</span>
<span class="fc" id="L401">					    iNumPredictorOrdinate].contraintValue();</span>
<span class="fc bfc" id="L402" title="All 2 branches covered.">				else if (j &lt; iNumPredictorOrdinate + iNumConstraint + iNumLeftDeriv)</span>
<span class="fc" id="L403">					adblPredictorResponseConstraintValue[j] = adblLeftEdgeDeriv[j - iNumPredictorOrdinate -</span>
					    iNumConstraint];
<span class="fc bfc" id="L405" title="All 2 branches covered.">				else if (j &lt; iNumPredictorOrdinate + iNumConstraint + iNumLeftDeriv + iNumRightDeriv)</span>
<span class="fc" id="L406">					adblPredictorResponseConstraintValue[j] = adblRightEdgeDeriv[j - iNumPredictorOrdinate -</span>
					    iNumConstraint - iNumLeftDeriv];
				else
<span class="fc" id="L409">					adblPredictorResponseConstraintValue[j] = bffp.basisPairPenaltyConstraint (j);</span>
			}

<span class="fc bfc" id="L412" title="All 2 branches covered.">			for (int i = 0; i &lt; iNumResponseBasisCoeff; ++i) {</span>
<span class="fc bfc" id="L413" title="All 2 branches covered.">				for (int l = 0; l &lt; iNumResponseBasisCoeff; ++l) {</span>
<span class="fc" id="L414">					double[] adblCalibBasisConstraintWeight = null;</span>

<span class="fc bfc" id="L416" title="All 6 branches covered.">					if (0 != iNumConstraint &amp;&amp; (l &gt;= iNumPredictorOrdinate &amp;&amp; l &lt; iNumPredictorOrdinate +</span>
						iNumConstraint))
<span class="fc" id="L418">						adblCalibBasisConstraintWeight = aSBFC[l -</span>
<span class="fc" id="L419">						    iNumPredictorOrdinate].responseBasisCoeffWeights();</span>

<span class="fc bfc" id="L421" title="All 2 branches covered.">					if (l &lt; iNumPredictorOrdinate)</span>
<span class="fc" id="L422">						aadblResponseBasisCoeffConstraint[l][i] = _be.shapedBasisFunctionResponse</span>
<span class="fc" id="L423">							(adblPredictorOrdinate[l], i);</span>
<span class="fc bfc" id="L424" title="All 2 branches covered.">					else if (l &lt; iNumPredictorOrdinate + iNumConstraint)</span>
<span class="fc" id="L425">						aadblResponseBasisCoeffConstraint[l][i] = adblCalibBasisConstraintWeight[i];</span>
<span class="fc bfc" id="L426" title="All 2 branches covered.">					else if (l &lt; iNumPredictorOrdinate + iNumConstraint + iNumLeftDeriv)</span>
<span class="fc" id="L427">						aadblResponseBasisCoeffConstraint[l][i] = _be.shapedBasisFunctionDerivative (left(),</span>
							l - iNumPredictorOrdinate - iNumConstraint + 1, i);
<span class="fc bfc" id="L429" title="All 2 branches covered.">					else if (l &lt; iNumPredictorOrdinate + iNumConstraint + iNumLeftDeriv + iNumRightDeriv)</span>
<span class="fc" id="L430">						aadblResponseBasisCoeffConstraint[l][i] = _be.shapedBasisFunctionDerivative</span>
<span class="fc" id="L431">							(right(), l - iNumPredictorOrdinate - iNumConstraint - iNumLeftDeriv + 1, i);</span>
					else
<span class="fc" id="L433">						aadblResponseBasisCoeffConstraint[l][i] = bffp.basisPairConstraintCoefficient (i, l);</span>
				}
			}
<span class="nc" id="L436">		} catch (java.lang.Exception e) {</span>
<span class="nc" id="L437">			e.printStackTrace();</span>

<span class="nc" id="L439">			return false;</span>
<span class="fc" id="L440">		}</span>

<span class="fc" id="L442">		org.drip.quant.linearalgebra.LinearizationOutput lo =</span>
			org.drip.quant.linearalgebra.LinearSystemSolver.SolveUsingMatrixInversion
<span class="fc" id="L444">				(aadblResponseBasisCoeffConstraint, adblPredictorResponseConstraintValue);</span>

<span class="pc bpc" id="L446" title="1 of 2 branches missed.">		if (null == lo) return false;</span>

<span class="fc" id="L448">		double[] adblCalibResponseBasisCoeff = lo.getTransformedRHS();</span>

<span class="pc bpc" id="L450" title="2 of 4 branches missed.">		if (null == adblCalibResponseBasisCoeff || adblCalibResponseBasisCoeff.length !=</span>
			iNumResponseBasisCoeff || null == (_aadblDResponseBasisCoeffDConstraint =
<span class="pc bpc" id="L452" title="3 of 6 branches missed.">				lo.getTransformedMatrix()) || _aadblDResponseBasisCoeffDConstraint.length !=</span>
					iNumResponseBasisCoeff || _aadblDResponseBasisCoeffDConstraint[0].length !=
						iNumResponseBasisCoeff)
<span class="nc" id="L455">			return false;</span>

<span class="fc bfc" id="L457" title="All 2 branches covered.">		for (int i = 0; i &lt; iNumResponseBasisCoeff; ++i) {</span>
<span class="pc bpc" id="L458" title="1 of 2 branches missed.">			if (!org.drip.quant.common.NumberUtil.IsValid (_adblResponseBasisCoeff[i] =</span>
				adblCalibResponseBasisCoeff[i]))
<span class="nc" id="L460">				return false;</span>
		}

<span class="fc" id="L463">		return true;</span>
	}

	/**
	 * Sensitivity Calibrator: Calibrate the Segment Manifest Measure Jacobian from the Calibration Inputs
	 * 
	 * @param ssciManifestSensitivity The Segment Manifest Calibration Sensitivity Inputs
	 * @param aSBFCState Array of Segment State Basis Flexure Constraints
	 * 
	 * @return The Manifest Sensitivity Coefficients
	 */

	public double[] calibrateManifestJacobian (
		final org.drip.spline.params.SegmentStateCalibrationInputs ssciManifestSensitivity,
		final org.drip.spline.params.SegmentBasisFlexureConstraint[] aSBFCState)
	{
<span class="pc bpc" id="L479" title="1 of 2 branches missed.">		if (null == ssciManifestSensitivity) return null;</span>

<span class="fc" id="L481">		double[] adblPredictorOrdinate = ssciManifestSensitivity.predictorOrdinates();</span>

<span class="fc" id="L483">		double[] adblResponseValueManifestSensitivity = ssciManifestSensitivity.responseValues();</span>

<span class="fc" id="L485">		double[] adblLeftEdgeDerivManifestSensitivity = ssciManifestSensitivity.leftEdgeDeriv();</span>

<span class="fc" id="L487">		double[] adblRightEdgeDerivManifestSensitivity = ssciManifestSensitivity.rightEdgeDeriv();</span>

<span class="fc" id="L489">		org.drip.spline.params.SegmentBestFitResponse sbfrManifestSensitivity =</span>
<span class="fc" id="L490">			ssciManifestSensitivity.bestFitResponse();</span>

<span class="fc" id="L492">		org.drip.spline.params.SegmentBasisFlexureConstraint[] aSBFCManifestSensitivity =</span>
<span class="fc" id="L493">			ssciManifestSensitivity.flexureConstraint();</span>

<span class="fc" id="L495">		int iNumConstraint = 0;</span>
<span class="fc" id="L496">		int iNumResponseBasisCoeff = _adblResponseBasisCoeff.length;</span>
<span class="fc bfc" id="L497" title="All 2 branches covered.">		int iNumPredictorOrdinate = null == adblPredictorOrdinate ? 0 : adblPredictorOrdinate.length;</span>
<span class="fc" id="L498">		double[] adblPredictorResponseManifestSensitivityConstraint = new double[iNumResponseBasisCoeff];</span>
<span class="fc bfc" id="L499" title="All 2 branches covered.">		int iNumLeftDerivManifestSensitivity = null == adblLeftEdgeDerivManifestSensitivity ? 0 :</span>
			adblLeftEdgeDerivManifestSensitivity.length;
<span class="pc bpc" id="L501" title="1 of 2 branches missed.">		int iNumRightDerivManifestSensitivity = null == adblRightEdgeDerivManifestSensitivity ? 0 :</span>
			adblRightEdgeDerivManifestSensitivity.length;
<span class="fc" id="L503">		double[][] aadblResponseCoeffConstraintManifestSensitivity = new</span>
			double[iNumResponseBasisCoeff][iNumResponseBasisCoeff];

<span class="fc bfc" id="L506" title="All 2 branches covered.">		if (null != aSBFCState) {</span>
<span class="fc" id="L507">			int iNumPotentialConstraint = aSBFCState.length;</span>

<span class="fc bfc" id="L509" title="All 2 branches covered.">			for (int i = 0; i &lt; iNumPotentialConstraint; ++i) {</span>
<span class="pc bpc" id="L510" title="1 of 2 branches missed.">				if (null != aSBFCState[i]) ++iNumConstraint;</span>
			}
		}

<span class="pc bpc" id="L514" title="1 of 2 branches missed.">		if (iNumResponseBasisCoeff &lt; iNumPredictorOrdinate + iNumLeftDerivManifestSensitivity +</span>
			iNumRightDerivManifestSensitivity + iNumConstraint)
<span class="nc" id="L516">			return null;</span>

		try {
<span class="pc bpc" id="L519" title="1 of 2 branches missed.">			org.drip.spline.segment.BestFitFlexurePenalizer bffpManifestSensitivity = new</span>
				org.drip.spline.segment.BestFitFlexurePenalizer (this, null == _sidc ? null :
<span class="pc bpc" id="L521" title="1 of 2 branches missed.">					_sidc.curvaturePenaltyControl(), null == _sidc ? null : _sidc.lengthPenaltyControl(),</span>
						sbfrManifestSensitivity, _be);

<span class="fc bfc" id="L524" title="All 2 branches covered.">			for (int j = 0; j &lt; iNumResponseBasisCoeff; ++j) {</span>
<span class="fc bfc" id="L525" title="All 2 branches covered.">				if (j &lt; iNumPredictorOrdinate)</span>
<span class="fc" id="L526">					adblPredictorResponseManifestSensitivityConstraint[j] =</span>
						adblResponseValueManifestSensitivity[j];
<span class="fc bfc" id="L528" title="All 2 branches covered.">				else if (j &lt; iNumPredictorOrdinate + iNumConstraint) {</span>
<span class="fc" id="L529">					adblPredictorResponseManifestSensitivityConstraint[j] = 0.;</span>
<span class="fc" id="L530">					org.drip.spline.params.SegmentBasisFlexureConstraint sbfcManifestSensitivity =</span>
						aSBFCManifestSensitivity[j - iNumPredictorOrdinate];

<span class="pc bpc" id="L533" title="1 of 2 branches missed.">					if (null != sbfcManifestSensitivity) {</span>
<span class="fc" id="L534">						adblPredictorResponseManifestSensitivityConstraint[j] =</span>
<span class="fc" id="L535">							sbfcManifestSensitivity.contraintValue();</span>

<span class="fc" id="L537">						double[] adblCalibConstraintWeightManifestSensitivity =</span>
<span class="fc" id="L538">							sbfcManifestSensitivity.responseBasisCoeffWeights();</span>

<span class="fc bfc" id="L540" title="All 2 branches covered.">						for (int i = 0; i &lt; iNumResponseBasisCoeff; ++i)</span>
<span class="fc" id="L541">							adblPredictorResponseManifestSensitivityConstraint[j] -=</span>
								_adblResponseBasisCoeff[i] * adblCalibConstraintWeightManifestSensitivity[i];
					}
<span class="fc bfc" id="L544" title="All 2 branches covered.">				} else if (j &lt; iNumPredictorOrdinate + iNumConstraint + iNumLeftDerivManifestSensitivity)</span>
<span class="fc" id="L545">					adblPredictorResponseManifestSensitivityConstraint[j] =</span>
						adblLeftEdgeDerivManifestSensitivity[j - iNumPredictorOrdinate - iNumConstraint];
<span class="pc bpc" id="L547" title="1 of 2 branches missed.">				else if (j &lt; iNumPredictorOrdinate + iNumConstraint + iNumLeftDerivManifestSensitivity +</span>
					iNumRightDerivManifestSensitivity)
<span class="nc" id="L549">					adblPredictorResponseManifestSensitivityConstraint[j] =</span>
						adblRightEdgeDerivManifestSensitivity[j - iNumPredictorOrdinate - iNumConstraint -
						    iNumLeftDerivManifestSensitivity];
				else
<span class="fc" id="L553">					adblPredictorResponseManifestSensitivityConstraint[j] =</span>
<span class="fc" id="L554">						bffpManifestSensitivity.basisPairPenaltyConstraint (j);</span>
			}

<span class="fc bfc" id="L557" title="All 2 branches covered.">			for (int i = 0; i &lt; iNumResponseBasisCoeff; ++i) {</span>
<span class="fc bfc" id="L558" title="All 2 branches covered.">				for (int l = 0; l &lt; iNumResponseBasisCoeff; ++l) {</span>
<span class="fc" id="L559">					double[] adblCalibBasisConstraintWeight = null;</span>

<span class="fc bfc" id="L561" title="All 6 branches covered.">					if (0 != iNumConstraint &amp;&amp; (l &gt;= iNumPredictorOrdinate &amp;&amp; l &lt; iNumPredictorOrdinate +</span>
						iNumConstraint))
<span class="fc" id="L563">						adblCalibBasisConstraintWeight = aSBFCState[l -</span>
<span class="fc" id="L564">						    iNumPredictorOrdinate].responseBasisCoeffWeights();</span>

<span class="fc bfc" id="L566" title="All 2 branches covered.">					if (l &lt; iNumPredictorOrdinate)</span>
<span class="fc" id="L567">						aadblResponseCoeffConstraintManifestSensitivity[l][i] =</span>
<span class="fc" id="L568">							_be.shapedBasisFunctionResponse (adblPredictorOrdinate[l], i);</span>
<span class="fc bfc" id="L569" title="All 2 branches covered.">					else if (l &lt; iNumPredictorOrdinate + iNumConstraint)</span>
<span class="fc" id="L570">						aadblResponseCoeffConstraintManifestSensitivity[l][i] =</span>
							adblCalibBasisConstraintWeight[i];
<span class="fc bfc" id="L572" title="All 2 branches covered.">					else if (l &lt; iNumPredictorOrdinate + iNumConstraint + iNumLeftDerivManifestSensitivity)</span>
<span class="fc" id="L573">						aadblResponseCoeffConstraintManifestSensitivity[l][i] =</span>
<span class="fc" id="L574">							_be.shapedBasisFunctionDerivative (left(), l - iNumPredictorOrdinate -</span>
								iNumConstraint + 1, i);
<span class="pc bpc" id="L576" title="1 of 2 branches missed.">					else if (l &lt; iNumPredictorOrdinate + iNumConstraint + iNumLeftDerivManifestSensitivity +</span>
						iNumRightDerivManifestSensitivity)
<span class="nc" id="L578">						aadblResponseCoeffConstraintManifestSensitivity[l][i] =</span>
<span class="nc" id="L579">							_be.shapedBasisFunctionDerivative (right(), l - iNumPredictorOrdinate -</span>
								iNumConstraint - iNumLeftDerivManifestSensitivity + 1, i);
					else
<span class="fc" id="L582">						aadblResponseCoeffConstraintManifestSensitivity[l][i] =</span>
<span class="fc" id="L583">							bffpManifestSensitivity.basisPairConstraintCoefficient (i, l);</span>
				}
			}
<span class="nc" id="L586">		} catch (java.lang.Exception e) {</span>
<span class="nc" id="L587">			e.printStackTrace();</span>

<span class="nc" id="L589">			return null;</span>
<span class="fc" id="L590">		}</span>

<span class="fc" id="L592">		org.drip.quant.linearalgebra.LinearizationOutput lo =</span>
			org.drip.quant.linearalgebra.LinearSystemSolver.SolveUsingMatrixInversion
<span class="fc" id="L594">				(aadblResponseCoeffConstraintManifestSensitivity,</span>
					adblPredictorResponseManifestSensitivityConstraint);

<span class="pc bpc" id="L597" title="1 of 2 branches missed.">		return null == lo ? null : lo.getTransformedRHS();</span>
	}

	/**
	 * Sensitivity Calibrator: Calibrate the Segment Local Manifest Jacobian from the Calibration Parameter
	 * 	Set
	 * 
	 * @param strManifestMeasure Latent State Manifest Measure
	 * @param ssciManifestSensitivity The Segment Manifest Calibration Parameter Sensitivity
	 * @param aSBFCState Array of Segment State Basis Flexure Constraints
	 * 
	 * @return TRUE - Local Manifest Sensitivity Calibration Successful
	 */

	public boolean calibrateLocalManifestJacobian (
		final java.lang.String strManifestMeasure,
		final org.drip.spline.params.SegmentStateCalibrationInputs ssciManifestSensitivity,
		final org.drip.spline.params.SegmentBasisFlexureConstraint[] aSBFCState)
	{
<span class="fc" id="L616">		org.drip.spline.segment.LatentStateManifestSensitivity lsms = manifestSensitivity</span>
<span class="fc" id="L617">			(strManifestMeasure);</span>

<span class="pc bpc" id="L619" title="1 of 2 branches missed.">		if (null == lsms) return false;</span>

<span class="fc" id="L621">		double[] adblDBasisCoeffDLocalManifest = calibrateManifestJacobian (ssciManifestSensitivity,</span>
			aSBFCState);

<span class="pc bpc" id="L624" title="2 of 4 branches missed.">		return null == adblDBasisCoeffDLocalManifest || adblDBasisCoeffDLocalManifest.length !=</span>
			_adblResponseBasisCoeff.length ? false : lsms.setDBasisCoeffDLocalManifest
<span class="fc" id="L626">				(adblDBasisCoeffDLocalManifest);</span>
	}

	/**
	 * Sensitivity Calibrator: Calibrate the Segment Preceeding Manifest Jacobian from the Calibration
	 *	Parameter Set
	 * 
	 * @param strManifestMeasure Latent State Manifest
	 * @param ssciPreceedingManifestSensitivity The Segment Preceeding Manifest Calibration Parameter
	 * 	Sensitivity
	 * 
	 * @return TRUE - Preceeding Manifest Sensitivity Calibration Successful
	 */

	public boolean calibratePreceedingManifestJacobian (
		final java.lang.String strManifestMeasure,
		final org.drip.spline.params.SegmentStateCalibrationInputs ssciPreceedingManifestSensitivity)
	{
<span class="fc" id="L644">		org.drip.spline.segment.LatentStateManifestSensitivity lsms = manifestSensitivity</span>
<span class="fc" id="L645">			(strManifestMeasure);</span>

<span class="pc bpc" id="L647" title="1 of 2 branches missed.">		if (null == lsms) return false;</span>

<span class="fc" id="L649">		double[] adblDBasisCoeffDPreceedingManifest = calibrateManifestJacobian</span>
<span class="fc" id="L650">			(ssciPreceedingManifestSensitivity, null);</span>

<span class="pc bpc" id="L652" title="2 of 4 branches missed.">		return null == adblDBasisCoeffDPreceedingManifest || adblDBasisCoeffDPreceedingManifest.length !=</span>
			_adblResponseBasisCoeff.length ? false : lsms.setDBasisCoeffDPreceedingManifest
<span class="fc" id="L654">				(adblDBasisCoeffDPreceedingManifest);</span>
	}

	/**
	 * Calibrate the coefficients from the prior Predictor/Response Segment, the Constraint, and fitness
	 * 	Weights
	 * 
	 * @param csPreceeding Preceeding Predictor/Response Segment
	 * @param srvcState The Segment State Response Value Constraint
	 * @param sbfrState Segment's Best Fit Weighted State Response Values
	 * 
	 * @return TRUE - If the calibration succeeds
	 */

	public boolean calibrate (
		final org.drip.spline.segment.LatentStateResponseModel csPreceeding,
		final org.drip.spline.params.SegmentResponseValueConstraint srvcState,
		final org.drip.spline.params.SegmentBestFitResponse sbfrState)
	{
<span class="fc" id="L673">		int iCk = _sidc.Ck();</span>

<span class="fc bfc" id="L675" title="All 2 branches covered.">		org.drip.spline.params.SegmentBasisFlexureConstraint[] aSBFCState = null == srvcState ? null : new</span>
			org.drip.spline.params.SegmentBasisFlexureConstraint[] {srvcState.responseIndexedBasisConstraint
<span class="fc" id="L677">				(_be, this)};</span>

<span class="fc" id="L679">		double[] adblManifestJacobianDerivAtLeftOrdinate = null;</span>

<span class="fc bfc" id="L681" title="All 2 branches covered.">		if (0 != iCk) {</span>
<span class="fc" id="L682">			adblManifestJacobianDerivAtLeftOrdinate = new double[iCk];</span>

<span class="fc bfc" id="L684" title="All 2 branches covered.">			for (int i = 0; i &lt; iCk; ++i)</span>
<span class="fc" id="L685">				adblManifestJacobianDerivAtLeftOrdinate[i] = 0.;</span>
		}

<span class="pc bpc" id="L688" title="1 of 2 branches missed.">		if (null == csPreceeding) {</span>
			try {
<span class="nc" id="L690">				double[] adblStateDerivAtLeftOrdinate = null;</span>

<span class="nc bnc" id="L692" title="All 2 branches missed.">				if (0 != iCk) {</span>
<span class="nc" id="L693">					adblStateDerivAtLeftOrdinate = new double[iCk];</span>

<span class="nc bnc" id="L695" title="All 2 branches missed.">					for (int i = 0; i &lt; iCk; ++i)</span>
<span class="nc" id="L696">						adblStateDerivAtLeftOrdinate[i] = _be.responseValueDerivative</span>
<span class="nc" id="L697">							(_adblResponseBasisCoeff, left(), i);</span>
				}

<span class="nc" id="L700">				return calibrateState (new org.drip.spline.params.SegmentStateCalibrationInputs (new double[]</span>
<span class="nc" id="L701">					{left()}, new double[] {_be.responseValue (_adblResponseBasisCoeff, left())},</span>
						adblStateDerivAtLeftOrdinate, null, aSBFCState, sbfrState));
<span class="nc" id="L703">			} catch (java.lang.Exception e) {</span>
<span class="nc" id="L704">				e.printStackTrace();</span>
			}

<span class="nc" id="L707">			return false;</span>
		}

		try {
<span class="fc" id="L711">			return calibrateState (new org.drip.spline.params.SegmentStateCalibrationInputs (new double[]</span>
<span class="fc bfc" id="L712" title="All 2 branches covered.">				{left()}, new double[] {csPreceeding.responseValue (left())}, 0 == iCk ? null :</span>
<span class="fc" id="L713">					transmissionCk (left(), csPreceeding, iCk), null, aSBFCState, sbfrState));</span>
<span class="nc" id="L714">		} catch (java.lang.Exception e) {</span>
<span class="nc" id="L715">			e.printStackTrace();</span>
		}

<span class="nc" id="L718">		return false;</span>
	}

	/**
	 * Calibrate the coefficients from the prior Segment and the Response Value at the Right Predictor
	 *  Ordinate
	 * 
	 * @param csPreceeding Preceeding Predictor/Response Segment
	 * @param dblRightStateValue Response Value at the Right Predictor Ordinate
	 * @param sbfrState Segment's Best Fit Weighted Response Values
	 * 
	 * @return TRUE - If the calibration succeeds
	 */

	public boolean calibrate (
		final LatentStateResponseModel csPreceeding,
		final double dblRightStateValue,
		final org.drip.spline.params.SegmentBestFitResponse sbfrState)
	{
<span class="pc bpc" id="L737" title="1 of 2 branches missed.">		if (null == csPreceeding) return false;</span>

<span class="fc" id="L739">		int iCk = _sidc.Ck();</span>

		try {
<span class="fc" id="L742">			return calibrateState (new org.drip.spline.params.SegmentStateCalibrationInputs (new double[]</span>
<span class="fc bfc" id="L743" title="All 2 branches covered.">				{left(), right()}, new double[] {csPreceeding.responseValue (left()), dblRightStateValue}, 0</span>
<span class="fc" id="L744">					!= iCk ? csPreceeding.transmissionCk (left(), this, iCk) : null, null, null, sbfrState));</span>
<span class="nc" id="L745">		} catch (java.lang.Exception e) {</span>
<span class="nc" id="L746">			e.printStackTrace();</span>
		}

<span class="nc" id="L749">		return false;</span>
	}

	/**
	 * Calibrate the Coefficients from the Edge Response Values and the Left Edge Response Slope
	 * 
	 * @param dblLeftValue Left Edge Response Value
	 * @param dblLeftSlope Left Edge Response Slope
	 * @param dblRightValue Right Edge Response Value
	 * @param sbfrState Segment's Best Fit Weighted Response Values
	 * 
	 * @return TRUE - The Calibration Succeeded
	 */

	public boolean calibrate (
		final double dblLeftValue,
		final double dblLeftSlope,
		final double dblRightValue,
		final org.drip.spline.params.SegmentBestFitResponse sbfrState)
	{
<span class="pc bpc" id="L769" title="1 of 2 branches missed.">		if (!org.drip.quant.common.NumberUtil.IsValid (dblLeftValue) ||</span>
<span class="pc bpc" id="L770" title="1 of 2 branches missed.">			!org.drip.quant.common.NumberUtil.IsValid (dblLeftSlope) ||</span>
<span class="pc bpc" id="L771" title="1 of 2 branches missed.">				!org.drip.quant.common.NumberUtil.IsValid (dblRightValue))</span>
<span class="nc" id="L772">			return false;</span>

		try {
<span class="fc" id="L775">			return calibrateState (new org.drip.spline.params.SegmentStateCalibrationInputs (new double[]</span>
<span class="fc" id="L776">				{left(), right()}, new double[] {dblLeftValue, dblRightValue},</span>
<span class="fc" id="L777">					org.drip.quant.common.CollectionUtil.DerivArrayFromSlope (numParameters() - 2,</span>
						dblLeftSlope), null, null, sbfrState));
<span class="nc" id="L779">		} catch (java.lang.Exception e) {</span>
<span class="nc" id="L780">			e.printStackTrace();</span>
		}

<span class="nc" id="L783">		return false;</span>
	}

	/**
	 * Calibrate the coefficients from the Left Edge Response Value Constraint, the Left Edge Response Value
	 *  Slope, and the Right Edge Response Value Constraint
	 * 
	 * @param wrvcStateLeft Left Edge Response Value Constraint
	 * @param dblLeftSlope Left Edge Response Value Slope
	 * @param wrvcStateRight Right Edge Response Value Constraint
	 * @param sbfrState Segment's Best Fit Weighted Response
	 * 
	 * @return TRUE - If the calibration succeeds
	 */

	public boolean calibrate (
		final org.drip.spline.params.SegmentResponseValueConstraint wrvcStateLeft,
		final double dblLeftSlope,
		final org.drip.spline.params.SegmentResponseValueConstraint wrvcStateRight,
		final org.drip.spline.params.SegmentBestFitResponse sbfrState)
	{
<span class="fc" id="L804">		org.drip.spline.params.SegmentBasisFlexureConstraint[] aSBFCState = null;</span>

		try {
<span class="pc bpc" id="L807" title="1 of 4 branches missed.">			if (null != wrvcStateLeft || null != wrvcStateRight)</span>
<span class="pc bpc" id="L808" title="1 of 2 branches missed.">				aSBFCState = new org.drip.spline.params.SegmentBasisFlexureConstraint[] {null ==</span>
<span class="fc bfc" id="L809" title="All 2 branches covered.">					wrvcStateLeft ? null : wrvcStateLeft.responseIndexedBasisConstraint (_be, this), null ==</span>
<span class="fc" id="L810">						wrvcStateRight ? null : wrvcStateRight.responseIndexedBasisConstraint (_be, this)};</span>

<span class="fc" id="L812">			return calibrateState (new org.drip.spline.params.SegmentStateCalibrationInputs (null, null,</span>
<span class="fc" id="L813">				org.drip.quant.common.CollectionUtil.DerivArrayFromSlope (numParameters() - 2, dblLeftSlope),</span>
					null, aSBFCState, sbfrState));
<span class="nc" id="L815">		} catch (java.lang.Exception e) {</span>
<span class="nc" id="L816">			e.printStackTrace();</span>
		}

<span class="nc" id="L819">		return false;</span>
	}

	/**
	 * Compute the Local and the Preceeding Manifest Measure Sensitivity Coefficients from the Preceeding
	 * 	Segment, the Local Response Value, the Local Response Value Manifest Measure Sensitivity, and the
	 * 	Local Best Fit Response Sensitivity
	 * 
	 * @param csPreceeding Preceeding Predictor/Response Segment
	 * @param strManifestMeasure Manifest Measure whose Sensitivity is sought
	 * @param srvcState The Segment State Response Value Constraint
	 * @param srvcManifestSensitivity The Segment State Response Value Constraint Manifest Sensitivity
	 * @param sbfrManifestSensitivity Segment's Best Fit Weighted State Response Value Manifest Sensitivity
	 * 
	 * @return TRUE - If the calibration succeeds
	 */

	public boolean manifestMeasureSensitivity (
		final org.drip.spline.segment.LatentStateResponseModel csPreceeding,
		final java.lang.String strManifestMeasure,
		final org.drip.spline.params.SegmentResponseValueConstraint srvcState,
		final org.drip.spline.params.SegmentResponseValueConstraint srvcManifestSensitivity,
		final org.drip.spline.params.SegmentBestFitResponse sbfrManifestSensitivity)
	{
<span class="pc bpc" id="L843" title="3 of 4 branches missed.">		if (null == srvcState &amp;&amp; null != srvcManifestSensitivity) return false;</span>

<span class="pc bpc" id="L845" title="1 of 2 branches missed.">		org.drip.spline.params.SegmentBasisFlexureConstraint[] aSBFCState = null == srvcState ? null : new</span>
			org.drip.spline.params.SegmentBasisFlexureConstraint[] {srvcState.responseIndexedBasisConstraint
<span class="fc" id="L847">				(_be, this)};</span>

<span class="pc bpc" id="L849" title="1 of 2 branches missed.">		org.drip.spline.params.SegmentBasisFlexureConstraint[] aSBFCManifestSensitivity = null ==</span>
			srvcManifestSensitivity ? null : new org.drip.spline.params.SegmentBasisFlexureConstraint[]
<span class="fc" id="L851">				{srvcManifestSensitivity.responseIndexedBasisConstraint (_be, this)};</span>

<span class="fc" id="L853">		double[] adblManifestJacobianDerivAtLeftOrdinate = null;</span>

<span class="fc" id="L855">		int iCk = _sidc.Ck();</span>

<span class="pc bpc" id="L857" title="1 of 2 branches missed.">		if (0 != iCk) {</span>
<span class="fc" id="L858">			adblManifestJacobianDerivAtLeftOrdinate = new double[iCk];</span>

<span class="fc bfc" id="L860" title="All 2 branches covered.">			for (int i = 0; i &lt; iCk; ++i)</span>
<span class="fc" id="L861">				adblManifestJacobianDerivAtLeftOrdinate[i] = 0.;</span>
		}

<span class="pc bpc" id="L864" title="1 of 2 branches missed.">		if (null == csPreceeding) return false;</span>

		try {
<span class="pc bpc" id="L867" title="1 of 2 branches missed.">			if (null == aSBFCManifestSensitivity) return true;</span>

<span class="pc bpc" id="L869" title="1 of 2 branches missed.">			if (!calibrateLocalManifestJacobian (strManifestMeasure, new</span>
<span class="fc" id="L870">				org.drip.spline.params.SegmentStateCalibrationInputs (new double[] {left()}, new double[]</span>
					{0.}, adblManifestJacobianDerivAtLeftOrdinate, null, aSBFCManifestSensitivity,
						sbfrManifestSensitivity), aSBFCState))
<span class="nc" id="L873">				return false;</span>

<span class="fc" id="L875">			org.drip.spline.segment.LatentStateManifestSensitivity lsms = manifestSensitivity</span>
<span class="fc" id="L876">				(strManifestMeasure);</span>

<span class="pc bpc" id="L878" title="1 of 2 branches missed.">			if (null == lsms) return true;</span>

<span class="pc bpc" id="L880" title="1 of 2 branches missed.">			return lsms.getPMSC().impactFade() ? calibratePreceedingManifestJacobian (strManifestMeasure, new</span>
<span class="fc" id="L881">				org.drip.spline.params.SegmentStateCalibrationInputs (new double[] {left(), right()}, new</span>
<span class="fc" id="L882">					double[] {csPreceeding.calcDResponseDManifest (strManifestMeasure, left(), 1), 0.}, null,</span>
<span class="fc" id="L883">						CkDBasisCoeffDPreceedingManifestMeasure (strManifestMeasure), null, null)) :</span>
<span class="nc" id="L884">							lsms.setDResponseDPreceedingManifest (csPreceeding.calcDResponseDManifest</span>
<span class="nc" id="L885">								(strManifestMeasure, left(), 1));</span>
<span class="nc" id="L886">		} catch (java.lang.Exception e) {</span>
<span class="nc" id="L887">			e.printStackTrace();</span>
		}

<span class="nc" id="L890">		return false;</span>
	}

	/**
	 * Compute the Local and the Preceeding Manifest Measure Sensitivity Coefficients from the Preceeding
	 * 	Segments, the Local Response Value Sensitivity at the Right Predictor Ordinate, and the Local Best
	 * 	Fit Response Sensitivity
	 * 
	 * @param csPreceeding Preceeding Predictor/Response Segment
	 * @param strManifestMeasure Manifest Measure whose Sensitivity is sought
	 * @param dblRightStateManifestSensitivity Response Value Manifest Sensitivity at the Right Predictor
	 * 	Ordinate
	 * @param sbfrManifestSensitivity Segment's Best Fit Weighted Response Value Manifest Sensitivity
	 * 
	 * @return TRUE - If the calibration succeeds
	 */

	public boolean manifestMeasureSensitivity (
		final LatentStateResponseModel csPreceeding,
		final java.lang.String strManifestMeasure,
		final double dblRightStateManifestSensitivity,
		final org.drip.spline.params.SegmentBestFitResponse sbfrManifestSensitivity)
	{
<span class="pc bpc" id="L913" title="1 of 2 branches missed.">		if (null == csPreceeding) return false;</span>

<span class="fc" id="L915">		int iCk = _sidc.Ck();</span>

		try {
<span class="fc" id="L918">			double[] adblManifestJacobianDerivAtLeftOrdinate = null;</span>

<span class="fc bfc" id="L920" title="All 2 branches covered.">			if (0 != iCk) {</span>
<span class="fc" id="L921">				adblManifestJacobianDerivAtLeftOrdinate = new double[iCk];</span>

<span class="fc bfc" id="L923" title="All 2 branches covered.">				for (int i = 0; i &lt; iCk; ++i)</span>
<span class="fc" id="L924">					adblManifestJacobianDerivAtLeftOrdinate[i] = 0.;</span>
			}

<span class="pc bpc" id="L927" title="1 of 2 branches missed.">			if (!org.drip.quant.common.NumberUtil.IsValid (dblRightStateManifestSensitivity)) return true;</span>

<span class="nc bnc" id="L929" title="All 2 branches missed.">			if (!calibrateLocalManifestJacobian (strManifestMeasure, new</span>
<span class="nc bnc" id="L930" title="All 2 branches missed.">				org.drip.spline.params.SegmentStateCalibrationInputs (new double[] {left(), right()}, new</span>
					double[] {0., dblRightStateManifestSensitivity}, 0 != iCk ?
						adblManifestJacobianDerivAtLeftOrdinate : null, null, null, sbfrManifestSensitivity),
							null))
<span class="nc" id="L934">				return false;</span>

<span class="nc" id="L936">			org.drip.spline.segment.LatentStateManifestSensitivity lsms = manifestSensitivity</span>
<span class="nc" id="L937">				(strManifestMeasure);</span>

<span class="nc bnc" id="L939" title="All 2 branches missed.">			if (null == lsms) return true;</span>

<span class="nc bnc" id="L941" title="All 2 branches missed.">			return lsms.getPMSC().impactFade() ? calibratePreceedingManifestJacobian (strManifestMeasure, new</span>
<span class="nc" id="L942">				org.drip.spline.params.SegmentStateCalibrationInputs (new double[] {left(), right()}, new</span>
<span class="nc" id="L943">					double[] {csPreceeding.calcDResponseDManifest (strManifestMeasure, left(), 1), 0.}, null,</span>
<span class="nc" id="L944">						CkDBasisCoeffDPreceedingManifestMeasure (strManifestMeasure), null, null)) :</span>
<span class="nc" id="L945">							lsms.setDResponseDPreceedingManifest (csPreceeding.calcDResponseDManifest</span>
<span class="nc" id="L946">								(strManifestMeasure, left(), 1));</span>
<span class="nc" id="L947">		} catch (java.lang.Exception e) {</span>
<span class="nc" id="L948">			e.printStackTrace();</span>
		}

<span class="nc" id="L951">		return false;</span>
	}

	/**
	 * Compute the Local and the Preceeding Manifest Measure Sensitivity Coefficients from the Local
	 * 	Response Value Sensitivity at the Left/Right Predictor Ordinate, the Local Left Response Value
	 * 	Sensitivity Slope, and the Local Best Fit Response Sensitivity.
	 * 
	 * @param strManifestMeasure Manifest Measure whose Sensitivity is sought
	 * @param dblLeftManifestSensitivity Left Edge Response Value Manifest Sensitivity
	 * @param dblLeftSlopeManifestSensitivity Left Edge Response Slope Manifest Sensitivity
	 * @param dblRightManifestSensitivity Right Edge Response Value Manifest Sensitivity
	 * @param sbfrManifestSensitivity Segment's Best Fit Weighted Response Values Manifest Sensitivity
	 * 
	 * @return TRUE - The Calibration Succeeded
	 */

	public boolean manifestMeasureSensitivity (
		final java.lang.String strManifestMeasure,
		final double dblLeftManifestSensitivity,
		final double dblLeftSlopeManifestSensitivity,
		final double dblRightManifestSensitivity,
		final org.drip.spline.params.SegmentBestFitResponse sbfrManifestSensitivity)
	{
		try {
<span class="nc bnc" id="L976" title="All 2 branches missed.">			return org.drip.quant.common.NumberUtil.IsValid (dblLeftManifestSensitivity) &amp;&amp;</span>
<span class="nc bnc" id="L977" title="All 2 branches missed.">				org.drip.quant.common.NumberUtil.IsValid (dblLeftSlopeManifestSensitivity) &amp;&amp;</span>
<span class="nc bnc" id="L978" title="All 2 branches missed.">					org.drip.quant.common.NumberUtil.IsValid (dblRightManifestSensitivity) ?</span>
<span class="nc" id="L979">						calibrateLocalManifestJacobian (strManifestMeasure, new</span>
<span class="nc" id="L980">							org.drip.spline.params.SegmentStateCalibrationInputs (new double[] {left(),</span>
<span class="nc" id="L981">								right()}, new double[] {dblLeftManifestSensitivity,</span>
									dblRightManifestSensitivity},
										org.drip.quant.common.CollectionUtil.DerivArrayFromSlope
<span class="nc" id="L984">											(numParameters() - 2, dblLeftSlopeManifestSensitivity), null,</span>
												null, sbfrManifestSensitivity), null) : true;
<span class="nc" id="L986">		} catch (java.lang.Exception e) {</span>
<span class="nc" id="L987">			e.printStackTrace();</span>
		}

<span class="nc" id="L990">		return false;</span>
	}

	/**
	 * Compute the Local and the Preceeding Manifest Measure Sensitivity Coefficients from the Local
	 * 	Response Value/Sensitivity Constraints at the Left/Right Predictor Ordinate, the Local Left
	 * 	Response Value Sensitivity Slope, and the Local Best Fit Response Sensitivity
	 * 
	 * @param strManifestMeasure Manifest Measure whose Sensitivity is sought
	 * @param wrvcStateLeft Left Edge Response Value Constraint
	 * @param wrvcStateRight Right Edge Response Value Constraint
	 * @param dblLeftSlopeManifestSensitivity Left Edge Response Value Slope Manifest Sensitivity
	 * @param wrvcStateLeftManifestSensitivity Left Edge Response Value Constraint Manifest Sensitivity
	 * @param wrvcStateRightManifestSensitivity Right Edge Response Value Constraint Manifest Sensitivity
	 * @param sbfrManifestSensitivity Segment's Best Fit Weighted Response Manifest Sensitivity
	 * 
	 * @return TRUE - If the calibration succeeds
	 */

	public boolean manifestMeasureSensitivity (
		final java.lang.String strManifestMeasure,
		final org.drip.spline.params.SegmentResponseValueConstraint wrvcStateLeft,
		final org.drip.spline.params.SegmentResponseValueConstraint wrvcStateRight,
		final double dblLeftSlopeManifestSensitivity,
		final org.drip.spline.params.SegmentResponseValueConstraint wrvcStateLeftManifestSensitivity,
		final org.drip.spline.params.SegmentResponseValueConstraint wrvcStateRightManifestSensitivity,
		final org.drip.spline.params.SegmentBestFitResponse sbfrManifestSensitivity)
	{
<span class="fc" id="L1018">		org.drip.spline.params.SegmentBasisFlexureConstraint[] aSBFCState = null;</span>
<span class="fc" id="L1019">		org.drip.spline.params.SegmentBasisFlexureConstraint[] aSBFCManifestSensitivity = null;</span>

		try {
<span class="pc bpc" id="L1022" title="3 of 4 branches missed.">			if (null != wrvcStateLeft || null != wrvcStateRight)</span>
<span class="pc bpc" id="L1023" title="1 of 2 branches missed.">				aSBFCState = new org.drip.spline.params.SegmentBasisFlexureConstraint[] {null ==</span>
<span class="pc bpc" id="L1024" title="1 of 2 branches missed.">					wrvcStateLeft ? null : wrvcStateLeft.responseIndexedBasisConstraint (_be, this), null ==</span>
<span class="fc" id="L1025">						wrvcStateRight ? null : wrvcStateRight.responseIndexedBasisConstraint (_be, this)};</span>

<span class="pc bpc" id="L1027" title="3 of 4 branches missed.">			if (null != wrvcStateLeftManifestSensitivity || null != wrvcStateRightManifestSensitivity)</span>
<span class="pc bpc" id="L1028" title="1 of 2 branches missed.">				aSBFCManifestSensitivity = new org.drip.spline.params.SegmentBasisFlexureConstraint[] {null</span>
					== wrvcStateLeftManifestSensitivity ? null :
<span class="pc bpc" id="L1030" title="1 of 2 branches missed.">						wrvcStateLeftManifestSensitivity.responseIndexedBasisConstraint (_be, this), null ==</span>
							wrvcStateRightManifestSensitivity ? null :
<span class="fc" id="L1032">								wrvcStateRightManifestSensitivity.responseIndexedBasisConstraint (_be,</span>
									this)};

<span class="pc bpc" id="L1035" title="1 of 2 branches missed.">			return null == aSBFCManifestSensitivity ? true : calibrateLocalManifestJacobian</span>
<span class="fc" id="L1036">				(strManifestMeasure, new org.drip.spline.params.SegmentStateCalibrationInputs (null, null,</span>
<span class="fc" id="L1037">					org.drip.quant.common.CollectionUtil.DerivArrayFromSlope (numParameters() - 2,</span>
						dblLeftSlopeManifestSensitivity), null, aSBFCManifestSensitivity,
							sbfrManifestSensitivity), aSBFCState);
<span class="nc" id="L1040">		} catch (java.lang.Exception e) {</span>
<span class="nc" id="L1041">			e.printStackTrace();</span>
		}

<span class="nc" id="L1044">		return false;</span>
	}

	/**
	 * Retrieve the Segment Curvature DPE
	 * 
	 * @return The Segment Curvature DPE
	 * 
	 * @throws java.lang.Exception Thrown if the Segment Curvature DPE cannot be computed
	 */

	public double curvatureDPE()
		throws java.lang.Exception
	{
<span class="fc" id="L1058">		double dblDPE = 0.;</span>

<span class="fc" id="L1060">		int iNumBasis = _be.numBasis();</span>

<span class="fc" id="L1062">		org.drip.spline.params.SegmentFlexurePenaltyControl sfpc = _sidc.curvaturePenaltyControl();</span>

<span class="pc bpc" id="L1064" title="1 of 2 branches missed.">		if (null == sfpc) sfpc = new org.drip.spline.params.SegmentFlexurePenaltyControl (2, 1.);</span>

<span class="fc" id="L1066">		org.drip.spline.segment.BestFitFlexurePenalizer bffp = new</span>
			org.drip.spline.segment.BestFitFlexurePenalizer (this, sfpc, null, null, _be);

<span class="fc bfc" id="L1069" title="All 2 branches covered.">		for (int i = 0; i &lt; iNumBasis; ++i) {</span>
<span class="fc bfc" id="L1070" title="All 2 branches covered.">			for (int j = 0; j &lt; iNumBasis; ++j)</span>
<span class="fc" id="L1071">				dblDPE += _adblResponseBasisCoeff[i] * _adblResponseBasisCoeff[j] *</span>
<span class="fc" id="L1072">					bffp.basisPairCurvaturePenalty (i, j);</span>
		}

<span class="fc" id="L1075">		return sfpc.amplitude() * dblDPE;</span>
	}

	/**
	 * Retrieve the Segment Length DPE
	 * 
	 * @return The Segment Length DPE
	 * 
	 * @throws java.lang.Exception Thrown if the Segment Length DPE cannot be computed
	 */

	public double lengthDPE()
		throws java.lang.Exception
	{
<span class="fc" id="L1089">		double dblDPE = 0.;</span>

<span class="fc" id="L1091">		int iNumBasis = _be.numBasis();</span>

<span class="fc" id="L1093">		org.drip.spline.params.SegmentFlexurePenaltyControl sfpcLength = _sidc.lengthPenaltyControl();</span>

<span class="pc bpc" id="L1095" title="1 of 2 branches missed.">		if (null == sfpcLength) sfpcLength = new org.drip.spline.params.SegmentFlexurePenaltyControl (1, 1.);</span>

<span class="fc" id="L1097">		org.drip.spline.segment.BestFitFlexurePenalizer bffp = new</span>
			org.drip.spline.segment.BestFitFlexurePenalizer (this, null, sfpcLength, null, _be);

<span class="fc bfc" id="L1100" title="All 2 branches covered.">		for (int i = 0; i &lt; iNumBasis; ++i) {</span>
<span class="fc bfc" id="L1101" title="All 2 branches covered.">			for (int j = 0; j &lt; iNumBasis; ++j)</span>
<span class="fc" id="L1102">				dblDPE += _adblResponseBasisCoeff[i] * _adblResponseBasisCoeff[j] *</span>
<span class="fc" id="L1103">					bffp.basisPairLengthPenalty (i, j);</span>
		}

<span class="fc" id="L1106">		return sfpcLength.amplitude() * dblDPE;</span>
	}

	/**
	 * Retrieve the Segment Best Fit DPE
	 * 
	 * @param sbfr The Segment's Best Fit Response Inputs
	 * 
	 * @return The Segment Best Fit DPE
	 * 
	 * @throws java.lang.Exception Thrown if the Segment Best Fit DPE cannot be computed
	 */

	public double bestFitDPE (
		final org.drip.spline.params.SegmentBestFitResponse sbfr)
		throws java.lang.Exception
	{
<span class="fc bfc" id="L1123" title="All 2 branches covered.">		if (null == sbfr) return 0.;</span>

<span class="fc" id="L1125">		double dblDPE = 0.;</span>

<span class="fc" id="L1127">		int iNumBasis = _be.numBasis();</span>

<span class="fc" id="L1129">		org.drip.spline.segment.BestFitFlexurePenalizer bffp = new</span>
			org.drip.spline.segment.BestFitFlexurePenalizer (this, null, null, sbfr, _be);

<span class="fc bfc" id="L1132" title="All 2 branches covered.">		for (int i = 0; i &lt; iNumBasis; ++i) {</span>
<span class="fc bfc" id="L1133" title="All 2 branches covered.">			for (int j = 0; j &lt; iNumBasis; ++j)</span>
<span class="fc" id="L1134">				dblDPE += _adblResponseBasisCoeff[i] * _adblResponseBasisCoeff[j] * bffp.basisBestFitPenalty</span>
<span class="fc" id="L1135">					(i, j);</span>
		}

<span class="fc" id="L1138">		return dblDPE;</span>
	}

	/**
	 * Calculate the Response Value at the given Predictor Ordinate
	 * 
	 * @param dblPredictorOrdinate Predictor Ordinate
	 * 
	 * @return The Response Value
	 * 
	 * @throws java.lang.Exception Thrown if the calculation did not succeed
	 */

	public double responseValue (
		final double dblPredictorOrdinate)
		throws java.lang.Exception
	{
<span class="fc" id="L1155">		return _be.responseValue (_adblResponseBasisCoeff, dblPredictorOrdinate);</span>
	}

	/**
	 * Calculate the Ordered Response Value Derivative at the Predictor Ordinate
	 * 
	 * @param dblPredictorOrdinate Predictor Ordinate at which the ordered Response Derivative is to be
	 * 	calculated
	 * @param iOrder Derivative Order
	 * 
	 * @throws java.lang.Exception Thrown if the Ordered Response Value Derivative cannot be calculated
	 * 
	 * @return Retrieve the Ordered Response Value Derivative
	 */

	public double calcResponseValueDerivative (
		final double dblPredictorOrdinate,
		final int iOrder)
		throws java.lang.Exception
	{
<span class="fc bfc" id="L1175" title="All 2 branches covered.">		return 0 == iOrder ? responseValue (dblPredictorOrdinate) : _be.responseValueDerivative</span>
<span class="fc" id="L1176">			(_adblResponseBasisCoeff, dblPredictorOrdinate, iOrder);</span>
	}

	/**
	 * Calculate the Ordered Derivative of the Response to the Manifest
	 * 
	 * @param strManifestMeasure Manifest Measure whose Sensitivity is sought
	 * @param dblPredictorOrdinate Predictor Ordinate at which the ordered Derivative of the Response to the
	 * 	Manifest is to be calculated
	 * @param iOrder Derivative Order
	 * 
	 * @throws java.lang.Exception Thrown if the Ordered Derivative of the Response to the Manifest cannot be
	 *  calculated
	 * 
	 * @return Retrieve the Ordered Derivative of the Response to the Manifest
	 */

	public double calcDResponseDManifest (
		final java.lang.String strManifestMeasure,
		final double dblPredictorOrdinate,
		final int iOrder)
		throws java.lang.Exception
	{
<span class="pc bpc" id="L1199" title="1 of 2 branches missed.">		if (0 == iOrder)</span>
<span class="nc" id="L1200">			throw new java.lang.Exception</span>
				(&quot;LatentStateResponseModel::calcDResponseDManifest =&gt; Invalid Inputs&quot;);

<span class="fc" id="L1203">		org.drip.spline.segment.LatentStateManifestSensitivity lsms = manifestSensitivity</span>
<span class="fc" id="L1204">			(strManifestMeasure);</span>

<span class="pc bpc" id="L1206" title="1 of 2 branches missed.">		if (null == lsms)</span>
<span class="nc" id="L1207">			throw new java.lang.Exception</span>
				(&quot;LatentStateResponseModel::calcDResponseDManifest =&gt; Invalid Inputs&quot;);

<span class="fc" id="L1210">		return _be.responseValue (lsms.getDBasisCoeffDLocalManifest(), dblPredictorOrdinate);</span>
	}

	/**
	 * Calculate the Ordered Derivative of the Response to the Preceeding Manifest
	 * 
	 * @param strManifestMeasure Manifest Measure whose Sensitivity is sought
	 * @param dblPredictorOrdinate Predictor Ordinate at which the ordered Derivative of the Response to the
	 * 	Manifest is to be calculated
	 * @param iOrder Derivative Order
	 * 
	 * @throws java.lang.Exception Thrown if the Ordered Derivative of the Response to the Manifest cannot be
	 *  calculated
	 * 
	 * @return Retrieve the Ordered Derivative of the Response to the Preceeding Manifest
	 */

	public double calcDResponseDPreceedingManifest (
		final java.lang.String strManifestMeasure,
		final double dblPredictorOrdinate,
		final int iOrder)
		throws java.lang.Exception
	{
<span class="nc bnc" id="L1233" title="All 2 branches missed.">		if (0 == iOrder)</span>
<span class="nc" id="L1234">			throw new java.lang.Exception</span>
				(&quot;LatentStateResponseModel::calcDResponseDPreceedingManifest =&gt; Invalid Inputs&quot;);

<span class="nc" id="L1237">		org.drip.spline.segment.LatentStateManifestSensitivity lsms = manifestSensitivity</span>
<span class="nc" id="L1238">			(strManifestMeasure);</span>

<span class="nc bnc" id="L1240" title="All 2 branches missed.">		if (null == lsms)</span>
<span class="nc" id="L1241">			throw new java.lang.Exception</span>
				(&quot;LatentStateResponseModel::calcDResponseDPreceedingManifest =&gt; Cannot locate state Manifest sensitivity&quot;);

<span class="nc" id="L1244">		org.drip.spline.params.PreceedingManifestSensitivityControl pqsc = lsms.getPMSC();</span>

<span class="nc" id="L1246">		double dblDResponseDPreceedingManifest = lsms.getDResponseDPreceedingManifest();</span>

<span class="nc bnc" id="L1248" title="All 2 branches missed.">		if (!pqsc.impactFade())</span>
<span class="nc bnc" id="L1249" title="All 2 branches missed.">			return org.drip.quant.common.NumberUtil.IsValid (dblDResponseDPreceedingManifest) ?</span>
				dblDResponseDPreceedingManifest : 0.;

<span class="nc" id="L1252">		org.drip.spline.segment.BasisEvaluator be = pqsc.basisEvaluator();</span>

<span class="nc" id="L1254">		double[] adblDBasisCoeffDPreceedingManifest = lsms.getDBasisCoeffDPreceedingManifest();</span>

<span class="nc bnc" id="L1256" title="All 4 branches missed.">		return null == adblDBasisCoeffDPreceedingManifest ? 0. : (null == be ? _be : be).responseValue</span>
<span class="nc" id="L1257">			(adblDBasisCoeffDPreceedingManifest, dblPredictorOrdinate);</span>
	}

	/**
	 * Retrieve the Manifest Measure Preceeding Manifest Impact Flag
	 * 
	 * @param strManifestMeasure Manifest Measure whose Sensitivity is sought
	 * 
	 * @return The Manifest Measure Preceeding Manifest Impact Flag
	 * 
	 * @throws java.lang.Exception Thrown if the Inputs are Invalid
	 */

	public boolean impactFade (
		final java.lang.String strManifestMeasure)
		throws java.lang.Exception
	{
<span class="nc" id="L1274">		org.drip.spline.segment.LatentStateManifestSensitivity lsms = manifestSensitivity</span>
<span class="nc" id="L1275">			(strManifestMeasure);</span>

<span class="nc bnc" id="L1277" title="All 2 branches missed.">		if (null == lsms)</span>
<span class="nc" id="L1278">			throw new java.lang.Exception</span>
				(&quot;LatentStateResponseModel::impactFade =&gt; Cannot locate state Manifest sensitivity&quot;);

<span class="nc" id="L1281">		return lsms.getPMSC().impactFade();</span>
	}

	/**
	 * Calculate the Jacobian of the Segment's Response Basis Function Coefficients to the Edge Inputs
	 * 
	 * @return The Jacobian of the Segment's Response Basis Function Coefficients to the Edge Inputs
	 */

	public org.drip.quant.calculus.WengertJacobian jackDCoeffDEdgeInputs()
	{
<span class="fc bfc" id="L1292" title="All 2 branches covered.">		if (null != _wjDBasisCoeffDEdgeValue) return _wjDBasisCoeffDEdgeValue;</span>

<span class="fc" id="L1294">		int iNumResponseBasisCoeff = _be.numBasis();</span>

		try {
<span class="fc" id="L1297">			_wjDBasisCoeffDEdgeValue = new org.drip.quant.calculus.WengertJacobian (iNumResponseBasisCoeff,</span>
				iNumResponseBasisCoeff);
<span class="nc" id="L1299">		} catch (java.lang.Exception e) {</span>
<span class="nc" id="L1300">			e.printStackTrace();</span>

<span class="nc" id="L1302">			return _wjDBasisCoeffDEdgeValue = null;</span>
<span class="fc" id="L1303">		}</span>

<span class="fc bfc" id="L1305" title="All 2 branches covered.">		for (int i = 0; i &lt; iNumResponseBasisCoeff; ++i) {</span>
<span class="pc bpc" id="L1306" title="1 of 2 branches missed.">			if (!_wjDBasisCoeffDEdgeValue.setWengert (i, _adblResponseBasisCoeff[i]))</span>
<span class="nc" id="L1307">				return _wjDBasisCoeffDEdgeValue = null;</span>
		}

<span class="fc bfc" id="L1310" title="All 2 branches covered.">		if (null == _aadblDResponseBasisCoeffDConstraint) return null;</span>

<span class="fc" id="L1312">		int iSize = _aadblDResponseBasisCoeffDConstraint.length;</span>

<span class="fc bfc" id="L1314" title="All 2 branches covered.">		for (int i = 0; i &lt; iSize; ++i) {</span>
<span class="fc bfc" id="L1315" title="All 2 branches covered.">			for (int j = 0; j &lt; iSize; ++j) {</span>
<span class="pc bpc" id="L1316" title="1 of 2 branches missed.">				if (!_wjDBasisCoeffDEdgeValue.accumulatePartialFirstDerivative (i, j,</span>
					_aadblDResponseBasisCoeffDConstraint[i][j]))
<span class="nc" id="L1318">					return null;</span>
			}
		}

<span class="fc" id="L1322">		return _wjDBasisCoeffDEdgeValue;</span>
	}

	/**
	 * Calculate the Jacobian of the Response to the Edge Inputs at the given Predictor Ordinate
	 * 
	 * @param dblPredictorOrdinate The Predictor Ordinate
	 * @param iOrder Order of the Derivative Desired
	 * 
	 * @return The Jacobian of the Response to the Edge Inputs at the given Predictor Ordinate
	 */

	public org.drip.quant.calculus.WengertJacobian jackDResponseDEdgeInput (
		final double dblPredictorOrdinate,
		final int iOrder)
	{
		try {
<span class="fc" id="L1339">			int iNumResponseBasisCoeff = _be.numBasis();</span>

<span class="fc" id="L1341">			org.drip.quant.calculus.WengertJacobian wjDResponseDEdgeParams = null;</span>
<span class="fc" id="L1342">			double[][] aadblDBasisCoeffDEdgeParams = new</span>
				double[iNumResponseBasisCoeff][iNumResponseBasisCoeff];

<span class="fc" id="L1345">			double[] adblDResponseDBasisCoeff = DResponseDBasisCoeff (dblPredictorOrdinate, iOrder);</span>

<span class="pc bpc" id="L1347" title="2 of 4 branches missed.">			if (null == adblDResponseDBasisCoeff || iNumResponseBasisCoeff !=</span>
				adblDResponseDBasisCoeff.length)
<span class="nc" id="L1349">				return null;</span>

<span class="fc bfc" id="L1351" title="All 2 branches covered.">			org.drip.quant.calculus.WengertJacobian wjDBasisCoeffDEdgeParams = (null ==</span>
<span class="fc" id="L1352">				_wjDBasisCoeffDEdgeValue) ? jackDCoeffDEdgeInputs() : _wjDBasisCoeffDEdgeValue;</span>

<span class="fc bfc" id="L1354" title="All 2 branches covered.">			for (int i = 0; i &lt; iNumResponseBasisCoeff; ++i) {</span>
<span class="fc bfc" id="L1355" title="All 2 branches covered.">				for (int j = 0; j &lt; iNumResponseBasisCoeff; ++j)</span>
<span class="fc" id="L1356">					aadblDBasisCoeffDEdgeParams[j][i] = wjDBasisCoeffDEdgeParams.firstDerivative (j, i);</span>
			}

<span class="fc" id="L1359">			if (!(wjDResponseDEdgeParams = new org.drip.quant.calculus.WengertJacobian (1,</span>
<span class="pc bpc" id="L1360" title="1 of 2 branches missed.">				iNumResponseBasisCoeff)).setWengert (0, responseValue (dblPredictorOrdinate)))</span>
<span class="nc" id="L1361">				return null;</span>

<span class="fc bfc" id="L1363" title="All 2 branches covered.">			for (int i = 0; i &lt; iNumResponseBasisCoeff; ++i) {</span>
<span class="fc bfc" id="L1364" title="All 2 branches covered.">				for (int j = 0; j &lt; iNumResponseBasisCoeff; ++j) {</span>
<span class="pc bpc" id="L1365" title="1 of 2 branches missed.">					if (!wjDResponseDEdgeParams.accumulatePartialFirstDerivative (0, i,</span>
						adblDResponseDBasisCoeff[j] * aadblDBasisCoeffDEdgeParams[j][i]))
<span class="nc" id="L1367">						return null;</span>
				}
			}

<span class="fc" id="L1371">			return wjDResponseDEdgeParams;</span>
<span class="nc" id="L1372">		} catch (java.lang.Exception e) {</span>
<span class="nc" id="L1373">			e.printStackTrace();</span>
		}

<span class="nc" id="L1376">		return null;</span>
	}

	/**
	 * Calculate the Jacobian of the Response to the Basis Coefficients at the given Predictor Ordinate
	 * 
	 * @param dblPredictorOrdinate The Predictor Ordinate
	 * @param iOrder Order of the Derivative Desired
	 * 
	 * @return The Jacobian of the Response to the Basis Coefficients at the given Predictor Ordinate
	 */

	public org.drip.quant.calculus.WengertJacobian jackDResponseDBasisCoeff (
		final double dblPredictorOrdinate,
		final int iOrder)
	{
		try {
<span class="nc" id="L1393">			int iNumResponseBasisCoeff = _be.numBasis();</span>

<span class="nc" id="L1395">			double[] adblBasisDResponseDBasisCoeff = DResponseDBasisCoeff (dblPredictorOrdinate, iOrder);</span>

<span class="nc bnc" id="L1397" title="All 4 branches missed.">			if (null == adblBasisDResponseDBasisCoeff || iNumResponseBasisCoeff !=</span>
				adblBasisDResponseDBasisCoeff.length)
<span class="nc" id="L1399">				return null;</span>

<span class="nc" id="L1401">			org.drip.quant.calculus.WengertJacobian wjDResponseDBasisCoeff = new</span>
				org.drip.quant.calculus.WengertJacobian (1, iNumResponseBasisCoeff);

<span class="nc bnc" id="L1404" title="All 2 branches missed.">			for (int i = 0; i &lt; iNumResponseBasisCoeff; ++i) {</span>
<span class="nc bnc" id="L1405" title="All 2 branches missed.">				if (!wjDResponseDBasisCoeff.accumulatePartialFirstDerivative (0, i,</span>
					adblBasisDResponseDBasisCoeff[i]))
<span class="nc" id="L1407">					return null;</span>
			}

<span class="nc" id="L1410">			return wjDResponseDBasisCoeff;</span>
<span class="nc" id="L1411">		} catch (java.lang.Exception e) {</span>
<span class="nc" id="L1412">			e.printStackTrace();</span>
		}

<span class="nc" id="L1415">		return null;</span>
	}

	/**
	 * Calibrate the segment and calculate the Jacobian of the Segment's Response Basis Function Coefficients
	 *  to the Edge Parameters
	 * 
	 * @param adblPredictorOrdinate Array of Predictor Ordinates
	 * @param adblResponseValue Array of Response Values
	 * @param adblLeftEdgeDeriv Array of Left Edge Derivatives
	 * @param adblRightEdgeDeriv Array of Right Edge Derivatives
	 * @param aSBFC Array of Segment Flexure Constraints, expressed as Basis Coefficients
	 * @param sbfr Segment Best Fit Response Instance
	 * 
	 * @return The Jacobian of the Segment's Response Basis Function Coefficients to the Edge Parameters
	 */

	public org.drip.quant.calculus.WengertJacobian jackDCoeffDEdgeParams (
		final double[] adblPredictorOrdinate,
		final double[] adblResponseValue,
		final double[] adblLeftEdgeDeriv,
		final double[] adblRightEdgeDeriv,
		final org.drip.spline.params.SegmentBasisFlexureConstraint[] aSBFC,
		final org.drip.spline.params.SegmentBestFitResponse sbfr)
	{
		try {
<span class="pc bpc" id="L1441" title="1 of 2 branches missed.">			return calibrateState (new org.drip.spline.params.SegmentStateCalibrationInputs</span>
				(adblPredictorOrdinate, adblResponseValue, adblLeftEdgeDeriv, adblRightEdgeDeriv, aSBFC,
<span class="pc" id="L1443">					sbfr)) ? jackDCoeffDEdgeInputs() : null;</span>
<span class="nc" id="L1444">		} catch (java.lang.Exception e) {</span>
<span class="nc" id="L1445">			e.printStackTrace();</span>
		}

<span class="nc" id="L1448">		return null;</span>
	}

	/**
	 * Calibrate the Coefficients from the Edge Response Values and the Left Edge Response Value Slope and
	 *  calculate the Jacobian of the Segment's Response Basis Function Coefficients to the Edge Parameters
	 * 
	 * @param dblLeftValue Left Edge Response Value
	 * @param dblLeftSlope Left Edge Response Slope
	 * @param dblRightValue Right Edge Response Value
	 * @param sbfrState Segment's Best Fit Weighted Response Values
	 * 
	 * @return The Jacobian of the Segment's Response Basis Function Coefficients to the Edge Parameters
	 */

	public org.drip.quant.calculus.WengertJacobian jackDCoeffDEdgeParams (
		final double dblLeftValue,
		final double dblLeftSlope,
		final double dblRightValue,
		final org.drip.spline.params.SegmentBestFitResponse sbfrState)
	{
<span class="pc bpc" id="L1469" title="1 of 2 branches missed.">		return calibrate (dblLeftValue, dblLeftSlope, dblRightValue, sbfrState) ? jackDCoeffDEdgeInputs() :</span>
			null;
	}

	/**
	 * Calibrate the coefficients from the prior Segment and the Response Value at the Right Predictor
	 *  Ordinate and calculate the Jacobian of the Segment's Response Basis Function Coefficients to the Edge
	 *  Parameters
	 * 
	 * @param csPreceeding Previous Predictor/Response Segment
	 * @param strManifestMeasure Manifest Measure whose Sensitivity is sought
	 * @param dblRightStateValue Response Value at the Right Predictor Ordinate
	 * @param sbfrState Segment's Best Fit Weighted Response Values
	 * @param dblRightStateManifestSensitivity Response Value Manifest Sensitivity at the Right Predictor
	 * 	Ordinate
	 * @param sbfrManifestSensitivity Segment's Best Fit Weighted Response Value Manifest Sensitivity
	 * 
	 * @return The Jacobian
	 */

	public org.drip.quant.calculus.WengertJacobian jackDCoeffDEdgeParams (
		final LatentStateResponseModel csPreceeding,
		final java.lang.String strManifestMeasure,
		final double dblRightStateValue,
		final org.drip.spline.params.SegmentBestFitResponse sbfrState,
		final double dblRightStateManifestSensitivity,
		final org.drip.spline.params.SegmentBestFitResponse sbfrManifestSensitivity)
	{
<span class="pc bpc" id="L1497" title="1 of 2 branches missed.">		return !calibrate (csPreceeding, dblRightStateValue, sbfrState) || !manifestMeasureSensitivity</span>
<span class="pc bpc" id="L1498" title="1 of 2 branches missed.">			(csPreceeding, strManifestMeasure, dblRightStateManifestSensitivity, sbfrManifestSensitivity) ?</span>
<span class="fc" id="L1499">				null : jackDCoeffDEdgeInputs();</span>
	}

	/**
	 * Indicate whether the given segment is monotone. If monotone, may optionally indicate the nature of
	 * 	the extrema contained inside (maxima/minima/infection).
	 *  
	 * @return The monotone Type
	 */

	public org.drip.spline.segment.Monotonocity monotoneType()
	{
<span class="fc bfc" id="L1511" title="All 2 branches covered.">		if (1 &gt;= _sidc.Ck()) {</span>
			try {
<span class="fc" id="L1513">				return new org.drip.spline.segment.Monotonocity</span>
					(org.drip.spline.segment.Monotonocity.MONOTONIC);
<span class="nc" id="L1515">			} catch (java.lang.Exception e) {</span>
<span class="nc" id="L1516">				e.printStackTrace();</span>

<span class="nc" id="L1518">				return null;</span>
			}
		}

<span class="fc" id="L1522">		org.drip.function.definition.R1ToR1 ofDeriv = new</span>
<span class="fc" id="L1523">			org.drip.function.definition.R1ToR1 (null) {</span>
			@Override public double evaluate (
				final double dblX)
				throws java.lang.Exception
			{
<span class="fc" id="L1528">				return _be.responseValueDerivative (_adblResponseBasisCoeff, dblX, 1);</span>
			}

			@Override public org.drip.quant.calculus.Differential differential (
				final double dblX,
				final double dblOFBase,
				final int iOrder)
			{
				try {
<span class="nc" id="L1537">					double dblVariateInfinitesimal = _dc.getVariateInfinitesimal (dblX);</span>

<span class="nc" id="L1539">					return new org.drip.quant.calculus.Differential (dblVariateInfinitesimal,</span>
<span class="nc" id="L1540">						_be.responseValueDerivative (_adblResponseBasisCoeff, dblX, iOrder) *</span>
							dblVariateInfinitesimal);
<span class="nc" id="L1542">				} catch (java.lang.Exception e) {</span>
<span class="nc" id="L1543">					e.printStackTrace();</span>
				}

<span class="nc" id="L1546">				return null;</span>
			}

			@Override public double integrate (
				final double dblBegin,
				final double dblEnd)
				throws java.lang.Exception
			{
<span class="nc" id="L1554">				return org.drip.quant.calculus.R1ToR1Integrator.Boole (this, dblBegin, dblEnd);</span>
			}
		};

		try {
<span class="fc" id="L1559">			org.drip.function.r1tor1solver.FixedPointFinderOutput fpop = new</span>
				org.drip.function.r1tor1solver.FixedPointFinderBrent (0., ofDeriv, false).findRoot
<span class="fc" id="L1561">					(org.drip.function.r1tor1solver.InitializationHeuristics.FromHardSearchEdges (0., 1.));</span>

<span class="pc bpc" id="L1563" title="1 of 4 branches missed.">			if (null == fpop || !fpop.containsRoot())</span>
<span class="fc" id="L1564">				return new org.drip.spline.segment.Monotonocity</span>
					(org.drip.spline.segment.Monotonocity.MONOTONIC);

<span class="fc" id="L1567">			double dblExtremum = fpop.getRoot();</span>

<span class="pc bpc" id="L1569" title="3 of 6 branches missed.">			if (!org.drip.quant.common.NumberUtil.IsValid (dblExtremum) || dblExtremum &lt;= 0. || dblExtremum</span>
				&gt;= 1.)
<span class="nc" id="L1571">				return new org.drip.spline.segment.Monotonocity</span>
					(org.drip.spline.segment.Monotonocity.MONOTONIC);

<span class="fc" id="L1574">			double dbl2ndDeriv = _be.responseValueDerivative (_adblResponseBasisCoeff, dblExtremum, 2);</span>

<span class="pc bpc" id="L1576" title="1 of 2 branches missed.">			if (0. &gt; dbl2ndDeriv)</span>
<span class="nc" id="L1577">				return new org.drip.spline.segment.Monotonocity</span>
					(org.drip.spline.segment.Monotonocity.MAXIMA);

<span class="pc bpc" id="L1580" title="1 of 2 branches missed.">			if (0. &lt; dbl2ndDeriv)</span>
<span class="fc" id="L1581">				return new org.drip.spline.segment.Monotonocity</span>
					(org.drip.spline.segment.Monotonocity.MINIMA);

<span class="nc bnc" id="L1584" title="All 2 branches missed.">			if (0. == dbl2ndDeriv)</span>
<span class="nc" id="L1585">				return new org.drip.spline.segment.Monotonocity</span>
					(org.drip.spline.segment.Monotonocity.INFLECTION);

<span class="nc" id="L1588">			return new org.drip.spline.segment.Monotonocity</span>
				(org.drip.spline.segment.Monotonocity.NON_MONOTONIC);
<span class="nc" id="L1590">		} catch (java.lang.Exception e) {</span>
<span class="nc" id="L1591">			e.printStackTrace();</span>
		}

		try {
<span class="nc" id="L1595">			return new org.drip.spline.segment.Monotonocity (org.drip.spline.segment.Monotonocity.MONOTONIC);</span>
<span class="nc" id="L1596">		} catch (java.lang.Exception e) {</span>
<span class="nc" id="L1597">			e.printStackTrace();</span>
		}

<span class="nc" id="L1600">		return null;</span>
	}

	/**
	 * Clip the part of the Segment to the Right of the specified Predictor Ordinate. Retain all other
	 * 	constraints the same.
	 * 
	 * @param dblPredictorOrdinate The Predictor Ordinate
	 * 
	 * @return The Clipped Segment
	 */

	public LatentStateResponseModel clipLeftOfPredictorOrdinate (
		final double dblPredictorOrdinate)
	{
		try {
<span class="fc" id="L1616">			LatentStateResponseModel csLeftSnipped = LatentStateResponseModel.Create (dblPredictorOrdinate,</span>
<span class="fc" id="L1617">				right(), _be.replicate(), _sidc);</span>

<span class="fc" id="L1619">			int iCk = _sidc.Ck();</span>

<span class="pc bpc" id="L1621" title="1 of 2 branches missed.">			double[] adblCalibLeftEdgeDeriv = 0 != iCk ? csLeftSnipped.transmissionCk (dblPredictorOrdinate,</span>
				this, iCk) : null;

<span class="pc bpc" id="L1624" title="1 of 2 branches missed.">			return csLeftSnipped.calibrateState (new org.drip.spline.params.SegmentStateCalibrationInputs</span>
<span class="fc" id="L1625">				(new double[] {dblPredictorOrdinate, right()}, new double[] {responseValue</span>
<span class="fc" id="L1626">					(dblPredictorOrdinate), responseValue (right())}, adblCalibLeftEdgeDeriv, null, null,</span>
						null)) ? csLeftSnipped : null;
<span class="nc" id="L1628">		} catch (java.lang.Exception e) {</span>
<span class="nc" id="L1629">			e.printStackTrace();</span>
		}

<span class="nc" id="L1632">		return null;</span>
	}

	/**
	 * Clip the part of the Segment to the Right of the specified Predictor Ordinate. Retain all other
	 * 	constraints the same.
	 * 
	 * @param dblPredictorOrdinate The Predictor Ordinate
	 * 
	 * @return The Clipped Segment
	 */

	public LatentStateResponseModel clipRightOfPredictorOrdinate (
		final double dblPredictorOrdinate)
	{
		try {
<span class="fc" id="L1648">			LatentStateResponseModel csRightSnipped = LatentStateResponseModel.Create (left(),</span>
<span class="fc" id="L1649">				dblPredictorOrdinate, _be.replicate(), _sidc);</span>

<span class="fc" id="L1651">			int iCk = _sidc.Ck();</span>

<span class="pc bpc" id="L1653" title="1 of 2 branches missed.">			return csRightSnipped.calibrateState (new org.drip.spline.params.SegmentStateCalibrationInputs</span>
<span class="fc" id="L1654">				(new double[] {left(), dblPredictorOrdinate}, new double[] {responseValue (left()),</span>
<span class="pc bpc" id="L1655" title="1 of 2 branches missed.">					responseValue (dblPredictorOrdinate)}, 0 != iCk ? csRightSnipped.transmissionCk (left(),</span>
						this, iCk) : null, null, null, null)) ? csRightSnipped : null;
<span class="nc" id="L1657">		} catch (java.lang.Exception e) {</span>
<span class="nc" id="L1658">			e.printStackTrace();</span>
		}

<span class="nc" id="L1661">		return null;</span>
	}

	/**
	 * Display the string representation for diagnostic purposes
	 * 
	 * @return The string representation
	 */

	public java.lang.String displayString()
	{
<span class="nc" id="L1672">		java.lang.StringBuffer sb = new java.lang.StringBuffer();</span>

<span class="nc" id="L1674">		sb.append (&quot;\t\t\t[&quot; + left() + &quot; =&gt; &quot; + right() + &quot;\n&quot;);</span>

<span class="nc bnc" id="L1676" title="All 2 branches missed.">		for (int i = 0; i &lt; _adblResponseBasisCoeff.length; ++i) {</span>
<span class="nc bnc" id="L1677" title="All 2 branches missed.">			if (0 != i) sb.append (&quot;  |  &quot;);</span>

<span class="nc" id="L1679">			sb.append (_adblResponseBasisCoeff[i] + &quot;\n&quot;);</span>
		}

<span class="nc" id="L1682">		return sb.toString();</span>
	}
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.7.9.201702052155</span></div></body></html>