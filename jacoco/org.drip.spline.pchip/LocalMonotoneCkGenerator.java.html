<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>LocalMonotoneCkGenerator.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">DROP</a> &gt; <a href="index.source.html" class="el_package">org.drip.spline.pchip</a> &gt; <span class="el_source">LocalMonotoneCkGenerator.java</span></div><h1>LocalMonotoneCkGenerator.java</h1><pre class="source lang-java linenums">
package org.drip.spline.pchip;

/*
 * -*- mode: java; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*-
 */

/*!
 * Copyright (C) 2020 Lakshmi Krishnamurthy
 * Copyright (C) 2019 Lakshmi Krishnamurthy
 * Copyright (C) 2018 Lakshmi Krishnamurthy
 * Copyright (C) 2017 Lakshmi Krishnamurthy
 * Copyright (C) 2016 Lakshmi Krishnamurthy
 * Copyright (C) 2015 Lakshmi Krishnamurthy
 * Copyright (C) 2014 Lakshmi Krishnamurthy
 * Copyright (C) 2013 Lakshmi Krishnamurthy
 * 
 *  This file is part of DROP, an open-source library targeting analytics/risk, transaction cost analytics,
 *  	asset liability management analytics, capital, exposure, and margin analytics, valuation adjustment
 *  	analytics, and portfolio construction analytics within and across fixed income, credit, commodity,
 *  	equity, FX, and structured products. It also includes auxiliary libraries for algorithm support,
 *  	numerical analysis, numerical optimization, spline builder, model validation, statistical learning,
 *  	and computational support.
 *  
 *  	https://lakshmidrip.github.io/DROP/
 *  
 *  DROP is composed of three modules:
 *  
 *  - DROP Product Core - https://lakshmidrip.github.io/DROP-Product-Core/
 *  - DROP Portfolio Core - https://lakshmidrip.github.io/DROP-Portfolio-Core/
 *  - DROP Computational Core - https://lakshmidrip.github.io/DROP-Computational-Core/
 * 
 * 	DROP Product Core implements libraries for the following:
 * 	- Fixed Income Analytics
 * 	- Loan Analytics
 * 	- Transaction Cost Analytics
 * 
 * 	DROP Portfolio Core implements libraries for the following:
 * 	- Asset Allocation Analytics
 *  - Asset Liability Management Analytics
 * 	- Capital Estimation Analytics
 * 	- Exposure Analytics
 * 	- Margin Analytics
 * 	- XVA Analytics
 * 
 * 	DROP Computational Core implements libraries for the following:
 * 	- Algorithm Support
 * 	- Computation Support
 * 	- Function Analysis
 *  - Model Validation
 * 	- Numerical Analysis
 * 	- Numerical Optimizer
 * 	- Spline Builder
 *  - Statistical Learning
 * 
 * 	Documentation for DROP is Spread Over:
 * 
 * 	- Main                     =&gt; https://lakshmidrip.github.io/DROP/
 * 	- Wiki                     =&gt; https://github.com/lakshmiDRIP/DROP/wiki
 * 	- GitHub                   =&gt; https://github.com/lakshmiDRIP/DROP
 * 	- Repo Layout Taxonomy     =&gt; https://github.com/lakshmiDRIP/DROP/blob/master/Taxonomy.md
 * 	- Javadoc                  =&gt; https://lakshmidrip.github.io/DROP/Javadoc/index.html
 * 	- Technical Specifications =&gt; https://github.com/lakshmiDRIP/DROP/tree/master/Docs/Internal
 * 	- Release Versions         =&gt; https://lakshmidrip.github.io/DROP/version.html
 * 	- Community Credits        =&gt; https://lakshmidrip.github.io/DROP/credits.html
 * 	- Issues Catalog           =&gt; https://github.com/lakshmiDRIP/DROP/issues
 * 	- JUnit                    =&gt; https://lakshmidrip.github.io/DROP/junit/index.html
 * 	- Jacoco                   =&gt; https://lakshmidrip.github.io/DROP/jacoco/index.html
 * 
 *  Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 *   	you may not use this file except in compliance with the License.
 *   
 *  You may obtain a copy of the License at
 *  	http://www.apache.org/licenses/LICENSE-2.0
 *  
 *  Unless required by applicable law or agreed to in writing, software
 *  	distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 *  	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  
 *  See the License for the specific language governing permissions and
 *  	limitations under the License.
 */

/**
 * &lt;i&gt;LocalMonotoneCkGenerator&lt;/i&gt; generates customized Local Stretch by trading off Ck for local control.
 * This class implements the following variants: Akima, Bessel, Harmonic, Hyman83, Hyman89, Kruger, Monotone
 * Convex, as well as the Van Leer and the Huynh/LeFloch limiters. It also provides the following custom
 * control on the resulting C1:
 *
 * &lt;br&gt;&lt;br&gt;
 *  &lt;ul&gt;
 *  	&lt;li&gt;
 *  		Eliminate the Spurious Extrema in the Input C1 Entry
 *  	&lt;/li&gt;
 *  	&lt;li&gt;
 *  		Apply the Monotone Filter in the Input C1 Entry
 *  	&lt;/li&gt;
 *  	&lt;li&gt;
 *  		Generate a Vanilla C1 Array from the specified Array of Predictor Ordinates and the Response
 *  			Values
 *  	&lt;/li&gt;
 *  	&lt;li&gt;
 *  		Verify if the given Quintic Polynomial is Monotone using the Hyman89 Algorithm, and generate it
 *  			if necessary
 *  	&lt;/li&gt;
 *  &lt;/ul&gt;
 *
 * &lt;br&gt;&lt;br&gt;
 *  &lt;ul&gt;
 *		&lt;li&gt;&lt;b&gt;Module &lt;/b&gt; = &lt;a href = &quot;https://github.com/lakshmiDRIP/DROP/tree/master/ComputationalCore.md&quot;&gt;Computational Core Module&lt;/a&gt;&lt;/li&gt;
 *		&lt;li&gt;&lt;b&gt;Library&lt;/b&gt; = &lt;a href = &quot;https://github.com/lakshmiDRIP/DROP/tree/master/SplineBuilderLibrary.md&quot;&gt;Spline Builder Library&lt;/a&gt;&lt;/li&gt;
 *		&lt;li&gt;&lt;b&gt;Project&lt;/b&gt; = &lt;a href = &quot;https://github.com/lakshmiDRIP/DROP/tree/master/src/main/java/org/drip/spline/README.md&quot;&gt;Basis Splines and Linear Compounders across a Broad Family of Spline Basis Functions&lt;/a&gt;&lt;/li&gt;
 *		&lt;li&gt;&lt;b&gt;Package&lt;/b&gt; = &lt;a href = &quot;https://github.com/lakshmiDRIP/DROP/tree/master/src/main/java/org/drip/spline/pchip/README.md&quot;&gt;Monotone Convex Themed PCHIP Splines&lt;/a&gt;&lt;/li&gt;
 *  &lt;/ul&gt;
 * &lt;br&gt;&lt;br&gt;
 *
 * @author Lakshmi Krishnamurthy
 */

public class LocalMonotoneCkGenerator {

	/**
	 * C1 Type: Vanilla
	 */

	public static final java.lang.String C1_VANILLA = &quot;C1_VANILLA&quot;;

	/**
	 * C1 Type: Akima
	 */

	public static final java.lang.String C1_AKIMA = &quot;C1_AKIMA&quot;;

	/**
	 * C1 Type: Bessel
	 */

	public static final java.lang.String C1_BESSEL = &quot;C1_BESSEL&quot;;

	/**
	 * C1 Type: Harmonic
	 */

	public static final java.lang.String C1_HARMONIC = &quot;C1_HARMONIC&quot;;

	/**
	 * C1 Type: Huynh - Le Floch Limiter
	 */

	public static final java.lang.String C1_HUYNH_LE_FLOCH = &quot;C1_HUYNH_LE_FLOCH&quot;;

	/**
	 * C1 Type: Hyman83
	 */

	public static final java.lang.String C1_HYMAN83 = &quot;C1_HYMAN83&quot;;

	/**
	 * C1 Type: Hyman89
	 */

	public static final java.lang.String C1_HYMAN89 = &quot;C1_HYMAN89&quot;;

	/**
	 * C1 Type: Kruger
	 */

	public static final java.lang.String C1_KRUGER = &quot;C1_KRUGER&quot;;

	/**
	 * C1 Type: Monotone Convex
	 */

	public static final java.lang.String C1_MONOTONE_CONVEX = &quot;C1_MONOTONE_CONVEX&quot;;

	/**
	 * C1 Type: Van Leer Limiter
	 */

	public static final java.lang.String C1_VAN_LEER = &quot;C1_VAN_LEER&quot;;

<span class="fc" id="L182">	private double[] _adblC1 = null;</span>
<span class="fc" id="L183">	private double[] _adblResponseValue = null;</span>
<span class="fc" id="L184">	private double[] _adblPredictorOrdinate = null;</span>

	/**
	 * Eliminate the Spurious Extrema in the Input C1 Entry
	 * 
	 * @param adblC1 The C1 Array in which the Spurious Extrema is to be eliminated
	 * @param adblLinearC1 Array of the Linear C1 Entries
	 * 
	 * @return The C1 Array with the Spurious Extrema eliminated
	 */

	public static final double[] EliminateSpuriousExtrema (
		final double[] adblC1,
		final double[] adblLinearC1)
	{
<span class="pc bpc" id="L199" title="2 of 4 branches missed.">		if (null == adblC1 || null == adblLinearC1) return null;</span>

<span class="fc" id="L201">		int iNumEntries = adblC1.length;</span>
<span class="fc" id="L202">		double[] adblUpdatedC1 = new double[iNumEntries];</span>
<span class="fc" id="L203">		adblUpdatedC1[0] = adblC1[0];</span>
<span class="fc" id="L204">		adblUpdatedC1[iNumEntries - 1] = adblC1[iNumEntries - 1];</span>

<span class="pc bpc" id="L206" title="2 of 4 branches missed.">		if (1 &gt;= iNumEntries || iNumEntries != adblLinearC1.length + 1) return null;</span>

<span class="fc bfc" id="L208" title="All 2 branches covered.">		for (int i = 1; i &lt; iNumEntries - 1; ++i)</span>
<span class="fc bfc" id="L209" title="All 2 branches covered.">			adblUpdatedC1[i] = 0. &lt; adblLinearC1[i] ? java.lang.Math.min (java.lang.Math.max (0., adblC1[i]),</span>
<span class="fc" id="L210">				java.lang.Math.min (adblLinearC1[i], adblLinearC1[i - 1])) : java.lang.Math.max</span>
<span class="fc" id="L211">					(java.lang.Math.min (0., adblC1[i]), java.lang.Math.max (adblLinearC1[i],</span>
						adblLinearC1[i - 1]));

<span class="fc" id="L214">		return adblUpdatedC1;</span>
	}

	/**
	 * Apply the Monotone Filter in the Input C1 Entry
	 * 
	 * @param adblC1 The C1 Array in which the Monotone Filter is to be applied
	 * @param adblLinearC1 Array of the Linear C1 Entries
	 * 
	 * @return The C1 Array with the Monotone Filter applied
	 */

	public static final double[] ApplyMonotoneFilter (
		final double[] adblC1,
		final double[] adblLinearC1)
	{
<span class="pc bpc" id="L230" title="2 of 4 branches missed.">		if (null == adblC1 || null == adblLinearC1) return null;</span>

<span class="fc" id="L232">		int iNumEntries = adblC1.length;</span>
<span class="fc" id="L233">		double[] adblUpdatedC1 = new double[iNumEntries];</span>
<span class="fc" id="L234">		adblUpdatedC1[0] = adblC1[0];</span>

<span class="pc bpc" id="L236" title="2 of 4 branches missed.">		if (1 &gt;= iNumEntries || iNumEntries != adblLinearC1.length + 1) return null;</span>

<span class="fc bfc" id="L238" title="All 2 branches covered.">		for (int i = 0; i &lt; iNumEntries; ++i) {</span>
<span class="fc bfc" id="L239" title="All 2 branches covered.">			if (0 == i) {</span>
<span class="pc bpc" id="L240" title="1 of 4 branches missed.">				if (adblC1[0] * adblLinearC1[0] &gt; 0. &amp;&amp; adblLinearC1[0] * adblLinearC1[1] &gt; 0. &amp;&amp;</span>
<span class="fc bfc" id="L241" title="All 2 branches covered.">					java.lang.Math.abs (adblC1[0]) &lt; 3. * java.lang.Math.abs (adblLinearC1[0]))</span>
<span class="fc" id="L242">					adblUpdatedC1[0] = 3. * adblLinearC1[0];</span>
<span class="fc bfc" id="L243" title="All 2 branches covered.">				else if (adblC1[0] * adblLinearC1[0] &lt;= 0.)</span>
<span class="fc" id="L244">					adblUpdatedC1[0] = 0.;</span>
<span class="pc bpc" id="L245" title="1 of 2 branches missed.">			} else if (iNumEntries == i) {</span>
<span class="nc bnc" id="L246" title="All 4 branches missed.">				if (adblC1[i] * adblLinearC1[i - 1] &gt; 0. &amp;&amp; adblLinearC1[i - 1] * adblLinearC1[i - 2] &gt; 0. &amp;&amp;</span>
<span class="nc bnc" id="L247" title="All 2 branches missed.">					java.lang.Math.abs (adblC1[i]) &lt; 3. * java.lang.Math.abs (adblLinearC1[i - 1]))</span>
<span class="nc" id="L248">					adblUpdatedC1[i] = 3. * adblLinearC1[i - 1];</span>
<span class="nc bnc" id="L249" title="All 2 branches missed.">				else if (adblC1[i] * adblLinearC1[i - 1] &lt;= 0.)</span>
<span class="nc" id="L250">					adblUpdatedC1[i] = 0.;</span>
			} else
<span class="fc" id="L252">				adblUpdatedC1[i] = adblC1[i];</span>
		}

<span class="fc" id="L255">		return adblUpdatedC1;</span>
	}

	/**
	 * Generate a Vanilla C1 Array from the specified Array of Predictor Ordinates and the Response Values
	 * 
	 * @param adblPredictorOrdinate The Predictor Ordinate Array
	 * @param adblResponseValue The Response Value Array
	 * 
	 * @return The C1 Array
	 */

	public static final double[] LinearC1 (
		final double[] adblPredictorOrdinate,
		final double[] adblResponseValue)
	{
<span class="fc" id="L271">		int iNumSegment = adblResponseValue.length - 1;</span>
<span class="fc" id="L272">		double[] adblLinearC1 = new double[iNumSegment];</span>

<span class="fc bfc" id="L274" title="All 2 branches covered.">		for (int i = 0; i &lt; iNumSegment; ++i)</span>
<span class="fc" id="L275">			adblLinearC1[i] = (adblResponseValue[i + 1] - adblResponseValue[i]) /</span>
				(adblPredictorOrdinate[i + 1] - adblPredictorOrdinate[i]);

<span class="fc" id="L278">		return adblLinearC1;</span>
	}

	/**
	 * Generate a Bessel C1 Array from the specified Array of Predictor Ordinates and the Response Values
	 * 
	 * @param adblPredictorOrdinate The Predictor Ordinate Array
	 * @param adblResponseValue The Response Value Array
	 * 
	 * @return The C1 Array
	 */

	public static final double[] BesselC1 (
		final double[] adblPredictorOrdinate,
		final double[] adblResponseValue)
	{
<span class="fc" id="L294">		int iNumResponse = adblResponseValue.length;</span>
<span class="fc" id="L295">		double[] adblBesselC1 = new double[iNumResponse];</span>

<span class="fc bfc" id="L297" title="All 2 branches covered.">		for (int i = 0; i &lt; iNumResponse; ++i) {</span>
<span class="fc bfc" id="L298" title="All 2 branches covered.">			if (0 == i) {</span>
<span class="fc" id="L299">				adblBesselC1[i] = (adblPredictorOrdinate[2] + adblPredictorOrdinate[1] - 2. *</span>
					adblPredictorOrdinate[0]) * (adblResponseValue[1] - adblResponseValue[0]) /
						(adblPredictorOrdinate[1] - adblPredictorOrdinate[0]);
<span class="fc" id="L302">				adblBesselC1[i] -= (adblPredictorOrdinate[1] - adblPredictorOrdinate[0]) *</span>
					(adblResponseValue[2] - adblResponseValue[1]) / (adblPredictorOrdinate[2] -
						adblPredictorOrdinate[1]);
<span class="fc" id="L305">				adblBesselC1[i] /= (adblPredictorOrdinate[2] - adblPredictorOrdinate[0]);</span>
<span class="fc bfc" id="L306" title="All 2 branches covered.">			} else if (iNumResponse - 1 == i) {</span>
<span class="fc" id="L307">				adblBesselC1[i] = (adblPredictorOrdinate[iNumResponse - 1] -</span>
					adblPredictorOrdinate[iNumResponse - 2]) * (adblResponseValue[iNumResponse - 2] -
						adblResponseValue[iNumResponse - 3]) / (adblPredictorOrdinate[iNumResponse - 2] -
							adblPredictorOrdinate[iNumResponse - 3]);
<span class="fc" id="L311">				adblBesselC1[i] -= (2. * adblPredictorOrdinate[iNumResponse - 1] -</span>
					adblPredictorOrdinate[iNumResponse - 2] - adblPredictorOrdinate[iNumResponse - 3]) *
						(adblResponseValue[iNumResponse - 1] - adblResponseValue[iNumResponse - 2]) /
							(adblPredictorOrdinate[iNumResponse - 1] -
								adblPredictorOrdinate[iNumResponse - 2]);
<span class="fc" id="L316">				adblBesselC1[i] /= (adblPredictorOrdinate[iNumResponse - 1] -</span>
					adblPredictorOrdinate[iNumResponse - 3]);
			} else {
<span class="fc" id="L319">				adblBesselC1[i] = (adblPredictorOrdinate[i + 1] - adblPredictorOrdinate[i]) *</span>
					(adblResponseValue[i] - adblResponseValue[i - 1]) / (adblPredictorOrdinate[i] -
						adblPredictorOrdinate[i - 1]);
<span class="fc" id="L322">				adblBesselC1[i] += (adblPredictorOrdinate[i] - adblPredictorOrdinate[i - 1]) *</span>
					(adblResponseValue[i + 1] - adblResponseValue[i]) / (adblPredictorOrdinate[i + 1] -
						adblPredictorOrdinate[i]);
<span class="fc" id="L325">				adblBesselC1[i] /= (adblPredictorOrdinate[iNumResponse - 1] -</span>
					adblPredictorOrdinate[iNumResponse - 3]);
			}
		}

<span class="fc" id="L330">		return adblBesselC1;</span>
	}

	/**
	 * Generate a Hyman83 C1 Array from the specified Array of Predictor Ordinates and the Response Values
	 * 
	 * 	Hyman (1983) Accurate Monotonicity Preserving Cubic Interpolation -
	 *  	SIAM J on Numerical Analysis 4 (4), 645-654.
	 * 
	 * @param adblPredictorOrdinate The Predictor Ordinate Array
	 * @param adblResponseValue The Response Value Array
	 * 
	 * @return The C1 Array
	 */

	public static final double[] Hyman83C1 (
		final double[] adblPredictorOrdinate,
		final double[] adblResponseValue)
	{
<span class="fc" id="L349">		int iNumResponse = adblResponseValue.length;</span>
<span class="fc" id="L350">		double dblLinearSlopePrev = java.lang.Double.NaN;</span>
<span class="fc" id="L351">		double[] adblHyman83C1 = new double[iNumResponse];</span>

<span class="fc bfc" id="L353" title="All 2 branches covered.">		for (int i = 0; i &lt; iNumResponse; ++i) {</span>
<span class="fc" id="L354">			adblHyman83C1[i] = 0.;</span>
<span class="fc bfc" id="L355" title="All 2 branches covered.">			double dblLinearSlope = iNumResponse - 1 != i ? (adblResponseValue[i + 1] - adblResponseValue[i])</span>
				/ (adblPredictorOrdinate[i + 1] - adblPredictorOrdinate[i]) : java.lang.Double.NaN;

<span class="fc bfc" id="L358" title="All 4 branches covered.">			if (0 != i &amp;&amp; iNumResponse - 1 != i) {</span>
<span class="fc" id="L359">				double dblMonotoneIndicator = dblLinearSlopePrev * dblLinearSlope;</span>

<span class="fc bfc" id="L361" title="All 2 branches covered.">				if (0. &lt;= dblMonotoneIndicator)</span>
<span class="fc" id="L362">					adblHyman83C1[i] = 3. * dblMonotoneIndicator / (java.lang.Math.max (dblLinearSlope,</span>
<span class="fc" id="L363">						dblLinearSlopePrev) + 2. * java.lang.Math.min (dblLinearSlope, dblLinearSlopePrev));</span>
			}

<span class="fc" id="L366">			dblLinearSlopePrev = dblLinearSlope;</span>
		}

<span class="fc" id="L369">		return adblHyman83C1;</span>
	}

	/**
	 * Generate a Hyman89 C1 Array from the specified Array of Predictor Ordinates and the Response Values
	 * 
	 * 	Doherty, Edelman, and Hyman (1989) Non-negative, monotonic, or convexity preserving cubic and quintic
	 *  	Hermite interpolation - Mathematics of Computation 52 (186), 471-494.
	 * 
	 * @param adblPredictorOrdinate The Predictor Ordinate Array
	 * @param adblResponseValue The Response Value Array
	 * 
	 * @return The C1 Array
	 */

	public static final double[] Hyman89C1 (
		final double[] adblPredictorOrdinate,
		final double[] adblResponseValue)
	{
<span class="fc" id="L388">		int iNumResponse = adblResponseValue.length;</span>
<span class="fc" id="L389">		double[] adblHyman89C1 = new double[iNumResponse];</span>

<span class="fc" id="L391">		double[] adblNodeC1 = LinearC1 (adblPredictorOrdinate, adblResponseValue);</span>

<span class="fc" id="L393">		double[] adblBesselC1 = BesselC1 (adblPredictorOrdinate, adblResponseValue);</span>

<span class="fc bfc" id="L395" title="All 2 branches covered.">		for (int i = 0; i &lt; iNumResponse; ++i) {</span>
<span class="fc bfc" id="L396" title="All 4 branches covered.">			if (i &lt; 2 || i &gt;= iNumResponse - 2)</span>
<span class="fc" id="L397">				adblHyman89C1[i] = adblBesselC1[i];</span>
			else {
<span class="fc" id="L399">				double dMuMinus = (adblNodeC1[i - 1] * (2. * (adblPredictorOrdinate[i] -</span>
					adblPredictorOrdinate[i - 1]) + adblPredictorOrdinate[i - 1] -
						adblPredictorOrdinate[i - 2]) - adblNodeC1[i - 2] * (adblPredictorOrdinate[i] -
							adblPredictorOrdinate[i - 1])) / (adblPredictorOrdinate[i] -
								adblPredictorOrdinate[i - 2]);
<span class="fc" id="L404">				double dMu0 = (adblNodeC1[i - 1] * (adblPredictorOrdinate[i + 1] - adblPredictorOrdinate[i])</span>
					+ adblNodeC1[i] * (adblPredictorOrdinate[i] - adblPredictorOrdinate[i - 1])) /
						(adblPredictorOrdinate[i + 1] - adblPredictorOrdinate[i - 1]);
<span class="fc" id="L407">				double dMuPlus = (adblNodeC1[i] * (2. * (adblPredictorOrdinate[i + 1] -</span>
					adblPredictorOrdinate[i]) + adblPredictorOrdinate[i + 2] - adblPredictorOrdinate[i + 1])
						- adblNodeC1[i + 1] * (adblPredictorOrdinate[i + 1] - adblPredictorOrdinate[i])) /
							(adblPredictorOrdinate[i + 2] - adblPredictorOrdinate[i]);

				try {
<span class="fc" id="L413">					double dblM = 3 * org.drip.numerical.common.NumberUtil.Minimum (new double[]</span>
<span class="fc" id="L414">						{java.lang.Math.abs (adblNodeC1[i - 1]), java.lang.Math.abs (adblNodeC1[i]),</span>
<span class="fc" id="L415">							java.lang.Math.abs (dMu0), java.lang.Math.abs (dMuPlus)});</span>

<span class="fc bfc" id="L417" title="All 2 branches covered.">					if (!org.drip.numerical.common.NumberUtil.SameSign (new double[] {dMu0, dMuMinus,</span>
							adblNodeC1[i - 1] - adblNodeC1[i - 2], adblNodeC1[i] - adblNodeC1[i - 1]}))
<span class="fc" id="L419">						dblM = java.lang.Math.max (dblM, 1.5 * java.lang.Math.min (java.lang.Math.abs (dMu0),</span>
<span class="fc" id="L420">							java.lang.Math.abs (dMuMinus)));</span>
<span class="pc bpc" id="L421" title="1 of 2 branches missed.">					else if (!org.drip.numerical.common.NumberUtil.SameSign (new double[] {-dMu0, -dMuPlus,</span>
							adblNodeC1[i] - adblNodeC1[i - 1], adblNodeC1[i + 1] - adblNodeC1[i]}))
<span class="fc" id="L423">						dblM = java.lang.Math.max (dblM, 1.5 * java.lang.Math.min (java.lang.Math.abs (dMu0),</span>
<span class="fc" id="L424">							java.lang.Math.abs (dMuPlus)));</span>

<span class="fc" id="L426">					adblHyman89C1[i] = 0.;</span>

<span class="pc bpc" id="L428" title="1 of 2 branches missed.">					if (adblBesselC1[i] * dMu0 &gt; 0.)</span>
<span class="fc" id="L429">						adblHyman89C1[i] = adblBesselC1[i] / java.lang.Math.abs (adblBesselC1[i]) *</span>
<span class="fc" id="L430">							java.lang.Math.min (java.lang.Math.abs (adblBesselC1[i]), dblM);</span>
<span class="nc" id="L431">				} catch (java.lang.Exception e) {</span>
<span class="nc" id="L432">					e.printStackTrace();</span>

<span class="nc" id="L434">					return null;</span>
<span class="fc" id="L435">				}</span>
			}
		}

<span class="fc" id="L439">		return adblHyman89C1;</span>
	}

	/**
	 * Generate a Harmonic C1 Array from the specified Array of Predictor Ordinates and the Response Values
	 * 
	 * 	Fritcsh and Butland (1984) A Method for constructing local monotonic piece-wise cubic interpolants -
	 *  	SIAM J on Scientific and Statistical Computing 5, 300-304.
	 * 
	 * @param adblPredictorOrdinate The Predictor Ordinate Array
	 * @param adblResponseValue The Response Value Array
	 * 
	 * @return The C1 Array
	 */

	public static final double[] HarmonicC1 (
		final double[] adblPredictorOrdinate,
		final double[] adblResponseValue)
	{
<span class="fc" id="L458">		int iNumResponse = adblResponseValue.length;</span>
<span class="fc" id="L459">		double[] adblHarmonicC1 = new double[iNumResponse];</span>

<span class="fc" id="L461">		double[] adblLinearC1 = LinearC1 (adblPredictorOrdinate, adblResponseValue);</span>

<span class="fc bfc" id="L463" title="All 2 branches covered.">		for (int i = 0; i &lt; iNumResponse; ++i) {</span>
<span class="fc bfc" id="L464" title="All 2 branches covered.">			if (0 == i) {</span>
<span class="fc" id="L465">				adblHarmonicC1[i] = (adblPredictorOrdinate[2] + adblPredictorOrdinate[1] - 2. *</span>
					adblPredictorOrdinate[0]) * adblLinearC1[0] / (adblPredictorOrdinate[2] -
						adblPredictorOrdinate[0]);
<span class="fc" id="L468">				adblHarmonicC1[i] -= (adblPredictorOrdinate[1] - adblPredictorOrdinate[0]) * adblLinearC1[1]</span>
					/ (adblPredictorOrdinate[2] - adblPredictorOrdinate[0]);
<span class="fc bfc" id="L470" title="All 2 branches covered.">			} else if (iNumResponse - 1 == i) {</span>
<span class="fc" id="L471">				adblHarmonicC1[i] = -(adblPredictorOrdinate[i] - adblPredictorOrdinate[i - 1]) *</span>
					adblLinearC1[i - 2] / (adblPredictorOrdinate[i] - adblPredictorOrdinate[i - 2]);
<span class="fc" id="L473">				adblHarmonicC1[i] += (2. * adblPredictorOrdinate[i] - adblPredictorOrdinate[i - 1] -</span>
					adblPredictorOrdinate[i - 2]) * adblLinearC1[i - 1] / (adblPredictorOrdinate[i] -
						adblPredictorOrdinate[i - 2]);
			} else {
<span class="fc bfc" id="L477" title="All 2 branches covered.">				if (adblLinearC1[i - 1] * adblLinearC1[i] &lt;= 0.)</span>
<span class="fc" id="L478">					adblHarmonicC1[i] = 0.;</span>
				else {
<span class="fc" id="L480">					adblHarmonicC1[i] = (adblPredictorOrdinate[i] - adblPredictorOrdinate[i - 1] + 2. *</span>
						(adblPredictorOrdinate[i + 1] - adblPredictorOrdinate[i])) / (3. *
							(adblPredictorOrdinate[i + 1] - adblPredictorOrdinate[i])) / adblLinearC1[i - 1];
<span class="fc" id="L483">					adblHarmonicC1[i] += (adblPredictorOrdinate[i + 1] - adblPredictorOrdinate[i] + 2. *</span>
						(adblPredictorOrdinate[i] - adblPredictorOrdinate[i - 1])) / (3. *
							(adblPredictorOrdinate[i + 1] - adblPredictorOrdinate[i])) / adblLinearC1[i];
<span class="fc" id="L486">					adblHarmonicC1[i] = 1. / adblHarmonicC1[i];</span>
				}
			}
		}

<span class="fc" id="L491">		return adblHarmonicC1;</span>
	}

	/**
	 * Generate a Van Leer Limiter C1 Array from the specified Array of Predictor Ordinates and the Response
	 *  Values.
	 * 
	 * 	Van Leer (1974) Towards the Ultimate Conservative Difference Scheme. II - Monotonicity and
	 * 		Conservation combined in a Second-Order Scheme, Journal of Computational Physics 14 (4), 361-370.
	 * 
	 * @param adblPredictorOrdinate The Predictor Ordinate Array
	 * @param adblResponseValue The Response Value Array
	 * 
	 * @return The C1 Array
	 */

	public static final double[] VanLeerLimiterC1 (
		final double[] adblPredictorOrdinate,
		final double[] adblResponseValue)
	{
<span class="fc" id="L511">		int iNumResponse = adblResponseValue.length;</span>
<span class="fc" id="L512">		double[] dblVanLeerLimiterC1 = new double[iNumResponse];</span>

<span class="fc" id="L514">		double[] adblNodeC1 = LinearC1 (adblPredictorOrdinate, adblResponseValue);</span>

<span class="fc bfc" id="L516" title="All 2 branches covered.">		for (int i = 0; i &lt; iNumResponse; ++i) {</span>
<span class="fc bfc" id="L517" title="All 2 branches covered.">			if (0 == i) {</span>
<span class="fc" id="L518">				dblVanLeerLimiterC1[i] = (adblPredictorOrdinate[2] + adblPredictorOrdinate[1] - 2. *</span>
					adblPredictorOrdinate[0]) * adblNodeC1[0] / (adblPredictorOrdinate[2] -
						adblPredictorOrdinate[0]);
<span class="fc" id="L521">				dblVanLeerLimiterC1[i] -= (adblPredictorOrdinate[1] - adblPredictorOrdinate[0]) *</span>
					adblNodeC1[1] / (adblPredictorOrdinate[2] - adblPredictorOrdinate[0]);
<span class="fc bfc" id="L523" title="All 2 branches covered.">			} else if (iNumResponse - 1 == i) {</span>
<span class="fc" id="L524">				dblVanLeerLimiterC1[i] = -(adblPredictorOrdinate[i] - adblPredictorOrdinate[i - 1]) *</span>
					adblNodeC1[i - 2] / (adblPredictorOrdinate[i] - adblPredictorOrdinate[i - 2]);
<span class="fc" id="L526">				dblVanLeerLimiterC1[i] += (2. * adblPredictorOrdinate[i] - adblPredictorOrdinate[i - 1] -</span>
					adblPredictorOrdinate[i - 2]) * adblNodeC1[i - 1] / (adblPredictorOrdinate[i] -
						adblPredictorOrdinate[i - 2]);
			} else {
<span class="pc bpc" id="L530" title="1 of 2 branches missed.">				if (0. != adblNodeC1[i - 1]) {</span>
<span class="fc" id="L531">					double dblR = adblNodeC1[i] / adblNodeC1[i - 1];</span>

<span class="fc" id="L533">					double dblRAbsolute = java.lang.Math.abs (dblR);</span>

<span class="fc" id="L535">					dblVanLeerLimiterC1[i] = adblNodeC1[i] * (dblR + dblRAbsolute) / (1. + dblRAbsolute);</span>
<span class="pc bnc" id="L536" title="All 2 branches missed.">				} else if (0. &gt;= adblNodeC1[i])</span>
<span class="nc" id="L537">					dblVanLeerLimiterC1[i] = 0.;</span>
<span class="nc bnc" id="L538" title="All 2 branches missed.">				else if (0. &lt; adblNodeC1[i])</span>
<span class="nc" id="L539">					dblVanLeerLimiterC1[i] = 2. * adblNodeC1[i];</span>
			}
		}

<span class="fc" id="L543">		return dblVanLeerLimiterC1;</span>
	}

	/**
	 * Generate a Huynh Le Floch Limiter C1 Array from the specified Array of Predictor Ordinates and the
	 *  Response Values.
	 * 
	 * 	Huynh (1993) Accurate Monotone Cubic Interpolation, SIAM J on Numerical Analysis 30 (1), 57-100.
	 * 
	 * @param adblPredictorOrdinate The Predictor Ordinate Array
	 * @param adblResponseValue The Response Value Array
	 * 
	 * @return The C1 Array
	 */

	public static final double[] HuynhLeFlochLimiterC1 (
		final double[] adblPredictorOrdinate,
		final double[] adblResponseValue)
	{
<span class="fc" id="L562">		int iNumResponse = adblResponseValue.length;</span>
<span class="fc" id="L563">		double[] adblHuynhLeFlochLimiterC1 = new double[iNumResponse];</span>

<span class="fc" id="L565">		double[] adblNodeC1 = LinearC1 (adblPredictorOrdinate, adblResponseValue);</span>

<span class="fc bfc" id="L567" title="All 2 branches covered.">		for (int i = 0; i &lt; iNumResponse; ++i) {</span>
<span class="fc bfc" id="L568" title="All 2 branches covered.">			if (0 == i) {</span>
<span class="fc" id="L569">				adblHuynhLeFlochLimiterC1[i] = (adblPredictorOrdinate[2] + adblPredictorOrdinate[1] - 2. *</span>
					adblPredictorOrdinate[0]) * adblNodeC1[0] / (adblPredictorOrdinate[2] -
						adblPredictorOrdinate[0]);
<span class="fc" id="L572">				adblHuynhLeFlochLimiterC1[i] -= (adblPredictorOrdinate[1] - adblPredictorOrdinate[0]) *</span>
					adblNodeC1[1] / (adblPredictorOrdinate[2] - adblPredictorOrdinate[0]);
<span class="fc bfc" id="L574" title="All 2 branches covered.">			} else if (iNumResponse - 1 == i) {</span>
<span class="fc" id="L575">				adblHuynhLeFlochLimiterC1[i] = -(adblPredictorOrdinate[i] - adblPredictorOrdinate[i - 1]) *</span>
					adblNodeC1[i - 2] / (adblPredictorOrdinate[i] - adblPredictorOrdinate[i - 2]);
<span class="fc" id="L577">				adblHuynhLeFlochLimiterC1[i] += (2. * adblPredictorOrdinate[i] - adblPredictorOrdinate[i - 1]</span>
					- adblPredictorOrdinate[i - 2]) * adblNodeC1[i - 1] / (adblPredictorOrdinate[i] -
						adblPredictorOrdinate[i - 2]);
			} else {
<span class="fc" id="L581">				double dblMonotoneIndicator = adblNodeC1[i] * adblNodeC1[i - 1];</span>

<span class="fc bfc" id="L583" title="All 2 branches covered.">				if (0. &lt; dblMonotoneIndicator)</span>
<span class="fc" id="L584">					adblHuynhLeFlochLimiterC1[i] = 3. * dblMonotoneIndicator * (adblNodeC1[i] +</span>
						adblNodeC1[i - 1]) / (adblNodeC1[i] * adblNodeC1[i] + adblNodeC1[i - 1] *
							adblNodeC1[i - 1] * 4. * dblMonotoneIndicator);
				else
<span class="fc" id="L588">					adblHuynhLeFlochLimiterC1[i] = 0.;</span>
			}
		}

<span class="fc" id="L592">		return adblHuynhLeFlochLimiterC1;</span>
	}

	/**
	 * Generate a Kruger C1 Array from the specified Array of Predictor Ordinates and the Response Values.
	 * 
	 * 	Kruger (2002) Constrained Cubic Spline Interpolations for Chemical Engineering Application,
	 *  	http://www.korf.co.uk/spline.pdf
	 * 
	 * @param adblPredictorOrdinate The Predictor Ordinate Array
	 * @param adblResponseValue The Response Value Array
	 * 
	 * @return The C1 Array
	 */

	public static final double[] KrugerC1 (
		final double[] adblPredictorOrdinate,
		final double[] adblResponseValue)
	{
<span class="fc" id="L611">		int iNumResponse = adblResponseValue.length;</span>
<span class="fc" id="L612">		double[] adblKrugerSlope = new double[iNumResponse];</span>

<span class="fc" id="L614">		double[] adblSlopeC1 = LinearC1 (adblPredictorOrdinate, adblResponseValue);</span>

<span class="pc bpc" id="L616" title="2 of 4 branches missed.">		if (null == adblSlopeC1 || adblSlopeC1.length != iNumResponse - 1) return null;</span>

<span class="fc bfc" id="L618" title="All 2 branches covered.">		for (int i = 0; i &lt; iNumResponse; ++i) {</span>
<span class="fc bfc" id="L619" title="All 4 branches covered.">			if (0 != i &amp;&amp; iNumResponse - 1 != i) {</span>
<span class="fc bfc" id="L620" title="All 2 branches covered.">				if (adblSlopeC1[i - 1] * adblSlopeC1[i] &lt;= 0.)</span>
<span class="fc" id="L621">					adblKrugerSlope[i] = 0.;</span>
				else
<span class="fc" id="L623">					adblKrugerSlope[i] = 2. / ((1. / adblSlopeC1[i - 1]) + (1. / adblSlopeC1[i]));</span>
			}
		}

<span class="fc" id="L627">		adblKrugerSlope[0] = 3.5 * adblSlopeC1[0] - 0.5 * adblKrugerSlope[1];</span>
<span class="fc" id="L628">		adblKrugerSlope[iNumResponse - 1] = 3.5 * adblSlopeC1[iNumResponse - 2] - 0.5 *</span>
			adblKrugerSlope[iNumResponse - 2];
<span class="fc" id="L630">		return adblKrugerSlope;</span>
	}

	/**
	 * Generate a Akima C1 Array from the specified Array of Predictor Ordinates and the Response Values.
	 * 
	 * 	Akima (1970): A New Method of Interpolation and Smooth Curve Fitting based on Local Procedures,
	 * 		Journal of the Association for the Computing Machinery 17 (4), 589-602.
	 * 
	 * @param adblPredictorOrdinate The Predictor Ordinate Array
	 * @param adblResponseValue The Response Value Array
	 * 
	 * @return The C1 Array
	 */

	public static final double[] AkimaC1 (
		final double[] adblPredictorOrdinate,
		final double[] adblResponseValue)
	{
<span class="fc" id="L649">		org.drip.spline.pchip.AkimaLocalC1Generator alcr =</span>
<span class="fc" id="L650">			org.drip.spline.pchip.AkimaLocalC1Generator.Create (adblPredictorOrdinate, adblResponseValue);</span>

<span class="pc bpc" id="L652" title="1 of 2 branches missed.">		return null == alcr ? null : alcr.C1();</span>
	}

	/**
	 * Verify if the given Quintic Polynomial is Monotone using the Hyman89 Algorithm
	 * 
	 * 	Doherty, Edelman, and Hyman (1989) Non-negative, monotonic, or convexity preserving cubic and quintic
	 *  	Hermite interpolation - Mathematics of Computation 52 (186), 471-494.
	 * 
	 * @param adblPredictorOrdinate Array of Predictor Ordinates
	 * @param adblResponseValue Array of Response Values
	 * @param adblFirstDerivative Array of First Derivatives
	 * @param adblSecondDerivative Array of Second Derivatives
	 * 
	 * @return TRUE - The given Quintic Polynomial is Monotone
	 * 
	 * @throws java.lang.Exception Thrown if the Monotonicity cannot be determined
	 */

	public static final boolean VerifyHyman89QuinticMonotonicity (
		final double[] adblPredictorOrdinate,
		final double[] adblResponseValue,
		final double[] adblFirstDerivative,
		final double[] adblSecondDerivative)
		throws java.lang.Exception
	{
<span class="nc bnc" id="L678" title="All 8 branches missed.">		if (null == adblPredictorOrdinate || null == adblResponseValue || null == adblFirstDerivative || null</span>
			== adblSecondDerivative)
<span class="nc" id="L680">			throw new java.lang.Exception</span>
				(&quot;LocalMonotoneCkGenerator::VerifyHyman89QuinticMonotonicity =&gt; Invalid Inputs&quot;);

<span class="nc" id="L683">		int iNumPredictor = adblPredictorOrdinate.length;</span>

<span class="nc bnc" id="L685" title="All 8 branches missed.">		if (1 &gt;= iNumPredictor || iNumPredictor != adblResponseValue.length || iNumPredictor !=</span>
			adblResponseValue.length || iNumPredictor != adblResponseValue.length)
<span class="nc" id="L687">			throw new java.lang.Exception</span>
				(&quot;LocalMonotoneCkGenerator::VerifyHyman89QuinticMonotonicity =&gt; Invalid Inputs&quot;);

<span class="nc bnc" id="L690" title="All 2 branches missed.">		for (int i = 1; i &lt; iNumPredictor - 1; ++i) {</span>
<span class="nc" id="L691">			double dblAbsoluteResponseValue = java.lang.Math.abs (adblResponseValue[i]);</span>

<span class="nc bnc" id="L693" title="All 2 branches missed.">			double dblResponseValueSign = adblResponseValue[i] &gt; 0. ? 1. : -1.;</span>
<span class="nc" id="L694">			double dblHMinus = (adblPredictorOrdinate[i] - adblPredictorOrdinate[i - 1]);</span>
<span class="nc" id="L695">			double dblHPlus = (adblPredictorOrdinate[i + 1] - adblPredictorOrdinate[i]);</span>

<span class="nc bnc" id="L697" title="All 4 branches missed.">			if (-5. * dblAbsoluteResponseValue / dblHPlus &gt; dblResponseValueSign * adblFirstDerivative[i] ||</span>
				5. * dblAbsoluteResponseValue / dblHMinus &lt; dblResponseValueSign * adblFirstDerivative[i])
<span class="nc" id="L699">				return false;</span>

<span class="nc" id="L701">			if (dblResponseValueSign * adblSecondDerivative[i] &lt; dblResponseValueSign * java.lang.Math.max</span>
<span class="nc bnc" id="L702" title="All 2 branches missed.">				(8. * adblFirstDerivative[i] / dblHMinus - 20. * adblResponseValue[i] / dblHMinus /</span>
					dblHMinus, -8. * adblFirstDerivative[i] / dblHPlus - 20. * adblResponseValue[i] /
						dblHPlus / dblHPlus))
<span class="nc" id="L705">				return false;</span>
		}

<span class="nc" id="L708">		return true;</span>
	}

	/**
	 * Generate C1 Slope Quintic Polynomial is Monotone using the Hyman89 Algorithm
	 * 
	 * 	Doherty, Edelman, and Hyman (1989) Non-negative, monotonic, or convexity preserving cubic and quintic
	 *  	Hermite interpolation - Mathematics of Computation 52 (186), 471-494.
	 * 
	 * @param adblPredictorOrdinate Array of Predictor Ordinates
	 * @param adblResponseValue Array of Response Values
	 * @param adblFirstDerivative Array of First Derivatives
	 * @param adblSecondDerivative Array of Second Derivatives
	 * 
	 * @return The C1 Slope Quintic Stretch
	 */

	public static final double[] Hyman89QuinticMonotoneC1 (
		final double[] adblPredictorOrdinate,
		final double[] adblResponseValue,
		final double[] adblFirstDerivative,
		final double[] adblSecondDerivative)
	{
<span class="nc bnc" id="L731" title="All 8 branches missed.">		if (null == adblPredictorOrdinate || null == adblResponseValue || null == adblFirstDerivative || null</span>
			== adblSecondDerivative)
<span class="nc" id="L733">			return null;</span>

<span class="nc" id="L735">		int iNumPredictor = adblPredictorOrdinate.length;</span>

<span class="nc bnc" id="L737" title="All 8 branches missed.">		if (1 &gt;= iNumPredictor || iNumPredictor != adblResponseValue.length || iNumPredictor !=</span>
			adblResponseValue.length || iNumPredictor != adblResponseValue.length)
<span class="nc" id="L739">			return null;</span>

<span class="nc" id="L741">		double[] adblAdjFirstDerivative = new double[iNumPredictor];</span>

<span class="nc" id="L743">		double[] adblNodeC1 = LinearC1 (adblPredictorOrdinate, adblResponseValue);</span>

<span class="nc" id="L745">		double[] adblBesselC1 = BesselC1 (adblPredictorOrdinate, adblResponseValue);</span>

<span class="nc bnc" id="L747" title="All 2 branches missed.">		for (int i = 0; i &lt; iNumPredictor; ++i) {</span>
<span class="nc bnc" id="L748" title="All 4 branches missed.">			if (i &lt; 2 || i &gt;= iNumPredictor - 2)</span>
<span class="nc" id="L749">				adblAdjFirstDerivative[i] = adblBesselC1[i];</span>
			else {
<span class="nc" id="L751">				double dblSign = 0.;</span>
<span class="nc" id="L752">				double dblHMinus = (adblPredictorOrdinate[i] - adblPredictorOrdinate[i - 1]);</span>
<span class="nc" id="L753">				double dblHPlus = (adblPredictorOrdinate[i + 1] - adblPredictorOrdinate[i]);</span>

<span class="nc bnc" id="L755" title="All 2 branches missed.">				if (adblFirstDerivative[i - 1] * adblFirstDerivative[i] &lt; 0.)</span>
<span class="nc bnc" id="L756" title="All 2 branches missed.">					dblSign = adblResponseValue[i] &gt; 0. ? 1. : -1.;</span>

<span class="nc" id="L758">				double dblMinSlope = java.lang.Math.min (java.lang.Math.abs (adblFirstDerivative[i - 1]),</span>
<span class="nc" id="L759">					java.lang.Math.abs (adblFirstDerivative[i]));</span>

<span class="nc bnc" id="L761" title="All 2 branches missed.">				if (dblSign &gt;= 0.)</span>
<span class="nc" id="L762">					adblAdjFirstDerivative[i] = java.lang.Math.min (java.lang.Math.max (0.,</span>
						adblFirstDerivative[i]), 5. * dblMinSlope);
				else
<span class="nc" id="L765">					adblAdjFirstDerivative[i] = java.lang.Math.max (java.lang.Math.min (0.,</span>
						adblFirstDerivative[i]), -5. * dblMinSlope);

<span class="nc" id="L768">				double dblA = java.lang.Math.max (0., adblAdjFirstDerivative[i] / adblNodeC1[i - 1]);</span>

<span class="nc" id="L770">				double dblB = java.lang.Math.max (0., adblAdjFirstDerivative[i + 1] / adblNodeC1[i]);</span>

<span class="nc bnc" id="L772" title="All 2 branches missed.">				double dblDPlus = adblAdjFirstDerivative[i] * adblNodeC1[i] &gt; 0. ? adblAdjFirstDerivative[i]</span>
					: 0.;
<span class="nc bnc" id="L774" title="All 2 branches missed.">				double dblDMinus = adblAdjFirstDerivative[i] * adblNodeC1[i - 1] &gt; 0. ?</span>
					adblAdjFirstDerivative[i] : 0.;
<span class="nc" id="L776">				double dblALeft = (-7.9 * dblDPlus - 0.26 * dblDPlus * dblB) / dblHPlus;</span>
<span class="nc" id="L777">				double dblARight = ((20. - 2. * dblB) * adblNodeC1[i] - 8. * dblDPlus - 0.48 * dblDPlus *</span>
					dblB) / dblHPlus;
<span class="nc" id="L779">				double dblBLeft = ((2. * dblA - 20.) * adblNodeC1[i - 1] + 8. * dblDMinus - 0.48 * dblDMinus</span>
					* dblA) / dblHMinus;
<span class="nc" id="L781">				double dblBRight = (7.9 * dblDMinus + 0.26 * dblDMinus * dblA) / dblHMinus;</span>

<span class="nc bnc" id="L783" title="All 4 branches missed.">				if (dblARight &lt;= dblBLeft || dblALeft &gt;= dblBRight) {</span>
<span class="nc" id="L784">					double dblDenom = ((8. + 0.48 * dblB) / dblHPlus) + ((8. + 0.48 * dblA) / dblHMinus);</span>
<span class="nc" id="L785">					adblAdjFirstDerivative[i] = (20. - 2. * dblB) * adblNodeC1[i] / dblHPlus;</span>
<span class="nc" id="L786">					adblAdjFirstDerivative[i] += (20. - 2. * dblA) * adblNodeC1[i - 1] / dblHMinus;</span>
<span class="nc" id="L787">					adblAdjFirstDerivative[i] /= dblDenom;</span>
				}
			}
		}

<span class="nc" id="L792">		return adblAdjFirstDerivative;</span>
	}

	/**
	 * Generate the Local Control Stretch in accordance with the desired Customization Parameters
	 * 
	 * @param adblPredictorOrdinate The Predictor Ordinate Array
	 * @param adblResponseValue The Response Value Array
	 * @param strGeneratorType The C1 Generator Type
	 * @param bEliminateSpuriousExtrema TRUE - Eliminate Spurious Extrema
	 * @param bApplyMonotoneFilter TRUE - Apply Monotone Filter
	 * 
	 * @return Instance of the Local Control Stretch
	 */

	public static final LocalMonotoneCkGenerator Create (
		final double[] adblPredictorOrdinate,
		final double[] adblResponseValue,
		final java.lang.String strGeneratorType,
		final boolean bEliminateSpuriousExtrema,
		final boolean bApplyMonotoneFilter)
	{
		try {
<span class="fc" id="L815">			LocalMonotoneCkGenerator lcr = new LocalMonotoneCkGenerator (adblPredictorOrdinate,</span>
				adblResponseValue);

<span class="pc bpc" id="L818" title="1 of 2 branches missed.">			if (!lcr.generateC1 (strGeneratorType)) return null;</span>

<span class="pc bpc" id="L820" title="1 of 4 branches missed.">			if (bEliminateSpuriousExtrema &amp;&amp; !lcr.eliminateSpuriousExtrema()) return null;</span>

<span class="fc bfc" id="L822" title="All 2 branches covered.">			if (bApplyMonotoneFilter) {</span>
<span class="pc bpc" id="L823" title="1 of 2 branches missed.">				if (!lcr.applyMonotoneFilter()) return null;</span>
			}

<span class="fc" id="L826">			return lcr;</span>
<span class="nc" id="L827">		} catch (java.lang.Exception e) {</span>
<span class="nc" id="L828">			e.printStackTrace();</span>
		}

<span class="nc" id="L831">		return null;</span>
	}

	/**
	 * Generate the Local Control Stretch in accordance with the desired Customization Parameters
	 * 
	 * @param aiPredictorOrdinate The Predictor Ordinate Array
	 * @param adblResponseValue The Response Value Array
	 * @param strGeneratorType The C1 Generator Type
	 * @param bEliminateSpuriousExtrema TRUE - Eliminate Spurious Extrema
	 * @param bApplyMonotoneFilter TRUE - Apply Monotone Filter
	 * 
	 * @return Instance of the Local Control Stretch
	 */

	public static final LocalMonotoneCkGenerator Create (
		final int[] aiPredictorOrdinate,
		final double[] adblResponseValue,
		final java.lang.String strGeneratorType,
		final boolean bEliminateSpuriousExtrema,
		final boolean bApplyMonotoneFilter)
	{
<span class="pc bpc" id="L853" title="1 of 2 branches missed.">		if (null == aiPredictorOrdinate) return null;</span>

<span class="fc" id="L855">		int iNumPredictorOrdinate = aiPredictorOrdinate.length;</span>
<span class="fc" id="L856">		double[] adblPredictorOrdinate = new double[iNumPredictorOrdinate];</span>

<span class="pc bpc" id="L858" title="1 of 2 branches missed.">		if (0 == iNumPredictorOrdinate) return null;</span>

<span class="fc bfc" id="L860" title="All 2 branches covered.">		for (int i = 0; i &lt; iNumPredictorOrdinate; ++i)</span>
<span class="fc" id="L861">			adblPredictorOrdinate[i] = aiPredictorOrdinate[i];</span>

<span class="fc" id="L863">		return Create (adblPredictorOrdinate, adblResponseValue, strGeneratorType, bEliminateSpuriousExtrema,</span>
			bApplyMonotoneFilter);
	}

	private LocalMonotoneCkGenerator (
		final double[] adblPredictorOrdinate,
		final double[] adblResponseValue)
		throws java.lang.Exception
<span class="fc" id="L871">	{</span>
<span class="pc bpc" id="L872" title="2 of 4 branches missed.">		if (null == (_adblPredictorOrdinate = adblPredictorOrdinate) || null == (_adblResponseValue =</span>
			adblResponseValue))
<span class="nc" id="L874">			throw new java.lang.Exception (&quot;LocalMonotoneCkGenerator ctr: Invalid Inputs!&quot;);</span>

<span class="fc" id="L876">		int iSize = _adblPredictorOrdinate.length;</span>

<span class="pc bpc" id="L878" title="2 of 4 branches missed.">		if (0 == iSize || iSize != _adblResponseValue.length)</span>
<span class="nc" id="L879">			throw new java.lang.Exception (&quot;LocalMonotoneCkGenerator ctr: Invalid Inputs!&quot;);</span>
<span class="fc" id="L880">	}</span>

	private boolean generateC1 (
		final java.lang.String strGeneratorType)
	{
<span class="pc bpc" id="L885" title="2 of 4 branches missed.">		if (null == strGeneratorType || strGeneratorType.isEmpty()) return false;</span>

<span class="fc bfc" id="L887" title="All 2 branches covered.">		if (C1_AKIMA.equalsIgnoreCase (strGeneratorType))</span>
<span class="pc bpc" id="L888" title="2 of 4 branches missed.">			return null != (_adblC1 = AkimaC1 (_adblPredictorOrdinate, _adblResponseValue)) &amp;&amp; 0 !=</span>
				_adblC1.length;

<span class="fc bfc" id="L891" title="All 2 branches covered.">		if (C1_BESSEL.equalsIgnoreCase (strGeneratorType))</span>
<span class="pc bpc" id="L892" title="2 of 4 branches missed.">			return null != (_adblC1 = BesselC1 (_adblPredictorOrdinate, _adblResponseValue)) &amp;&amp; 0 !=</span>
				_adblC1.length;

<span class="fc bfc" id="L895" title="All 2 branches covered.">		if (C1_HARMONIC.equalsIgnoreCase (strGeneratorType))</span>
<span class="pc bpc" id="L896" title="2 of 4 branches missed.">			return null != (_adblC1 = HarmonicC1 (_adblPredictorOrdinate, _adblResponseValue)) &amp;&amp; 0 !=</span>
				_adblC1.length;

<span class="fc bfc" id="L899" title="All 2 branches covered.">		if (C1_HUYNH_LE_FLOCH.equalsIgnoreCase (strGeneratorType))</span>
<span class="pc bpc" id="L900" title="2 of 4 branches missed.">			return null != (_adblC1 = HuynhLeFlochLimiterC1 (_adblPredictorOrdinate, _adblResponseValue)) &amp;&amp;</span>
				0 != _adblC1.length;

<span class="fc bfc" id="L903" title="All 2 branches covered.">		if (C1_HYMAN83.equalsIgnoreCase (strGeneratorType))</span>
<span class="pc bpc" id="L904" title="2 of 4 branches missed.">			return null != (_adblC1 = Hyman83C1 (_adblPredictorOrdinate, _adblResponseValue)) &amp;&amp; 0 !=</span>
				_adblC1.length;

<span class="fc bfc" id="L907" title="All 2 branches covered.">		if (C1_HYMAN89.equalsIgnoreCase (strGeneratorType))</span>
<span class="pc bpc" id="L908" title="2 of 4 branches missed.">			return null != (_adblC1 = Hyman89C1 (_adblPredictorOrdinate, _adblResponseValue)) &amp;&amp; 0 !=</span>
				_adblC1.length;

<span class="fc bfc" id="L911" title="All 2 branches covered.">		if (C1_KRUGER.equalsIgnoreCase (strGeneratorType))</span>
<span class="pc bpc" id="L912" title="2 of 4 branches missed.">			return null != (_adblC1 = KrugerC1 (_adblPredictorOrdinate, _adblResponseValue)) &amp;&amp; 0 !=</span>
				_adblC1.length;

<span class="fc bfc" id="L915" title="All 2 branches covered.">		if (C1_MONOTONE_CONVEX.equalsIgnoreCase (strGeneratorType))</span>
<span class="pc bpc" id="L916" title="2 of 4 branches missed.">			return null != (_adblC1 = BesselC1 (_adblPredictorOrdinate, _adblResponseValue)) &amp;&amp; 0 !=</span>
			_adblC1.length;

<span class="pc bpc" id="L919" title="1 of 2 branches missed.">		if (C1_VANILLA.equalsIgnoreCase (strGeneratorType))</span>
<span class="nc bnc" id="L920" title="All 4 branches missed.">			return null != (_adblC1 = LinearC1 (_adblPredictorOrdinate, _adblResponseValue)) &amp;&amp; 0 !=</span>
				_adblC1.length;

<span class="pc bpc" id="L923" title="1 of 2 branches missed.">		if (C1_VAN_LEER.equalsIgnoreCase (strGeneratorType))</span>
<span class="pc bpc" id="L924" title="2 of 4 branches missed.">			return null != (_adblC1 = VanLeerLimiterC1 (_adblPredictorOrdinate, _adblResponseValue)) &amp;&amp; 0 !=</span>
				_adblC1.length;

<span class="nc" id="L927">		return false;</span>
	}

	private boolean eliminateSpuriousExtrema()
	{
<span class="pc bpc" id="L932" title="2 of 4 branches missed.">		return null != (_adblC1 = EliminateSpuriousExtrema (_adblC1, LinearC1 (_adblPredictorOrdinate,</span>
			_adblResponseValue))) &amp;&amp; 0 != _adblC1.length; 
	}

	private boolean applyMonotoneFilter()
	{
<span class="pc bpc" id="L938" title="2 of 4 branches missed.">		return null != (_adblC1 = ApplyMonotoneFilter (_adblC1, LinearC1 (_adblPredictorOrdinate,</span>
			_adblResponseValue))) &amp;&amp; 0 != _adblC1.length; 
	}

	/**
	 * Retrieve the C1 Array
	 * 
	 * @return The C1 Array
	 */

	public double[] C1()
	{
<span class="fc" id="L950">		return _adblC1;</span>
	}
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.7.9.201702052155</span></div></body></html>