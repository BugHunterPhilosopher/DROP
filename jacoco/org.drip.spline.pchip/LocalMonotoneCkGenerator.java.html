<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>LocalMonotoneCkGenerator.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">DROP</a> &gt; <a href="index.source.html" class="el_package">org.drip.spline.pchip</a> &gt; <span class="el_source">LocalMonotoneCkGenerator.java</span></div><h1>LocalMonotoneCkGenerator.java</h1><pre class="source lang-java linenums">
package org.drip.spline.pchip;

/*
 * -*- mode: java; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*-
 */

/*!
 * Copyright (C) 2019 Lakshmi Krishnamurthy
 * Copyright (C) 2018 Lakshmi Krishnamurthy
 * Copyright (C) 2017 Lakshmi Krishnamurthy
 * Copyright (C) 2016 Lakshmi Krishnamurthy
 * Copyright (C) 2015 Lakshmi Krishnamurthy
 * Copyright (C) 2014 Lakshmi Krishnamurthy
 * Copyright (C) 2013 Lakshmi Krishnamurthy
 * 
 *  This file is part of DROP, an open-source library targeting risk, transaction costs, exposure, margin
 *  	calculations, and portfolio construction within and across fixed income, credit, commodity, equity,
 *  	FX, and structured products.
 *  
 *  	https://lakshmidrip.github.io/DROP/
 *  
 *  DROP is composed of three main modules:
 *  
 *  - DROP Analytics Core - https://lakshmidrip.github.io/DROP-Analytics-Core/
 *  - DROP Portfolio Core - https://lakshmidrip.github.io/DROP-Portfolio-Core/
 *  - DROP Numerical Core - https://lakshmidrip.github.io/DROP-Numerical-Core/
 * 
 * 	DROP Analytics Core implements libraries for the following:
 * 	- Fixed Income Analytics
 * 	- Asset Backed Analytics
 * 	- XVA Analytics
 * 	- Exposure and Margin Analytics
 * 
 * 	DROP Portfolio Core implements libraries for the following:
 * 	- Asset Allocation Analytics
 * 	- Transaction Cost Analytics
 * 
 * 	DROP Numerical Core implements libraries for the following:
 * 	- Statistical Learning Library
 * 	- Numerical Optimizer Library
 * 	- Machine Learning Library
 * 	- Spline Builder Library
 * 
 * 	Documentation for DROP is Spread Over:
 * 
 * 	- Main                     =&gt; https://lakshmidrip.github.io/DROP/
 * 	- Wiki                     =&gt; https://github.com/lakshmiDRIP/DROP/wiki
 * 	- GitHub                   =&gt; https://github.com/lakshmiDRIP/DROP
 * 	- Javadoc                  =&gt; https://lakshmidrip.github.io/DROP/Javadoc/index.html
 * 	- Technical Specifications =&gt; https://github.com/lakshmiDRIP/DROP/tree/master/Docs/Internal
 * 	- Release Versions         =&gt; https://lakshmidrip.github.io/DROP/version.html
 * 	- Community Credits        =&gt; https://lakshmidrip.github.io/DROP/credits.html
 * 	- Issues Catalog           =&gt; https://github.com/lakshmiDRIP/DROP/issues
 * 	- JUnit                    =&gt; https://lakshmidrip.github.io/DROP/junit/index.html
 * 	- Jacoco                   =&gt; https://lakshmidrip.github.io/DROP/jacoco/index.html
 * 
 *  Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 *   	you may not use this file except in compliance with the License.
 *   
 *  You may obtain a copy of the License at
 *  	http://www.apache.org/licenses/LICENSE-2.0
 *  
 *  Unless required by applicable law or agreed to in writing, software
 *  	distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 *  	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  
 *  See the License for the specific language governing permissions and
 *  	limitations under the License.
 */

/**
 * &lt;i&gt;LocalMonotoneCkGenerator&lt;/i&gt; generates customized Local Stretch by trading off Ck for local control.
 * This class implements the following variants: Akima, Bessel, Harmonic, Hyman83, Hyman89, Kruger, Monotone
 * Convex, as well as the Van Leer and the Huynh/LeFloch limiters. It also provides the following custom
 * control on the resulting C1:
 *
 * &lt;br&gt;&lt;br&gt;
 *  &lt;ul&gt;
 *  	&lt;li&gt;
 *  		Eliminate the Spurious Extrema in the Input C1 Entry
 *  	&lt;/li&gt;
 *  	&lt;li&gt;
 *  		Apply the Monotone Filter in the Input C1 Entry
 *  	&lt;/li&gt;
 *  	&lt;li&gt;
 *  		Generate a Vanilla C1 Array from the specified Array of Predictor Ordinates and the Response
 *  			Values
 *  	&lt;/li&gt;
 *  	&lt;li&gt;
 *  		Verify if the given Quintic Polynomial is Monotone using the Hyman89 Algorithm, and generate it
 *  			if necessary
 *  	&lt;/li&gt;
 *  &lt;/ul&gt;
 *
 * &lt;br&gt;&lt;br&gt;
 *  &lt;ul&gt;
 *		&lt;li&gt;&lt;b&gt;Module &lt;/b&gt; = &lt;a href = &quot;https://github.com/lakshmiDRIP/DROP/tree/master/NumericalCore.md&quot;&gt;Numerical Core Module&lt;/a&gt;&lt;/li&gt;
 *		&lt;li&gt;&lt;b&gt;Library&lt;/b&gt; = &lt;a href = &quot;https://github.com/lakshmiDRIP/DROP/tree/master/SplineBuilderLibrary.md&quot;&gt;Spline Builder Library&lt;/a&gt;&lt;/li&gt;
 *		&lt;li&gt;&lt;b&gt;Project&lt;/b&gt; = &lt;a href = &quot;https://github.com/lakshmiDRIP/DROP/tree/master/src/main/java/org/drip/spline&quot;&gt;Spline&lt;/a&gt;&lt;/li&gt;
 *		&lt;li&gt;&lt;b&gt;Package&lt;/b&gt; = &lt;a href = &quot;https://github.com/lakshmiDRIP/DROP/tree/master/src/main/java/org/drip/spline/pchip&quot;&gt;PCHIP&lt;/a&gt;&lt;/li&gt;
 *  &lt;/ul&gt;
 * &lt;br&gt;&lt;br&gt;
 *
 * @author Lakshmi Krishnamurthy
 */

public class LocalMonotoneCkGenerator {

	/**
	 * C1 Type: Vanilla
	 */

	public static final java.lang.String C1_VANILLA = &quot;C1_VANILLA&quot;;

	/**
	 * C1 Type: Akima
	 */

	public static final java.lang.String C1_AKIMA = &quot;C1_AKIMA&quot;;

	/**
	 * C1 Type: Bessel
	 */

	public static final java.lang.String C1_BESSEL = &quot;C1_BESSEL&quot;;

	/**
	 * C1 Type: Harmonic
	 */

	public static final java.lang.String C1_HARMONIC = &quot;C1_HARMONIC&quot;;

	/**
	 * C1 Type: Huynh - Le Floch Limiter
	 */

	public static final java.lang.String C1_HUYNH_LE_FLOCH = &quot;C1_HUYNH_LE_FLOCH&quot;;

	/**
	 * C1 Type: Hyman83
	 */

	public static final java.lang.String C1_HYMAN83 = &quot;C1_HYMAN83&quot;;

	/**
	 * C1 Type: Hyman89
	 */

	public static final java.lang.String C1_HYMAN89 = &quot;C1_HYMAN89&quot;;

	/**
	 * C1 Type: Kruger
	 */

	public static final java.lang.String C1_KRUGER = &quot;C1_KRUGER&quot;;

	/**
	 * C1 Type: Monotone Convex
	 */

	public static final java.lang.String C1_MONOTONE_CONVEX = &quot;C1_MONOTONE_CONVEX&quot;;

	/**
	 * C1 Type: Van Leer Limiter
	 */

	public static final java.lang.String C1_VAN_LEER = &quot;C1_VAN_LEER&quot;;

<span class="fc" id="L170">	private double[] _adblC1 = null;</span>
<span class="fc" id="L171">	private double[] _adblResponseValue = null;</span>
<span class="fc" id="L172">	private double[] _adblPredictorOrdinate = null;</span>

	/**
	 * Eliminate the Spurious Extrema in the Input C1 Entry
	 * 
	 * @param adblC1 The C1 Array in which the Spurious Extrema is to be eliminated
	 * @param adblLinearC1 Array of the Linear C1 Entries
	 * 
	 * @return The C1 Array with the Spurious Extrema eliminated
	 */

	public static final double[] EliminateSpuriousExtrema (
		final double[] adblC1,
		final double[] adblLinearC1)
	{
<span class="pc bpc" id="L187" title="2 of 4 branches missed.">		if (null == adblC1 || null == adblLinearC1) return null;</span>

<span class="fc" id="L189">		int iNumEntries = adblC1.length;</span>
<span class="fc" id="L190">		double[] adblUpdatedC1 = new double[iNumEntries];</span>
<span class="fc" id="L191">		adblUpdatedC1[0] = adblC1[0];</span>
<span class="fc" id="L192">		adblUpdatedC1[iNumEntries - 1] = adblC1[iNumEntries - 1];</span>

<span class="pc bpc" id="L194" title="2 of 4 branches missed.">		if (1 &gt;= iNumEntries || iNumEntries != adblLinearC1.length + 1) return null;</span>

<span class="fc bfc" id="L196" title="All 2 branches covered.">		for (int i = 1; i &lt; iNumEntries - 1; ++i)</span>
<span class="fc bfc" id="L197" title="All 2 branches covered.">			adblUpdatedC1[i] = 0. &lt; adblLinearC1[i] ? java.lang.Math.min (java.lang.Math.max (0., adblC1[i]),</span>
<span class="fc" id="L198">				java.lang.Math.min (adblLinearC1[i], adblLinearC1[i - 1])) : java.lang.Math.max</span>
<span class="fc" id="L199">					(java.lang.Math.min (0., adblC1[i]), java.lang.Math.max (adblLinearC1[i],</span>
						adblLinearC1[i - 1]));

<span class="fc" id="L202">		return adblUpdatedC1;</span>
	}

	/**
	 * Apply the Monotone Filter in the Input C1 Entry
	 * 
	 * @param adblC1 The C1 Array in which the Monotone Filter is to be applied
	 * @param adblLinearC1 Array of the Linear C1 Entries
	 * 
	 * @return The C1 Array with the Monotone Filter applied
	 */

	public static final double[] ApplyMonotoneFilter (
		final double[] adblC1,
		final double[] adblLinearC1)
	{
<span class="pc bpc" id="L218" title="2 of 4 branches missed.">		if (null == adblC1 || null == adblLinearC1) return null;</span>

<span class="fc" id="L220">		int iNumEntries = adblC1.length;</span>
<span class="fc" id="L221">		double[] adblUpdatedC1 = new double[iNumEntries];</span>
<span class="fc" id="L222">		adblUpdatedC1[0] = adblC1[0];</span>

<span class="pc bpc" id="L224" title="2 of 4 branches missed.">		if (1 &gt;= iNumEntries || iNumEntries != adblLinearC1.length + 1) return null;</span>

<span class="fc bfc" id="L226" title="All 2 branches covered.">		for (int i = 0; i &lt; iNumEntries; ++i) {</span>
<span class="fc bfc" id="L227" title="All 2 branches covered.">			if (0 == i) {</span>
<span class="pc bpc" id="L228" title="1 of 4 branches missed.">				if (adblC1[0] * adblLinearC1[0] &gt; 0. &amp;&amp; adblLinearC1[0] * adblLinearC1[1] &gt; 0. &amp;&amp;</span>
<span class="fc bfc" id="L229" title="All 2 branches covered.">					java.lang.Math.abs (adblC1[0]) &lt; 3. * java.lang.Math.abs (adblLinearC1[0]))</span>
<span class="fc" id="L230">					adblUpdatedC1[0] = 3. * adblLinearC1[0];</span>
<span class="fc bfc" id="L231" title="All 2 branches covered.">				else if (adblC1[0] * adblLinearC1[0] &lt;= 0.)</span>
<span class="fc" id="L232">					adblUpdatedC1[0] = 0.;</span>
<span class="pc bpc" id="L233" title="1 of 2 branches missed.">			} else if (iNumEntries == i) {</span>
<span class="nc bnc" id="L234" title="All 4 branches missed.">				if (adblC1[i] * adblLinearC1[i - 1] &gt; 0. &amp;&amp; adblLinearC1[i - 1] * adblLinearC1[i - 2] &gt; 0. &amp;&amp;</span>
<span class="nc bnc" id="L235" title="All 2 branches missed.">					java.lang.Math.abs (adblC1[i]) &lt; 3. * java.lang.Math.abs (adblLinearC1[i - 1]))</span>
<span class="nc" id="L236">					adblUpdatedC1[i] = 3. * adblLinearC1[i - 1];</span>
<span class="nc bnc" id="L237" title="All 2 branches missed.">				else if (adblC1[i] * adblLinearC1[i - 1] &lt;= 0.)</span>
<span class="nc" id="L238">					adblUpdatedC1[i] = 0.;</span>
			} else
<span class="fc" id="L240">				adblUpdatedC1[i] = adblC1[i];</span>
		}

<span class="fc" id="L243">		return adblUpdatedC1;</span>
	}

	/**
	 * Generate a Vanilla C1 Array from the specified Array of Predictor Ordinates and the Response Values
	 * 
	 * @param adblPredictorOrdinate The Predictor Ordinate Array
	 * @param adblResponseValue The Response Value Array
	 * 
	 * @return The C1 Array
	 */

	public static final double[] LinearC1 (
		final double[] adblPredictorOrdinate,
		final double[] adblResponseValue)
	{
<span class="fc" id="L259">		int iNumSegment = adblResponseValue.length - 1;</span>
<span class="fc" id="L260">		double[] adblLinearC1 = new double[iNumSegment];</span>

<span class="fc bfc" id="L262" title="All 2 branches covered.">		for (int i = 0; i &lt; iNumSegment; ++i)</span>
<span class="fc" id="L263">			adblLinearC1[i] = (adblResponseValue[i + 1] - adblResponseValue[i]) /</span>
				(adblPredictorOrdinate[i + 1] - adblPredictorOrdinate[i]);

<span class="fc" id="L266">		return adblLinearC1;</span>
	}

	/**
	 * Generate a Bessel C1 Array from the specified Array of Predictor Ordinates and the Response Values
	 * 
	 * @param adblPredictorOrdinate The Predictor Ordinate Array
	 * @param adblResponseValue The Response Value Array
	 * 
	 * @return The C1 Array
	 */

	public static final double[] BesselC1 (
		final double[] adblPredictorOrdinate,
		final double[] adblResponseValue)
	{
<span class="fc" id="L282">		int iNumResponse = adblResponseValue.length;</span>
<span class="fc" id="L283">		double[] adblBesselC1 = new double[iNumResponse];</span>

<span class="fc bfc" id="L285" title="All 2 branches covered.">		for (int i = 0; i &lt; iNumResponse; ++i) {</span>
<span class="fc bfc" id="L286" title="All 2 branches covered.">			if (0 == i) {</span>
<span class="fc" id="L287">				adblBesselC1[i] = (adblPredictorOrdinate[2] + adblPredictorOrdinate[1] - 2. *</span>
					adblPredictorOrdinate[0]) * (adblResponseValue[1] - adblResponseValue[0]) /
						(adblPredictorOrdinate[1] - adblPredictorOrdinate[0]);
<span class="fc" id="L290">				adblBesselC1[i] -= (adblPredictorOrdinate[1] - adblPredictorOrdinate[0]) *</span>
					(adblResponseValue[2] - adblResponseValue[1]) / (adblPredictorOrdinate[2] -
						adblPredictorOrdinate[1]);
<span class="fc" id="L293">				adblBesselC1[i] /= (adblPredictorOrdinate[2] - adblPredictorOrdinate[0]);</span>
<span class="fc bfc" id="L294" title="All 2 branches covered.">			} else if (iNumResponse - 1 == i) {</span>
<span class="fc" id="L295">				adblBesselC1[i] = (adblPredictorOrdinate[iNumResponse - 1] -</span>
					adblPredictorOrdinate[iNumResponse - 2]) * (adblResponseValue[iNumResponse - 2] -
						adblResponseValue[iNumResponse - 3]) / (adblPredictorOrdinate[iNumResponse - 2] -
							adblPredictorOrdinate[iNumResponse - 3]);
<span class="fc" id="L299">				adblBesselC1[i] -= (2. * adblPredictorOrdinate[iNumResponse - 1] -</span>
					adblPredictorOrdinate[iNumResponse - 2] - adblPredictorOrdinate[iNumResponse - 3]) *
						(adblResponseValue[iNumResponse - 1] - adblResponseValue[iNumResponse - 2]) /
							(adblPredictorOrdinate[iNumResponse - 1] -
								adblPredictorOrdinate[iNumResponse - 2]);
<span class="fc" id="L304">				adblBesselC1[i] /= (adblPredictorOrdinate[iNumResponse - 1] -</span>
					adblPredictorOrdinate[iNumResponse - 3]);
			} else {
<span class="fc" id="L307">				adblBesselC1[i] = (adblPredictorOrdinate[i + 1] - adblPredictorOrdinate[i]) *</span>
					(adblResponseValue[i] - adblResponseValue[i - 1]) / (adblPredictorOrdinate[i] -
						adblPredictorOrdinate[i - 1]);
<span class="fc" id="L310">				adblBesselC1[i] += (adblPredictorOrdinate[i] - adblPredictorOrdinate[i - 1]) *</span>
					(adblResponseValue[i + 1] - adblResponseValue[i]) / (adblPredictorOrdinate[i + 1] -
						adblPredictorOrdinate[i]);
<span class="fc" id="L313">				adblBesselC1[i] /= (adblPredictorOrdinate[iNumResponse - 1] -</span>
					adblPredictorOrdinate[iNumResponse - 3]);
			}
		}

<span class="fc" id="L318">		return adblBesselC1;</span>
	}

	/**
	 * Generate a Hyman83 C1 Array from the specified Array of Predictor Ordinates and the Response Values
	 * 
	 * 	Hyman (1983) Accurate Monotonicity Preserving Cubic Interpolation -
	 *  	SIAM J on Numerical Analysis 4 (4), 645-654.
	 * 
	 * @param adblPredictorOrdinate The Predictor Ordinate Array
	 * @param adblResponseValue The Response Value Array
	 * 
	 * @return The C1 Array
	 */

	public static final double[] Hyman83C1 (
		final double[] adblPredictorOrdinate,
		final double[] adblResponseValue)
	{
<span class="fc" id="L337">		int iNumResponse = adblResponseValue.length;</span>
<span class="fc" id="L338">		double dblLinearSlopePrev = java.lang.Double.NaN;</span>
<span class="fc" id="L339">		double[] adblHyman83C1 = new double[iNumResponse];</span>

<span class="fc bfc" id="L341" title="All 2 branches covered.">		for (int i = 0; i &lt; iNumResponse; ++i) {</span>
<span class="fc" id="L342">			adblHyman83C1[i] = 0.;</span>
<span class="fc bfc" id="L343" title="All 2 branches covered.">			double dblLinearSlope = iNumResponse - 1 != i ? (adblResponseValue[i + 1] - adblResponseValue[i])</span>
				/ (adblPredictorOrdinate[i + 1] - adblPredictorOrdinate[i]) : java.lang.Double.NaN;

<span class="fc bfc" id="L346" title="All 4 branches covered.">			if (0 != i &amp;&amp; iNumResponse - 1 != i) {</span>
<span class="fc" id="L347">				double dblMonotoneIndicator = dblLinearSlopePrev * dblLinearSlope;</span>

<span class="fc bfc" id="L349" title="All 2 branches covered.">				if (0. &lt;= dblMonotoneIndicator)</span>
<span class="fc" id="L350">					adblHyman83C1[i] = 3. * dblMonotoneIndicator / (java.lang.Math.max (dblLinearSlope,</span>
<span class="fc" id="L351">						dblLinearSlopePrev) + 2. * java.lang.Math.min (dblLinearSlope, dblLinearSlopePrev));</span>
			}

<span class="fc" id="L354">			dblLinearSlopePrev = dblLinearSlope;</span>
		}

<span class="fc" id="L357">		return adblHyman83C1;</span>
	}

	/**
	 * Generate a Hyman89 C1 Array from the specified Array of Predictor Ordinates and the Response Values
	 * 
	 * 	Doherty, Edelman, and Hyman (1989) Non-negative, monotonic, or convexity preserving cubic and quintic
	 *  	Hermite interpolation - Mathematics of Computation 52 (186), 471-494.
	 * 
	 * @param adblPredictorOrdinate The Predictor Ordinate Array
	 * @param adblResponseValue The Response Value Array
	 * 
	 * @return The C1 Array
	 */

	public static final double[] Hyman89C1 (
		final double[] adblPredictorOrdinate,
		final double[] adblResponseValue)
	{
<span class="fc" id="L376">		int iNumResponse = adblResponseValue.length;</span>
<span class="fc" id="L377">		double[] adblHyman89C1 = new double[iNumResponse];</span>

<span class="fc" id="L379">		double[] adblNodeC1 = LinearC1 (adblPredictorOrdinate, adblResponseValue);</span>

<span class="fc" id="L381">		double[] adblBesselC1 = BesselC1 (adblPredictorOrdinate, adblResponseValue);</span>

<span class="fc bfc" id="L383" title="All 2 branches covered.">		for (int i = 0; i &lt; iNumResponse; ++i) {</span>
<span class="fc bfc" id="L384" title="All 4 branches covered.">			if (i &lt; 2 || i &gt;= iNumResponse - 2)</span>
<span class="fc" id="L385">				adblHyman89C1[i] = adblBesselC1[i];</span>
			else {
<span class="fc" id="L387">				double dMuMinus = (adblNodeC1[i - 1] * (2. * (adblPredictorOrdinate[i] -</span>
					adblPredictorOrdinate[i - 1]) + adblPredictorOrdinate[i - 1] -
						adblPredictorOrdinate[i - 2]) - adblNodeC1[i - 2] * (adblPredictorOrdinate[i] -
							adblPredictorOrdinate[i - 1])) / (adblPredictorOrdinate[i] -
								adblPredictorOrdinate[i - 2]);
<span class="fc" id="L392">				double dMu0 = (adblNodeC1[i - 1] * (adblPredictorOrdinate[i + 1] - adblPredictorOrdinate[i])</span>
					+ adblNodeC1[i] * (adblPredictorOrdinate[i] - adblPredictorOrdinate[i - 1])) /
						(adblPredictorOrdinate[i + 1] - adblPredictorOrdinate[i - 1]);
<span class="fc" id="L395">				double dMuPlus = (adblNodeC1[i] * (2. * (adblPredictorOrdinate[i + 1] -</span>
					adblPredictorOrdinate[i]) + adblPredictorOrdinate[i + 2] - adblPredictorOrdinate[i + 1])
						- adblNodeC1[i + 1] * (adblPredictorOrdinate[i + 1] - adblPredictorOrdinate[i])) /
							(adblPredictorOrdinate[i + 2] - adblPredictorOrdinate[i]);

				try {
<span class="fc" id="L401">					double dblM = 3 * org.drip.quant.common.NumberUtil.Minimum (new double[]</span>
<span class="fc" id="L402">						{java.lang.Math.abs (adblNodeC1[i - 1]), java.lang.Math.abs (adblNodeC1[i]),</span>
<span class="fc" id="L403">							java.lang.Math.abs (dMu0), java.lang.Math.abs (dMuPlus)});</span>

<span class="fc bfc" id="L405" title="All 2 branches covered.">					if (!org.drip.quant.common.NumberUtil.SameSign (new double[] {dMu0, dMuMinus,</span>
							adblNodeC1[i - 1] - adblNodeC1[i - 2], adblNodeC1[i] - adblNodeC1[i - 1]}))
<span class="fc" id="L407">						dblM = java.lang.Math.max (dblM, 1.5 * java.lang.Math.min (java.lang.Math.abs (dMu0),</span>
<span class="fc" id="L408">							java.lang.Math.abs (dMuMinus)));</span>
<span class="pc bpc" id="L409" title="1 of 2 branches missed.">					else if (!org.drip.quant.common.NumberUtil.SameSign (new double[] {-dMu0, -dMuPlus,</span>
							adblNodeC1[i] - adblNodeC1[i - 1], adblNodeC1[i + 1] - adblNodeC1[i]}))
<span class="fc" id="L411">						dblM = java.lang.Math.max (dblM, 1.5 * java.lang.Math.min (java.lang.Math.abs (dMu0),</span>
<span class="fc" id="L412">							java.lang.Math.abs (dMuPlus)));</span>

<span class="fc" id="L414">					adblHyman89C1[i] = 0.;</span>

<span class="pc bpc" id="L416" title="1 of 2 branches missed.">					if (adblBesselC1[i] * dMu0 &gt; 0.)</span>
<span class="fc" id="L417">						adblHyman89C1[i] = adblBesselC1[i] / java.lang.Math.abs (adblBesselC1[i]) *</span>
<span class="fc" id="L418">							java.lang.Math.min (java.lang.Math.abs (adblBesselC1[i]), dblM);</span>
<span class="nc" id="L419">				} catch (java.lang.Exception e) {</span>
<span class="nc" id="L420">					e.printStackTrace();</span>

<span class="nc" id="L422">					return null;</span>
<span class="fc" id="L423">				}</span>
			}
		}

<span class="fc" id="L427">		return adblHyman89C1;</span>
	}

	/**
	 * Generate a Harmonic C1 Array from the specified Array of Predictor Ordinates and the Response Values
	 * 
	 * 	Fritcsh and Butland (1984) A Method for constructing local monotonic piece-wise cubic interpolants -
	 *  	SIAM J on Scientific and Statistical Computing 5, 300-304.
	 * 
	 * @param adblPredictorOrdinate The Predictor Ordinate Array
	 * @param adblResponseValue The Response Value Array
	 * 
	 * @return The C1 Array
	 */

	public static final double[] HarmonicC1 (
		final double[] adblPredictorOrdinate,
		final double[] adblResponseValue)
	{
<span class="fc" id="L446">		int iNumResponse = adblResponseValue.length;</span>
<span class="fc" id="L447">		double[] adblHarmonicC1 = new double[iNumResponse];</span>

<span class="fc" id="L449">		double[] adblLinearC1 = LinearC1 (adblPredictorOrdinate, adblResponseValue);</span>

<span class="fc bfc" id="L451" title="All 2 branches covered.">		for (int i = 0; i &lt; iNumResponse; ++i) {</span>
<span class="fc bfc" id="L452" title="All 2 branches covered.">			if (0 == i) {</span>
<span class="fc" id="L453">				adblHarmonicC1[i] = (adblPredictorOrdinate[2] + adblPredictorOrdinate[1] - 2. *</span>
					adblPredictorOrdinate[0]) * adblLinearC1[0] / (adblPredictorOrdinate[2] -
						adblPredictorOrdinate[0]);
<span class="fc" id="L456">				adblHarmonicC1[i] -= (adblPredictorOrdinate[1] - adblPredictorOrdinate[0]) * adblLinearC1[1]</span>
					/ (adblPredictorOrdinate[2] - adblPredictorOrdinate[0]);
<span class="fc bfc" id="L458" title="All 2 branches covered.">			} else if (iNumResponse - 1 == i) {</span>
<span class="fc" id="L459">				adblHarmonicC1[i] = -(adblPredictorOrdinate[i] - adblPredictorOrdinate[i - 1]) *</span>
					adblLinearC1[i - 2] / (adblPredictorOrdinate[i] - adblPredictorOrdinate[i - 2]);
<span class="fc" id="L461">				adblHarmonicC1[i] += (2. * adblPredictorOrdinate[i] - adblPredictorOrdinate[i - 1] -</span>
					adblPredictorOrdinate[i - 2]) * adblLinearC1[i - 1] / (adblPredictorOrdinate[i] -
						adblPredictorOrdinate[i - 2]);
			} else {
<span class="fc bfc" id="L465" title="All 2 branches covered.">				if (adblLinearC1[i - 1] * adblLinearC1[i] &lt;= 0.)</span>
<span class="fc" id="L466">					adblHarmonicC1[i] = 0.;</span>
				else {
<span class="fc" id="L468">					adblHarmonicC1[i] = (adblPredictorOrdinate[i] - adblPredictorOrdinate[i - 1] + 2. *</span>
						(adblPredictorOrdinate[i + 1] - adblPredictorOrdinate[i])) / (3. *
							(adblPredictorOrdinate[i + 1] - adblPredictorOrdinate[i])) / adblLinearC1[i - 1];
<span class="fc" id="L471">					adblHarmonicC1[i] += (adblPredictorOrdinate[i + 1] - adblPredictorOrdinate[i] + 2. *</span>
						(adblPredictorOrdinate[i] - adblPredictorOrdinate[i - 1])) / (3. *
							(adblPredictorOrdinate[i + 1] - adblPredictorOrdinate[i])) / adblLinearC1[i];
<span class="fc" id="L474">					adblHarmonicC1[i] = 1. / adblHarmonicC1[i];</span>
				}
			}
		}

<span class="fc" id="L479">		return adblHarmonicC1;</span>
	}

	/**
	 * Generate a Van Leer Limiter C1 Array from the specified Array of Predictor Ordinates and the Response
	 *  Values.
	 * 
	 * 	Van Leer (1974) Towards the Ultimate Conservative Difference Scheme. II - Monotonicity and
	 * 		Conservation combined in a Second-Order Scheme, Journal of Computational Physics 14 (4), 361-370.
	 * 
	 * @param adblPredictorOrdinate The Predictor Ordinate Array
	 * @param adblResponseValue The Response Value Array
	 * 
	 * @return The C1 Array
	 */

	public static final double[] VanLeerLimiterC1 (
		final double[] adblPredictorOrdinate,
		final double[] adblResponseValue)
	{
<span class="fc" id="L499">		int iNumResponse = adblResponseValue.length;</span>
<span class="fc" id="L500">		double[] dblVanLeerLimiterC1 = new double[iNumResponse];</span>

<span class="fc" id="L502">		double[] adblNodeC1 = LinearC1 (adblPredictorOrdinate, adblResponseValue);</span>

<span class="fc bfc" id="L504" title="All 2 branches covered.">		for (int i = 0; i &lt; iNumResponse; ++i) {</span>
<span class="fc bfc" id="L505" title="All 2 branches covered.">			if (0 == i) {</span>
<span class="fc" id="L506">				dblVanLeerLimiterC1[i] = (adblPredictorOrdinate[2] + adblPredictorOrdinate[1] - 2. *</span>
					adblPredictorOrdinate[0]) * adblNodeC1[0] / (adblPredictorOrdinate[2] -
						adblPredictorOrdinate[0]);
<span class="fc" id="L509">				dblVanLeerLimiterC1[i] -= (adblPredictorOrdinate[1] - adblPredictorOrdinate[0]) *</span>
					adblNodeC1[1] / (adblPredictorOrdinate[2] - adblPredictorOrdinate[0]);
<span class="fc bfc" id="L511" title="All 2 branches covered.">			} else if (iNumResponse - 1 == i) {</span>
<span class="fc" id="L512">				dblVanLeerLimiterC1[i] = -(adblPredictorOrdinate[i] - adblPredictorOrdinate[i - 1]) *</span>
					adblNodeC1[i - 2] / (adblPredictorOrdinate[i] - adblPredictorOrdinate[i - 2]);
<span class="fc" id="L514">				dblVanLeerLimiterC1[i] += (2. * adblPredictorOrdinate[i] - adblPredictorOrdinate[i - 1] -</span>
					adblPredictorOrdinate[i - 2]) * adblNodeC1[i - 1] / (adblPredictorOrdinate[i] -
						adblPredictorOrdinate[i - 2]);
			} else {
<span class="pc bpc" id="L518" title="1 of 2 branches missed.">				if (0. != adblNodeC1[i - 1]) {</span>
<span class="fc" id="L519">					double dblR = adblNodeC1[i] / adblNodeC1[i - 1];</span>

<span class="fc" id="L521">					double dblRAbsolute = java.lang.Math.abs (dblR);</span>

<span class="fc" id="L523">					dblVanLeerLimiterC1[i] = adblNodeC1[i] * (dblR + dblRAbsolute) / (1. + dblRAbsolute);</span>
<span class="pc bnc" id="L524" title="All 2 branches missed.">				} else if (0. &gt;= adblNodeC1[i])</span>
<span class="nc" id="L525">					dblVanLeerLimiterC1[i] = 0.;</span>
<span class="nc bnc" id="L526" title="All 2 branches missed.">				else if (0. &lt; adblNodeC1[i])</span>
<span class="nc" id="L527">					dblVanLeerLimiterC1[i] = 2. * adblNodeC1[i];</span>
			}
		}

<span class="fc" id="L531">		return dblVanLeerLimiterC1;</span>
	}

	/**
	 * Generate a Huynh Le Floch Limiter C1 Array from the specified Array of Predictor Ordinates and the
	 *  Response Values.
	 * 
	 * 	Huynh (1993) Accurate Monotone Cubic Interpolation, SIAM J on Numerical Analysis 30 (1), 57-100.
	 * 
	 * @param adblPredictorOrdinate The Predictor Ordinate Array
	 * @param adblResponseValue The Response Value Array
	 * 
	 * @return The C1 Array
	 */

	public static final double[] HuynhLeFlochLimiterC1 (
		final double[] adblPredictorOrdinate,
		final double[] adblResponseValue)
	{
<span class="fc" id="L550">		int iNumResponse = adblResponseValue.length;</span>
<span class="fc" id="L551">		double[] adblHuynhLeFlochLimiterC1 = new double[iNumResponse];</span>

<span class="fc" id="L553">		double[] adblNodeC1 = LinearC1 (adblPredictorOrdinate, adblResponseValue);</span>

<span class="fc bfc" id="L555" title="All 2 branches covered.">		for (int i = 0; i &lt; iNumResponse; ++i) {</span>
<span class="fc bfc" id="L556" title="All 2 branches covered.">			if (0 == i) {</span>
<span class="fc" id="L557">				adblHuynhLeFlochLimiterC1[i] = (adblPredictorOrdinate[2] + adblPredictorOrdinate[1] - 2. *</span>
					adblPredictorOrdinate[0]) * adblNodeC1[0] / (adblPredictorOrdinate[2] -
						adblPredictorOrdinate[0]);
<span class="fc" id="L560">				adblHuynhLeFlochLimiterC1[i] -= (adblPredictorOrdinate[1] - adblPredictorOrdinate[0]) *</span>
					adblNodeC1[1] / (adblPredictorOrdinate[2] - adblPredictorOrdinate[0]);
<span class="fc bfc" id="L562" title="All 2 branches covered.">			} else if (iNumResponse - 1 == i) {</span>
<span class="fc" id="L563">				adblHuynhLeFlochLimiterC1[i] = -(adblPredictorOrdinate[i] - adblPredictorOrdinate[i - 1]) *</span>
					adblNodeC1[i - 2] / (adblPredictorOrdinate[i] - adblPredictorOrdinate[i - 2]);
<span class="fc" id="L565">				adblHuynhLeFlochLimiterC1[i] += (2. * adblPredictorOrdinate[i] - adblPredictorOrdinate[i - 1]</span>
					- adblPredictorOrdinate[i - 2]) * adblNodeC1[i - 1] / (adblPredictorOrdinate[i] -
						adblPredictorOrdinate[i - 2]);
			} else {
<span class="fc" id="L569">				double dblMonotoneIndicator = adblNodeC1[i] * adblNodeC1[i - 1];</span>

<span class="fc bfc" id="L571" title="All 2 branches covered.">				if (0. &lt; dblMonotoneIndicator)</span>
<span class="fc" id="L572">					adblHuynhLeFlochLimiterC1[i] = 3. * dblMonotoneIndicator * (adblNodeC1[i] +</span>
						adblNodeC1[i - 1]) / (adblNodeC1[i] * adblNodeC1[i] + adblNodeC1[i - 1] *
							adblNodeC1[i - 1] * 4. * dblMonotoneIndicator);
				else
<span class="fc" id="L576">					adblHuynhLeFlochLimiterC1[i] = 0.;</span>
			}
		}

<span class="fc" id="L580">		return adblHuynhLeFlochLimiterC1;</span>
	}

	/**
	 * Generate a Kruger C1 Array from the specified Array of Predictor Ordinates and the Response Values.
	 * 
	 * 	Kruger (2002) Constrained Cubic Spline Interpolations for Chemical Engineering Application,
	 *  	http://www.korf.co.uk/spline.pdf
	 * 
	 * @param adblPredictorOrdinate The Predictor Ordinate Array
	 * @param adblResponseValue The Response Value Array
	 * 
	 * @return The C1 Array
	 */

	public static final double[] KrugerC1 (
		final double[] adblPredictorOrdinate,
		final double[] adblResponseValue)
	{
<span class="fc" id="L599">		int iNumResponse = adblResponseValue.length;</span>
<span class="fc" id="L600">		double[] adblKrugerSlope = new double[iNumResponse];</span>

<span class="fc" id="L602">		double[] adblSlopeC1 = LinearC1 (adblPredictorOrdinate, adblResponseValue);</span>

<span class="pc bpc" id="L604" title="2 of 4 branches missed.">		if (null == adblSlopeC1 || adblSlopeC1.length != iNumResponse - 1) return null;</span>

<span class="fc bfc" id="L606" title="All 2 branches covered.">		for (int i = 0; i &lt; iNumResponse; ++i) {</span>
<span class="fc bfc" id="L607" title="All 4 branches covered.">			if (0 != i &amp;&amp; iNumResponse - 1 != i) {</span>
<span class="fc bfc" id="L608" title="All 2 branches covered.">				if (adblSlopeC1[i - 1] * adblSlopeC1[i] &lt;= 0.)</span>
<span class="fc" id="L609">					adblKrugerSlope[i] = 0.;</span>
				else
<span class="fc" id="L611">					adblKrugerSlope[i] = 2. / ((1. / adblSlopeC1[i - 1]) + (1. / adblSlopeC1[i]));</span>
			}
		}

<span class="fc" id="L615">		adblKrugerSlope[0] = 3.5 * adblSlopeC1[0] - 0.5 * adblKrugerSlope[1];</span>
<span class="fc" id="L616">		adblKrugerSlope[iNumResponse - 1] = 3.5 * adblSlopeC1[iNumResponse - 2] - 0.5 *</span>
			adblKrugerSlope[iNumResponse - 2];
<span class="fc" id="L618">		return adblKrugerSlope;</span>
	}

	/**
	 * Generate a Akima C1 Array from the specified Array of Predictor Ordinates and the Response Values.
	 * 
	 * 	Akima (1970): A New Method of Interpolation and Smooth Curve Fitting based on Local Procedures,
	 * 		Journal of the Association for the Computing Machinery 17 (4), 589-602.
	 * 
	 * @param adblPredictorOrdinate The Predictor Ordinate Array
	 * @param adblResponseValue The Response Value Array
	 * 
	 * @return The C1 Array
	 */

	public static final double[] AkimaC1 (
		final double[] adblPredictorOrdinate,
		final double[] adblResponseValue)
	{
<span class="fc" id="L637">		org.drip.spline.pchip.AkimaLocalC1Generator alcr =</span>
<span class="fc" id="L638">			org.drip.spline.pchip.AkimaLocalC1Generator.Create (adblPredictorOrdinate, adblResponseValue);</span>

<span class="pc bpc" id="L640" title="1 of 2 branches missed.">		return null == alcr ? null : alcr.C1();</span>
	}

	/**
	 * Verify if the given Quintic Polynomial is Monotone using the Hyman89 Algorithm
	 * 
	 * 	Doherty, Edelman, and Hyman (1989) Non-negative, monotonic, or convexity preserving cubic and quintic
	 *  	Hermite interpolation - Mathematics of Computation 52 (186), 471-494.
	 * 
	 * @param adblPredictorOrdinate Array of Predictor Ordinates
	 * @param adblResponseValue Array of Response Values
	 * @param adblFirstDerivative Array of First Derivatives
	 * @param adblSecondDerivative Array of Second Derivatives
	 * 
	 * @return TRUE - The given Quintic Polynomial is Monotone
	 * 
	 * @throws java.lang.Exception Thrown if the Monotonicity cannot be determined
	 */

	public static final boolean VerifyHyman89QuinticMonotonicity (
		final double[] adblPredictorOrdinate,
		final double[] adblResponseValue,
		final double[] adblFirstDerivative,
		final double[] adblSecondDerivative)
		throws java.lang.Exception
	{
<span class="nc bnc" id="L666" title="All 8 branches missed.">		if (null == adblPredictorOrdinate || null == adblResponseValue || null == adblFirstDerivative || null</span>
			== adblSecondDerivative)
<span class="nc" id="L668">			throw new java.lang.Exception</span>
				(&quot;LocalMonotoneCkGenerator::VerifyHyman89QuinticMonotonicity =&gt; Invalid Inputs&quot;);

<span class="nc" id="L671">		int iNumPredictor = adblPredictorOrdinate.length;</span>

<span class="nc bnc" id="L673" title="All 8 branches missed.">		if (1 &gt;= iNumPredictor || iNumPredictor != adblResponseValue.length || iNumPredictor !=</span>
			adblResponseValue.length || iNumPredictor != adblResponseValue.length)
<span class="nc" id="L675">			throw new java.lang.Exception</span>
				(&quot;LocalMonotoneCkGenerator::VerifyHyman89QuinticMonotonicity =&gt; Invalid Inputs&quot;);

<span class="nc bnc" id="L678" title="All 2 branches missed.">		for (int i = 1; i &lt; iNumPredictor - 1; ++i) {</span>
<span class="nc" id="L679">			double dblAbsoluteResponseValue = java.lang.Math.abs (adblResponseValue[i]);</span>

<span class="nc bnc" id="L681" title="All 2 branches missed.">			double dblResponseValueSign = adblResponseValue[i] &gt; 0. ? 1. : -1.;</span>
<span class="nc" id="L682">			double dblHMinus = (adblPredictorOrdinate[i] - adblPredictorOrdinate[i - 1]);</span>
<span class="nc" id="L683">			double dblHPlus = (adblPredictorOrdinate[i + 1] - adblPredictorOrdinate[i]);</span>

<span class="nc bnc" id="L685" title="All 4 branches missed.">			if (-5. * dblAbsoluteResponseValue / dblHPlus &gt; dblResponseValueSign * adblFirstDerivative[i] ||</span>
				5. * dblAbsoluteResponseValue / dblHMinus &lt; dblResponseValueSign * adblFirstDerivative[i])
<span class="nc" id="L687">				return false;</span>

<span class="nc" id="L689">			if (dblResponseValueSign * adblSecondDerivative[i] &lt; dblResponseValueSign * java.lang.Math.max</span>
<span class="nc bnc" id="L690" title="All 2 branches missed.">				(8. * adblFirstDerivative[i] / dblHMinus - 20. * adblResponseValue[i] / dblHMinus /</span>
					dblHMinus, -8. * adblFirstDerivative[i] / dblHPlus - 20. * adblResponseValue[i] /
						dblHPlus / dblHPlus))
<span class="nc" id="L693">				return false;</span>
		}

<span class="nc" id="L696">		return true;</span>
	}

	/**
	 * Generate C1 Slope Quintic Polynomial is Monotone using the Hyman89 Algorithm
	 * 
	 * 	Doherty, Edelman, and Hyman (1989) Non-negative, monotonic, or convexity preserving cubic and quintic
	 *  	Hermite interpolation - Mathematics of Computation 52 (186), 471-494.
	 * 
	 * @param adblPredictorOrdinate Array of Predictor Ordinates
	 * @param adblResponseValue Array of Response Values
	 * @param adblFirstDerivative Array of First Derivatives
	 * @param adblSecondDerivative Array of Second Derivatives
	 * 
	 * @return The C1 Slope Quintic Stretch
	 */

	public static final double[] Hyman89QuinticMonotoneC1 (
		final double[] adblPredictorOrdinate,
		final double[] adblResponseValue,
		final double[] adblFirstDerivative,
		final double[] adblSecondDerivative)
	{
<span class="nc bnc" id="L719" title="All 8 branches missed.">		if (null == adblPredictorOrdinate || null == adblResponseValue || null == adblFirstDerivative || null</span>
			== adblSecondDerivative)
<span class="nc" id="L721">			return null;</span>

<span class="nc" id="L723">		int iNumPredictor = adblPredictorOrdinate.length;</span>

<span class="nc bnc" id="L725" title="All 8 branches missed.">		if (1 &gt;= iNumPredictor || iNumPredictor != adblResponseValue.length || iNumPredictor !=</span>
			adblResponseValue.length || iNumPredictor != adblResponseValue.length)
<span class="nc" id="L727">			return null;</span>

<span class="nc" id="L729">		double[] adblAdjFirstDerivative = new double[iNumPredictor];</span>

<span class="nc" id="L731">		double[] adblNodeC1 = LinearC1 (adblPredictorOrdinate, adblResponseValue);</span>

<span class="nc" id="L733">		double[] adblBesselC1 = BesselC1 (adblPredictorOrdinate, adblResponseValue);</span>

<span class="nc bnc" id="L735" title="All 2 branches missed.">		for (int i = 0; i &lt; iNumPredictor; ++i) {</span>
<span class="nc bnc" id="L736" title="All 4 branches missed.">			if (i &lt; 2 || i &gt;= iNumPredictor - 2)</span>
<span class="nc" id="L737">				adblAdjFirstDerivative[i] = adblBesselC1[i];</span>
			else {
<span class="nc" id="L739">				double dblSign = 0.;</span>
<span class="nc" id="L740">				double dblHMinus = (adblPredictorOrdinate[i] - adblPredictorOrdinate[i - 1]);</span>
<span class="nc" id="L741">				double dblHPlus = (adblPredictorOrdinate[i + 1] - adblPredictorOrdinate[i]);</span>

<span class="nc bnc" id="L743" title="All 2 branches missed.">				if (adblFirstDerivative[i - 1] * adblFirstDerivative[i] &lt; 0.)</span>
<span class="nc bnc" id="L744" title="All 2 branches missed.">					dblSign = adblResponseValue[i] &gt; 0. ? 1. : -1.;</span>

<span class="nc" id="L746">				double dblMinSlope = java.lang.Math.min (java.lang.Math.abs (adblFirstDerivative[i - 1]),</span>
<span class="nc" id="L747">					java.lang.Math.abs (adblFirstDerivative[i]));</span>

<span class="nc bnc" id="L749" title="All 2 branches missed.">				if (dblSign &gt;= 0.)</span>
<span class="nc" id="L750">					adblAdjFirstDerivative[i] = java.lang.Math.min (java.lang.Math.max (0.,</span>
						adblFirstDerivative[i]), 5. * dblMinSlope);
				else
<span class="nc" id="L753">					adblAdjFirstDerivative[i] = java.lang.Math.max (java.lang.Math.min (0.,</span>
						adblFirstDerivative[i]), -5. * dblMinSlope);

<span class="nc" id="L756">				double dblA = java.lang.Math.max (0., adblAdjFirstDerivative[i] / adblNodeC1[i - 1]);</span>

<span class="nc" id="L758">				double dblB = java.lang.Math.max (0., adblAdjFirstDerivative[i + 1] / adblNodeC1[i]);</span>

<span class="nc bnc" id="L760" title="All 2 branches missed.">				double dblDPlus = adblAdjFirstDerivative[i] * adblNodeC1[i] &gt; 0. ? adblAdjFirstDerivative[i]</span>
					: 0.;
<span class="nc bnc" id="L762" title="All 2 branches missed.">				double dblDMinus = adblAdjFirstDerivative[i] * adblNodeC1[i - 1] &gt; 0. ?</span>
					adblAdjFirstDerivative[i] : 0.;
<span class="nc" id="L764">				double dblALeft = (-7.9 * dblDPlus - 0.26 * dblDPlus * dblB) / dblHPlus;</span>
<span class="nc" id="L765">				double dblARight = ((20. - 2. * dblB) * adblNodeC1[i] - 8. * dblDPlus - 0.48 * dblDPlus *</span>
					dblB) / dblHPlus;
<span class="nc" id="L767">				double dblBLeft = ((2. * dblA - 20.) * adblNodeC1[i - 1] + 8. * dblDMinus - 0.48 * dblDMinus</span>
					* dblA) / dblHMinus;
<span class="nc" id="L769">				double dblBRight = (7.9 * dblDMinus + 0.26 * dblDMinus * dblA) / dblHMinus;</span>

<span class="nc bnc" id="L771" title="All 4 branches missed.">				if (dblARight &lt;= dblBLeft || dblALeft &gt;= dblBRight) {</span>
<span class="nc" id="L772">					double dblDenom = ((8. + 0.48 * dblB) / dblHPlus) + ((8. + 0.48 * dblA) / dblHMinus);</span>
<span class="nc" id="L773">					adblAdjFirstDerivative[i] = (20. - 2. * dblB) * adblNodeC1[i] / dblHPlus;</span>
<span class="nc" id="L774">					adblAdjFirstDerivative[i] += (20. - 2. * dblA) * adblNodeC1[i - 1] / dblHMinus;</span>
<span class="nc" id="L775">					adblAdjFirstDerivative[i] /= dblDenom;</span>
				}
			}
		}

<span class="nc" id="L780">		return adblAdjFirstDerivative;</span>
	}

	/**
	 * Generate the Local Control Stretch in accordance with the desired Customization Parameters
	 * 
	 * @param adblPredictorOrdinate The Predictor Ordinate Array
	 * @param adblResponseValue The Response Value Array
	 * @param strGeneratorType The C1 Generator Type
	 * @param bEliminateSpuriousExtrema TRUE - Eliminate Spurious Extrema
	 * @param bApplyMonotoneFilter TRUE - Apply Monotone Filter
	 * 
	 * @return Instance of the Local Control Stretch
	 */

	public static final LocalMonotoneCkGenerator Create (
		final double[] adblPredictorOrdinate,
		final double[] adblResponseValue,
		final java.lang.String strGeneratorType,
		final boolean bEliminateSpuriousExtrema,
		final boolean bApplyMonotoneFilter)
	{
		try {
<span class="fc" id="L803">			LocalMonotoneCkGenerator lcr = new LocalMonotoneCkGenerator (adblPredictorOrdinate,</span>
				adblResponseValue);

<span class="pc bpc" id="L806" title="1 of 2 branches missed.">			if (!lcr.generateC1 (strGeneratorType)) return null;</span>

<span class="pc bpc" id="L808" title="1 of 4 branches missed.">			if (bEliminateSpuriousExtrema &amp;&amp; !lcr.eliminateSpuriousExtrema()) return null;</span>

<span class="fc bfc" id="L810" title="All 2 branches covered.">			if (bApplyMonotoneFilter) {</span>
<span class="pc bpc" id="L811" title="1 of 2 branches missed.">				if (!lcr.applyMonotoneFilter()) return null;</span>
			}

<span class="fc" id="L814">			return lcr;</span>
<span class="nc" id="L815">		} catch (java.lang.Exception e) {</span>
<span class="nc" id="L816">			e.printStackTrace();</span>
		}

<span class="nc" id="L819">		return null;</span>
	}

	/**
	 * Generate the Local Control Stretch in accordance with the desired Customization Parameters
	 * 
	 * @param aiPredictorOrdinate The Predictor Ordinate Array
	 * @param adblResponseValue The Response Value Array
	 * @param strGeneratorType The C1 Generator Type
	 * @param bEliminateSpuriousExtrema TRUE - Eliminate Spurious Extrema
	 * @param bApplyMonotoneFilter TRUE - Apply Monotone Filter
	 * 
	 * @return Instance of the Local Control Stretch
	 */

	public static final LocalMonotoneCkGenerator Create (
		final int[] aiPredictorOrdinate,
		final double[] adblResponseValue,
		final java.lang.String strGeneratorType,
		final boolean bEliminateSpuriousExtrema,
		final boolean bApplyMonotoneFilter)
	{
<span class="pc bpc" id="L841" title="1 of 2 branches missed.">		if (null == aiPredictorOrdinate) return null;</span>

<span class="fc" id="L843">		int iNumPredictorOrdinate = aiPredictorOrdinate.length;</span>
<span class="fc" id="L844">		double[] adblPredictorOrdinate = new double[iNumPredictorOrdinate];</span>

<span class="pc bpc" id="L846" title="1 of 2 branches missed.">		if (0 == iNumPredictorOrdinate) return null;</span>

<span class="fc bfc" id="L848" title="All 2 branches covered.">		for (int i = 0; i &lt; iNumPredictorOrdinate; ++i)</span>
<span class="fc" id="L849">			adblPredictorOrdinate[i] = aiPredictorOrdinate[i];</span>

<span class="fc" id="L851">		return Create (adblPredictorOrdinate, adblResponseValue, strGeneratorType, bEliminateSpuriousExtrema,</span>
			bApplyMonotoneFilter);
	}

	private LocalMonotoneCkGenerator (
		final double[] adblPredictorOrdinate,
		final double[] adblResponseValue)
		throws java.lang.Exception
<span class="fc" id="L859">	{</span>
<span class="pc bpc" id="L860" title="2 of 4 branches missed.">		if (null == (_adblPredictorOrdinate = adblPredictorOrdinate) || null == (_adblResponseValue =</span>
			adblResponseValue))
<span class="nc" id="L862">			throw new java.lang.Exception (&quot;LocalMonotoneCkGenerator ctr: Invalid Inputs!&quot;);</span>

<span class="fc" id="L864">		int iSize = _adblPredictorOrdinate.length;</span>

<span class="pc bpc" id="L866" title="2 of 4 branches missed.">		if (0 == iSize || iSize != _adblResponseValue.length)</span>
<span class="nc" id="L867">			throw new java.lang.Exception (&quot;LocalMonotoneCkGenerator ctr: Invalid Inputs!&quot;);</span>
<span class="fc" id="L868">	}</span>

	private boolean generateC1 (
		final java.lang.String strGeneratorType)
	{
<span class="pc bpc" id="L873" title="2 of 4 branches missed.">		if (null == strGeneratorType || strGeneratorType.isEmpty()) return false;</span>

<span class="fc bfc" id="L875" title="All 2 branches covered.">		if (C1_AKIMA.equalsIgnoreCase (strGeneratorType))</span>
<span class="pc bpc" id="L876" title="2 of 4 branches missed.">			return null != (_adblC1 = AkimaC1 (_adblPredictorOrdinate, _adblResponseValue)) &amp;&amp; 0 !=</span>
				_adblC1.length;

<span class="fc bfc" id="L879" title="All 2 branches covered.">		if (C1_BESSEL.equalsIgnoreCase (strGeneratorType))</span>
<span class="pc bpc" id="L880" title="2 of 4 branches missed.">			return null != (_adblC1 = BesselC1 (_adblPredictorOrdinate, _adblResponseValue)) &amp;&amp; 0 !=</span>
				_adblC1.length;

<span class="fc bfc" id="L883" title="All 2 branches covered.">		if (C1_HARMONIC.equalsIgnoreCase (strGeneratorType))</span>
<span class="pc bpc" id="L884" title="2 of 4 branches missed.">			return null != (_adblC1 = HarmonicC1 (_adblPredictorOrdinate, _adblResponseValue)) &amp;&amp; 0 !=</span>
				_adblC1.length;

<span class="fc bfc" id="L887" title="All 2 branches covered.">		if (C1_HUYNH_LE_FLOCH.equalsIgnoreCase (strGeneratorType))</span>
<span class="pc bpc" id="L888" title="2 of 4 branches missed.">			return null != (_adblC1 = HuynhLeFlochLimiterC1 (_adblPredictorOrdinate, _adblResponseValue)) &amp;&amp;</span>
				0 != _adblC1.length;

<span class="fc bfc" id="L891" title="All 2 branches covered.">		if (C1_HYMAN83.equalsIgnoreCase (strGeneratorType))</span>
<span class="pc bpc" id="L892" title="2 of 4 branches missed.">			return null != (_adblC1 = Hyman83C1 (_adblPredictorOrdinate, _adblResponseValue)) &amp;&amp; 0 !=</span>
				_adblC1.length;

<span class="fc bfc" id="L895" title="All 2 branches covered.">		if (C1_HYMAN89.equalsIgnoreCase (strGeneratorType))</span>
<span class="pc bpc" id="L896" title="2 of 4 branches missed.">			return null != (_adblC1 = Hyman89C1 (_adblPredictorOrdinate, _adblResponseValue)) &amp;&amp; 0 !=</span>
				_adblC1.length;

<span class="fc bfc" id="L899" title="All 2 branches covered.">		if (C1_KRUGER.equalsIgnoreCase (strGeneratorType))</span>
<span class="pc bpc" id="L900" title="2 of 4 branches missed.">			return null != (_adblC1 = KrugerC1 (_adblPredictorOrdinate, _adblResponseValue)) &amp;&amp; 0 !=</span>
				_adblC1.length;

<span class="fc bfc" id="L903" title="All 2 branches covered.">		if (C1_MONOTONE_CONVEX.equalsIgnoreCase (strGeneratorType))</span>
<span class="pc bpc" id="L904" title="2 of 4 branches missed.">			return null != (_adblC1 = BesselC1 (_adblPredictorOrdinate, _adblResponseValue)) &amp;&amp; 0 !=</span>
			_adblC1.length;

<span class="pc bpc" id="L907" title="1 of 2 branches missed.">		if (C1_VANILLA.equalsIgnoreCase (strGeneratorType))</span>
<span class="nc bnc" id="L908" title="All 4 branches missed.">			return null != (_adblC1 = LinearC1 (_adblPredictorOrdinate, _adblResponseValue)) &amp;&amp; 0 !=</span>
				_adblC1.length;

<span class="pc bpc" id="L911" title="1 of 2 branches missed.">		if (C1_VAN_LEER.equalsIgnoreCase (strGeneratorType))</span>
<span class="pc bpc" id="L912" title="2 of 4 branches missed.">			return null != (_adblC1 = VanLeerLimiterC1 (_adblPredictorOrdinate, _adblResponseValue)) &amp;&amp; 0 !=</span>
				_adblC1.length;

<span class="nc" id="L915">		return false;</span>
	}

	private boolean eliminateSpuriousExtrema()
	{
<span class="pc bpc" id="L920" title="2 of 4 branches missed.">		return null != (_adblC1 = EliminateSpuriousExtrema (_adblC1, LinearC1 (_adblPredictorOrdinate,</span>
			_adblResponseValue))) &amp;&amp; 0 != _adblC1.length; 
	}

	private boolean applyMonotoneFilter()
	{
<span class="pc bpc" id="L926" title="2 of 4 branches missed.">		return null != (_adblC1 = ApplyMonotoneFilter (_adblC1, LinearC1 (_adblPredictorOrdinate,</span>
			_adblResponseValue))) &amp;&amp; 0 != _adblC1.length; 
	}

	/**
	 * Retrieve the C1 Array
	 * 
	 * @return The C1 Array
	 */

	public double[] C1()
	{
<span class="fc" id="L938">		return _adblC1;</span>
	}
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.7.9.201702052155</span></div></body></html>